!function() {
  try {
      var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : {}
        , n = (new e.Error).stack;
      n && (e._sentryDebugIds = e._sentryDebugIds || {},
      e._sentryDebugIds[n] = "77044b42-b44e-52ae-9245-698515222543")
  } catch (e) {}
}();
const __vite__mapDeps = (i, m=__vite__mapDeps, d=(m.f || (m.f = [window.__toStaticUrl("assets/queryClient.aZi-y_WY.js"), window.__toStaticUrl("assets/queryClient.DGABi0zX.js"), window.__toStaticUrl("assets/vendor-tanstack.MLyr5TzU.js"), window.__toStaticUrl("assets/vendor-ai-sdk.bIx37Nd0.js"), window.__toStaticUrl("assets/rolldown-runtime.C5J9oJ2H.js"), window.__toStaticUrl("assets/vendor-nivo.tgzLbjSN.js"), window.__toStaticUrl("assets/vendor-dnd-kit.Cq_cSjAK.js"), window.__toStaticUrl("assets/LocalDraftIssueCreate.CYOv6Dpa.js"), window.__toStaticUrl("assets/LocalDraftIssueCreate.4o-qrBw8.js"), window.__toStaticUrl("assets/vendor-mobx.Dx0HSepL.js"), window.__toStaticUrl("assets/ConfirmationDialog.IE4b0J8q.js"), window.__toStaticUrl("assets/ConfirmationDialog.C2jFmT3t.js"), window.__toStaticUrl("assets/decorativeIconKeywords.B72edX-A.js"), window.__toStaticUrl("assets/emojis.2I4cPjbc.js"), window.__toStaticUrl("assets/timezone.DN00OUHb.js"), window.__toStaticUrl("assets/timezone.Bn4z2q4u.js"), window.__toStaticUrl("assets/vendor-compromise-dates.C4Fx0sZT.js"), window.__toStaticUrl("assets/vendor-date-fns.dm-uAj-6.js"), window.__toStaticUrl("assets/vendor-lodash.h6qBqras.js"), window.__toStaticUrl("assets/Root.KqdDXkDP.js"), window.__toStaticUrl("assets/vendor-sanity-client.CdnKFwqT.js"), window.__toStaticUrl("assets/vendor-radix-ui.BFxWlVjg.js"), window.__toStaticUrl("assets/TabsHelper.9vJNIym4.js"), window.__toStaticUrl("assets/RenderPerformanceReporting.ChGXX_jl.js"), window.__toStaticUrl("assets/PreBootstrapContext.mfieuJkc.js"), window.__toStaticUrl("assets/router.DHJHvAGa.js"), window.__toStaticUrl("assets/RouteErrorBoundary.Db3jIinu.js"), window.__toStaticUrl("assets/Error404Message.Bk4ym84p.js"), window.__toStaticUrl("assets/Loading.LBFFIEm6.js"), window.__toStaticUrl("assets/vendor-react-use.DOwjM9nX.js"), window.__toStaticUrl("assets/RouteErrorResponse.DycgFP9i.js"), window.__toStaticUrl("assets/vendor-react-router.BLx1FJVc.js"), window.__toStaticUrl("assets/getViewFilters.C1ZBhSVr.js"), window.__toStaticUrl("assets/InlineFilter.BjQSDPJQ.js"), window.__toStaticUrl("assets/openAuthView.w5NhLb_T.js"), window.__toStaticUrl("assets/random.C3Xqy_D7.js"), window.__toStaticUrl("assets/resolveIssueViewAndRelatedModels.CpzC4tIq.js"), window.__toStaticUrl("assets/useLoadIssue.-pCvJ3ie.js"), window.__toStaticUrl("assets/useQueryOrLocationState.Dq_gfOBC.js"), window.__toStaticUrl("assets/useUser.BFWUSeXo.js"), window.__toStaticUrl("assets/routeProtection.B5wdD2zt.js"), window.__toStaticUrl("assets/LoadModelByParam.BNyUlLIX.js"), window.__toStaticUrl("assets/LazyLoginView.D2ap8sWp.js"), window.__toStaticUrl("assets/InitiativesTab.IB8OyE8e.js"), window.__toStaticUrl("assets/vendor-sentry.B3ovw4Li.js"), window.__toStaticUrl("assets/archivedCustomerNeedsCount.CN6JrTaT.js"), window.__toStaticUrl("assets/vendor-graphql-request.BGz8ja23.js"), window.__toStaticUrl("assets/vendor-graphql.C_V28ikq.js"), window.__toStaticUrl("assets/sentryAuthUrl.Ci0-I6Cg.js"), window.__toStaticUrl("assets/vendor-emotion.BGBCZUbU.js"), window.__toStaticUrl("assets/vendor-mobx-react-lite.Cv7O6XgG.js"), window.__toStaticUrl("assets/vendor-react-dom.DZ-_2kBN.js"), window.__toStaticUrl("assets/lightThemeRefresh.DpODeF_f.js"), window.__toStaticUrl("assets/Root-Coz1XKOx.css")]))) => i.map(i => d[i]);
import {c as e, n as t, t as n} from "./rolldown-runtime.C5J9oJ2H.js";
import {Bt as r, Fn as i, Gt as a, Hn as o, It as s, Jn as c, Kt as l, Lt as u, Un as d, Ut as f, Vt as p, Wn as m, Xt as h, Yt as g, hn as _, ln as ee, mn as te, sn as ne, un as re} from "./vendor-nivo.tgzLbjSN.js";
import {A as ie, B as ae, D as oe, F as se, G as ce, H as le, I as ue, J as de, K as fe, L as pe, M as me, N as he, O as ge, P as v, R as _e, T as ve, U as ye, V as be, W as xe, Y as Se, k as Ce, q as we, w as Te, z as Ee} from "./vendor-lodash.h6qBqras.js";
import {i as De, r as Oe} from "./vendor-compromise-dates.C4Fx0sZT.js";
import {$ as ke, A as Ae, D as je, Dt as Me, E as Ne, G as Pe, H as Fe, I as Ie, L as Le, Mt as Re, Nt as ze, O as Be, Ot as eee, P as Ve, Pt as tee, Q as He, R as nee, S as ree, T as Ue, Tt as We, V as Ge, W as Ke, _ as iee, a as qe, at as aee, b as Je, bt as Ye, d as Xe, dt as Ze, et as Qe, ft as $e, ht as et, jt as tt, k as oee, kt as see, m as cee, n as nt, nt as rt, o as it, q as lee, s as at, st as ot, ut as st, v as uee, vt as ct, wt as lt, x as dee, yt as ut} from "./vendor-date-fns.dm-uAj-6.js";
import {A as dt, C as ft, D as pt, E as fee, F as mt, L as ht, M as gt, N as _t, O as vt, P as yt, R as pee, S as bt, T as xt, _ as St, at as mee, b as Ct, j as wt, k as Tt, v as hee, w as Et, x as Dt} from "./vendor-ai-sdk.bIx37Nd0.js";
import {D as Ot, E as kt} from "./vendor-sanity-client.CdnKFwqT.js";
import {C as At, D as jt, E as gee, M as _ee, O as Mt, S as Nt, b as Pt, c as vee, i as Ft, j as It, k as Lt, o as Rt, p as zt, s as Bt, w as Vt} from "./vendor-mobx.Dx0HSepL.js";
import {s as Ht} from "./vendor-react-dnd.DEvc7Fmp.js";
import {n as Ut, r as Wt, t as yee} from "./vendor-graphql-request.BGz8ja23.js";
import {t as Gt} from "./vendor-pluralize.C-D1hbG8.js";
import {E as bee, O as xee, S as See, _ as Kt, b as qt, g as Jt, h as Yt, n as Cee, p as wee, r as Tee, t as Xt, w as Zt, x as Eee} from "./vendor-react-router.BLx1FJVc.js";
import {c as Dee, d as Oee, f as Qt, g as kee, h as $t, l as Aee, m as jee, n as Mee, p as en, s as Nee, t as tn, u as Pee} from "./vendor-sentry.B3ovw4Li.js";
import {s as nn} from "./vendor-formik.o3xTY_i9.js";
import {C as rn, F as an, L as Fee, M as Iee, N as on, _ as sn, b as cn, g as Lee, k as ln, m as un, w as dn, y as fn, z as pn} from "./vendor-prosemirror-commands.DjBY6wiL.js";
import {t as Ree} from "./vendor-html-entities.BrATahDL.js";
import {f as mn, t as hn, x as zee} from "./vendor-prosemirror-tables.CCB6EMdC.js";
import {n as gn, t as _n} from "./vendor-mobx-utils.DfTXNeDE.js";
import {a as Bee, c as Vee} from "./vendor-yup.qhm7x7p3.js";
import {n as Hee, t as Uee} from "./vendor-markdown-it.CVpOX3Bp.js";
import {n as Wee, r as Gee, t as Kee} from "./vendor-prosemirror-markdown.djJGEAKo.js";
import {t as qee} from "./vendor-object-hash.DC0n-i8m.js";
import {i as vn, n as yn, r as Jee, t as Yee} from "./vendor-idb.CEB64amZ.js";
import {F as Xee, L as Zee} from "./vendor-lib0.ZxNCR8JV.js";
import {C as Qee, D as $ee, E as ete, T as bn, b as tte, d as nte, l as rte, s as xn, t as ite, u as ate} from "./vendor-y-prosemirror.BsJatDoH.js";
import {n as ote, r as ste, t as cte} from "./vendor-prosemirror-changeset.DzGI70jR.js";
import {c as lte, i as ute, n as dte, r as Sn, s as fte, t as Cn} from "./vendor-diff.5IEc2HUw.js";
import {a as wn, i as Tn, n as pte, t as mte} from "./vendor-emotion.BGBCZUbU.js";
import {n as hte, t as En} from "./vendor-semver.CVJY03sY.js";
import {r as Dn, t as On} from "./vendor-mobx-react-lite.Cv7O6XgG.js";
import {i as gte, n as kn, r as An, t as _te} from "./vendor-sonner.B2_YQXBB.js";
import {l as vte, s as yte, t as bte} from "./vendor-react-use.DOwjM9nX.js";
import {n as xte, r as Ste, t as jn} from "./vendor-popperjs.BBWeSJCs.js";
import {n as Mn, t as Nn} from "./vendor-react-portal.CfGeDFUv.js";
import {a as Cte, n as wte, r as Tte, t as Pn} from "./vendor-comlink.BDHC1wxY.js";
import {a as Ete, o as Dte} from "./vendor-react-window.dH66_lbp.js";
var Ote = t(( () => {
  (function() {
      let e = document.createElement(`link`).relList;
      if (e && e.supports && e.supports(`modulepreload`))
          return;
      for (let e of document.querySelectorAll(`link[rel="modulepreload"]`))
          n(e);
      new MutationObserver(e => {
          for (let t of e)
              if (t.type === `childList`)
                  for (let e of t.addedNodes)
                      e.tagName === `LINK` && e.rel === `modulepreload` && n(e)
      }
      ).observe(document, {
          childList: !0,
          subtree: !0
      });
      function t(e) {
          let t = {};
          return e.integrity && (t.integrity = e.integrity),
          e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy),
          e.crossOrigin === `use-credentials` ? t.credentials = `include` : e.crossOrigin === `anonymous` ? t.credentials = `omit` : t.credentials = `same-origin`,
          t
      }
      function n(e) {
          if (e.ep)
              return;
          e.ep = !0;
          let n = t(e);
          fetch(e.href, n)
      }
  }
  )()
}
))
, kte = t(( () => {}
));
function Ate() {
  `hasOwn`in Object || Object.defineProperty(Object, `hasOwn`, {
      value: Object.call.bind(Object.hasOwnProperty),
      writable: !0,
      enumerable: !1,
      configurable: !0
  })
}
var jte = t(( () => {}
));
function Mte() {
  Array.prototype.distinct = function() {
      return this.length <= 15 ? this.filter( (e, t, n) => n.indexOf(e) === t) : [...new Set(this)]
  }
  ,
  Array.prototype.concrete = function() {
      return this.filter(e => e !== void 0)
  }
  ,
  Array.prototype.groupBy = function(e, t) {
      let n = new Map;
      for (let t of this) {
          let r = t[e]
            , i = n.get(r);
          i ? i.push(t) : n.set(r, [t])
      }
      if (t) {
          let e = Array.from(n.keys()).sortBy(t)
            , r = new Map;
          for (let t of e)
              r.set(t, n.get(t));
          return r
      } else
          return n
  }
  ,
  Array.prototype.orderBy = function(e, t) {
      return (0,
      In.default)(this, e, t)
  }
  ,
  Array.prototype.sortBy = function(e) {
      return (0,
      Fn.default)(this, e)
  }
  ,
  Array.prototype.toReversed || (Array.prototype.toReversed = function() {
      return [...this].reverse()
  }
  )
}
var Fn, In, Nte = t(( () => {
  Fn = e(_(), 1),
  In = e(Se(), 1)
}
));
function y(e) {
  return new Rn(e)
}
function Ln(e) {
  throw new Rn(e)
}
var Rn, zn = t(( () => {
  Rn = class extends Error {
      constructor(e) {
          super(`Unreachable case: ${e}`)
      }
  }
}
));
function Pte() {
  Date.prototype.beginningOfWeek = function(e) {
      let t = De(this, e).day(0).hour(0).minute(0).second(0).millisecond(0);
      return new Date(t.epoch)
  }
  ,
  Date.prototype.nextWeekDay = function(e, t) {
      let n = De(this, t).day(e).hour(0).minute(0).second(0).millisecond(0);
      return n.isBefore(De(this, t)) || n.isEqual(De(this, t)) ? new Date(n.add(1, `week`).epoch) : new Date(n.epoch)
  }
  ,
  Date.prototype.midnight = function(e) {
      if (!e) {
          let e = new Date(this.getTime());
          return e.setHours(0),
          e.setMinutes(0),
          e.setSeconds(0),
          e.setMilliseconds(0),
          e
      }
      let t = De(this, e).hour(0).minute(0).second(0).millisecond(0);
      return new Date(t.epoch)
  }
  ,
  Date.prototype.nearestMidnight = function(e) {
      if (!e)
          return this.offsetByHours(12).midnight();
      let t = De(this, e).hour(12).minute(0).second(0).millisecond(0)
        , n = De(this, e);
      return n.isAfter(t) && (n = n.add(1, `day`)),
      n = n.hour(0).minute(0).second(0).millisecond(0),
      new Date(n.epoch)
  }
  ,
  Date.prototype.offsetByDays = function(e, t) {
      if (!t) {
          let t = new Date(this.getTime());
          return t.setDate(t.getDate() + e),
          t
      }
      let n = De(this, t).add(e, `day`);
      return new Date(n.epoch)
  }
  ,
  Date.prototype.offsetByBusinessDays = function(e, t, n) {
      return Fte(this, e, t, n)
  }
  ,
  Date.prototype.offsetByHours = function(e) {
      return new Date(this.getTime() + e * 60 * 60 * 1e3)
  }
  ,
  Date.prototype.offsetBySeconds = function(e) {
      return new Date(this.getTime() + e * 1e3)
  }
  ,
  Date.prototype.toUTCDate = function() {
      return new Date(this.getTime() + this.getTimezoneOffset() * 6e4)
  }
  ,
  Date.prototype.daysTo = function(e) {
      return lt(e, this)
  }
  ,
  Date.prototype.toTimelessDate = function() {
      let e = (this.getMonth() + 1).toString().padStart(2, `0`)
        , t = this.getDate().toString().padStart(2, `0`);
      return `${this.getFullYear()}-${e}-${t}`
  }
  ,
  String.prototype.toLocalDate = function(e) {
      let t = new Date(this);
      if (t.toString() === `Invalid Date`)
          return this.length === 0 ? new Date : this.substring(0, this.length - 1).toLocalDate();
      if (!e)
          return new Date(t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate());
      let n = De(this, e).year(t.getUTCFullYear()).month(t.getUTCMonth()).date(t.getUTCDate()).hour(0).minute(0).second(0).millisecond(0);
      return new Date(n.epoch)
  }
}
function Bn(e) {
  switch (e) {
  case Vn.Sunday:
      return `Sunday`;
  case Vn.Monday:
      return `Monday`;
  case Vn.Tuesday:
      return `Tuesday`;
  case Vn.Wednesday:
      return `Wednesday`;
  case Vn.Thursday:
      return `Thursday`;
  case Vn.Friday:
      return `Friday`;
  case Vn.Saturday:
      return `Saturday`;
  default:
      throw new Rn(e)
  }
}
function Fte(e, t, n, r) {
  if (n.length === 0 || n.length > 7 || n.some(e => e < 0 || e > 6))
      throw Error(`Invalid work days specified`);
  if (Math.abs(t) > Hn)
      throw Error(`Business day offset out of bounds (>${Hn} offset)`);
  if (t === 0)
      return e;
  let i = r ? De(e, r) : new Date(e.getTime())
    , a = Math.sign(t)
    , o = Math.max(0, Math.abs(Math.trunc(t / n.length)) - 1);
  i = i instanceof Date ? Ye(i, a * o) : i.add(a * o, `week`);
  let s = Math.abs(t) - o * n.length;
  for (; s > 0; ) {
      let e;
      i instanceof Date ? (i = ze(i, a),
      e = Ve(i)) : (i = i.add(a, `day`),
      e = i.day()),
      n.includes(e) && --s
  }
  return i instanceof Date ? i : new Date(i.epoch)
}
var Vn, Hn, Un = t(( () => {
  Oe(),
  nt(),
  zn(),
  Vn = function(e) {
      return e[e.Sunday = 0] = `Sunday`,
      e[e.Monday = 1] = `Monday`,
      e[e.Tuesday = 2] = `Tuesday`,
      e[e.Wednesday = 3] = `Wednesday`,
      e[e.Thursday = 4] = `Thursday`,
      e[e.Friday = 5] = `Friday`,
      e[e.Saturday = 6] = `Saturday`,
      e
  }({}),
  Hn = 1e7
}
));
function Ite(e, t) {
  if (e.length === 0)
      return new Promise(e => e(void 0));
  let n = t ?? (e => e);
  return new Promise( (t, r) => {
      let i = e.length;
      e.forEach(e => {
          Promise.resolve(e).then(e => {
              n(e) && t(e)
          }
          ).catch(e => {
              r(e)
          }
          ).finally( () => {
              i--,
              i === 0 && t(void 0)
          }
          )
      }
      )
  }
  )
}
function Lte() {
  let e, t;
  return {
      promise: new Promise( (n, r) => {
          e = n,
          t = r
      }
      ),
      resolve: e,
      reject: t
  }
}
function Rte() {
  Promise.any || (Promise.any = Wn),
  Promise.raceFind || (Promise.raceFind = Ite),
  Promise.withResolvers || (Promise.withResolvers = Lte)
}
var Wn, zte = t(( () => {
  Wn = e => Promise.all([...e].map(e => new Promise( (t, n) => Promise.resolve(e).then(n, t)))).then(e => Promise.reject(e), e => Promise.resolve(e))
}
));
function Bte() {
  String.prototype.capitalize = function() {
      return this.charAt(0).toUpperCase() + this.slice(1)
  }
  ,
  String.prototype.deCapitalize = function() {
      return this.charAt(0).toLowerCase() + this.slice(1)
  }
  ,
  String.prototype.toQuestion = function() {
      let e = this.replace(/(\.|,|:)$/, ``);
      return e.lastIndexOf(`?`) === e.length - 1 ? e : e + `?`
  }
}
var Vte = t(( () => {}
));
function Hte() {
  Set.prototype.isEqualTo = function(e) {
      return this.size === e.size && [...this].every(t => e.has(t))
  }
}
var Ute = t(( () => {}
));
function Wte() {
  Gn(`dispose`),
  Gn(`asyncDispose`)
}
function Gn(e) {
  Object.getOwnPropertyDescriptor(Symbol, e) || Object.defineProperty(Symbol, e, {
      value: Symbol(`@linear/Symbol.${e}`),
      configurable: !1,
      enumerable: !1,
      writable: !1
  })
}
var Gte = t(( () => {}
));
function Kn() {
  Mte(),
  Pte(),
  Rte(),
  Bte(),
  Ate(),
  Hte(),
  Wte()
}
var qn = t(( () => {
  jte(),
  Nte(),
  Un(),
  zte(),
  Vte(),
  Ute(),
  Gte()
}
));
function Kte(e) {
  Yn = e
}
var Jn, Yn, Xn = t(( () => {
  Jn = new Proxy({},{
      get(e, t) {
          if (!Yn)
              throw Error(`Config has not been injected. Call injectConfig() during client initialization.`);
          return Yn[t]
      }
  })
}
));
function Zn(e) {
  let t = Qn(e);
  return t === void 0 ? (console.error(`Environment variable ${e} is not defined`),
  ``) : t
}
function Qn(e) {
  return window.CLIENT_ENV && e in window.CLIENT_ENV ? window.CLIENT_ENV[e] : {
      BASE_URL: `https://static.linear.app/client/`,
      DEV: !1,
      MODE: `production`,
      PROD: !0,
      SSR: !1,
      VITE_ALGOLIA_SEARCH_KEY: `b52da28605c5df5ebf54e3cd09d1302e`,
      VITE_ANALYTICS_URL: `https://e.linear.app`,
      VITE_API_SERVER_URL: `https://client-api.linear.app`,
      VITE_ASSET_URL: `https://static.linear.app/client/`,
      VITE_CJS_IGNORE_WARNING: `true`,
      VITE_CLIENT_URL: `https://linear.app`,
      VITE_DEBUG_LOG_NETWORK_DATA: `false`,
      VITE_DEMO_ORGANIZATION_ID: `3c2f7bee-10f9-4248-838b-c94f7e2242f1`,
      VITE_DEMO_USER_ACCOUNT_ID: `ba7a19e2-cb18-4f3b-8089-23895c7bc4e6`,
      VITE_DEMO_USER_EMAIL: `user@linear-demo.com`,
      VITE_DEMO_USER_ID: `193aab40-d27d-464c-97b3-1859abfcd721`,
      VITE_DISCORD_OAUTH_CLIENT_ID: `957060182561669132`,
      VITE_DISCORD_OAUTH_REDIRECT_URL: `https://linear.app/connect/discord/callback`,
      VITE_EMAIL_INTAKE_FROM_EMAIL: `issues@linear.app`,
      VITE_EMAIL_INTAKE_HOSTNAME: `intake.linear.app`,
      VITE_FIGMA_INTERNAL_OAUTH_CLIENT_ID: `a68faaa3f27a017c4b067874c86773e4`,
      VITE_FIGMA_OAUTH_CLIENT_ID: `STbJqWt09xEGg40Xij0i59`,
      VITE_FIGMA_OAUTH_REDIRECT_URL: `https://linear.app/connect/figma/callback`,
      VITE_FRONT_INTERNAL_OAUTH_CLIENT_ID: `1cb4cbf677a40183f0dc8a178e7d049d`,
      VITE_FRONT_OAUTH_CLIENT_ID: `358600cf7be06c253af8`,
      VITE_FRONT_OAUTH_REDIRECT_URL: `https://linear.app/connect/front/callback`,
      VITE_GITHUB_APP_OAUTH_CLIENT_ID: `Iv1.085d682ea245c945`,
      VITE_GITHUB_APP_OAUTH_REDIRECT_URL: `https://linear.app/connect/github-account/callback`,
      VITE_GITHUB_APP_URL: `https://github.com/apps/linear`,
      VITE_GITHUB_CODE_ACCESS_APP_OAUTH_CLIENT_ID: `Iv23lia2it3rsjIhboVE`,
      VITE_GITHUB_CODE_ACCESS_APP_OAUTH_REDIRECT_URL: `https://linear.app/connect/github-account-code-access/callback`,
      VITE_GITHUB_CODE_ACCESS_APP_URL: `https://github.com/apps/linear-code-review`,
      VITE_GITHUB_IMPORTER_APP_URL: `https://github.com/apps/linear-data-importer`,
      VITE_GITHUB_IMPORTER_INSTALL_URL: `https://github.com/apps/linear-data-importer/installations/new`,
      VITE_GONG_OAUTH_CLIENT_ID: `ryzvvfnqas`,
      VITE_GONG_OAUTH_REDIRECT_URL: `https://linear.app/connect/gong/callback`,
      VITE_GOOGLE_CALENDAR_REDIRECT_URL: `https://linear.app/connect/google/callback`,
      VITE_GOOGLE_OAUTH_CLIENT_ID: `463717515632-5f96ed9uaue5p206umg9toffdbfmsfbm.apps.googleusercontent.com`,
      VITE_GOOGLE_OAUTH_REDIRECT_URL: `https://linear.app/auth/google/callback`,
      VITE_GOOGLE_SHEETS_REDIRECT_URL: `https://linear.app/connect/google/callback`,
      VITE_GRAPHQL_SERVER_HTTP: `https://client-api.linear.app/graphql`,
      VITE_HOST: `local.linear.dev`,
      VITE_INTERCOM_OAUTH_CLIENT_ID: `56c76476-e15f-425d-9de1-2f60ebcb3370`,
      VITE_JIRA_OAUTH_CLIENT_ID: `SbDhEGt9q209sJQh3gOTNeUuibVKhXjg`,
      VITE_JIRA_OAUTH_REDIRECT_URL: `https://linear.app/connect/jira/callback`,
      VITE_LAUNCHDARKLY_OAUTH_CLIENT_ID: `1ad0c39d-ef78-449d-bf60-97ece78954eb`,
      VITE_LAUNCHDARKLY_OAUTH_REDIRECT_URL: `https://linear.app/connect/launchdarkly/callback`,
      VITE_LINEAR_DEMO_ORGANIZATION_ID: `d763f07e-f5da-4a9f-b9da-12c4563607a7`,
      VITE_NOTION_INTERNAL_OAUTH_CLIENT_ID: `dd7bac7615ab5b83e6093725b56c42ce`,
      VITE_PAGERDUTY_OAUTH_CLIENT_ID: `de0027f4-8caf-48ec-8a87-caf596dbafc0`,
      VITE_PAGERDUTY_OAUTH_REDIRECT_URL: `https://linear.app/connect/pagerduty/callback`,
      VITE_POSTHOG_SESSION_REPLAY_WRITE_KEY: `phc_ug8xcON3MBePKK6mnfbrmOXkv969J77eRbKipX17XpQ`,
      VITE_POSTHOG_WRITE_KEY: `phc_PaCjzqaetuAlYgXjb0uftDOw8QzOmXfWIbD7nkaYrjr`,
      VITE_PUSH_MESSAGE_VAPID_PUBLIC_KEY: `BGmzp5YJU9nt-dFhX-jQvi9Ch-ROVsxrK1AqWOsRmPE6zFY6zg4qcln3P_3EsH9M1pddJEGXeK326zp1MSPlNIQ`,
      VITE_SALESFORCE_INTERNAL_OAUTH_CLIENT_ID: `ceb1d7ca0c9c37b8c1aa32fb5385bbe1`,
      VITE_SALESFORCE_OAUTH_CLIENT_ID: `3MVG9B0tr1AAvBIQEYGt4zJ59m7gDLHrRnaFPAc5yTmzVUH6WGufOyxCW0P1K0BxbtCr2spr260bvd_.RDq9a`,
      VITE_SALESFORCE_OAUTH_REDIRECT_URL: `https://linear.app/connect/salesforce/callback`,
      VITE_SANITY_CHANGELOG_API_KEY: ``,
      VITE_SANITY_PROJECT_ID: `ornj730p`,
      VITE_SECURE_IMAGE_PROXY_URL: `https://secure-img-proxy.linear.app`,
      VITE_SENTRY_DSN: `https://f172c25063bf4e3492ece32b840ab90b@o415358.ingest.us.sentry.io/5337513`,
      VITE_SENTRY_INTEGRATION_APP_NAME: `linear`,
      VITE_SENTRY_TUNNEL: `https://s.linear.app/tunnel`,
      VITE_SLACK_CLIENT_ID: `328068080260.497819820514`,
      VITE_SLACK_INTAKE_APP_CLIENT_ID: `328068080260.4867786112663`,
      VITE_SLACK_STAGING_CLIENT_ID: `328068080260.5674009759762`,
      VITE_SOCKET_SERVER_URL: `wss://sync.linear.app`,
      VITE_START_SERVICE_WORKER: `true`,
      VITE_STRIPE_PUBLIC_KEY: `pk_live_DIFLzeTR6Mm4NO6AWaQZ0erl`,
      VITE_UPLOAD_BUCKET_DOMAIN: `https://uploads.linear.app`,
      VITE_USER_NODE_ENV: `production`,
      VITE_ZENDESK_INTERNAL_OAUTH_CLIENT_ID: `f5961297b58e81fa7f2e8b2bf36a41bc`,
      VITE_ZENDESK_OAUTH_CLIENT_ID: `zdg-linear`,
      VITE_ZENDESK_OAUTH_REDIRECT_URL: `https://linear.app/connect/zendesk/callback`
  }[`VITE_` + e]
}
var $n, er = t(( () => {
  $n = {
      ALGOLIA_SEARCH_KEY: Zn(`ALGOLIA_SEARCH_KEY`),
      API_SERVER_URL: Zn(`API_SERVER_URL`),
      ASSET_URL: Qn(`ASSET_URL`) ?? ``,
      CLIENT_URL: Zn(`CLIENT_URL`),
      CLIENT_HOSTNAME: new URL(Zn(`CLIENT_URL`)).hostname,
      ANALYTICS_URL: Zn(`ANALYTICS_URL`),
      DEMO_ORGANIZATION_ID: Zn(`DEMO_ORGANIZATION_ID`),
      DEMO_USER_EMAIL: Zn(`DEMO_USER_EMAIL`),
      DEMO_USER_ID: Zn(`DEMO_USER_ID`),
      DEMO_USER_ACCOUNT_ID: Zn(`DEMO_USER_ACCOUNT_ID`),
      DISCORD_OAUTH_CLIENT_ID: Zn(`DISCORD_OAUTH_CLIENT_ID`),
      DISCORD_OAUTH_REDIRECT_URL: Zn(`DISCORD_OAUTH_REDIRECT_URL`),
      EMAIL_INTAKE_HOSTNAME: Zn(`EMAIL_INTAKE_HOSTNAME`),
      EMAIL_INTAKE_FROM_EMAIL: Zn(`EMAIL_INTAKE_FROM_EMAIL`),
      FIGMA_OAUTH_CLIENT_ID: Zn(`FIGMA_OAUTH_CLIENT_ID`),
      FIGMA_OAUTH_REDIRECT_URL: Zn(`FIGMA_OAUTH_REDIRECT_URL`),
      GITHUB_APP_URL: Zn(`GITHUB_APP_URL`),
      GITHUB_IMPORTER_APP_URL: Zn(`GITHUB_IMPORTER_APP_URL`),
      GITHUB_CODE_ACCESS_APP_URL: Zn(`GITHUB_CODE_ACCESS_APP_URL`),
      GITHUB_APP_OAUTH_REDIRECT_URL: Zn(`GITHUB_APP_OAUTH_REDIRECT_URL`),
      GITHUB_APP_OAUTH_CLIENT_ID: Zn(`GITHUB_APP_OAUTH_CLIENT_ID`),
      GITHUB_CODE_ACCESS_APP_OAUTH_REDIRECT_URL: Zn(`GITHUB_CODE_ACCESS_APP_OAUTH_REDIRECT_URL`),
      GITHUB_CODE_ACCESS_APP_OAUTH_CLIENT_ID: Zn(`GITHUB_CODE_ACCESS_APP_OAUTH_CLIENT_ID`),
      GITHUB_IMPORTER_INSTALL_URL: Zn(`GITHUB_IMPORTER_INSTALL_URL`),
      GONG_OAUTH_CLIENT_ID: Zn(`GONG_OAUTH_CLIENT_ID`),
      GONG_OAUTH_REDIRECT_URL: Zn(`GONG_OAUTH_REDIRECT_URL`),
      GOOGLE_OAUTH_CLIENT_ID: Zn(`GOOGLE_OAUTH_CLIENT_ID`),
      GOOGLE_OAUTH_REDIRECT_URL: Zn(`GOOGLE_OAUTH_REDIRECT_URL`),
      GOOGLE_SHEETS_REDIRECT_URL: Zn(`GOOGLE_SHEETS_REDIRECT_URL`),
      GOOGLE_CALENDAR_REDIRECT_URL: Zn(`GOOGLE_CALENDAR_REDIRECT_URL`),
      GRAPHQL_SERVER_HTTP: Zn(`GRAPHQL_SERVER_HTTP`),
      INTERCOM_OAUTH_CLIENT_ID: Zn(`INTERCOM_OAUTH_CLIENT_ID`),
      JIRA_OAUTH_CLIENT_ID: Zn(`JIRA_OAUTH_CLIENT_ID`),
      JIRA_OAUTH_REDIRECT_URL: Zn(`JIRA_OAUTH_REDIRECT_URL`),
      LINEAR_DEMO_ORGANIZATION_ID: Zn(`LINEAR_DEMO_ORGANIZATION_ID`),
      NOTION_INTERNAL_OAUTH_CLIENT_ID: Zn(`NOTION_INTERNAL_OAUTH_CLIENT_ID`),
      FIGMA_INTERNAL_OAUTH_CLIENT_ID: Zn(`FIGMA_INTERNAL_OAUTH_CLIENT_ID`),
      PAGERDUTY_OAUTH_CLIENT_ID: Zn(`PAGERDUTY_OAUTH_CLIENT_ID`),
      PAGERDUTY_OAUTH_REDIRECT_URL: Zn(`PAGERDUTY_OAUTH_REDIRECT_URL`),
      LAUNCHDARKLY_OAUTH_CLIENT_ID: Zn(`LAUNCHDARKLY_OAUTH_CLIENT_ID`),
      LAUNCHDARKLY_OAUTH_REDIRECT_URL: Zn(`LAUNCHDARKLY_OAUTH_REDIRECT_URL`),
      PUSH_MESSAGE_VAPID_PUBLIC_KEY: Zn(`PUSH_MESSAGE_VAPID_PUBLIC_KEY`),
      SANITY_PROJECT_ID: Zn(`SANITY_PROJECT_ID`),
      SANITY_CHANGELOG_API_KEY: Zn(`SANITY_CHANGELOG_API_KEY`),
      SECURE_IMAGE_PROXY_URL: Zn(`SECURE_IMAGE_PROXY_URL`),
      SENTRY_DSN: Qn(`SENTRY_DSN`),
      SENTRY_TUNNEL: Qn(`SENTRY_TUNNEL`),
      SENTRY_INTEGRATION_APP_NAME: Zn(`SENTRY_INTEGRATION_APP_NAME`),
      SLACK_CLIENT_ID: Zn(`SLACK_CLIENT_ID`),
      SLACK_STAGING_CLIENT_ID: Zn(`SLACK_STAGING_CLIENT_ID`),
      SLACK_INTAKE_APP_CLIENT_ID: Zn(`SLACK_INTAKE_APP_CLIENT_ID`),
      SOCKET_SERVER_URL: Zn(`SOCKET_SERVER_URL`),
      STRIPE_PUBLIC_KEY: Zn(`STRIPE_PUBLIC_KEY`),
      ZENDESK_INTERNAL_OAUTH_CLIENT_ID: Zn(`ZENDESK_INTERNAL_OAUTH_CLIENT_ID`),
      ZENDESK_OAUTH_CLIENT_ID: Zn(`ZENDESK_OAUTH_CLIENT_ID`),
      ZENDESK_OAUTH_REDIRECT_URL: Zn(`ZENDESK_OAUTH_REDIRECT_URL`),
      FRONT_INTERNAL_OAUTH_CLIENT_ID: Zn(`FRONT_INTERNAL_OAUTH_CLIENT_ID`),
      FRONT_OAUTH_CLIENT_ID: Zn(`FRONT_OAUTH_CLIENT_ID`),
      FRONT_OAUTH_REDIRECT_URL: Zn(`FRONT_OAUTH_REDIRECT_URL`),
      BUILD_REVISION: window.__RELEASE_INFO?.BUILD_REVISION ?? Qn(`PREVIEW_BUILD_REVISION`),
      DEPLOYED_AT: window.__RELEASE_INFO?.DEPLOYED_AT ? new Date(window.__RELEASE_INFO.DEPLOYED_AT) : void 0,
      SHORT_SHA: window.__RELEASE_INFO?.SHORT_SHA,
      PREVIEW_BUILD: Qn(`PREVIEW_BUILD`) === `true`,
      PREVIEW_PR_NUMBER: Qn(`PREVIEW_PR_NUMBER`) || new URL(self.document.URL).host.match(/pr-(\d+)/)?.[1],
      POSTHOG_WRITE_KEY: Zn(`POSTHOG_WRITE_KEY`),
      POSTHOG_SESSION_REPLAY_WRITE_KEY: Qn(`POSTHOG_SESSION_REPLAY_WRITE_KEY`),
      COUNTRY_CODE: Qn(`COUNTRY_CODE`),
      SALESFORCE_INTERNAL_OAUTH_CLIENT_ID: Zn(`SALESFORCE_INTERNAL_OAUTH_CLIENT_ID`),
      SALESFORCE_OAUTH_CLIENT_ID: Zn(`SALESFORCE_OAUTH_CLIENT_ID`),
      SALESFORCE_OAUTH_REDIRECT_URL: Zn(`SALESFORCE_OAUTH_REDIRECT_URL`),
      UPLOAD_BUCKET_DOMAIN: Zn(`UPLOAD_BUCKET_DOMAIN`),
      ENABLE_CRASH_REPORTING: !!Qn(`ENABLE_CRASH_REPORTING`),
      IS_PRODUCTION_ENV: !0,
      IS_TEST_ENV: !1,
      IS_DEVELOPMENT_ENV: !1,
      IS_STAGING: !!Qn(`IS_STAGING`),
      DEBUG_LOG_NETWORK_DATA: Qn(`DEBUG_LOG_NETWORK_DATA`) === `true`,
      DEBUG_LOG_EXPAND_BATCH_LOAD: Qn(`DEBUG_LOG_EXPAND_BATCH_LOAD`) === `true`
  }
}
)), qte = t(( () => {
  if (qn(),
  Xn(),
  er(),
  pee(),
  Kn(),
  Kte($n),
  window.__toStaticUrl = e => `${$n.ASSET_URL}${e}`,
  mee({
      jitless: !0
  }),
  window.requestIdleCallback = window.requestIdleCallback || function(e) {
      let t = Date.now();
      return setTimeout(function() {
          e({
              didTimeout: !1,
              timeRemaining: function() {
                  return Math.max(0, 50 - (Date.now() - t))
              }
          })
      }, 1)
  }
  ,
  window.cancelIdleCallback = window.cancelIdleCallback || function(e) {
      clearTimeout(e)
  }
  ,
  window.__electronSystemLocale__) {
      let e = window.__electronSystemLocale__;
      try {
          new Intl.Locale(e)
      } catch {
          e = e.includes(`@`) ? e.split(`@`)[0] : e;
          try {
              e = e.split(`@`)[0]
          } catch {
              e = `en-US`
          }
      }
      let t = Intl.DateTimeFormat;
      Intl.DateTimeFormat = function(n, r) {
          return new t(n || e,r)
      }
      ,
      Object.setPrototypeOf(Intl.DateTimeFormat, t);
      let n = Intl.NumberFormat;
      Intl.NumberFormat = function(t, r) {
          return new n(t || e,r)
      }
      ,
      Object.setPrototypeOf(Intl.NumberFormat, n),
      Object.defineProperty(navigator, `language`, {
          get: () => e,
          configurable: !0
      }),
      Object.defineProperty(navigator, `languages`, {
          get: () => [e, `en-US`],
          configurable: !0
      })
  }
}
)), tr, nr = t(( () => {
  tr = (function() {
      return !!(typeof process < `u` && typeof process.versions == `object` && process.versions.electron || typeof navigator == `object` && typeof navigator.userAgent == `string` && navigator.userAgent.indexOf(`Electron`) >= 0 && navigator.userAgent.indexOf(`Linear`) >= 0)
  }
  )()
}
)), rr, ir = t(( () => {
  nr(),
  rr = class e {
      static get browserName() {
          let e = this.isSafari ? `Safari` : this.isChrome ? `Chrome` : this.isBrave ? `Brave` : this.isFirefox ? `Firefox` : `Unknown`;
          return this.isMobile ? `${e} (Mobile)` : e
      }
      static #e = this.isSafari = typeof navigator < `u` && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      static get isSafari16() {
          return e.memoize(e.isSafari16Fnc)
      }
      static #t = this.isBrave = typeof navigator < `u` && navigator.brave?.isBrave.name === `isBrave`;
      static #n = this.isFirefox = typeof navigator < `u` && navigator.userAgent.toLowerCase().indexOf(`firefox`) > -1;
      static #r = this.isChrome = typeof navigator < `u` && navigator.userAgent.toLowerCase().indexOf(`chrome`) > -1;
      static #i = this.isMobileSize = typeof window < `u` && window.innerWidth < 640;
      static #a = this.isMac = typeof navigator < `u` && navigator.platform === `MacIntel`;
      static get isMacOSWithLargeWindowBorders() {
          return e.memoize( () => {
              if (tr || !e.isMac || typeof navigator > `u`)
                  return !1;
              let t = /Mac OS X (\d+)[_.](\d+)/.exec(navigator.userAgent);
              if (!t)
                  return !1;
              let n = parseInt(t[1], 10)
                , r = parseInt(t[2], 10);
              return n >= 10 && r >= 15
          }
          )
      }
      static #o = this.isiPad = typeof navigator < `u` && (/iPad/.test(navigator.userAgent) || navigator.platform === `MacIntel` && navigator.maxTouchPoints > 1);
      static #s = this.isiOS = typeof navigator < `u` && (/iPhone|iPod/.test(navigator.userAgent) || e.isiPad);
      static #c = this.isAppleDevice = e.isiOS || e.isMac || e.isiPad;
      static #l = this.isAndroid = typeof navigator < `u` && /android/i.test(navigator.userAgent);
      static #u = this.isWindows = typeof navigator < `u` && `platform`in navigator && navigator.platform === `Win32`;
      static #d = this.isLinux = typeof navigator < `u` && `platform`in navigator && navigator.platform.includes(`Linux`);
      static #f = this.isPixel = typeof navigator < `u` && /\(Linux; Android \d+\; Pixel \d+/i.test(navigator.userAgent);
      static #p = this.isMobile = typeof navigator < `u` && /mobile/i.test(navigator.userAgent) && (e.isiOS || e.isAndroid);
      static #m = this.isPWA = typeof navigator < `u` && `standalone`in navigator && navigator.standalone === !0 || typeof window < `u` && window.matchMedia?.(`(display-mode: standalone)`).matches;
      static get isPureTouchDevice() {
          return e._isPureTouch === void 0 && (e._isPureTouch = e.isPureTouchDeviceFnc()),
          e._isPureTouch
      }
      static #h = this.FORCE_POINTER_MODE_LOCAL_STORAGE_KEY = `FORCE_POINTER_MODE`;
      static #g = this.FORCE_POINTER_MODE = {
          FINE: `fine`,
          COARSE: `coarse`
      };
      static isSafari16Fnc() {
          return /(\s|^)AppleWebKit\/[\d\.]+\s+\(.+\)\s+Version\/16(\.|$|\s)/i.test(navigator.userAgent)
      }
      static isPureTouchDeviceFnc() {
          let t;
          try {
              let n = localStorage.getItem(e.FORCE_POINTER_MODE_LOCAL_STORAGE_KEY);
              t = n ? JSON.parse(n) : void 0
          } catch {}
          return t === void 0 ? e.isPixel === !0 || typeof window < `u` && window.matchMedia?.(`(pointer: coarse)`)?.matches : t === e.FORCE_POINTER_MODE.COARSE
      }
      static memoize(t) {
          e.memo === void 0 && (e.memo = new Map);
          let n = e.memo.get(t);
          return n === void 0 && (n = t(),
          e.memo.set(t, n)),
          n
      }
  }
}
)), ar, or, sr, cr = t(( () => {
  ar = typeof window < `u`,
  or = e => ar ? window.CLIENT_ENV?.[e] ?? `` : {}[e] ?? ``,
  sr = {
      DESKTOP_PORTS: [44450, 18450, 33234],
      DEFAULT_ISSUES_TEAM_ID_LESS_100: `3e7dcab1-67f5-4301-94f8-1a4e93279069`,
      DEFAULT_ISSUES_TEAM_ID_MORE_100: `58c33d85-ef8a-4aea-ba14-782eb33cf0b3`,
      PRODUCTION_ENV: !0,
      CLIENT_URL: (or(`CLIENT_URL`) || `https://linear.app`) ?? `https://linear.app`,
      API_SERVER_URL: or(`API_SERVER_URL`),
      FRONT_INTERNAL_OAUTH_CLIENT_ID: or(`FRONT_INTERNAL_OAUTH_CLIENT_ID`),
      ZENDESK_INTERNAL_OAUTH_CLIENT_ID: or(`ZENDESK_INTERNAL_OAUTH_CLIENT_ID`),
      FIGMA_INTERNAL_OAUTH_CLIENT_ID: or(`FIGMA_INTERNAL_OAUTH_CLIENT_ID`)
  }
}
)), lr, ur, dr, fr, pr, mr, hr, Jte = t(( () => {
  cr(),
  lr = e => ` __                                               _____          __          __           ______          v${e}\n/\\ \\       __                                    /\\  __\`\\       /\\ \\      __/\\ \\__       /\\__  _\\
\\ \\ \\     /\\_\\    ___      __     __     _ __    \\ \\ \\/\\ \\  _ __\\ \\ \\____/\\_\\ \\ ,_\\      \\/_/\\ \\/     ___     ___
\\ \\ \\  __\\/\\ \\ /' _ \`\\  /'__\`\\ /'__\`\\  /\\\`'__\\   \\ \\ \\ \\ \\/\\\`'__\\ \\ '__\`\\/\\ \\ \\ \\/         \\ \\ \\   /' _ \`\\  /'___\\
\\ \\ \\L\\ \\\\ \\ \\/\\ \\/\\ \\/\\  __//\\ \\L\\.\\_\\ \\ \\/     \\ \\ \\_\\ \\ \\ \\/ \\ \\ \\L\\ \\ \\ \\ \\ \\_  __     \\_\\ \\__/\\ \\/\\ \\/\\ \\__/  __
 \\ \\____/ \\ \\_\\ \\_\\ \\_\\ \\____\\ \\__/.\\_\\\\ \\_\\      \\ \\_____\\ \\_\\  \\ \\_,__/\\ \\_\\ \\__\\/\\ \\    /\\_____\\ \\_\\ \\_\\ \\____\\/\\_\\
  \\/___/   \\/_/\\/_/\\/_/\\/____/\\/__/\\/_/ \\/_/       \\/_____/\\/_/   \\/___/  \\/_/\\/__/\\ \\/    \\/_____/\\/_/\\/_/\\/____/\\/_/
                                                                                    \\/`,
  ur = `Build products better`,
  dr = `WE'RE HIRING: https://linear.app/careers`,
  fr = `CHANGELOG:    https://linear.app/changelog`,
  pr = () => `
font-family: monospace;
color: ${typeof window < `u` && window.matchMedia(`(prefers-color-scheme: dark)`).matches ? `#F7F8F8` : `#282A30`};
`,
  mr = !1,
  hr = e => {
      !mr && sr.PRODUCTION_ENV && (console.log(`%c${lr(e)}\n\n${ur}\n\n${dr}\n${fr}\n`, pr()),
      mr = !0)
  }
}
)), gr, _r = t(( () => {
  cr(),
  gr = class {
      static versionString(e, t) {
          let n = e ?? `0`;
          return sr.PRODUCTION_ENV ? `1.${n}.0${t ? `-${t}` : ``}` : `12345.0.0`
      }
  }
}
));
function vr(e) {
  try {
      return JSON.parse(e)
  } catch {
      return
  }
}
var yr = t(( () => {}
));
function br(e, t, n) {
  if (n < 0 || t < 0 || e < 0)
      throw Error(`all values must be non negative`);
  if (n < t)
      throw Error(`max must be greater than min`);
  return e + Math.floor(Math.random() * (n - t + 1) + t)
}
function xr(e, t) {
  let {year: n=`numeric`, month: r=`short`, day: i=`numeric`} = t ?? {}
    , a = e instanceof Date ? e : e.toLocalDate();
  return oee(a) === oee(new Date) ? (Ir ??= new Intl.DateTimeFormat(`en-US`,{
      day: i,
      month: r
  }),
  Ir.format(a)) : (Fr ??= new Intl.DateTimeFormat(`en-US`,{
      day: i,
      month: r,
      year: n
  }),
  Fr.format(a))
}
function Sr(e, t, n) {
  let r = st(e, t)
    , i = {
      minute: [`m`, `minute`],
      hour: [`h`, `hour`],
      day: [`d`, `day`],
      week: [`w`, `week`],
      month: [`mo`, `month`],
      year: [`y`, `year`]
  }
    , a = (e, t) => {
      let[r,a] = i[t];
      return n?.fullNames ? `${e} ${(0,
      Er.default)(a, e)}` : `${e}${r}`
  }
    , o = (e, t) => !t || n?.singlePart ? e : n?.fullNames ? `${e} and ${t}` : `${e} ${t}`;
  if (r < b.MINUTE)
      return a(1, `minute`);
  if (r < b.HOUR) {
      let e = Math.round(r / b.MINUTE);
      return e === 60 ? a(1, `hour`) : a(e, `minute`)
  }
  if (r < b.HOUR * 8) {
      let e = Math.floor(r / b.HOUR)
        , t = Math.round((r - e * b.HOUR) / b.MINUTE);
      return t === 60 ? a(e + 1, `hour`) : o(a(e, `hour`), t > 0 ? a(t, `minute`) : void 0)
  }
  if (r < b.HOUR * 24)
      return a(Math.round(r / b.HOUR), `hour`);
  if (r < b.DAY * 5) {
      let e = Math.floor(r / b.DAY)
        , t = Math.round((r - e * b.DAY) / b.HOUR);
      return t === 24 ? a(e + 1, `day`) : o(a(e, `day`), t > 0 ? a(t, `hour`) : void 0)
  }
  if (r < b.MONTH)
      return a(Math.round(r / b.DAY), `day`);
  if (r < b.WEEK * 10) {
      let e = Math.floor(r / b.WEEK)
        , t = Math.round((r - e * b.WEEK) / b.DAY);
      return t === 7 ? a(e + 1, `week`) : o(a(e, `week`), t > 0 ? a(t, `day`) : void 0)
  }
  return r < b.YEAR ? a(Math.max(1, Math.floor(r / b.MONTH)), `month`) : a(wr(r / b.YEAR), `year`)
}
function Yte(e) {
  return /^(\d+)(s|m|h|d)$/.test(e)
}
function Xte(e, t) {
  let n = /^(\d+)(s|m|h|d)$/.exec(e);
  if (!n) {
      if (t !== void 0)
          return t;
      throw Error(`Could not parse TimeString format: ${e}`)
  }
  let[,r,i] = n;
  return (i === `s` ? b.SECOND : i === `m` ? b.MINUTE : i === `h` ? b.HOUR : b.DAY) * Number(r)
}
function Zte(e) {
  let t = Pr[e];
  switch (t) {
  case `Saturday`:
  case `Sunday`:
  case `Monday`:
      return Pr.indexOf(`Friday`);
  case `Tuesday`:
      return Pr.indexOf(`Monday`);
  case `Wednesday`:
      return Pr.indexOf(`Tuesday`);
  case `Thursday`:
      return Pr.indexOf(`Wednesday`);
  case `Friday`:
      return Pr.indexOf(`Thursday`);
  default:
      throw new Rn(t)
  }
}
function Cr(e, t, n) {
  let r = st(e, t)
    , i = (e, t) => {
      let[r,i] = qr[t]
        , a = n?.agoSuffix ? ` ago` : ``;
      return (n?.short ? `${e}${r}` : `${e} ${(0,
      Er.default)(i, e)}`) + a
  }
  ;
  if (r < b.MINUTE)
      return Kr;
  if (r < b.HOUR) {
      let e = Math.round(r / b.MINUTE);
      return e === 60 ? i(1, `hour`) : i(e, `minute`)
  }
  if (r < b.DAY) {
      let e = Math.round(r / b.HOUR);
      return e === 24 ? i(1, `day`) : i(e, `hour`)
  }
  if (r < b.WEEK * 3) {
      let e = Math.round(r / b.DAY);
      return e === 7 ? i(1, `week`) : e === 14 ? i(2, `week`) : i(e, `day`)
  }
  if (r < b.WEEK * 8) {
      let e = Math.round(r / b.DAY);
      if (e === 29 || e === 30 || e === 31 || e === 32)
          return i(1, `month`);
      let t = r / b.WEEK
        , n = Math.floor(t)
        , a = t - n >= 66 / 100;
      return i(Math.max(1, n + (a ? 1 : 0)), `week`)
  }
  if (r < b.DAY * 365) {
      let e = r / (b.DAY * 30)
        , t = Math.floor(e)
        , n = e - t >= 66 / 100;
      return i(Math.max(1, t + (n ? 1 : 0)), `month`)
  }
  return i(wr(r / (b.DAY * 365)), `year`)
}
function wr(e, t=.85) {
  let n = e - Math.floor(e) >= t;
  return Math.max(1, Math.floor(e) + (n ? 1 : 0))
}
function Tr(e, t) {
  let n = new Date
    , r = je(e, n)
    , i = r ? Cr(e, n, {
      short: t?.short
  }) : Cr(n, e, {
      short: t?.short
  });
  return i === `just now` ? t?.withoutSuffix ? `now` : i : t?.withoutSuffix ? i : `${i} ${r ? `from now` : `ago`}`
}
function Qte(e, t=!1) {
  if (!Number.isFinite(e) || e <= 0 || e > Jr)
      return t ? `00:00:00` : `00:00`;
  let n = Math.floor(e)
    , r = Math.floor(n / 3600).toString().padStart(2, `0`)
    , i = Math.floor(n % 3600 / 60).toString().padStart(2, `0`)
    , a = Math.floor(n % 60).toString().padStart(2, `0`);
  return t ? `${r}:${i}:${a}` : `${i}:${a}`
}
function $te(e) {
  if (!Number.isFinite(e) || e <= 0 || e > Jr)
      return `PT0S`;
  let t = Be({
      start: new Date(0),
      end: new Date(e * 1e3)
  })
    , n = (e, t) => e ? e.toString() + t : void 0;
  return [`P`, n(t.years, `Y`), n(t.months, `M`), n(t.weeks, `W`), n(t.days, `D`), (t.hours || t.minutes || t.seconds) && `T`, n(t.hours, `H`), n(t.minutes, `M`), n(t.seconds, `S`)].filter(Boolean).join(``)
}
function ene(e, t) {
  if (!Number.isFinite(e) || e < 0 || e > Jr || !Number.isFinite(t) || t < 0 || t > Jr)
      return `0 seconds of 0 seconds`;
  let n = {
      format: t > 3600 ? [`hours`, `minutes`, `seconds`] : [`minutes`, `seconds`]
  };
  return `${Le(Be({
      start: new Date(0),
      end: new Date(e * 1e3)
  }), n) || `0 seconds`} of ${Le(Be({
      start: new Date(0),
      end: new Date(t * 1e3)
  }), n) || `0 seconds`}`
}
function tne(e, t) {
  let n = Math.round(e / 1e3)
    , r = t === `short`;
  if (n === 0)
      return `0`;
  if (n < 60)
      return `${n}${r ? `s` : ` ` + (0,
      Er.default)(`second`, n)}`;
  if (n < 3600) {
      let e = Math.round(n / 60);
      return e === 60 ? r ? `1h` : `1 hour` : `${e}${r ? `m` : ` ` + (0,
      Er.default)(`minute`, e)}`
  } else if (n < 3600 * 24) {
      let e = Math.round(n / 60 / 60);
      return e === 24 ? r ? `1d` : `1 day` : `${e}${r ? `h` : ` ` + (0,
      Er.default)(`hour`, e)}`
  } else if (n < 3600 * 24 * 7 * 2) {
      let e = Math.round(n / 60 / 60 / 24);
      return `${e}${r ? `d` : ` ` + (0,
      Er.default)(`day`, e)}`
  } else if (n < 3600 * 24 * 7 * 4) {
      let e = Math.floor(n / 60 / 60 / 24 / 7);
      return `${e}${r ? `w` : ` ` + (0,
      Er.default)(`week`, e)}`
  } else if (n < 3600 * 24 * 365) {
      let e = Math.max(1, Math.floor(n / 60 / 60 / 24 / 30));
      return `${e}${r ? `mo` : ` ` + (0,
      Er.default)(`month`, e)}`
  } else {
      let e = Math.floor(n / 60 / 60 / 24 / 365);
      return `${e}${r ? `y` : ` ` + (0,
      Er.default)(`year`, e)}`
  }
}
var Er, Dr, Or, kr, Ar, jr, Mr, Nr, Pr, b, Fr, Ir, Lr, Rr, zr, Br, Vr, Hr, Ur, Wr, Gr, Kr, qr, Jr, Yr = t(( () => {
  nt(),
  Er = e(Gt(), 1),
  zn(),
  Dr = 1e3,
  Or = Dr * 60,
  kr = Or * 60,
  Ar = kr * 24,
  jr = Ar * 7,
  Mr = jr * 4.35,
  Nr = Mr * 12,
  Pr = [`Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`],
  b = {
      SECOND: Dr,
      MINUTE: Or,
      HOUR: kr,
      DAY: Ar,
      WEEK: jr,
      MONTH: Mr,
      YEAR: Nr
  },
  Lr = function(e) {
      return e.sunday = `sunday`,
      e.monday = `monday`,
      e.tuesday = `tuesday`,
      e.wednesday = `wednesday`,
      e.thursday = `thursday`,
      e.friday = `friday`,
      e.saturday = `saturday`,
      e
  }({}),
  Rr = e => {
      if (e < 0 || e > 6)
          throw Error(`Day of week must be represented by a number between 0 and 6.`);
      return Object.keys(Lr)[e]
  }
  ,
  zr = e => {
      switch (e) {
      case Lr.sunday:
          return `Sunday`;
      case Lr.monday:
          return `Monday`;
      case Lr.tuesday:
          return `Tuesday`;
      case Lr.wednesday:
          return `Wednesday`;
      case Lr.thursday:
          return `Thursday`;
      case Lr.friday:
          return `Friday`;
      case Lr.saturday:
          return `Saturday`;
      default:
          throw new Rn(e)
      }
  }
  ,
  Br = (e, t) => {
      switch (!0) {
      case t?.hideYear:
          return Ge(e, `MMM`);
      case t?.shortYear:
          return Ge(e, `MMM ''yy`);
      default:
          return Ge(e, `MMM yyyy`)
      }
  }
  ,
  Vr = (e, t) => {
      let {fiscalYearStartMonth: n=0, hideYear: r} = t ?? {}
        , i = Ge(at(e, n), `QQQ`);
      return r ? i : `${i} ${Ur(e, t)}`
  }
  ,
  Hr = (e, t) => {
      let {fiscalYearStartMonth: n=0, hideYear: r} = t ?? {}
        , i = Ae(at(e, n)) < 6 ? `1` : `2`;
      return r ? `H${i}` : `H${i} ${Ur(e, t)}`
  }
  ,
  Ur = (e, t) => {
      let {fiscalYearStartMonth: n=0, shortYear: r} = t ?? {}
        , i = Re(e, 12 - n);
      return n === 0 ? Ge(e, r ? `''yy` : `yyyy`) : `FY${Ge(i, `yy`)}`
  }
  ,
  Wr = [`January`, `February`, `March`, `April`, `May`, `June`, `July`, `August`, `September`, `October`, `November`, `December`],
  Gr = Wr.map(e => e.slice(0, 3)),
  Kr = `just now`,
  qr = {
      second: [`s`, `second`],
      minute: [`min`, `minute`],
      hour: [`h`, `hour`],
      day: [`d`, `day`],
      week: [`w`, `week`],
      month: [`mo`, `month`],
      year: [`y`, `year`]
  },
  Jr = 864e10
}
)), Xr, Zr, Qr, $r = t(( () => {
  Xr = {
      slackStagingApp: `slack-staging-app`,
      slackIntegrationOptOutOfReadingMessageHistory: `slack-integration-opt-out-of-reading-message-history`,
      slackIntegrationOptOutOfAutojoiningChannel: `slack-integration-opt-out-of-autojoining-channel`,
      sessionRecording: `session-recording`,
      showDeveloperToolbarForGuest: `show-developer-toolbar-for-guest`,
      sparklesCommentSummaries: `sparkles-comment-summaries`,
      hackweekGlobalPasteAndUpload: `hackweek-global-paste-and-upload`,
      frequentLabels: `frequent-labels`,
      diary: `diary`,
      wtAdamVideoToIssue: `wt-adam-video-to-issue`,
      forceSlackUpdate: `force-slack-update`,
      forceClientSideDiffing: `force-client-side-diffing`,
      disableCommentsVirtualization: `disable-comments-virtualization`,
      logPromptResults: `log-prompt-results`,
      editorEntityEmbed: `editor-entity-embed`,
      createSlackChannelForProject: `create-slack-channel-for-project`,
      previewVideosInSlack: `preview-videos-in-slack`,
      pinnedTabsFrozenUrl: `pinned-tabs-frozen-url`,
      aiProjectDetailSuggestion: `ai-project-detail-suggestion`,
      githubEnterpriseServer: `github-enterprise-server`,
      githubCodeAccess: `github-code-access`,
      imageLayout: `image-layout`,
      githubLabelFiltering: `github-label-filtering`,
      feedPostUpdate: `feed-post-update`,
      featureFlags: `feature-flags`,
      hideFeedWelcomeBanner: `hide-feed-welcome-banner`,
      facetSlackSubscriptions: `facet-slack-subscriptions`,
      onlyEditorsSaveInCollab: `only-editors-save-in-collab`,
      electronRedirectDefault: `electron-redirect-default`,
      pinViews: `pin-views`,
      aiReports: `ai-reports`,
      initiativeActivity: `initiative-activity`,
      nestedSubIssues: `nested-sub-issues`,
      customKeyboardShortcutsAxelWT: `custom-keyboard-shortcuts-axel-wt`,
      teamUpdatesFeed: `team-updates-feed`,
      documentsOnIssues: `documents-on-issues`,
      prNewIssueKeyword: `pr-new-issue-keyword`,
      generateInitiativeUpdate: `generate-initiative-update`,
      serverBackedCustomViews: `server-backed-customviews`,
      subIssueContributors: `sub-issue-contributors`,
      customersIntercomUnmerge: `customers-intercom-unmerge`,
      binaryStreamingResponses: `binary-streaming-responses`,
      teamResourceFolders: `team-resource-folders`,
      "video-summaries-d1c9a0208324": `video-summaries-d1c9a0208324`,
      linearAi: `linear-ai`,
      linearAiSlackWorkflows: `linear-ai-slack-workflows`,
      aiGeneratedProjectUpdates: `ai-generated-updates`,
      aiGeneratedInitiativeUpdates: `ai-generated-initiative-updates`,
      aiProjectProgressSummary: `ai-project-progress-summary`,
      syncSubscriptions: `sync-subscriptions`,
      asksSaml: `asks-saml`,
      gongIntegration: `gong-integration`,
      dashboardMultiTeams: `dashboard-multi-teams`,
      pullRequestSearch: `pull-request-search`,
      googleSheetsInitiativesExport: `google-sheets-initiatives-export`,
      productIntelligenceClarificationRequests: `product-intelligence-clarification-requests`,
      codeReviews: `code-reviews`,
      supportForMermaidDiagrams: `support-for-mermaid-diagrams`,
      fastCreateUpdate: `fast-create-update`,
      skipActionManagerHydration: `skip-action-manager-hydration`,
      redesign: `redesign`,
      showAgentActivityFallback: `show-agent-activity-fallback`,
      productIntelligenceMemory: `product-intelligence-memory`,
      productIntelligenceGpt51: `lin-46766-add-gpt-51-model-variant-for`,
      openInExternalAppDeeplink: `open-in-external-app-deeplink`,
      scatterplotCanvas: `scatterplot-canvas`,
      intercomAiIntake: `intercom-ai-intake`,
      agentSessionStandaloneUI: `agent-session-standalone-ui`,
      slackWorkObjectsIssueSummaries: `slack-work-objects-issue-summaries`,
      teamOwners: `team-owners`,
      zendeskAiIntake: `zendesk-ai-intake`,
      flattenDocumentsBeforeSave: `flatten-documents-before-save`,
      agentPlanApi: `agent-plan-api`,
      agentSessionsTab: `agent-sessions-tab`,
      mcpClient: `mcp-client`,
      timeInCurrentStatus: `time-in-current-status`,
      jiraEpicSync: `jira-epic-sync`,
      triageAgent: `triage-agent`,
      agentsCodeReview: `agents-code-review`,
      openInLinearReviewAnyway: `open-in-linear-review-anyway`,
      codeIntelligence: `code-intelligence`,
      asksUnfurlHandling: `asks-unfurl-handling`,
      agentSessionPanelActivitiesRefresh: `agent-session-panel-activities-refresh`,
      sharedIssues: `shared-issues`,
      agentToolbar: `agent-toolbar`,
      documentAttributions: `document-attributions`,
      insightTimeInStatus: `insight-time-in-status`,
      peopleMentionChips: `des-558-create-smartchip-for-people-in`,
      revertingARevertShouldCloseIssue: `lin-37909-reverting-a-revert-should`,
      releaseManagement: `release-management`,
      memberColors: `member-colors`,
      orFilters: `or-filters`
  },
  Zr = {
      "team-updates-feed": {
          title: `Team updates feed`,
          description: `Show updates for a team in the feed`
      },
      "hide-feed-welcome-banner": {
          title: `Hide Pulse welcome banner`,
          description: `Hides the Pulse welcome banner for organizations already using Pulse`
      },
      "slack-integration-opt-out-of-reading-message-history": {
          title: `Slack Integration: opt out of reading message history`,
          description: `When true, does not request the *:history Slack scopes during the OAuth flow`
      },
      "slack-integration-opt-out-of-autojoining-channel": {
          title: `Slack Integration: opt out of autojoining channel`,
          description: `When true, does not request the channels:join Slack scope during the OAuth flow`
      },
      "slack-staging-app": {
          title: `Linear Stating Slack app`,
          description: `Allow the workspace to install the Linear Staging Slack app`
      },
      "session-recording": {
          title: `Session recording`,
          description: `Internal control for throttling session recording`
      },
      "editor-entity-embed": {
          title: `Editor entity embed`,
          description: `Let you embed entities (Issue, Project, Document) into the editor`
      },
      "create-slack-channel-for-project": {
          title: `Create Slack channel for project`,
          description: `Automatically create a Slack channel for a project`
      },
      "force-slack-update": {
          title: `Force Slack update`,
          description: `Displays an option to update Slack integration no matter what`
      },
      "sparkles-comment-summaries": {
          title: `Sparkles: comment summaries`,
          description: `AI actions for summarizing comments`
      },
      "preview-videos-in-slack": {
          title: `Preview videos in Slack`,
          description: `Enables previewing unfurling videos in Slack`
      },
      "pinned-tabs-frozen-url": {
          title: `Pinned tabs frozen URL`,
          description: `Pinned tabs will have a frozen URL and all links will open in new tabs.`
      },
      "ai-project-detail-suggestion": {
          title: `AI suggest project details`,
          description: `Suggest icon/color when composing a project`
      },
      "hackweek-global-paste-and-upload": {
          title: `[Hackweek] Global Paste and Upload (hackweek)`,
          description: `Allow pasting and uploading files globally`
      },
      diary: {
          title: `[Hackweek] Diary`,
          description: `A personal space for your daily plans and thoughts.`
      },
      "wt-adam-video-to-issue": {
          title: `WT Adam video to issue`,
          description: `Enable AI video to issues`,
          defaultValue: !1
      },
      "github-enterprise-server": {
          title: `GitHub Enterprise Server`,
          description: `Enable GitHub Enterprise Server integration`,
          defaultValue: !1
      },
      "github-code-access": {
          title: `GitHub Code Access`,
          description: `Enable enhanced GitHub integration with code access permissions`,
          defaultValue: !1
      },
      "image-layout": {
          title: `Image layout`,
          description: `Enable image grouping in documents`,
          defaultValue: !1
      },
      "github-label-filtering": {
          title: `Github Label Filtering`,
          description: `Allows to use labels as a filter for GH imports and Sync`
      },
      "feed-post-update": {
          title: `Feed post update`,
          description: `Post team updates to the feed`
      },
      "feature-flags": {
          title: `[Hackweek] Feature flags`,
          description: `Feature flags as first class citizen in Linear`
      },
      "facet-slack-subscriptions": {
          title: `Facet Slack subscriptions`,
          description: `Show Slack subscriptions for facets`,
          defaultValue: !1
      },
      "only-editors-save-in-collab": {
          title: `Only editors save document content in collaborative session`,
          description: `[Technical] Do not save content changes in session unless local changes present`,
          defaultValue: !1
      },
      "electron-redirect-default": {
          title: `Electron redirect default`,
          description: `Redirect to last active tab when opening Electron`,
          defaultValue: !1
      },
      "force-client-side-diffing": {
          title: `Force client side diffing`,
          description: `Ignore the pre-computed diff in metadata and re-compute the diff`,
          defaultValue: !1
      },
      "pin-views": {
          title: `Pin views`,
          description: `Allow pinning and unpinning views`,
          defaultValue: !1
      },
      "ai-reports": {
          title: `AI reports`,
          description: `AI generated reports for views`,
          defaultValue: !1
      },
      "nested-sub-issues": {
          title: `Nested sub-issues`,
          description: `Show sub-issues as a nested tree structure on issue lists`,
          defaultValue: !1
      },
      "custom-keyboard-shortcuts-axel-wt": {
          title: `Custom keyboard shortcuts (Axel WT)`,
          description: `Custom keyboard shortcuts / Axel WT project`,
          defaultValue: !1
      },
      "show-developer-toolbar-for-guest": {
          title: `Show developer toolbar for guest`,
          description: `Show developer toolbar for guest users in Linear workspaces`,
          defaultValue: !1
      },
      "documents-on-issues": {
          title: `Documents on issues`,
          description: `Show a Resources section on issues and list linked documents`,
          defaultValue: !1
      },
      "pr-new-issue-keyword": {
          title: `PRs: create new issue with keyword`,
          description: `Create a new issue with a keyword when a PR is created`,
          defaultValue: !1
      },
      "log-prompt-results": {
          title: `Log prompt results for evals`,
          description: `Log prompt results to braintrust for evals`,
          defaultValue: !1
      },
      "initiative-activity": {
          title: `Initiative activity`,
          description: `Enable activity for initiatives`,
          defaultValue: !1
      },
      "frequent-labels": {
          title: `Frequent Labels`,
          description: `Show frequently used labels at the top of the label list`,
          defaultValue: !1
      },
      "disable-comments-virtualization": {
          title: `Disable comments virtualization [debug]`,
          description: `Disable comments virtualization (temporary flag for debugging)`,
          defaultValue: !1
      },
      "generate-initiative-update": {
          title: `Generate initiative update`,
          description: `Generate initiative update draft using AI.`
      },
      "server-backed-customviews": {
          title: `Server-sorted custom views`,
          description: `Server-sorted custom views`,
          defaultValue: !1
      },
      "sub-issue-contributors": {
          title: `Sub-issue contributors`,
          description: `Show contributors for sub-issues`,
          defaultValue: !1
      },
      "customers-intercom-unmerge": {
          title: `Customers Intercom unmerge`,
          description: `Unmerge customers from Intercom`,
          defaultValue: !1
      },
      "binary-streaming-responses": {
          title: `Binary streaming responses`,
          description: `Use binary streaming responses`
      },
      "team-resource-folders": {
          title: `Team resource folders`,
          description: `Enable resource pages with folder support on teams`,
          defaultValue: !1
      },
      "video-summaries-d1c9a0208324": {
          title: `Video summaries`,
          description: `Enable video summaries`,
          defaultValue: !1
      },
      "linear-ai": {
          title: `Linear AI`,
          description: `Enable AI side panel with in-app context & tools`,
          defaultValue: !1
      },
      "linear-ai-slack-workflows": {
          title: `Linear Agent Slack workflows`,
          description: `Enable Linear Agent to have org-wide access in Slack workflows`,
          defaultValue: !1
      },
      "ai-generated-updates": {
          title: `AI generated project updates`,
          description: `Use AI to generate updates for projects`,
          defaultValue: !1
      },
      "ai-generated-initiative-updates": {
          title: `AI generated initiative updates`,
          description: `Use AI to generate updates for initiatives`,
          defaultValue: !1
      },
      "ai-project-progress-summary": {
          title: `AI generated project progress summary`,
          description: `Use AI to generate project progress summary`,
          defaultValue: !1
      },
      "sync-subscriptions": {
          title: `Sync subscriptions`,
          description: `If sync subscriptions are enabled`,
          defaultValue: !1
      },
      "asks-saml": {
          title: `Asks SAML`,
          description: `Enable SAML for Asks web forms`,
          defaultValue: !1
      },
      "gong-integration": {
          title: `Gong integration`,
          description: `Enable Gong integration for call recording ingestion`,
          defaultValue: !1
      },
      "dashboard-multi-teams": {
          title: `Dashboard multi-teams`,
          description: `Allow dashboards to target multiple teams at once`,
          defaultValue: !1
      },
      "pull-request-search": {
          title: `Pull request search`,
          description: `Enable pull request search`,
          defaultValue: !1
      },
      "google-sheets-initiatives-export": {
          title: `Google Sheets initiatives export`,
          description: `Enable Google Sheets initiatives export`,
          defaultValue: !1
      },
      "product-intelligence-clarification-requests": {
          title: `Product Intelligence clarification requests`,
          description: `Enable product intelligence clarification requests`,
          defaultValue: !1
      },
      "code-reviews": {
          title: `Code reviews`,
          description: `Enable code reviews`,
          defaultValue: !1
      },
      "support-for-mermaid-diagrams": {
          title: `Mermaid diagrams`,
          description: `Enable diagram nodes (Mermaid) in the editor`,
          defaultValue: !1
      },
      "fast-create-update": {
          title: `Fast create update`,
          description: `Enables the FastCreate form for updates`,
          defaultValue: !1
      },
      "skip-action-manager-hydration": {
          title: `Skip action manager hydration`,
          description: `Skip hydration of models in the action manager`,
          defaultValue: !1
      },
      redesign: {
          title: `Redesign`,
          description: `Redesign of the app chrome`,
          defaultValue: !1
      },
      "show-agent-activity-fallback": {
          title: `Show agent activity fallback`,
          description: `[Internal] Render all agent activity entries for debugging`,
          defaultValue: !1
      },
      "product-intelligence-memory": {
          title: `Product Intelligence memory`,
          description: `Enable product intelligence memory`,
          defaultValue: !1
      },
      "lin-46766-add-gpt-51-model-variant-for": {
          title: `Product Intelligence GPT-5.1`,
          description: `Enable GPT-5.1 model variant for product intelligence`,
          defaultValue: !1
      },
      "open-in-external-app-deeplink": {
          title: `Open issue in an external app`,
          description: `Deeplinking to Conductor, ChatGPT, etc.`,
          defaultValue: !1
      },
      "scatterplot-canvas": {
          title: `Scatterplot canvas`,
          description: `Enable using canvas for scatterplot graphs instead of SVG`,
          defaultValue: !1
      },
      "intercom-ai-intake": {
          title: `Intercom AI intake`,
          description: `Enable Intercom AI intake`
      },
      "zendesk-ai-intake": {
          title: `Zendesk AI intake`,
          description: `Enable Zendesk AI intake`,
          defaultValue: !1
      },
      "team-owners": {
          title: `Team owners`,
          description: `Enable team owners for business workspaces and higher`,
          defaultValue: !1
      },
      "agent-session-standalone-ui": {
          title: `Agent session standalone UI`,
          description: `UI refresh project separating agent sessions from comments`,
          defaultValue: !1
      },
      "slack-work-objects-issue-summaries": {
          title: `Slack Work Objects issue summaries`,
          description: `Show AI-generated summaries in Slack work object unfurls for issues`,
          defaultValue: !1
      },
      "flatten-documents-before-save": {
          title: `Flatten documents before save`,
          description: `Flatten documents before save`,
          defaultValue: !1
      },
      "agent-plan-api": {
          title: `Agent can use "plan" API`,
          description: `Allow agent and workspace to use the "plan" field to emit work progress`,
          defaultValue: !1
      },
      "agent-sessions-tab": {
          title: `Agent sessions tab`,
          description: `Enable the Agents tab to view and manage agent sessions`,
          defaultValue: !1
      },
      "mcp-client": {
          title: `MCP client`,
          description: `Enable MCP client for Linear Agent`,
          defaultValue: !1
      },
      "time-in-current-status": {
          title: `Time in current status`,
          description: `Enable filter, sorting, and display of time in current status for issues on list and board views`,
          defaultValue: !1
      },
      "jira-epic-sync": {
          title: `Jira epic sync`,
          description: `Enable Jira epic syncing`,
          defaultValue: !1
      },
      "triage-agent": {
          title: `Triage agent`,
          description: `Enable custom triage agent that runs when issues are added to triage`
      },
      "agents-code-review": {
          title: `Agents code review`,
          description: `Code review as an extension of the Agent Panel`,
          defaultValue: !1
      },
      "open-in-linear-review-anyway": {
          title: `Pretend GitHub integration is connected`,
          description: `[DEV] Pretend GitHub personal/org integration is connected. Use with caution for UI debugging only`,
          defaultValue: !1
      },
      "code-intelligence": {
          title: `Code intelligence`,
          description: `Enable code intelligence features`,
          defaultValue: !1
      },
      "asks-unfurl-handling": {
          title: `Asks unfurl handling`,
          description: `Let Asks handle unfurls even if both apps enabled`,
          defaultValue: !1
      },
      "agent-session-panel-activities-refresh": {
          title: `Agent session panel activities refresh`,
          description: `Updated components for agent activities in agent session panel`,
          defaultValue: !1
      },
      "shared-issues": {
          title: `Issue level permissions - Sharing issues`,
          description: `Sharing issue access to users outside of private teams`,
          defaultValue: !1
      },
      "agent-toolbar": {
          title: `Agent toolbar`,
          description: `Enable agent toolbar`,
          defaultValue: !1
      },
      "document-attributions": {
          title: `Author attributions`,
          description: `Line-level author attributions in documents`,
          defaultValue: !1
      },
      "insight-time-in-status": {
          title: `Insight time in status`,
          description: `Allow displaying a scatterplot with the time in any single status`,
          defaultValue: !1
      },
      "des-558-create-smartchip-for-people-in": {
          title: `People mention chips`,
          description: `Display avatars of users in mentions + chip form`
      },
      "lin-37909-reverting-a-revert-should": {
          title: `Reverting a revert should close the issue`,
          description: `Reverting a revert should close the issue`,
          defaultValue: !1
      },
      "release-management": {
          title: `Release management`,
          description: `Enable release management features`,
          defaultValue: !1
      },
      "member-colors": {
          title: `Member colors`,
          description: `Control whether the workspace and team member statuses are displayed in color`,
          defaultValue: !1
      },
      "or-filters": {
          title: `OR filters`,
          description: `Enable OR filter logic with AND/OR component for rendering between filter blocks`,
          defaultValue: !1
      }
  },
  Qr = {
      bootstrapRateLimitedRetryCount: `bootstrap-ratelimited-retry-count`,
      bootstrapRatelimitedInSyncDeltaRetryCount: `bootstrap-ratelimited-in-sync-delta-retry-count`,
      clientDatabaseMinVersion: `client-database-min-version`,
      debugClientDeletionModels: `debug-client-deletion-models`,
      trialLength: `plus-trial-length`,
      timeBeforeFullBootstrap: `time-before-full-bootstrap`,
      analyticsSampleRate: `analytics-sample-rate`,
      similarIssuesCreationMinSimilarity: `similar-issues-creation-min-similarity`,
      similarIssuesTriageMinSimilarity: `similar-issues-triage-min-similarity`,
      similarIssuesMarkDuplicateMinSimilarity: `similar-issues-mark-duplicate-min-similarity`,
      tracingCategories: `tracing-categories`,
      sentryTracingRate: `sentry-tracing-rate`,
      skipPrefetching: `skip-prefetching`,
      sharedSlackChannelName: `shared-slack-channel-name`,
      desktopUserSegment: `desktop-user-segment`,
      desktopMinimumCustomUpdaterVersion: `desktop-minimum-custom-updater-version`
  }
}
));
function nne() {
  let e = Object.keys(sessionStorage);
  for (let t of e)
      t.startsWith(ti) && sessionStorage.removeItem(t)
}
var ei, ti, ni = t(( () => {
  Ot(),
  ei = class {
      static set(e, t, n) {
          try {
              return this.setString(e, JSON.stringify(t), n)
          } catch (t) {
              return this.getLogger().then(n => n.error(`Could not serialize data for storage key`, t, {
                  key: e
              })),
              !1
          }
      }
      static setString(e, t, n=localStorage, r) {
          if (!n)
              return this.getLogger().then(e => e.warning(`Local storage not supported`)),
              !1;
          try {
              return n.setItem(e, t),
              !0
          } catch (e) {
              return r && r(e),
              !1
          }
      }
      static setSession(e, t) {
          try {
              let n = JSON.stringify(t);
              return this.setString(e, n, sessionStorage, t => {
                  t.name === `QuotaExceededError` && (nne(),
                  this.setString(e, n, sessionStorage, t => {
                      t.name === `QuotaExceededError` && (sessionStorage.clear(),
                      this.setString(e, n, sessionStorage))
                  }
                  ))
              }
              ),
              !0
          } catch (t) {
              return this.getLogger().then(n => n.error(`Could not serialize data for session storage key`, t, {
                  key: e
              })),
              !1
          }
      }
      static setEphemeralSession(e, t) {
          return this.setSession(ti + e, t)
      }
      static setPersistent(e, t, n) {
          try {
              return this.setString(`p_${t.id}_${e}`, JSON.stringify(n), localStorage),
              !0
          } catch (t) {
              return this.getLogger().then(n => n.error(`Could not serialize data for storage key`, t, {
                  key: e
              })),
              !1
          }
      }
      static get(e, t={
          logError: !0
      }) {
          try {
              let n = this.getString(e, t.storageMechanism);
              return n ? JSON.parse(n) : void 0
          } catch (n) {
              t.logError && this.getLogger().then(t => t.error(`Could not load local storage key`, n, {
                  key: e
              }));
              return
          }
      }
      static getPersistent(e, t) {
          try {
              let n = this.getString(`p_${t.id}_${e}`);
              return n ? JSON.parse(n) : void 0
          } catch (t) {
              this.getLogger().then(n => n.error(`Could not load local storage key`, t, {
                  key: e
              }));
              return
          }
      }
      static getSession(e) {
          try {
              let t = this.getString(e, sessionStorage);
              return t ? JSON.parse(t) : void 0
          } catch (t) {
              this.getLogger().then(n => n.error(`Could not load session storage key`, t, {
                  key: e
              }));
              return
          }
      }
      static getEphemeralSession(e) {
          return this.getSession(ti + e)
      }
      static getString(e, t=localStorage) {
          if (!t) {
              this.getLogger().then(e => e.warning(`Local storage not supported`));
              return
          }
          try {
              return t.getItem(e) || void 0
          } catch (t) {
              this.getLogger().then(n => n.info(`Failed reading storage item`, {
                  key: e,
                  error: t
              }));
              return
          }
      }
      static remove(e, t=localStorage) {
          if (!t) {
              this.getLogger().then(e => e.warning(`Local storage not supported`));
              return
          }
          try {
              t.removeItem(e)
          } catch (t) {
              this.getLogger().then(n => n.info(`Failed removing storage item`, {
                  key: e,
                  error: t
              }))
          }
      }
      static removeAllWithCondition(e, t=localStorage) {
          if (!t) {
              this.getLogger().then(e => e.warning(`Local storage not supported`));
              return
          }
          for (let n of this.getKeys(t))
              e(n) && t.removeItem(n)
      }
      static removeSession(e) {
          this.remove(e, sessionStorage)
      }
      static removeEphemeralSession(e) {
          this.remove(ti + e, sessionStorage)
      }
      static removePersistent(e, t) {
          localStorage.removeItem(`p_${t.id}_${e}`)
      }
      static clear(e=localStorage) {
          if (!e) {
              this.getLogger().then(e => e.warning(`Local storage not supported`));
              return
          }
          for (let t in e)
              t && !t.startsWith(`p_`) && e.removeItem(t)
      }
      static getKeys(e=localStorage) {
          let t = [];
          for (let n = 0, r = e.length; n < r; n++) {
              let r = e.key(n);
              r && t.push(r)
          }
          return t
      }
      static clearAllNonAuthData() {
          this.removeAllWithCondition(e => ![`isLinearSuperuser`, `clientId`, `ApplicationStore`, `featureFlagMetadata`, `FeatureFlags`].includes(e), localStorage),
          this.removeAllWithCondition(e => ![`ApplicationStore`].includes(e), sessionStorage)
      }
      static async getLogger() {
          let {Logger: e} = await kt(async () => {
              let {Logger: e} = await import(`./Logger.DRn9Zpo2.js`);
              return {
                  Logger: e
              }
          }
          , [], import.meta.url);
          return e
      }
  }
  ,
  ti = `ephemeral_`
}
));
function ri(e, t) {
  let n = new Promise(n => {
      setTimeout( () => {
          t?.(),
          n()
      }
      , e)
  }
  );
  return t === void 0 ? n : void 0
}
function ii(e=1, t) {
  let n = new Promise(n => {
      let r = () => {
          e--,
          e <= 0 ? (t?.(),
          n()) : setTimeout(r, 0)
      }
      ;
      setTimeout(r, 0)
  }
  );
  return t === void 0 ? n : void 0
}
async function rne(e, t) {
  return new Promise(n => {
      ii(1, () => {
          setTimeout( () => {
              t?.(),
              n()
          }
          , e)
      }
      )
  }
  )
}
var ai = t(( () => {}
));
async function oi() {
  let {Logger: e} = await kt(async () => {
      let {Logger: e} = await import(`./Logger.DRn9Zpo2.js`);
      return {
          Logger: e
      }
  }
  , [], import.meta.url);
  return e
}
var si, ci, li, ui, di, fi, pi = t(( () => {
  si = e(Ht(), 1),
  Wt(),
  zt(),
  yr(),
  Yr(),
  $r(),
  Xn(),
  ni(),
  ai(),
  Ot(),
  ci = Xr,
  li = Qr,
  ui = {
      ...ci,
      specs: Zr,
      all: Object.values(ci).filter(e => typeof e == `string`),
      isEnabled: (e, t=!1) => fi.getValue(e, ui.specs[e]?.defaultValue || !1, t).value
  },
  di = {
      ...li,
      all: Object.values(li).filter(e => typeof e == `string`),
      getValue: (e, t, n=!1) => fi.getValue(e, t, n).value
  },
  (function(e) {
      let t = `FeatureFlags`, n = `FeatureFlagsOverrides`, r = `FeatureFlagsReleaseChannelOverride`, i = `FeatureFlagsCurrentUser`, a = `FeatureFlagsMissingTracked`, o = Vt.box(``), s, c, l, u = new Set, d = new Map, f = [], p, m = new Set, h = new Set;
      function g(e, t, n=!1) {
          let r = ge.get()[e]
            , i = o.get();
          if (r === void 0)
              return i && u.has(i) && !m.has(e) && (setTimeout( () => {
                  oi().then(t => t.warning(`Non existing flag`, {
                      userId: i,
                      flag: e,
                      originalFlag: e
                  }))
              }
              , 0),
              m.add(e)),
              {
                  value: t
              };
          if (typeof r != typeof t)
              return h.has(e) || (setTimeout( () => {
                  oi().then(n => n.warning(`Invalid flag value type`, {
                      userId: i,
                      flag: e,
                      value: r,
                      defaultValue: t
                  }))
              }
              , 0),
              h.add(e)),
              {
                  value: t
              };
          let a = v()[e];
          typeof a != typeof r && (a = void 0);
          let s = a ?? r;
          return n || _e(e, r),
          {
              value: s,
              originalValue: s === r ? void 0 : r
          }
      }
      e.getValue = g;
      function _(e) {
          return e.graphQLClient.query(Ut`
        query FlagsMetadata {
          flagsMetadata {
            flag
            name
            description
            maintainer
            isEnabled
            releaseChannel
            status
          }
        }
      `, void 0, {
              dontLog: !0
          }).then(e => e.flagsMetadata.reduce( (e, t) => (e[t.flag] = t,
          e), {})).catch( () => ({}))
      }
      e.fetchMetadata = _;
      function ee() {
          return Object.entries(ge.get()).reduce( (e, [t,n]) => (e[t] = g(t, n, !0),
          e), {})
      }
      e.getAllValues = ee;
      function te(e) {
          return `https://app.launchdarkly.com/default/${Jn.IS_PRODUCTION_ENV ? `production` : `test`}/features/${e}`
      }
      e.getFlagUrl = te;
      function ne(e) {
          let t = o.get();
          if (t)
              if (e) {
                  let n = {
                      ...v()
                  };
                  for (let t of e)
                      delete n[t];
                  me(t, n)
              } else
                  me(t)
      }
      e.clearOverrides = ne;
      function re(e, t) {
          let n = o.get();
          if (n)
              if (t == null) {
                  let t = {
                      ...v()
                  };
                  delete t[e],
                  me(n, t)
              } else
                  me(n, {
                      ...v(),
                      [e]: t
                  })
      }
      e.setOverride = re;
      function ie(e) {
          if (e ??= o.get(),
          e)
              return l.get(e) ?? void 0
      }
      e.getReleaseChannelOverride = ie;
      function ae(e, t) {
          he(e, t)
      }
      e.setReleaseOverrideChannel = ae;
      async function oe(e, t) {
          let {defaultValue: n, opts: r, type: a} = t
            , o = ( () => a === `featureFlag` ? ui.specs[e]?.defaultValue ?? !1 : n)()
            , s = r?.maxRetries ?? 5
            , c = r?.retryInterval ?? b.SECOND
            , l = ve(i)
            , u = () => fi.getValue(e, o, !1).value;
          if (!l || !ce(l))
              return {
                  value: u(),
                  timedOut: !1
              };
          let d = 0;
          for (; d < s; ) {
              if (!ce(l))
                  return {
                      value: u(),
                      timedOut: !1
                  };
              d++,
              d < s && await ri(c)
          }
          return typeof navigator < `u` && navigator.onLine && oi().then(t => t.warning(`Timed out waiting for flag/config to load`, {
              name: e,
              retries: d
          })),
          {
              value: u(),
              timedOut: !0
          }
      }
      e.waitForFlagOrConfig = oe;
      function se(e) {
          o.set(e),
          ye(i, e)
      }
      e.setUser = se;
      function ce(e) {
          let t = s.get(e)
            , n = ui.all.filter(e => t?.[e] === void 0)
            , r = di.all.filter(e => t?.[e] === void 0);
          if (t && n.length === 0 && r.length === 0)
              return !1;
          try {
              let e = ei.get(a)
                , t = {
                  missingConfigs: r.filter(t => !e?.includes(t)),
                  missingFeatures: n.filter(t => !e?.includes(t))
              };
              if (t.missingConfigs.length === di.all.length && t.missingFeatures.length === ui.all.length)
                  return `all`;
              let i = [...e ?? [], ...t.missingConfigs, ...t.missingFeatures].distinct();
              return i.length !== (e?.length ?? 0) && ei.set(a, i),
              t.missingConfigs.length > 0 || t.missingFeatures.length > 0 ? (oi().then(e => e.info(`Loading flags for user as at least one flag is missing`, {
                  missingFeatures: n,
                  missingConfigs: r
              })),
              `some`) : !1
          } catch (e) {
              return oi().then(t => t.error(`Error tracking missing flags`, e)),
              !1
          }
      }
      e.hasMissingFlags = ce;
      function le(e) {
          setTimeout( () => {
              u.add(e)
          }
          , 0)
      }
      e.ensureLoaded = le;
      function ue(e, t) {
          pe(e, t)
      }
      e.setFlags = ue;
      function de(e) {
          p = e;
          for (let t of f)
              e(t)
      }
      e.registerReportEvaluationFnc = de;
      function fe(e) {
          p === e && (p = void 0)
      }
      e.unregisterReportEvaluationFnc = fe;
      let pe = Ft( (e, n) => {
          let r = s.get(e);
          r && (0,
          si.default)(r, n) || (s.set(e, n),
          ye(t, JSON.stringify(s.toJSON())))
      }
      )
        , me = Ft( (e, t) => {
          (0,
          si.default)(c.get(e) ?? {}, t ?? {}) || (c.set(e, t ?? {}),
          ye(n, JSON.stringify(c.toJSON())))
      }
      )
        , he = Ft( (e, t) => {
          (l.get(e) ?? null) !== (t ?? null) && (l.set(e, t ?? null),
          ye(r, JSON.stringify(l.toJSON())))
      }
      )
        , ge = Bt( () => {
          let e = o.get();
          return e ? {
              ...Object.fromEntries(ui.all.map(e => [e, !1])),
              ...s.get(e)
          } : {}
      }
      );
      function v() {
          let e = o.get();
          return e ? c.get(e) ?? {} : {}
      }
      function _e(e, t) {
          let n = `${o.get()}-${e}-${typeof t == `boolean` || typeof t == `number` || typeof t == `string` ? t : `object`}`;
          Date.now() - (d.get(n) || 0) < b.HOUR || (d.set(n, Date.now()),
          setTimeout( () => {
              let n = {
                  cmd: `flagEvaluated`,
                  flag: e,
                  value: t
              };
              p ? p(n) : f.push(n)
          }
          , 1))
      }
      function ve(e) {
          if (!(typeof localStorage > `u`))
              try {
                  return localStorage.getItem(e)
              } catch (e) {
                  setTimeout( () => {
                      oi().then(t => t.warning(`Error getting flags state from local storage.`, e))
                  }
                  , 0);
                  return
              }
      }
      function ye(e, t) {
          if (!(typeof localStorage > `u`))
              try {
                  localStorage.setItem(e, t)
              } catch (e) {
                  setTimeout( () => {
                      oi().then(t => t.warning(`Error saving flags state to local storage.`, e))
                  }
                  , 0)
              }
      }
      function be() {
          try {
              o.set(ve(i) || ``),
              s = Vt.map(vr(ve(t) || `{}`) || {}),
              c = Vt.map(vr(ve(n) || `{}`) || {}),
              l = Vt.map(vr(ve(r) || `{}`) || {})
          } catch (e) {
              setTimeout( () => {
                  oi().then(t => t.error(`Error loading flags from local storage. Resetting.`, e))
              }
              , 0),
              s = Vt.map({}),
              ye(t, JSON.stringify(s.toJSON())),
              c = Vt.map({}),
              l = Vt.map({}),
              ye(n, JSON.stringify(c.toJSON()))
          }
      }
      function xe(e) {
          ei.remove(e, localStorage)
      }
      function Se(e) {
          xe(t),
          xe(a),
          e || xe(n),
          xe(r),
          xe(i)
      }
      e.clearAll = Se,
      be()
  }
  )(fi ||= {})
}
));
function mi(e) {
  try {
      if (!Fi.trusted && !qi) {
          let e = Ii.sharedLength || 0;
          e < Ii.length && (Ii.length = e)
      }
      let t;
      if (Fi.randomAccessStructure && Ai[x] < 64 && Ai[x] >= 32 && Yi ? (t = Yi(Ai, x, ji, Fi),
      Ai = null,
      !(e && e.lazy) && t && (t = t.toJSON()),
      x = ji) : t = gi(),
      Bi &&= (x = Bi.postBundlePosition,
      null),
      qi && (Ii.restoreStructures = null),
      x == ji)
          Ii && Ii.restoreStructures && hi(),
          Ii = null,
          Ai = null,
          Vi &&= null;
      else if (x > ji)
          throw Error(`Unexpected end of MessagePack data`);
      else if (!qi) {
          let e;
          try {
              e = JSON.stringify(t, (e, t) => typeof t == `bigint` ? `${t}n` : t).slice(0, 100)
          } catch (t) {
              e = `(JSON view not available ` + t + `)`
          }
          throw Error(`Data read, but end of buffer not reached ` + e)
      }
      return t
  } catch (e) {
      throw Ii && Ii.restoreStructures && hi(),
      Oi(),
      (e instanceof RangeError || e.message.startsWith(`Unexpected end of buffer`) || x > ji) && (e.incomplete = !0),
      e
  }
}
function hi() {
  for (let e in Ii.restoreStructures)
      Ii[e] = Ii.restoreStructures[e];
  Ii.restoreStructures = null
}
function gi() {
  let e = Ai[x++];
  if (e < 160)
      if (e < 128) {
          if (e < 64)
              return e;
          {
              let t = Ii[e & 63] || Fi.getStructures && vi()[e & 63];
              return t ? (t.read ||= _i(t, e & 63),
              t.read()) : e
          }
      } else if (e < 144)
          if (e -= 128,
          Fi.mapsAsObjects) {
              let t = {};
              for (let n = 0; n < e; n++) {
                  let e = Di();
                  e === `__proto__` && (e = `__proto_`),
                  t[e] = gi()
              }
              return t
          } else {
              let t = new Map;
              for (let n = 0; n < e; n++)
                  t.set(gi(), gi());
              return t
          }
      else {
          e -= 144;
          let t = Array(e);
          for (let n = 0; n < e; n++)
              t[n] = gi();
          return Fi.freezeData ? Object.freeze(t) : t
      }
  else if (e < 192) {
      let t = e - 160;
      if (zi >= x)
          return Li.slice(x - Ri, (x += t) - Ri);
      if (zi == 0 && ji < 140) {
          let e = t < 16 ? Ci(t) : Si(t);
          if (e != null)
              return e
      }
      return ta(t)
  } else {
      let t;
      switch (e) {
      case 192:
          return null;
      case 193:
          return Bi ? (t = gi(),
          t > 0 ? Bi[1].slice(Bi.position1, Bi.position1 += t) : Bi[0].slice(Bi.position0, Bi.position0 -= t)) : Ki;
      case 194:
          return !1;
      case 195:
          return !0;
      case 196:
          if (t = Ai[x++],
          t === void 0)
              throw Error(`Unexpected end of buffer`);
          return Ti(t);
      case 197:
          return t = Ui.getUint16(x),
          x += 2,
          Ti(t);
      case 198:
          return t = Ui.getUint32(x),
          x += 4,
          Ti(t);
      case 199:
          return Ei(Ai[x++]);
      case 200:
          return t = Ui.getUint16(x),
          x += 2,
          Ei(t);
      case 201:
          return t = Ui.getUint32(x),
          x += 4,
          Ei(t);
      case 202:
          if (t = Ui.getFloat32(x),
          Fi.useFloat32 > 2) {
              let e = fa[(Ai[x] & 127) << 1 | Ai[x + 1] >> 7];
              return x += 4,
              (e * t + (t > 0 ? .5 : -.5) >> 0) / e
          }
          return x += 4,
          t;
      case 203:
          return t = Ui.getFloat64(x),
          x += 8,
          t;
      case 204:
          return Ai[x++];
      case 205:
          return t = Ui.getUint16(x),
          x += 2,
          t;
      case 206:
          return t = Ui.getUint32(x),
          x += 4,
          t;
      case 207:
          return Fi.int64AsType === `number` ? (t = Ui.getUint32(x) * 4294967296,
          t += Ui.getUint32(x + 4)) : Fi.int64AsType === `string` ? t = Ui.getBigUint64(x).toString() : Fi.int64AsType === `auto` ? (t = Ui.getBigUint64(x),
          t <= BigInt(2) << BigInt(52) && (t = Number(t))) : t = Ui.getBigUint64(x),
          x += 8,
          t;
      case 208:
          return Ui.getInt8(x++);
      case 209:
          return t = Ui.getInt16(x),
          x += 2,
          t;
      case 210:
          return t = Ui.getInt32(x),
          x += 4,
          t;
      case 211:
          return Fi.int64AsType === `number` ? (t = Ui.getInt32(x) * 4294967296,
          t += Ui.getUint32(x + 4)) : Fi.int64AsType === `string` ? t = Ui.getBigInt64(x).toString() : Fi.int64AsType === `auto` ? (t = Ui.getBigInt64(x),
          t >= BigInt(-2) << BigInt(52) && t <= BigInt(2) << BigInt(52) && (t = Number(t))) : t = Ui.getBigInt64(x),
          x += 8,
          t;
      case 212:
          if (t = Ai[x++],
          t == 114)
              return sa(Ai[x++] & 63);
          {
              let e = Hi[t];
              if (e)
                  return e.read ? (x++,
                  e.read(gi())) : e.noBuffer ? (x++,
                  e()) : e(Ai.subarray(x, ++x));
              throw Error(`Unknown extension ` + t)
          }
      case 213:
          return t = Ai[x],
          t == 114 ? (x++,
          sa(Ai[x++] & 63, Ai[x++])) : Ei(2);
      case 214:
          return Ei(4);
      case 215:
          return Ei(8);
      case 216:
          return Ei(16);
      case 217:
          return t = Ai[x++],
          zi >= x ? Li.slice(x - Ri, (x += t) - Ri) : na(t);
      case 218:
          return t = Ui.getUint16(x),
          x += 2,
          zi >= x ? Li.slice(x - Ri, (x += t) - Ri) : ra(t);
      case 219:
          return t = Ui.getUint32(x),
          x += 4,
          zi >= x ? Li.slice(x - Ri, (x += t) - Ri) : ia(t);
      case 220:
          return t = Ui.getUint16(x),
          x += 2,
          bi(t);
      case 221:
          return t = Ui.getUint32(x),
          x += 4,
          bi(t);
      case 222:
          return t = Ui.getUint16(x),
          x += 2,
          xi(t);
      case 223:
          return t = Ui.getUint32(x),
          x += 4,
          xi(t);
      default:
          if (e >= 224)
              return e - 256;
          if (e === void 0) {
              let e = Error(`Unexpected end of MessagePack data`);
              throw e.incomplete = !0,
              e
          }
          throw Error(`Unknown MessagePack token ` + e)
      }
  }
}
function _i(e, t) {
  function n() {
      if (n.count++ > Ji) {
          let n = e.read = Function(`r`, `return function(){return ` + (Fi.freezeData ? `Object.freeze` : ``) + `({` + e.map(e => e === `__proto__` ? `__proto_:r()` : $i.test(e) ? e + `:r()` : `[` + JSON.stringify(e) + `]:r()`).join(`,`) + `})}`)(gi);
          return e.highByte === 0 && (e.read = ea(t, e.read)),
          n()
      }
      let r = {};
      for (let t = 0, n = e.length; t < n; t++) {
          let n = e[t];
          n === `__proto__` && (n = `__proto_`),
          r[n] = gi()
      }
      return Fi.freezeData ? Object.freeze(r) : r
  }
  return n.count = 0,
  e.highByte === 0 ? ea(t, n) : n
}
function vi() {
  let e = ane( () => (Ai = null,
  Fi.getStructures()));
  return Ii = Fi._mergeStructures(e, Ii)
}
function yi(e) {
  let t;
  if (e < 16 && (t = Ci(e)))
      return t;
  if (e > 64 && ki)
      return ki.decode(Ai.subarray(x, x += e));
  let n = x + e
    , r = [];
  for (t = ``; x < n; ) {
      let e = Ai[x++];
      if (!(e & 128))
          r.push(e);
      else if ((e & 224) == 192) {
          let t = Ai[x++] & 63;
          r.push((e & 31) << 6 | t)
      } else if ((e & 240) == 224) {
          let t = Ai[x++] & 63
            , n = Ai[x++] & 63;
          r.push((e & 31) << 12 | t << 6 | n)
      } else if ((e & 248) == 240) {
          let t = Ai[x++] & 63
            , n = Ai[x++] & 63
            , i = Ai[x++] & 63
            , a = (e & 7) << 18 | t << 12 | n << 6 | i;
          a > 65535 && (a -= 65536,
          r.push(a >>> 10 & 1023 | 55296),
          a = 56320 | a & 1023),
          r.push(a)
      } else
          r.push(e);
      r.length >= 4096 && (t += aa.apply(String, r),
      r.length = 0)
  }
  return r.length > 0 && (t += aa.apply(String, r)),
  t
}
function bi(e) {
  let t = Array(e);
  for (let n = 0; n < e; n++)
      t[n] = gi();
  return Fi.freezeData ? Object.freeze(t) : t
}
function xi(e) {
  if (Fi.mapsAsObjects) {
      let t = {};
      for (let n = 0; n < e; n++) {
          let e = Di();
          e === `__proto__` && (e = `__proto_`),
          t[e] = gi()
      }
      return t
  } else {
      let t = new Map;
      for (let n = 0; n < e; n++)
          t.set(gi(), gi());
      return t
  }
}
function Si(e) {
  let t = x
    , n = Array(e);
  for (let r = 0; r < e; r++) {
      let e = Ai[x++];
      if ((e & 128) > 0) {
          x = t;
          return
      }
      n[r] = e
  }
  return aa.apply(String, n)
}
function Ci(e) {
  if (e < 4)
      if (e < 2) {
          if (e === 0)
              return ``;
          {
              let e = Ai[x++];
              if ((e & 128) > 1) {
                  --x;
                  return
              }
              return aa(e)
          }
      } else {
          let t = Ai[x++]
            , n = Ai[x++];
          if ((t & 128) > 0 || (n & 128) > 0) {
              x -= 2;
              return
          }
          if (e < 3)
              return aa(t, n);
          let r = Ai[x++];
          if ((r & 128) > 0) {
              x -= 3;
              return
          }
          return aa(t, n, r)
      }
  else {
      let t = Ai[x++]
        , n = Ai[x++]
        , r = Ai[x++]
        , i = Ai[x++];
      if ((t & 128) > 0 || (n & 128) > 0 || (r & 128) > 0 || (i & 128) > 0) {
          x -= 4;
          return
      }
      if (e < 6) {
          if (e === 4)
              return aa(t, n, r, i);
          {
              let e = Ai[x++];
              if ((e & 128) > 0) {
                  x -= 5;
                  return
              }
              return aa(t, n, r, i, e)
          }
      } else if (e < 8) {
          let a = Ai[x++]
            , o = Ai[x++];
          if ((a & 128) > 0 || (o & 128) > 0) {
              x -= 6;
              return
          }
          if (e < 7)
              return aa(t, n, r, i, a, o);
          let s = Ai[x++];
          if ((s & 128) > 0) {
              x -= 7;
              return
          }
          return aa(t, n, r, i, a, o, s)
      } else {
          let a = Ai[x++]
            , o = Ai[x++]
            , s = Ai[x++]
            , c = Ai[x++];
          if ((a & 128) > 0 || (o & 128) > 0 || (s & 128) > 0 || (c & 128) > 0) {
              x -= 8;
              return
          }
          if (e < 10) {
              if (e === 8)
                  return aa(t, n, r, i, a, o, s, c);
              {
                  let e = Ai[x++];
                  if ((e & 128) > 0) {
                      x -= 9;
                      return
                  }
                  return aa(t, n, r, i, a, o, s, c, e)
              }
          } else if (e < 12) {
              let l = Ai[x++]
                , u = Ai[x++];
              if ((l & 128) > 0 || (u & 128) > 0) {
                  x -= 10;
                  return
              }
              if (e < 11)
                  return aa(t, n, r, i, a, o, s, c, l, u);
              let d = Ai[x++];
              if ((d & 128) > 0) {
                  x -= 11;
                  return
              }
              return aa(t, n, r, i, a, o, s, c, l, u, d)
          } else {
              let l = Ai[x++]
                , u = Ai[x++]
                , d = Ai[x++]
                , f = Ai[x++];
              if ((l & 128) > 0 || (u & 128) > 0 || (d & 128) > 0 || (f & 128) > 0) {
                  x -= 12;
                  return
              }
              if (e < 14) {
                  if (e === 12)
                      return aa(t, n, r, i, a, o, s, c, l, u, d, f);
                  {
                      let e = Ai[x++];
                      if ((e & 128) > 0) {
                          x -= 13;
                          return
                      }
                      return aa(t, n, r, i, a, o, s, c, l, u, d, f, e)
                  }
              } else {
                  let p = Ai[x++]
                    , m = Ai[x++];
                  if ((p & 128) > 0 || (m & 128) > 0) {
                      x -= 14;
                      return
                  }
                  if (e < 15)
                      return aa(t, n, r, i, a, o, s, c, l, u, d, f, p, m);
                  let h = Ai[x++];
                  if ((h & 128) > 0) {
                      x -= 15;
                      return
                  }
                  return aa(t, n, r, i, a, o, s, c, l, u, d, f, p, m, h)
              }
          }
      }
  }
}
function wi() {
  let e = Ai[x++], t;
  if (e < 192)
      t = e - 160;
  else
      switch (e) {
      case 217:
          t = Ai[x++];
          break;
      case 218:
          t = Ui.getUint16(x),
          x += 2;
          break;
      case 219:
          t = Ui.getUint32(x),
          x += 4;
          break;
      default:
          throw Error(`Expected string`)
      }
  return yi(t)
}
function Ti(e) {
  return Fi.copyBuffers ? Uint8Array.prototype.slice.call(Ai, x, x += e) : Ai.subarray(x, x += e)
}
function Ei(e) {
  let t = Ai[x++];
  if (Hi[t]) {
      let n;
      return Hi[t](Ai.subarray(x, n = x += e), e => {
          x = e;
          try {
              return gi()
          } finally {
              x = n
          }
      }
      )
  } else
      throw Error(`Unknown extension type ` + t)
}
function Di() {
  let e = Ai[x++];
  if (e >= 160 && e < 192) {
      if (e -= 160,
      zi >= x)
          return Li.slice(x - Ri, (x += e) - Ri);
      if (!(zi == 0 && ji < 180))
          return ta(e)
  } else
      return x--,
      ine(gi());
  let t = (e << 5 ^ (e > 1 ? Ui.getUint16(x) : e > 0 ? Ai[x] : 0)) & 4095, n = oa[t], r = x, i = x + e - 3, a, o = 0;
  if (n && n.bytes == e) {
      for (; r < i; ) {
          if (a = Ui.getUint32(r),
          a != n[o++]) {
              r = 1879048192;
              break
          }
          r += 4
      }
      for (i += 3; r < i; )
          if (a = Ai[r++],
          a != n[o++]) {
              r = 1879048192;
              break
          }
      if (r === i)
          return x = r,
          n.string;
      i -= 3,
      r = x
  }
  for (n = [],
  oa[t] = n,
  n.bytes = e; r < i; )
      a = Ui.getUint32(r),
      n.push(a),
      r += 4;
  for (i += 3; r < i; )
      a = Ai[r++],
      n.push(a);
  let s = e < 16 ? Ci(e) : Si(e);
  return s == null ? n.string = ta(e) : n.string = s
}
function ine(e) {
  if (typeof e == `string`)
      return e;
  if (typeof e == `number` || typeof e == `boolean` || typeof e == `bigint`)
      return e.toString();
  if (e == null)
      return e + ``;
  throw Error(`Invalid property type for record`, typeof e)
}
function ane(e) {
  Zi && Zi();
  let t = ji
    , n = x
    , r = Pi
    , i = Ri
    , a = zi
    , o = Li
    , s = Ni
    , c = Vi
    , l = Bi
    , u = new Uint8Array(Ai.slice(0, ji))
    , d = Ii
    , f = Ii.slice(0, Ii.length)
    , p = Fi
    , m = qi
    , h = e();
  return ji = t,
  x = n,
  Pi = r,
  Ri = i,
  zi = a,
  Li = o,
  Ni = s,
  Vi = c,
  Bi = l,
  Ai = u,
  qi = m,
  Ii = d,
  Ii.splice(0, Ii.length, ...f),
  Fi = p,
  Ui = new DataView(Ai.buffer,Ai.byteOffset,Ai.byteLength),
  h
}
function Oi() {
  Ai = null,
  Vi = null,
  Ii = null
}
function one(e) {
  e.unpack ? Hi[e.type] = e.unpack : Hi[e.type] = e
}
var ki, Ai, ji, x, Mi, Ni, Pi, Fi, Ii, Li, Ri, zi, Bi, Vi, Hi, Ui, Wi, Gi, Ki, qi, Ji, Yi, Xi, Zi, Qi, $i, ea, ta, na, ra, ia, aa, oa, sa, ca, la, ua, da, fa, pa, ma, ha, ga = t(( () => {
  try {
      ki = new TextDecoder
  } catch {}
  x = 0,
  Mi = [],
  Ni = Mi,
  Pi = 0,
  Fi = {},
  Ri = 0,
  zi = 0,
  Hi = [],
  Wi = {
      useRecords: !1,
      mapsAsObjects: !0
  },
  Gi = class {
  }
  ,
  Ki = new Gi,
  Ki.name = `MessagePack 0xC1`,
  qi = !1,
  Ji = 2;
  try {
      Ji = 1 / 0
  } catch {
      Ji = 1 / 0
  }
  Qi = class e {
      constructor(e) {
          e && (e.useRecords === !1 && e.mapsAsObjects === void 0 && (e.mapsAsObjects = !0),
          e.sequential && e.trusted !== !1 && (e.trusted = !0,
          !e.structures && e.useRecords != 0 && (e.structures = [],
          e.maxSharedStructures ||= 0)),
          e.structures ? e.structures.sharedLength = e.structures.length : e.getStructures && ((e.structures = []).uninitialized = !0,
          e.structures.sharedLength = 0),
          e.int64AsNumber && (e.int64AsType = `number`)),
          Object.assign(this, e)
      }
      unpack(t, n) {
          if (Ai)
              return ane( () => (Oi(),
              this ? this.unpack(t, n) : e.prototype.unpack.call(Wi, t, n)));
          !t.buffer && t.constructor === ArrayBuffer && (t = typeof Buffer < `u` ? Buffer.from(t) : new Uint8Array(t)),
          typeof n == `object` ? (ji = n.end || t.length,
          x = n.start || 0) : (x = 0,
          ji = n > -1 ? n : t.length),
          Pi = 0,
          zi = 0,
          Li = null,
          Ni = Mi,
          Bi = null,
          Ai = t;
          try {
              Ui = t.dataView ||= new DataView(t.buffer,t.byteOffset,t.byteLength)
          } catch (e) {
              throw Ai = null,
              t instanceof Uint8Array ? e : Error(`Source must be a Uint8Array or Buffer but was a ` + (t && typeof t == `object` ? t.constructor.name : typeof t))
          }
          if (this instanceof e) {
              if (Fi = this,
              this.structures)
                  return Ii = this.structures,
                  mi(n);
              (!Ii || Ii.length > 0) && (Ii = [])
          } else
              Fi = Wi,
              (!Ii || Ii.length > 0) && (Ii = []);
          return mi(n)
      }
      unpackMultiple(e, t) {
          let n, r = 0;
          try {
              qi = !0;
              let i = e.length
                , a = this ? this.unpack(e, i) : pa.unpack(e, i);
              if (t) {
                  if (t(a, r, x) === !1)
                      return;
                  for (; x < i; )
                      if (r = x,
                      t(mi(), r, x) === !1)
                          return
              } else {
                  for (n = [a]; x < i; )
                      r = x,
                      n.push(mi());
                  return n
              }
          } catch (e) {
              throw e.lastPosition = r,
              e.values = n,
              e
          } finally {
              qi = !1,
              Oi()
          }
      }
      _mergeStructures(e, t) {
          Xi && (e = Xi.call(this, e)),
          e ||= [],
          Object.isFrozen(e) && (e = e.map(e => e.slice(0)));
          for (let t = 0, n = e.length; t < n; t++) {
              let n = e[t];
              n && (n.isShared = !0,
              t >= 32 && (n.highByte = t - 32 >> 5))
          }
          for (let n in e.sharedLength = e.length,
          t || [])
              if (n >= 0) {
                  let r = e[n]
                    , i = t[n];
                  i && (r && ((e.restoreStructures ||= [])[n] = r),
                  e[n] = i)
              }
          return this.structures = e
      }
      decode(e, t) {
          return this.unpack(e, t)
      }
  }
  ,
  $i = /^[a-zA-Z_$][a-zA-Z\d_$]*$/,
  ea = (e, t) => function() {
      let n = Ai[x++];
      if (n === 0)
          return t();
      let r = e < 32 ? -(e + (n << 5)) : e + (n << 5)
        , i = Ii[r] || vi()[r];
      if (!i)
          throw Error(`Record id is not defined for ` + r);
      return i.read ||= _i(i, e),
      i.read()
  }
  ,
  ta = yi,
  na = yi,
  ra = yi,
  ia = yi,
  aa = String.fromCharCode,
  oa = Array(4096),
  sa = (e, t) => {
      let n = gi().map(ine)
        , r = e;
      t !== void 0 && (e = e < 32 ? -((t << 5) + e) : (t << 5) + e,
      n.highByte = t);
      let i = Ii[e];
      return i && (i.isShared || qi) && ((Ii.restoreStructures ||= [])[e] = i),
      Ii[e] = n,
      n.read = _i(n, r),
      n.read()
  }
  ,
  Hi[0] = () => {}
  ,
  Hi[0].noBuffer = !0,
  Hi[66] = e => {
      let t = e.length
        , n = BigInt(e[0] & 128 ? e[0] - 256 : e[0]);
      for (let r = 1; r < t; r++)
          n <<= BigInt(8),
          n += BigInt(e[r]);
      return n
  }
  ,
  ca = {
      Error,
      TypeError,
      ReferenceError
  },
  Hi[101] = () => {
      let e = gi();
      return (ca[e[0]] || Error)(e[1], {
          cause: e[2]
      })
  }
  ,
  Hi[105] = e => {
      if (Fi.structuredClone === !1)
          throw Error(`Structured clone extension is disabled`);
      let t = Ui.getUint32(x - 4);
      Vi ||= new Map;
      let n = Ai[x], r;
      r = n >= 144 && n < 160 || n == 220 || n == 221 ? [] : {};
      let i = {
          target: r
      };
      Vi.set(t, i);
      let a = gi();
      return i.used ? Object.assign(r, a) : (i.target = a,
      a)
  }
  ,
  Hi[112] = e => {
      if (Fi.structuredClone === !1)
          throw Error(`Structured clone extension is disabled`);
      let t = Ui.getUint32(x - 4)
        , n = Vi.get(t);
      return n.used = !0,
      n.target
  }
  ,
  Hi[115] = () => new Set(gi()),
  la = [`Int8`, `Uint8`, `Uint8Clamped`, `Int16`, `Uint16`, `Int32`, `Uint32`, `Float32`, `Float64`, `BigInt64`, `BigUint64`].map(e => e + `Array`),
  ua = typeof globalThis == `object` ? globalThis : window,
  Hi[116] = e => {
      let t = e[0]
        , n = la[t];
      if (!n) {
          if (t === 16) {
              let t = new ArrayBuffer(e.length - 1);
              return new Uint8Array(t).set(e.subarray(1)),
              t
          }
          throw Error(`Could not find typed array for code ` + t)
      }
      return new ua[n](Uint8Array.prototype.slice.call(e, 1).buffer)
  }
  ,
  Hi[120] = () => {
      let e = gi();
      return new RegExp(e[0],e[1])
  }
  ,
  da = [],
  Hi[98] = e => {
      let t = (e[0] << 24) + (e[1] << 16) + (e[2] << 8) + e[3]
        , n = x;
      return x += t - e.length,
      Bi = da,
      Bi = [wi(), wi()],
      Bi.position0 = 0,
      Bi.position1 = 0,
      Bi.postBundlePosition = x,
      x = n,
      gi()
  }
  ,
  Hi[255] = e => e.length == 4 ? new Date((e[0] * 16777216 + (e[1] << 16) + (e[2] << 8) + e[3]) * 1e3) : e.length == 8 ? new Date(((e[0] << 22) + (e[1] << 14) + (e[2] << 6) + (e[3] >> 2)) / 1e6 + ((e[3] & 3) * 4294967296 + e[4] * 16777216 + (e[5] << 16) + (e[6] << 8) + e[7]) * 1e3) : e.length == 12 ? new Date(((e[0] << 24) + (e[1] << 16) + (e[2] << 8) + e[3]) / 1e6 + ((e[4] & 128 ? -281474976710656 : 0) + e[6] * 1099511627776 + e[7] * 4294967296 + e[8] * 16777216 + (e[9] << 16) + (e[10] << 8) + e[11]) * 1e3) : new Date(`invalid`),
  fa = Array(147);
  for (let e = 0; e < 256; e++)
      fa[e] = +(`1e` + Math.floor(45.15 - e * .30103));
  pa = new Qi({
      useRecords: !1
  }),
  pa.unpack,
  pa.unpackMultiple,
  pa.unpack,
  ma = {
      NEVER: 0,
      ALWAYS: 1,
      DECIMAL_ROUND: 3,
      DECIMAL_FIT: 4
  },
  ha = new Float32Array(1),
  new Uint8Array(ha.buffer,0,4)
}
));
function _a(e, t, n, r) {
  let i = e.byteLength;
  if (i + 1 < 256) {
      var {target: a, position: o} = n(4 + i);
      a[o++] = 199,
      a[o++] = i + 1
  } else if (i + 1 < 65536) {
      var {target: a, position: o} = n(5 + i);
      a[o++] = 200,
      a[o++] = i + 1 >> 8,
      a[o++] = i + 1 & 255
  } else {
      var {target: a, position: o, targetView: s} = n(7 + i);
      a[o++] = 201,
      s.setUint32(o, i + 1),
      o += 4
  }
  a[o++] = 116,
  a[o++] = t,
  e.buffer || (e = new Uint8Array(e)),
  a.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength), o)
}
function va(e, t) {
  let n = e.byteLength;
  var r, i;
  if (n < 256) {
      var {target: r, position: i} = t(n + 2);
      r[i++] = 196,
      r[i++] = n
  } else if (n < 65536) {
      var {target: r, position: i} = t(n + 3);
      r[i++] = 197,
      r[i++] = n >> 8,
      r[i++] = n & 255
  } else {
      var {target: r, position: i, targetView: a} = t(n + 5);
      r[i++] = 198,
      a.setUint32(i, n),
      i += 4
  }
  r.set(e, i)
}
function sne(e, t, n, r) {
  let i = e.length;
  switch (i) {
  case 1:
      t[n++] = 212;
      break;
  case 2:
      t[n++] = 213;
      break;
  case 4:
      t[n++] = 214;
      break;
  case 8:
      t[n++] = 215;
      break;
  case 16:
      t[n++] = 216;
      break;
  default:
      i < 256 ? (t[n++] = 199,
      t[n++] = i) : i < 65536 ? (t[n++] = 200,
      t[n++] = i >> 8,
      t[n++] = i & 255) : (t[n++] = 201,
      t[n++] = i >> 24,
      t[n++] = i >> 16 & 255,
      t[n++] = i >> 8 & 255,
      t[n++] = i & 255)
  }
  return t[n++] = r,
  t.set(e, n),
  n += i,
  n
}
function cne(e, t) {
  let n, r = t.length * 6, i = e.length - r;
  for (; n = t.pop(); ) {
      let t = n.offset
        , a = n.id;
      e.copyWithin(t + r, t, i),
      r -= 6;
      let o = t + r;
      e[o++] = 214,
      e[o++] = 105,
      e[o++] = a >> 24,
      e[o++] = a >> 16 & 255,
      e[o++] = a >> 8 & 255,
      e[o++] = a & 255,
      i = t
  }
  return e
}
function ya(e, t, n) {
  if (Aa.length > 0) {
      Oa.setUint32(Aa.position + e, C + n - Aa.position - e),
      Aa.stringsPosition = C - e;
      let r = Aa;
      Aa = null,
      t(r[0]),
      t(r[1])
  }
}
function lne(e) {
  if (e.Class) {
      if (!e.pack && !e.write)
          throw Error(`Extension has no pack or write function`);
      if (e.pack && !e.type)
          throw Error(`Extension has no type (numeric code to identify the extension)`);
      Sa.unshift(e.Class),
      xa.unshift(e)
  }
  one(e)
}
function une(e, t) {
  return e.isCompatible = e => {
      let n = !e || (t.lastNamedStructuresLength || 0) === e.length;
      return n || t._mergeStructures(e),
      n
  }
  ,
  e
}
var ba, xa, Sa, Ca, wa, Ta, Ea, S, Da, Oa, C, ka, Aa, dne, ja, Ma, Na, Pa, Fa, fne, pne, mne, hne, Ia = t(( () => {
  ga();
  try {
      ba = new TextEncoder
  } catch {}
  Ca = typeof Buffer < `u`,
  wa = Ca ? function(e) {
      return Buffer.allocUnsafeSlow(e)
  }
  : Uint8Array,
  Ta = Ca ? Buffer : Uint8Array,
  Ea = Ca ? 4294967296 : 2144337920,
  C = 0,
  Aa = null,
  ja = 21760,
  Ma = /[\u0080-\uFFFF]/,
  Na = Symbol(`record-id`),
  Pa = class extends Qi {
      constructor(e) {
          super(e),
          this.offset = 0;
          let t, n, r, i, a = Ta.prototype.utf8Write ? function(e, t) {
              return S.utf8Write(e, t, S.byteLength - t)
          }
          : ba && ba.encodeInto ? function(e, t) {
              return ba.encodeInto(e, S.subarray(t)).written
          }
          : !1, o = this;
          e ||= {};
          let s = e && e.sequential
            , c = e.structures || e.saveStructures
            , l = e.maxSharedStructures;
          if (l ??= c ? 32 : 0,
          l > 8160)
              throw Error(`Maximum maxSharedStructure is 8160`);
          e.structuredClone && e.moreTypes == null && (this.moreTypes = !0);
          let u = e.maxOwnStructures;
          u ??= c ? 32 : 64,
          !this.structures && e.useRecords != 0 && (this.structures = []);
          let d = l > 32 || u + l > 64
            , f = l + 64
            , p = l + u + 64;
          if (p > 8256)
              throw Error(`Maximum maxSharedStructure + maxOwnStructure is 8192`);
          let m = []
            , h = 0
            , g = 0;
          this.pack = this.encode = function(e, a) {
              if (S || (S = new wa(8192),
              Oa = S.dataView ||= new DataView(S.buffer,0,8192),
              C = 0),
              ka = S.length - 10,
              ka - C < 2048 ? (S = new wa(S.length),
              Oa = S.dataView ||= new DataView(S.buffer,0,S.length),
              ka = S.length - 10,
              C = 0) : C = C + 7 & 2147483640,
              t = C,
              a & 2048 && (C += a & 255),
              i = o.structuredClone ? new Map : null,
              o.bundleStrings && typeof e != `string` ? (Aa = [],
              Aa.size = 1 / 0) : Aa = null,
              r = o.structures,
              r) {
                  r.uninitialized && (r = o._mergeStructures(o.getStructures()));
                  let e = r.sharedLength || 0;
                  if (e > l)
                      throw Error(`Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ` + r.sharedLength);
                  if (!r.transitions) {
                      r.transitions = Object.create(null);
                      for (let t = 0; t < e; t++) {
                          let e = r[t];
                          if (!e)
                              continue;
                          let n, i = r.transitions;
                          for (let t = 0, r = e.length; t < r; t++) {
                              let r = e[t];
                              n = i[r],
                              n ||= i[r] = Object.create(null),
                              i = n
                          }
                          i[Na] = t + 64
                      }
                      this.lastNamedStructuresLength = e
                  }
                  s || (r.nextId = e + 64)
              }
              n &&= !1;
              let c;
              try {
                  o.randomAccessStructure && e && e.constructor && e.constructor === Object ? le(e) : te(e);
                  let n = Aa;
                  if (Aa && ya(t, te, 0),
                  i && i.idsToInsert) {
                      let e = i.idsToInsert.sort( (e, t) => e.offset > t.offset ? 1 : -1)
                        , r = e.length
                        , a = -1;
                      for (; n && r > 0; ) {
                          let i = e[--r].offset + t;
                          i < n.stringsPosition + t && a === -1 && (a = 0),
                          i > n.position + t ? a >= 0 && (a += 6) : (a >= 0 && (Oa.setUint32(n.position + t, Oa.getUint32(n.position + t) + a),
                          a = -1),
                          n = n.previous,
                          r++)
                      }
                      a >= 0 && n && Oa.setUint32(n.position + t, Oa.getUint32(n.position + t) + a),
                      C += e.length * 6,
                      C > ka && oe(C),
                      o.offset = C;
                      let s = cne(S.subarray(t, C), e);
                      return i = null,
                      s
                  }
                  return o.offset = C,
                  a & 512 ? (S.start = t,
                  S.end = C,
                  S) : S.subarray(t, C)
              } catch (e) {
                  throw c = e,
                  e
              } finally {
                  if (r && (_(),
                  n && o.saveStructures)) {
                      let n = r.sharedLength || 0
                        , i = S.subarray(t, C)
                        , s = une(r, o);
                      if (!c)
                          return o.saveStructures(s, s.isCompatible) === !1 ? o.pack(e, a) : (o.lastNamedStructuresLength = n,
                          S.length > 1073741824 && (S = null),
                          i)
                  }
                  S.length > 1073741824 && (S = null),
                  a & 1024 && (C = t)
              }
          }
          ;
          let _ = () => {
              g < 10 && g++;
              let e = r.sharedLength || 0;
              if (r.length > e && !s && (r.length = e),
              h > 1e4)
                  r.transitions = null,
                  g = 0,
                  h = 0,
                  m.length > 0 && (m = []);
              else if (m.length > 0 && !s) {
                  for (let e = 0, t = m.length; e < t; e++)
                      m[e][Na] = 0;
                  m = []
              }
          }
            , ee = e => {
              var t = e.length;
              t < 16 ? S[C++] = 144 | t : t < 65536 ? (S[C++] = 220,
              S[C++] = t >> 8,
              S[C++] = t & 255) : (S[C++] = 221,
              Oa.setUint32(C, t),
              C += 4);
              for (let n = 0; n < t; n++)
                  te(e[n])
          }
            , te = e => {
              C > ka && (S = oe(C));
              var n = typeof e, r;
              if (n === `string`) {
                  let n = e.length;
                  if (Aa && n >= 4 && n < 4096) {
                      if ((Aa.size += n) > ja) {
                          let e, n = (Aa[0] ? Aa[0].length * 3 + Aa[1].length : 0) + 10;
                          C + n > ka && (S = oe(C + n));
                          let r;
                          Aa.position ? (r = Aa,
                          S[C] = 200,
                          C += 3,
                          S[C++] = 98,
                          e = C - t,
                          C += 4,
                          ya(t, te, 0),
                          Oa.setUint16(e + t - 3, C - t - e)) : (S[C++] = 214,
                          S[C++] = 98,
                          e = C - t,
                          C += 4),
                          Aa = [``, ``],
                          Aa.previous = r,
                          Aa.size = 0,
                          Aa.position = e
                      }
                      let r = Ma.test(e);
                      Aa[r ? 0 : 1] += e,
                      S[C++] = 193,
                      te(r ? -n : n);
                      return
                  }
                  let i;
                  i = n < 32 ? 1 : n < 256 ? 2 : n < 65536 ? 3 : 5;
                  let o = n * 3;
                  if (C + o > ka && (S = oe(C + o)),
                  n < 64 || !a) {
                      let t, a, o, s = C + i;
                      for (t = 0; t < n; t++)
                          a = e.charCodeAt(t),
                          a < 128 ? S[s++] = a : a < 2048 ? (S[s++] = a >> 6 | 192,
                          S[s++] = a & 63 | 128) : (a & 64512) == 55296 && ((o = e.charCodeAt(t + 1)) & 64512) == 56320 ? (a = 65536 + ((a & 1023) << 10) + (o & 1023),
                          t++,
                          S[s++] = a >> 18 | 240,
                          S[s++] = a >> 12 & 63 | 128,
                          S[s++] = a >> 6 & 63 | 128,
                          S[s++] = a & 63 | 128) : (S[s++] = a >> 12 | 224,
                          S[s++] = a >> 6 & 63 | 128,
                          S[s++] = a & 63 | 128);
                      r = s - C - i
                  } else
                      r = a(e, C + i);
                  r < 32 ? S[C++] = 160 | r : r < 256 ? (i < 2 && S.copyWithin(C + 2, C + 1, C + 1 + r),
                  S[C++] = 217,
                  S[C++] = r) : r < 65536 ? (i < 3 && S.copyWithin(C + 3, C + 2, C + 2 + r),
                  S[C++] = 218,
                  S[C++] = r >> 8,
                  S[C++] = r & 255) : (i < 5 && S.copyWithin(C + 5, C + 3, C + 3 + r),
                  S[C++] = 219,
                  Oa.setUint32(C, r),
                  C += 4),
                  C += r
              } else if (n === `number`)
                  if (e >>> 0 === e)
                      e < 32 || e < 128 && this.useRecords === !1 || e < 64 && !this.randomAccessStructure ? S[C++] = e : e < 256 ? (S[C++] = 204,
                      S[C++] = e) : e < 65536 ? (S[C++] = 205,
                      S[C++] = e >> 8,
                      S[C++] = e & 255) : (S[C++] = 206,
                      Oa.setUint32(C, e),
                      C += 4);
                  else if (e >> 0 === e)
                      e >= -32 ? S[C++] = 256 + e : e >= -128 ? (S[C++] = 208,
                      S[C++] = e + 256) : e >= -32768 ? (S[C++] = 209,
                      Oa.setInt16(C, e),
                      C += 2) : (S[C++] = 210,
                      Oa.setInt32(C, e),
                      C += 4);
                  else {
                      let t;
                      if ((t = this.useFloat32) > 0 && e < 4294967296 && e >= -2147483648) {
                          S[C++] = 202,
                          Oa.setFloat32(C, e);
                          let n;
                          if (t < 4 || (n = e * fa[(S[C] & 127) << 1 | S[C + 1] >> 7]) >> 0 === n) {
                              C += 4;
                              return
                          } else
                              C--
                      }
                      S[C++] = 203,
                      Oa.setFloat64(C, e),
                      C += 8
                  }
              else if (n === `object` || n === `function`)
                  if (!e)
                      S[C++] = 192;
                  else {
                      if (i) {
                          let n = i.get(e);
                          if (n) {
                              n.id ||= (i.idsToInsert ||= []).push(n),
                              S[C++] = 214,
                              S[C++] = 112,
                              Oa.setUint32(C, n.id),
                              C += 4;
                              return
                          } else
                              i.set(e, {
                                  offset: C - t
                              })
                      }
                      let a = e.constructor;
                      if (a === Object)
                          ae(e);
                      else if (a === Array)
                          ee(e);
                      else if (a === Map)
                          if (this.mapAsEmptyObject)
                              S[C++] = 128;
                          else {
                              r = e.size,
                              r < 16 ? S[C++] = 128 | r : r < 65536 ? (S[C++] = 222,
                              S[C++] = r >> 8,
                              S[C++] = r & 255) : (S[C++] = 223,
                              Oa.setUint32(C, r),
                              C += 4);
                              for (let[t,n] of e)
                                  te(t),
                                  te(n)
                          }
                      else {
                          for (let t = 0, n = xa.length; t < n; t++) {
                              let n = Sa[t];
                              if (e instanceof n) {
                                  let n = xa[t];
                                  if (n.write) {
                                      n.type && (S[C++] = 212,
                                      S[C++] = n.type,
                                      S[C++] = 0);
                                      let t = n.write.call(this, e);
                                      t === e ? Array.isArray(e) ? ee(e) : ae(e) : te(t);
                                      return
                                  }
                                  let r = S
                                    , i = Oa
                                    , a = C;
                                  S = null;
                                  let o;
                                  try {
                                      o = n.pack.call(this, e, e => (S = r,
                                      r = null,
                                      C += e,
                                      C > ka && oe(C),
                                      {
                                          target: S,
                                          targetView: Oa,
                                          position: C - e
                                      }), te)
                                  } finally {
                                      r && (S = r,
                                      Oa = i,
                                      C = a,
                                      ka = S.length - 10)
                                  }
                                  o && (o.length + C > ka && oe(o.length + C),
                                  C = sne(o, S, C, n.type));
                                  return
                              }
                          }
                          if (Array.isArray(e))
                              ee(e);
                          else {
                              if (e.toJSON) {
                                  let t = e.toJSON();
                                  if (t !== e)
                                      return te(t)
                              }
                              if (n === `function`)
                                  return te(this.writeFunction && this.writeFunction(e));
                              ae(e)
                          }
                      }
                  }
              else if (n === `boolean`)
                  S[C++] = e ? 195 : 194;
              else if (n === `bigint`) {
                  if (e < BigInt(1) << BigInt(63) && e >= -(BigInt(1) << BigInt(63)))
                      S[C++] = 211,
                      Oa.setBigInt64(C, e);
                  else if (e < BigInt(1) << BigInt(64) && e > 0)
                      S[C++] = 207,
                      Oa.setBigUint64(C, e);
                  else if (this.largeBigIntToFloat)
                      S[C++] = 203,
                      Oa.setFloat64(C, Number(e));
                  else if (this.largeBigIntToString)
                      return te(e.toString());
                  else if (this.useBigIntExtension && e < BigInt(2) ** BigInt(1023) && e > -(BigInt(2) ** BigInt(1023))) {
                      S[C++] = 199,
                      C++,
                      S[C++] = 66;
                      let t = [], n;
                      do {
                          let r = e & BigInt(255);
                          n = (r & BigInt(128)) === (e < BigInt(0) ? BigInt(128) : BigInt(0)),
                          t.push(r),
                          e >>= BigInt(8)
                      } while (!((e === BigInt(0) || e === BigInt(-1)) && n));
                      S[C - 2] = t.length;
                      for (let e = t.length; e > 0; )
                          S[C++] = Number(t[--e]);
                      return
                  } else
                      throw RangeError(e + ` was too large to fit in MessagePack 64-bit integer format, use useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set largeBigIntToString to convert to string`);
                  C += 8
              } else if (n === `undefined`)
                  this.encodeUndefinedAsNil ? S[C++] = 192 : (S[C++] = 212,
                  S[C++] = 0,
                  S[C++] = 0);
              else
                  throw Error(`Unknown type: ` + n)
          }
            , ne = this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues ? e => {
              let t;
              if (this.skipValues)
                  for (let n in t = [],
                  e)
                      (typeof e.hasOwnProperty != `function` || e.hasOwnProperty(n)) && !this.skipValues.includes(e[n]) && t.push(n);
              else
                  t = Object.keys(e);
              let n = t.length;
              n < 16 ? S[C++] = 128 | n : n < 65536 ? (S[C++] = 222,
              S[C++] = n >> 8,
              S[C++] = n & 255) : (S[C++] = 223,
              Oa.setUint32(C, n),
              C += 4);
              let r;
              if (this.coercibleKeyAsNumber)
                  for (let i = 0; i < n; i++) {
                      r = t[i];
                      let n = Number(r);
                      te(isNaN(n) ? r : n),
                      te(e[r])
                  }
              else
                  for (let i = 0; i < n; i++)
                      te(r = t[i]),
                      te(e[r])
          }
          : e => {
              S[C++] = 222;
              let n = C - t;
              C += 2;
              let r = 0;
              for (let t in e)
                  (typeof e.hasOwnProperty != `function` || e.hasOwnProperty(t)) && (te(t),
                  te(e[t]),
                  r++);
              if (r > 65535)
                  throw Error(`Object is too large to serialize with fast 16-bit map size, use the "variableMapSize" option to serialize this object`);
              S[n++ + t] = r >> 8,
              S[n + t] = r & 255
          }
            , re = this.useRecords === !1 ? ne : e.progressiveRecords && !d ? e => {
              let n, i = r.transitions ||= Object.create(null), a = C++ - t, o;
              for (let s in e)
                  if (typeof e.hasOwnProperty != `function` || e.hasOwnProperty(s)) {
                      if (n = i[s],
                      n)
                          i = n;
                      else {
                          let c = Object.keys(e)
                            , l = i;
                          i = r.transitions;
                          let u = 0;
                          for (let e = 0, t = c.length; e < t; e++) {
                              let t = c[e];
                              n = i[t],
                              n || (n = i[t] = Object.create(null),
                              u++),
                              i = n
                          }
                          a + t + 1 == C ? (C--,
                          se(i, c, u)) : ce(i, c, a, u),
                          o = !0,
                          i = l[s]
                      }
                      te(e[s])
                  }
              if (!o) {
                  let n = i[Na];
                  n ? S[a + t] = n : ce(i, Object.keys(e), a, 0)
              }
          }
          : e => {
              let t, n = r.transitions ||= Object.create(null), i = 0;
              for (let r in e)
                  (typeof e.hasOwnProperty != `function` || e.hasOwnProperty(r)) && (t = n[r],
                  t || (t = n[r] = Object.create(null),
                  i++),
                  n = t);
              let a = n[Na];
              for (let t in a ? a >= 96 && d ? (S[C++] = ((a -= 96) & 31) + 96,
              S[C++] = a >> 5) : S[C++] = a : se(n, n.__keys__ || Object.keys(e), i),
              e)
                  (typeof e.hasOwnProperty != `function` || e.hasOwnProperty(t)) && te(e[t])
          }
            , ie = typeof this.useRecords == `function` && this.useRecords
            , ae = ie ? e => {
              ie(e) ? re(e) : ne(e)
          }
          : re
            , oe = e => {
              let n;
              if (e > 16777216) {
                  if (e - t > Ea)
                      throw Error(`Packed buffer would be larger than maximum buffer size`);
                  n = Math.min(Ea, Math.round(Math.max((e - t) * (e > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096)
              } else
                  n = (Math.max(e - t << 2, S.length - 1) >> 12) + 1 << 12;
              let r = new wa(n);
              return Oa = r.dataView ||= new DataView(r.buffer,0,n),
              e = Math.min(e, S.length),
              S.copy ? S.copy(r, 0, t, e) : r.set(S.slice(t, e)),
              C -= t,
              t = 0,
              ka = r.length - 10,
              S = r
          }
            , se = (e, t, i) => {
              let a = r.nextId;
              a ||= 64,
              a < f && this.shouldShareStructure && !this.shouldShareStructure(t) ? (a = r.nextOwnId,
              a < p || (a = f),
              r.nextOwnId = a + 1) : (a >= p && (a = f),
              r.nextId = a + 1);
              let o = t.highByte = a >= 96 && d ? a - 96 >> 5 : -1;
              e[Na] = a,
              e.__keys__ = t,
              r[a - 64] = t,
              a < f ? (t.isShared = !0,
              r.sharedLength = a - 63,
              n = !0,
              o >= 0 ? (S[C++] = (a & 31) + 96,
              S[C++] = o) : S[C++] = a) : (o >= 0 ? (S[C++] = 213,
              S[C++] = 114,
              S[C++] = (a & 31) + 96,
              S[C++] = o) : (S[C++] = 212,
              S[C++] = 114,
              S[C++] = a),
              i && (h += g * i),
              m.length >= u && (m.shift()[Na] = 0),
              m.push(e),
              te(t))
          }
            , ce = (e, n, r, i) => {
              let a = S
                , o = C
                , s = ka
                , c = t;
              S = Da,
              C = 0,
              t = 0,
              S || (Da = S = new wa(8192)),
              ka = S.length - 10,
              se(e, n, i),
              Da = S;
              let l = C;
              if (S = a,
              C = o,
              ka = s,
              t = c,
              l > 1) {
                  let e = C + l - 1;
                  e > ka && oe(e);
                  let n = r + t;
                  S.copyWithin(n + l, n + 1, C),
                  S.set(Da.slice(0, l), n),
                  C = e
              } else
                  S[r + t] = Da[0]
          }
            , le = e => {
              let i = dne(e, S, t, C, r, oe, (e, t, r) => {
                  if (r)
                      return n = !0;
                  C = t;
                  let i = S;
                  return te(e),
                  _(),
                  i === S ? C : {
                      position: C,
                      targetView: Oa,
                      target: S
                  }
              }
              , this);
              if (i === 0)
                  return ae(e);
              C = i
          }
      }
      useBuffer(e) {
          S = e,
          S.dataView ||= new DataView(S.buffer,S.byteOffset,S.byteLength),
          C = 0
      }
      set position(e) {
          C = e
      }
      get position() {
          return C
      }
      clearSharedData() {
          this.structures &&= [],
          this.typedStructs &&= []
      }
  }
  ,
  Sa = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, Gi],
  xa = [{
      pack(e, t, n) {
          let r = e.getTime() / 1e3;
          if ((this.useTimestamp32 || e.getMilliseconds() === 0) && r >= 0 && r < 4294967296) {
              let {target: e, targetView: n, position: i} = t(6);
              e[i++] = 214,
              e[i++] = 255,
              n.setUint32(i, r)
          } else if (r > 0 && r < 4294967296) {
              let {target: n, targetView: i, position: a} = t(10);
              n[a++] = 215,
              n[a++] = 255,
              i.setUint32(a, e.getMilliseconds() * 4e6 + (r / 1e3 / 4294967296 >> 0)),
              i.setUint32(a + 4, r)
          } else if (isNaN(r)) {
              if (this.onInvalidDate)
                  return t(0),
                  n(this.onInvalidDate());
              let {target: e, targetView: r, position: i} = t(3);
              e[i++] = 212,
              e[i++] = 255,
              e[i++] = 255
          } else {
              let {target: n, targetView: i, position: a} = t(15);
              n[a++] = 199,
              n[a++] = 12,
              n[a++] = 255,
              i.setUint32(a, e.getMilliseconds() * 1e6),
              i.setBigInt64(a + 4, BigInt(Math.floor(r)))
          }
      }
  }, {
      pack(e, t, n) {
          if (this.setAsEmptyObject)
              return t(0),
              n({});
          let r = Array.from(e)
            , {target: i, position: a} = t(this.moreTypes ? 3 : 0);
          this.moreTypes && (i[a++] = 212,
          i[a++] = 115,
          i[a++] = 0),
          n(r)
      }
  }, {
      pack(e, t, n) {
          let {target: r, position: i} = t(this.moreTypes ? 3 : 0);
          this.moreTypes && (r[i++] = 212,
          r[i++] = 101,
          r[i++] = 0),
          n([e.name, e.message, e.cause])
      }
  }, {
      pack(e, t, n) {
          let {target: r, position: i} = t(this.moreTypes ? 3 : 0);
          this.moreTypes && (r[i++] = 212,
          r[i++] = 120,
          r[i++] = 0),
          n([e.source, e.flags])
      }
  }, {
      pack(e, t) {
          this.moreTypes ? _a(e, 16, t) : va(Ca ? Buffer.from(e) : new Uint8Array(e), t)
      }
  }, {
      pack(e, t) {
          let n = e.constructor;
          n !== Ta && this.moreTypes ? _a(e, la.indexOf(n.name), t) : va(e, t)
      }
  }, {
      pack(e, t) {
          let {target: n, position: r} = t(1);
          n[r] = 193
      }
  }],
  Fa = new Pa({
      useRecords: !1
  }),
  Fa.pack,
  Fa.pack,
  {NEVER: fne, ALWAYS: pne, DECIMAL_ROUND: mne, DECIMAL_FIT: hne} = ma
}
)), gne = t(( () => {
  Ia(),
  ga()
}
)), La = t(( () => {
  Ia(),
  ga(),
  gne()
}
)), Ra, za, Ba, Va = t(( () => {
  La(),
  Ra = function(e) {
      return e[e.CollabMessage = 1] = `CollabMessage`,
      e[e.CollabCommand = 2] = `CollabCommand`,
      e
  }({}),
  za = class {
      static registerBinaryExtension(e, t, n) {
          if (Ba.has(t))
              throw Error(`Type ${t} is already used to register a MessagePack extension`);
          Ba.add(t),
          lne({
              Class: e,
              type: t,
              write: function(e) {
                  return n.map(t => e[t])
              },
              read: function(t) {
                  return new e(...t)
              }
          })
      }
  }
  ,
  Ba = new Set
}
)), Ha, Ua, Wa, Ga = t(( () => {
  Va(),
  Ha = function(e) {
      return e.warningToast = `warningToast`,
      e.refresh = `refresh`,
      e.load = `load`,
      e.clear = `clear`,
      e
  }({}),
  Ua = class {
      constructor(e, t) {
          this.id = e,
          this.update = t,
          this.cmd = `collab`
      }
  }
  ,
  za.registerBinaryExtension(Ua, Ra.CollabMessage, [`id`, `update`]),
  Wa = function(e) {
      return e[e.rebootstrapRequired = 4001] = `rebootstrapRequired`,
      e[e.authenticationError = 4002] = `authenticationError`,
      e[e.tooManyConnections = 4003] = `tooManyConnections`,
      e[e.loggedOut = 4004] = `loggedOut`,
      e[e.invalidBinaryMessage = 4005] = `invalidBinaryMessage`,
      e[e.unknownAbbreviation = 4006] = `unknownAbbreviation`,
      e[e.notPartOfCollabDocument = 4007] = `notPartOfCollabDocument`,
      e[e.ipAddrNotAllowed = 4008] = `ipAddrNotAllowed`,
      e
  }({})
}
)), Ka, qa = t(( () => {
  Ka = e => e.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i) !== null
}
));
function Ja(e, t=void 0) {
  return new Promise(n => {
      setTimeout( () => {
          n(t)
      }
      , e)
  }
  )
}
var Ya = t(( () => {}
));
function Xa(e, ...t) {
  return _ne(e) ? e(...t) : e
}
function _ne(e) {
  return typeof e == `function`
}
var Za = t(( () => {}
)), Qa, $a, eo, to = t(( () => {
  Za(),
  zn(),
  (function(e) {
      async function t(e, t) {
          let {maxRetries: n, backoff: r, shouldRetry: i, beforeRetry: a} = e
            , o = 0;
          for (; ; )
              try {
                  return await t(o)
              } catch (e) {
                  let t = e instanceof Error ? e : Error(String(e));
                  if (i?.(t) === !1 || o >= n)
                      throw t;
                  let s = Xa(r, t)
                    , c = typeof s == `number` ? s : s.type === `exponential` ? Math.min(2 ** o * s.delay, s.maxDelay ?? 2 ** 53 - 1) : Ln(s.type);
                  o++,
                  a?.(t, c),
                  await new Promise(e => setTimeout(e, c))
              }
      }
      e.executeWithRetries = t;
      function n(e) {
          return e instanceof Error && e.name === `AbortError`
      }
      e.isAbortError = n;
      function r(e, t) {
          return e instanceof Error ? e : Error(t ? `${t} ${String(e)}` : String(e))
      }
      e.buildError = r;
      function i(e) {
          let t = `${einstanceof Error ? e.message : typeof e == `string` ? e : `Unknown error`}`
            , n = e instanceof Error ? e.name : `Unknown error`;
          return n === `TypeError` && t.startsWith(`Load failed`) || t.startsWith(`TypeError: Load failed`) || t === `Content-Length header of network response exceeds response Body.` || n === `TypeError` && t === `NetworkError when attempting to fetch resource.` || t.startsWith(`TypeError: NetworkError when attempting to fetch resource.`)
      }
      e.isBrowserNetworkError = i
  }
  )(Qa ||= {}),
  $a = class extends Error {
      constructor(e) {
          super(e),
          this.name = `AbortError`
      }
  }
  ,
  eo = class extends Error {
      constructor(e) {
          super(e),
          this.userPresentableMessage = e,
          this.name = `UserPresentableError`
      }
  }
}
));
function no() {
  let e, t, n = new Promise( (n, r) => {
      e = n,
      t = r
  }
  );
  return n.resolve = e,
  n.reject = t,
  n
}
var ro = t(( () => {}
)), io, ao, oo, so = t(( () => {
  io = e(we(), 1),
  ao = {
      query: {
          rate: .2
      },
      mutation: {
          rate: .2
      },
      $pageview: {
          rate: .2
      }
  },
  (function(e) {
      function t(e, t) {
          let n = (0,
          io.default)(t, 0, 1)
            , r = (oo.computeHash(e) % 100 + 1) / 100;
          return {
              shouldTrack: r <= n,
              samplingRate: n,
              bucket: r
          }
      }
      e.shouldUserBeTracked = t;
      function n(e) {
          let t = 5381
            , n = e.length;
          for (; n; )
              t = t * 33 ^ e.charCodeAt(--n);
          return t >>> 0
      }
      e.computeHash = n
  }
  )(oo ||= {})
}
)), co, lo = t(( () => {
  co = class e {
      static get isElectron() {
          return e.implementation ? e.implementation.isElectron : !1
      }
      static get hasNewDesktopQuitCloseRefreshBehaviour() {
          return e.implementation ? e.implementation.hasNewDesktopQuitCloseRefreshBehaviour : !1
      }
      static get bridge() {
          return e.implementation ? e.implementation.bridge : new Proxy({},{
              get() {
                  return () => {}
              }
          })
      }
      static register(t) {
          e.implementation = t
      }
  }
}
)), uo, fo, po, vne = t(( () => {
  zt(),
  so(),
  Xn(),
  lo(),
  ni(),
  uo = `trackedEvents`,
  fo = `hasAliasedUser`,
  po = class {
      constructor(e, t) {
          this.track = (e, t={}, n={}) => {
              if (this.store.user.isAnonymous || n.stopTrackingAt && n.stopTrackingAt <= new Date || this.store.organization?.urlKey === `linear-xl`)
                  return;
              if (this.updateSessionTrackedEvents(),
              n.trackOncePerSession) {
                  if (this.sessionTrackedEvents.has(e))
                      return;
                  Mt( () => this.sessionTrackedEvents.add(e))
              }
              let r;
              if (n.sampleRate && (r = oo.shouldUserBeTracked(this.store.user.id, n.sampleRate),
              !r.shouldTrack))
                  return;
              t = {
                  $useragent: navigator.userAgent,
                  platform: co.isElectron ? `desktop` : `web`,
                  $browser_language: navigator.languages?.length ? navigator.languages[0] : navigator.language,
                  $screen_height: screen.height,
                  $screen_width: screen.width,
                  $set: {
                      ...n.setUserProperties
                  },
                  ...t,
                  sampling: {
                      ...r
                  }
              };
              let i = {
                  cmd: `track`,
                  event: {
                      event: e,
                      properties: t
                  }
              };
              this.store.user.settings.debugAnalytics && console.info(`Analytics event: `, e, t),
              this.socket.send(i)
          }
          ,
          this.sessionTrackedEvents = Mt( () => new Set),
          this.anonymousIdKey = `ph_${Jn.POSTHOG_WRITE_KEY}_posthog`,
          this.updateSessionTrackedEvents = Ft( () => {
              this.sessionTrackedEvents = new Set(ei.getSession(uo) ?? [])
          }
          ),
          this.store = e,
          this.socket = t,
          this.updateSessionTrackedEvents(),
          Rt( () => {
              ei.setSession(uo, Array.from(this.sessionTrackedEvents));
              let e = this.getWebAnonymousId();
              if (e && !ei.get(fo)) {
                  let t = {
                      cmd: `alias`,
                      anonymousId: e
                  };
                  this.socket.send(t),
                  ei.set(fo, !0)
              }
          }
          , {
              delay: 50
          }),
          Nt(this)
      }
      getWebAnonymousId() {
          return ei.getSession(this.anonymousIdKey)?.distinct_id
      }
  }
}
)), mo, ho = t(( () => {
  mo = class {
      static hasMultipleWorkspaces() {
          return this.options?.hasMultipleWorkspaces() ?? !1
      }
      static async unsetCurrentUser(e) {
          await this.options?.unsetUser(e)
      }
      static async logoutCurrentUserAccount(e, t) {
          await this.options?.logoutCurrentUserAccount(e, t)
      }
      static register(e) {
          this.options = e
      }
  }
}
)), go, _o, vo, yo, bo = t(( () => {
  go = e(m(), 1),
  _o = e(c(), 1),
  vo = e(i(), 1),
  yo = class e {
      static #e = this.sensitiveFields = `accessToken.refreshToken.token.deviceToken.authToken.code.password.webhookSecret.description.descriptionData.descriptionContent.content.contentData.contentState.body.bodyData.key.markdown.title.properties.previousProperties.templateData.html.text.asanaToken.clubhouseToken.githubToken.jiraToken.authorization.Authorization`.split(`.`);
      static sanitizeAndTrimData(t, n={}, r=0) {
          if (r > (n.maxDepth ?? 4))
              return `[Trimmed]`;
          if ((0,
          _o.default)(t)) {
              if (e.sanitizedWeakSet.has(t))
                  return t;
              let i = t.length
                , a = t.slice(0, 10).map(t => e.sanitizeAndTrimData(t, n, r + 1));
              return i > 10 && a.push(``),
              a
          }
          if ((0,
          vo.default)(t))
              return `[Buffer]`;
          if (t instanceof Date)
              return t;
          if (t instanceof Error)
              return {
                  message: t.message,
                  stack: t.stack
              };
          if ((0,
          go.default)(t)) {
              if (e.sanitizedWeakSet.has(t))
                  return t;
              let i = {
                  ...t
              };
              for (let a of Object.keys(i))
                  if ((0,
                  _o.default)(i[a])) {
                      if (e.sanitizedWeakSet.has(i[a]))
                          return t;
                      let o = i[a].length;
                      i[a] = i[a].slice(0, 10).map(t => e.sanitizeAndTrimData(t, n, r + 1)),
                      o > 10 && i[a].push(`...`)
                  } else
                      (0,
                      vo.default)(i[a]) ? i[a] = `[Buffer]` : (0,
                      go.default)(i[a]) ? i[a] = e.sanitizeAndTrimData(i[a], n, r + 1) : e.sensitiveFields.includes(a) || n.additionalSensitiveFields?.includes(a) ? i[a] = `[Filtered]` : typeof i[a] == `string` && i[a].length > 1e4 && (i[a] = i[a].substring(0, 1e4) + `...`);
              return i
          }
          return typeof t == `string` && t.length > 1e4 ? t.substring(0, 1e4) + `...` : t
      }
      static markAsSanitized(t) {
          return typeof t == `object` && t && e.sanitizedWeakSet.add(t),
          t
      }
      static #t = this.sanitizedWeakSet = new WeakSet
  }
}
));
function xo(e) {
  return typeof e == `object` && !!e && `type`in e && typeof e.type == `string` && `userError`in e && typeof e.userError == `boolean`
}
var So = t(( () => {}
)), Co, wo, To = t(( () => {
  Co = `abcdefghijkmnpqrstuvwxyz23456789`,
  wo = RegExp(`^[${Co}]+$`)
}
));
function yne(e) {
  let {allowedAuthServices: t, samlEnabled: n, servicesToForbid: r, servicesToAllow: i} = e
    , a = [Eo.email, Eo.google];
  n && a.push(Eo.saml);
  let o = t.length === 0 ? [...a] : t
    , s = [];
  for (let e of r || [])
      if (s = o.filter(t => t !== e),
      s.length === 0)
          throw Error(`At least one authentication service must be enabled`);
  for (let e of i || [])
      s = [...o.filter(t => t !== e), e];
  return s.length === a.length ? [] : s
}
var Eo, Do, Oo, ko, Ao, jo, Mo, No = t(( () => {
  To(),
  Eo = function(e) {
      return e.google = `google`,
      e.email = `email`,
      e.saml = `saml`,
      e.passkey = `passkey`,
      e.appUser = `appUser`,
      e
  }({}),
  Do = {
      google: `Google`,
      email: `Email & passkeys`,
      saml: `SAML`,
      passkey: `Passkey`,
      appUser: `App User`
  },
  Oo = 10,
  RegExp(`^[${Co}-]+$`, `i`),
  ko = e => `csrfToken_${e}`,
  Ao = {
      CU: `Cuba`,
      IR: `Iran`,
      KP: `North Korea`,
      RU: `Russia`
  },
  jo = `RESTRICTED_COUNTRY_BLOCKED`,
  Mo = e => !!e && Object.keys(Ao).includes(e)
}
)), Po, Fo, Io, Lo = t(( () => {
  Va(),
  Po = function(e) {
      return e.web = `web`,
      e.desktop = `desktop`,
      e.mobile = `mobile`,
      e
  }({}),
  Fo = class {
      constructor(e, t) {
          this.id = e,
          this.update = t,
          this.cmd = `collab`
      }
  }
  ,
  za.registerBinaryExtension(Fo, Ra.CollabCommand, [`id`, `update`]),
  Io = function(e) {
      return e[e.increment = 1] = `increment`,
      e[e.decrement = 2] = `decrement`,
      e[e.gauge = 3] = `gauge`,
      e[e.histogram = 4] = `histogram`,
      e[e.distribution = 5] = `distribution`,
      e[e.set = 6] = `set`,
      e
  }({})
}
)), Ro, bne = t(( () => {
  Ro = class {
      constructor(e, t) {
          this.maxInvocations = e,
          this.timeWindow = t,
          this.count = 0
      }
      consume(e=1) {
          let t = Date.now()
            , n = t - this.timeWindow;
          if (this.startTs === void 0 || this.startTs < n)
              this.startTs = t,
              this.count = 0;
          else if (this.count >= this.maxInvocations)
              return !1;
          return this.count += e,
          !0
      }
  }
}
)), zo, Bo, Vo, Ho = t(( () => {
  Lo(),
  Yr(),
  bne(),
  zo = 300,
  Bo = new Set([`network.error`]),
  Vo = class {
      static increment(e, t, n) {
          this.send({
              cmd: `mtr`,
              type: Io.increment,
              stat: e,
              tags: t
          }, n)
      }
      static decrement(e, t) {
          this.send({
              cmd: `mtr`,
              type: Io.decrement,
              stat: e
          }, t)
      }
      static gauge(e, t, n, r) {
          this.send({
              cmd: `mtr`,
              type: Io.gauge,
              stat: e,
              value: t,
              tags: n
          }, r)
      }
      static histogram(e, t, n, r) {
          this.send({
              cmd: `mtr`,
              type: Io.histogram,
              stat: e,
              value: t,
              tags: n
          }, r)
      }
      static distribution(e, t, n, r) {
          this.send({
              cmd: `mtr`,
              type: Io.distribution,
              stat: e,
              value: t,
              tags: n
          }, r)
      }
      static set(e, t, n, r) {
          this.send({
              cmd: `mtr`,
              type: Io.set,
              stat: e,
              value: t,
              tags: n
          }, r)
      }
      static reportSpans(e, t, n, r, i) {
          n.length !== 0 && this.send({
              cmd: `spn`,
              rootSpanName: e,
              resource: t,
              spans: n.orderBy([`startTime`, `endTime`], [`asc`, `desc`]),
              tags: r
          }, i)
      }
      static setSocket(e) {
          if (this.socket = e,
          e) {
              for (let t of this.bufferedCommands)
                  e.send(t);
              this.bufferedCommands = []
          }
      }
      static #e = this.metricRateLimiter = {
          "network.error": new Ro(10,30 * b.SECOND)
      };
      static #t = this.bufferedCommands = [];
      static #n = this.bufferThreshold = Math.round(zo * .1);
      static send(e, t) {
          if (this.socket) {
              if (e.cmd === `mtr` && this.metricRateLimiter[e.stat]?.consume() === !1)
                  return;
              this.socket.send(e, t)
          } else if (e.cmd === `mtr` && !t?.onlySendWhenOnline) {
              let t = e.stat;
              if (Bo.has(t) && this.bufferedCommands.find(e => e.cmd === `mtr` && e.stat === t))
                  return
          }
          this.bufferedCommands.push(e),
          this.bufferedCommands.length > zo + this.bufferThreshold && (this.bufferedCommands = this.bufferedCommands.slice(2 * this.bufferThreshold))
      }
  }
}
));
function Uo(e, t) {
  return `userPresentableMessage`in e && typeof e.userPresentableMessage == `string` ? e.userPresentableMessage : t || `An unknown error occurred.`
}
function Wo(e, t) {
  return e instanceof $o ? e.type === `authentication error` || e.metaData?.code === `AUTHENTICATION_ERROR` || e.metaData?.code === `RESTRICTED_COUNTRY_BLOCKED` || t?.logoutOnForbidden === !0 && e.metaData?.code === `FORBIDDEN` : !1
}
function Go(e) {
  return !!(e instanceof $o && e.type === `network error` || e instanceof Error && (e.message?.includes(`Failed to fetch`) || e.message?.includes(`Importing a module script failed`) || e.message?.includes(`due to network error`) || e.message?.includes(`error loading dynamically imported module`)))
}
function Ko(e) {
  return e instanceof $o && e.type === `aborted`
}
function qo(e) {
  return e instanceof $o
}
function xne(e) {
  return e instanceof $o && e.metaData?.code === `FORBIDDEN`
}
function Jo(e) {
  return e instanceof $o && e.metaData?.code === `RATELIMITED`
}
function Yo(e) {
  if (e instanceof $o)
      return e;
  if (e.response) {
      let t = Zo(e.response.headers);
      if (e.response.errors && e.response.errors.length) {
          let n = e.response.errors[0]
            , r = n.extensions;
          if (r) {
              let i = n.message;
              return (!i || !i.length) && (i = `An internal server error has occurred.`),
              new $o({
                  type: r.type,
                  message: i,
                  userError: r.userError,
                  userPresentableMessage: r.userPresentableMessage,
                  flags: r.flags,
                  metaData: {
                      ...r.meta,
                      code: r.code,
                      statusCode: e.response.status
                  },
                  fieldErrors: r.fieldErrors,
                  requestId: t,
                  skipSentry: r.code === jo
              })
          } else
              return new $o({
                  type: `unknown`,
                  message: n.message,
                  userError: !1,
                  requestId: t
              })
      } else if (e.response.error && xo(e.response.extensions)) {
          let n = e.response.extensions
            , r = typeof e.response.error == `string` ? e.response.error : `An internal server error has occurred.`;
          return new $o({
              type: n.type,
              message: r,
              userError: n.userError,
              userPresentableMessage: n.userPresentableMessage ?? (n.type === `payload too large` ? `Payload too large` : void 0),
              flags: n.flags,
              metaData: {
                  ...n.meta,
                  code: n.code,
                  statusCode: e.response.status
              },
              fieldErrors: n.fieldErrors,
              requestId: t,
              skipSentry: n.code === jo
          })
      }
  }
  return navigator.onLine && Vo.increment(`network.error`, {
      source: `graphql`
  }),
  new $o({
      type: `network error`,
      message: e.message,
      userError: !0,
      skipSentry: !0
  })
}
async function Xo(e, t) {
  if (e.ok)
      throw Error(`Unexpected success response.`);
  let n = Zo(e.headers)
    , r = e.status
    , i = Qo(e.headers)
    , a = await e.text().catch(e => (Vo.increment(`network.error`, {
      source: `rest_error_body`
  }, {
      onlySendWhenOnline: !0
  }),
  new $o({
      type: `network error`,
      message: `${t || `Network error: `}${e.message}`,
      userError: !0,
      requestId: n,
      metaData: {
          statusCode: r,
          edgeCacheStatus: i
      }
  })));
  if (a instanceof $o)
      return a;
  try {
      let e = vr(a), o, s;
      return e ? `errors`in e ? (o = e.errors[0].message || `An unknown error occurred.`,
      s = e.errors[0].extensions) : (o = e.error || `An unknown error occurred.`,
      s = e.extensions) : o = `An unknown error occurred.`,
      s ? new $o({
          type: s.type,
          message: `${t || ``}${o}`,
          userError: s.userError || !1,
          userPresentableMessage: s.userPresentableMessage,
          flags: s.flags,
          metaData: {
              ...s.meta,
              code: s.code,
              statusCode: r,
              edgeCacheStatus: i
          },
          fieldErrors: s.fieldErrors,
          requestId: n
      }) : new $o({
          type: `unknown`,
          message: o,
          userError: !1,
          requestId: n,
          metaData: {
              statusCode: r,
              edgeCacheStatus: i
          }
      })
  } catch {
      return new $o({
          type: `internal error`,
          message: `${t || `Internal error: `}Invalid response format.`,
          userError: !1,
          requestId: n,
          metaData: {
              statusCode: r,
              edgeCacheStatus: i
          }
      })
  }
}
function Zo(e) {
  return e.get(`x-request-id`) || e.get(`cf-ray`) || void 0
}
function Qo(e) {
  let t = e.get(`cf-cache-status`) || ``;
  return t ? /hit/i.test(t) ? `hit` : /miss/i.test(t) ? `miss` : /dynamic/i.test(t) ? `dynamic` : `unknown` : `none`
}
var $o, es = t(( () => {
  So(),
  No(),
  yr(),
  Ho(),
  $o = class e extends Error {
      constructor(t) {
          super(t.message),
          Object.setPrototypeOf(this, e.prototype),
          this.name = `ClientError`,
          this.type = t.type,
          this.userError = t.userError,
          this.userPresentableMessage = t.userPresentableMessage,
          this.metaData = t.metaData,
          this.flags = t.flags,
          this.fieldErrors = t.fieldErrors,
          this.requestId = t.requestId || void 0,
          this.skipSentry = !!t.skipSentry
      }
  }
}
));
function Sne() {
  if (!ts && (ts = typeof crypto < `u` && crypto.getRandomValues && crypto.getRandomValues.bind(crypto),
  !ts))
      throw Error(`crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported`);
  return ts(ns)
}
var ts, ns, Cne = t(( () => {
  ns = new Uint8Array(16)
}
));
function wne(e, t=0) {
  return rs[e[t + 0]] + rs[e[t + 1]] + rs[e[t + 2]] + rs[e[t + 3]] + `-` + rs[e[t + 4]] + rs[e[t + 5]] + `-` + rs[e[t + 6]] + rs[e[t + 7]] + `-` + rs[e[t + 8]] + rs[e[t + 9]] + `-` + rs[e[t + 10]] + rs[e[t + 11]] + rs[e[t + 12]] + rs[e[t + 13]] + rs[e[t + 14]] + rs[e[t + 15]]
}
var rs, Tne = t(( () => {
  rs = [];
  for (let e = 0; e < 256; ++e)
      rs.push((e + 256).toString(16).slice(1))
}
)), is, as, Ene = t(( () => {
  is = typeof crypto < `u` && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  as = {
      randomUUID: is
  }
}
));
function Dne(e, t, n) {
  if (as.randomUUID && !t && !e)
      return as.randomUUID();
  e ||= {};
  let r = e.random || (e.rng || Sne)();
  if (r[6] = r[6] & 15 | 64,
  r[8] = r[8] & 63 | 128,
  t) {
      n ||= 0;
      for (let e = 0; e < 16; ++e)
          t[n + e] = r[e];
      return t
  }
  return wne(r)
}
var os, One = t(( () => {
  Ene(),
  Cne(),
  Tne(),
  os = Dne
}
)), ss = t(( () => {
  One()
}
)), cs, ls, us, ds, fs, kne = t(( () => {
  nt(),
  ss(),
  Yr(),
  ai(),
  ni(),
  cs = 10 * b.SECOND,
  ls = 2 * b.MINUTE,
  us = 5 * b.MINUTE,
  ds = 50,
  fs = class {
      constructor(e) {
          this.started = !1,
          this.handleUpdateSession = () => {
              this.addBreadcrumb(`Crash monitor is updating`)
          }
          ,
          this.handleCheckForCrashes = () => {
              let e = Date.now()
                , t = ei.getKeys();
              for (let n of t)
                  if (n !== this.sessionKey && n.indexOf(`crashMonitor_`) === 0) {
                      let t = ei.get(n);
                      t && (t.lastUpdate ? e > t.lastUpdate + us && this.delayedCrashReport(n) : ei.remove(n))
                  }
          }
          ,
          this.crashDetectedCallback = e,
          this.sessionKey = `crashMonitor_` + os(),
          this.startTime = Date.now(),
          this.sessionData = {
              lastUpdate: Date.now(),
              breadCrumbs: [],
              version: 2
          },
          window.addEventListener(`beforeunload`, e => {
              e.defaultPrevented || this.stopCrashDetection()
          }
          ),
          self.document.addEventListener(`freeze`, () => {
              this.stopCrashDetection()
          }
          ),
          self.document.addEventListener(`resume`, () => {
              this.started && !self.document.hidden && this.startCrashDetection()
          }
          ),
          self.document.addEventListener(`visibilitychange`, () => {
              this.started && !self.document.hidden ? this.startCrashDetection() : this.stopCrashDetection()
          }
          )
      }
      startCrashDetection() {
          this.checkInterval || (this.started = !0,
          this.checkInterval = window.setInterval(this.handleCheckForCrashes, ls),
          this.updateInterval = window.setInterval(this.handleUpdateSession, cs),
          this.handleUpdateSession(),
          this.handleCheckForCrashes())
      }
      addBreadcrumb(e) {
          this.checkInterval && (this.sessionData.breadCrumbs.push(Ge(new Date, `hh:mm:ss`) + ` ` + e),
          this.sessionData.breadCrumbs.length > ds && this.sessionData.breadCrumbs.shift(),
          this.sessionData.lastUpdate = Date.now(),
          ei.set(this.sessionKey, this.sessionData))
      }
      stopCrashDetection() {
          ei.remove(this.sessionKey),
          window.clearInterval(this.checkInterval),
          window.clearInterval(this.updateInterval),
          this.checkInterval = void 0,
          this.updateInterval = void 0
      }
      async delayedCrashReport(e) {
          await ri(12 * b.SECOND + 4 * Math.random() * b.SECOND);
          let t = ei.get(e);
          if (t)
              try {
                  Date.now() > t.lastUpdate + us && (ei.remove(e),
                  this.crashDetectedCallback(t))
              } catch {
                  ei.remove(e)
              }
      }
  }
}
));
function ps(e) {
  for (let[t,n] of Object.entries(Cs))
      new RegExp(t).test(e) && (e = e.replace(new RegExp(t), n));
  return e.replace(/https:\/\/[^ ]+/, ``).trim()
}
var ms, hs, gs, _s, vs, ys, bs, xs, w, Ss, Cs, ws = t(( () => {
  if (ms = e(ht(), 1),
  Xt(),
  tn(),
  bo(),
  _r(),
  So(),
  Yr(),
  Xn(),
  pi(),
  es(),
  kne(),
  hs = 200,
  gs = 5,
  _s = Jn.IS_PRODUCTION_ENV,
  vs = `loggerSavedBreadcrumbs`,
  ys = !1,
  bs = !1,
  Jn.SENTRY_DSN)
      try {
          let e = window.localStorage.getItem(`profilingEnabled`);
          bs = e === `true` || e === null && !_s
      } catch {
          bs = !1
      }
  xs = function(e) {
      return e[e.none = 0] = `none`,
      e[e.regular = 1] = `regular`,
      e[e.verbose = 2] = `verbose`,
      e
  }({}),
  Nee({
      dsn: Jn.SENTRY_DSN,
      tunnel: Jn.SENTRY_TUNNEL,
      release: gr.versionString(Jn.BUILD_REVISION, Jn.PREVIEW_PR_NUMBER),
      environment: _s ? `production` : `development`,
      ignoreErrors: [/.*ResizeObserver loop.*/, `TypeError: Failed to fetch`, `TypeError: NetworkError when attempting to fetch resource.`, `ReferenceError: Can't find variable: _chromeNamespace`, `error loading dynamically imported module`, `Importing a module script failed.`],
      attachStacktrace: !0,
      tracesSampler: e => {
          if (e.parentSampled !== void 0)
              return e.parentSampled;
          let t = e.name.substring(e.name.indexOf(`/`, 1));
          try {
              let e = di.getValue(di.sentryTracingRate, {}).tracingRates?.find(e => e.nameRegex === void 0 ? !0 : new RegExp(e.nameRegex,`i`).test(t));
              if (typeof e?.rate == `number` && e.rate <= 1 && e.rate >= 0)
                  return e.rate
          } catch {}
          return _s ? .001 : 1
      }
      ,
      profilesSampleRate: di.getValue(di.sentryTracingRate, {}).profilingEnabled === !0 ? 1 : 0,
      normalizeDepth: 6,
      transport: Aee(Oee),
      allowUrls: [_s ? `linear.app` : `local.linear.dev`],
      integrations: [Pee(), Mee({
          useEffect: ms.useEffect,
          useLocation: Zt,
          useNavigationType: xee,
          createRoutesFromChildren: wee,
          matchRoutes: Jt
      }), bs ? Dee() : void 0].concrete(),
      beforeSend: (e, t) => {
          if (delete e.request?.cookies,
          e.tags = e.tags || {},
          e.tags[`browser.online`] = navigator.onLine,
          e.tags[`document.visibilityState`] = self.document.visibilityState,
          e.tags[`sync.deltaSyncReceived`] = w.deltaSyncReceived,
          e.request?.url) {
              let t = new URL(e.request.url);
              t.search && t.searchParams.forEach( (e, n) => {
                  t.searchParams.set(n, `redacted`)
              }
              )
          }
          let n = e.fingerprint || []
            , {originalException: r} = t;
          if (r instanceof Error) {
              if (qo(r)) {
                  if (r.skipSentry)
                      return null;
                  if (r.requestId && (e.contexts ||= {},
                  e.contexts.metaData = {
                      ...e.contexts.metaData,
                      requestId: r.requestId
                  }),
                  r.userError)
                      e.level = `info`;
                  else if (r.type === `network error` || r.type === `downtime`) {
                      if (ys)
                          return null;
                      e.level = `info`,
                      ys = !0
                  }
                  n.push(`Client error (${r.type})`)
              }
              typeof e.extra?.description == `string` && n.push(e.extra.description),
              r instanceof Error && typeof r.message == `string` && n.push(ps(r.message))
          } else
              e.message && typeof e.message == `string` && n.push(ps(e.message));
          n.length > 0 && (e.fingerprint = n);
          let i = e.message || e.extra?.description + ``;
          if (i) {
              let e = (Ss.get(i) || 0) + 1;
              if (Ss.set(i, e),
              e > gs)
                  return null
          }
          if ((Ss.get(`*`) ?? 0) > hs)
              return null;
          Ss.set(`*`, (Ss.get(`*`) ?? 0) + 1);
          let a = e.exception?.values?.[0]
            , o = e.extra?.description;
          return a && o && (a.type && (a.value = a.value ? `${a.type}: ${a.value}` : a.type),
          a.type = typeof o == `string` ? o : void 0),
          e
      }
  }),
  w = class e {
      static #e = this.loggingLevel = xs.none;
      static #t = this.crashMonitor = Jn.ENABLE_CRASH_REPORTING ? new fs(e.reportCrash) : void 0;
      static setUser(e) {
          e && e.organization ? ($t({
              id: e.id,
              name: e.name,
              email: e.email,
              isOwner: e.isOwner,
              isAdmin: e.isAdmin,
              isGuest: e.guest,
              organizationId: e.organization.id,
              organizationName: e.organization.name,
              linearClientId: this.clientId
          }),
          jee(`organization`, e.organization.name)) : $t(null),
          this.crashMonitor?.startCrashDetection()
      }
      static info(t, n) {
          this.leaveBreadcrumb(`info`, t, n),
          e.loggingLevel !== xs.none && (n ? console.log(t, n) : console.log(t))
      }
      static remote(t, n) {
          e.debug(`[REM] ` + t, n);
          let r = {
              cmd: `log`,
              message: t,
              metaData: n
          };
          e.socket?.send(r)
      }
      static debug(t, n) {
          this.leaveBreadcrumb(`debug`, t, n),
          e.loggingLevel !== xs.none && (n ? console.debug(t, n) : console.debug(t))
      }
      static network(t, n) {
          this.leaveBreadcrumb(`info`, t, n),
          e.loggingLevel !== xs.none && (n ? console.debug(`[NET] ${t}`, n) : console.debug(`[NET] ${t}`))
      }
      static flare() {
          return en(`User sent debugging flare`, {
              level: `error`
          })
      }
      static verbose(t) {
          if (e.loggingLevel === xs.verbose) {
              let e = t();
              typeof e == `string` ? console.debug(`[VER] ${e}`) : console.debug(`[VER] ${e.message}`, e.metaData)
          }
      }
      static error(e, t, n) {
          t ? en(t, {
              extra: {
                  description: e
              },
              contexts: n ? {
                  metaData: this.redactData(n)
              } : void 0,
              level: `error`
          }) : en(e, {
              contexts: n ? {
                  metaData: this.redactData(n)
              } : void 0,
              level: `error`
          }),
          console.error(...[e, t, n].concrete())
      }
      static warning(t, n) {
          this.leaveBreadcrumb(`warning`, t, n),
          en(t, {
              level: `info`,
              contexts: n ? {
                  metaData: this.redactData(n)
              } : void 0
          }),
          e.loggingLevel !== xs.none && (n ? console.warn(t, n) : console.warn(t))
      }
      static withEnabledLogging(t) {
          let n = e.loggingLevel;
          e.loggingLevel = xs.verbose;
          try {
              t()
          } finally {
              e.loggingLevel = n
          }
      }
      static persistBreadcrumbs() {
          let e = self.sessionStorage;
          if (!e)
              return;
          let t = kee().getScopeData().breadcrumbs ?? [];
          if (t && t.length > 0)
              try {
                  e.setItem(vs, JSON.stringify({
                      timestamp: Date.now(),
                      breadcrumbs: t.slice(-100),
                      version: 1
                  }))
              } catch {}
      }
      static restoreBreadcrumbs() {
          let e = self.sessionStorage;
          if (!e)
              return;
          let t;
          try {
              t = e.getItem(vs)
          } catch {
              return
          }
          if (typeof t != `string`)
              return;
          try {
              e.removeItem(vs)
          } catch {}
          let n;
          try {
              n = JSON.parse(t)
          } catch {
              return
          }
          if (n && n.version === 1 && n.timestamp > Date.now() - b.MINUTE)
              for (let e of n.breadcrumbs)
                  Qt(e)
      }
      static get clientId() {
          if (!this._clientId) {
              try {
                  this._clientId = window.localStorage.getItem(`clientId`) || ``
              } catch {}
              if (!this._clientId) {
                  this._clientId = Math.random().toString(36).substring(2, 15);
                  try {
                      window.localStorage.setItem(`clientId`, this._clientId)
                  } catch {}
              }
          }
          return this._clientId
      }
      static get profilingEnabled() {
          return bs
      }
      static toggleProfiling() {
          bs = !bs;
          try {
              window.localStorage.setItem(`profilingEnabled`, bs + ``)
          } catch {}
      }
      static get deltaSyncReceived() {
          return this._deltaSyncReceived
      }
      static setDeltaSyncReceived() {
          this._deltaSyncReceived = !0
      }
      static initialize(e) {
          this.socket = e
      }
      static #n = this._deltaSyncReceived = !1;
      static leaveBreadcrumb(e, t, n) {
          let r;
          if (n)
              try {
                  r = this.redactData(n)
              } catch {
                  r = {
                      redactionError: !0
                  }
              }
          try {
              Qt({
                  level: e,
                  message: t,
                  ...r && {
                      data: r
                  }
              }),
              this.crashMonitor?.addBreadcrumb(t)
          } catch {}
      }
      static redactData(e) {
          return yo.sanitizeAndTrimData(e, {
              additionalSensitiveFields: [`name`, `displayName`, `email`, `state`, `delta`]
          })
      }
      static reportCrash(t) {
          t.version && e.error(`Crash monitor detected crash`, void 0, {
              breadcrumbs: t.breadCrumbs
          })
      }
  }
  ,
  w.restoreBreadcrumbs(),
  Ss = new Map,
  Cs = {
      "No cell found around position \\d+": `No cell found around position <N>`,
      "Please include the request ID req_[a-zA-Z0-9]+ in your message.": `Please include the request ID req_<N> in your message.`
  }
}
)), Ts, Es = t(( () => {
  ws(),
  Ts = class {
      get hasAutoFired() {
          return this.hasAutoFireData
      }
      get observerCount() {
          return this.observers.size + this.onceObservers.size
      }
      constructor(e) {
          this.observers = new Set,
          this.onceObservers = new Set,
          this.maxObservers = e?.maxObservers ?? 40
      }
      subscribe(e) {
          return this.isSubscribed(e) || (this.observers.add(e),
          this.maxObservers !== 0 && this.observers.size > this.maxObservers && w.warning(`Signal is oversubscribed`, {
              subscriberCount: this.observers.size
          })),
          this.hasAutoFireData && e(this.autoFireData),
          () => {
              this.unsubscribe(e)
          }
      }
      subscribeOnce(e) {
          this.hasAutoFireData ? e(this.autoFireData) : this.onceObservers.add(e)
      }
      isSubscribed(e) {
          return this.observers.has(e) || this.onceObservers.has(e)
      }
      unsubscribe(e) {
          this.observers.delete(e),
          this.onceObservers.delete(e)
      }
      fire(e) {
          let t = [];
          for (let n of this.observers)
              t.push(n(e));
          for (let n of this.onceObservers)
              t.push(n(e));
          return this.onceObservers.clear(),
          t
      }
      autoFire(e) {
          return this.autoFireData = e,
          this.hasAutoFireData = !0,
          this.fire(e)
      }
  }
}
)), Ds, Os = t(( () => {
  Es(),
  Ds = class e {
      static get onVisible() {
          return e.implementation ? e.implementation.onVisible : e.noOpSignal
      }
      static get onHide() {
          return e.implementation ? e.implementation.onHide : e.noOpSignal
      }
      static get visible() {
          return e.implementation ? e.implementation.visible : !0
      }
      static get hasBeenHiddenDuringSession() {
          return e.implementation ? e.implementation.hasBeenHiddenDuringSession : !1
      }
      static waitUntilVisible() {
          return e.implementation ? e.implementation.waitUntilVisible() : Promise.resolve()
      }
      static register(t) {
          e.implementation = t
      }
      static #e = this.noOpSignal = new Ts
  }
}
)), ks, As = t(( () => {
  ks = class e {
      static refreshWhenReady(t, n, r) {
          return e.implementation ? e.implementation.refreshWhenReady(t, n, r) : !1
      }
      static forceRefresh(t, n) {
          e.implementation?.forceRefresh(t, n)
      }
      static register(t) {
          e.implementation = t
      }
  }
}
)), js = n(( (e, t) => {
  (function(n, r, i) {
      typeof e == `object` ? (t.exports = i(),
      t.exports.default = i()) : typeof define == `function` && define.amd ? define(i) : r[n] = i()
  }
  )(`slugify`, e, function() {
      var e = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","":"cent","":"pound","":"currency","":"yen","":"(c)","":"a","":"(r)","":"o","":"A","":"A","":"A","":"A","":"A","":"A","":"AE","":"C","":"E","":"E","":"E","":"E","":"I","":"I","":"I","":"I","":"D","":"N","":"O","":"O","":"O","":"O","":"O","":"O","":"U","":"U","":"U","":"U","":"Y","":"TH","":"ss","":"a","":"a","":"a","":"a","":"a","":"a","":"ae","":"c","":"e","":"e","":"e","":"e","":"i","":"i","":"i","":"i","":"d","":"n","":"o","":"o","":"o","":"o","":"o","":"o","":"u","":"u","":"u","":"u","":"y","":"th","":"y","":"A","":"a","":"A","":"a","":"A","":"a","":"C","":"c","":"C","":"c","":"D","":"d","":"DJ","":"dj","":"E","":"e","":"E","":"e","":"e","":"e","":"E","":"e","":"G","":"g","":"G","":"g","":"I","":"i","":"i","":"i","":"I","":"i","":"I","":"i","":"k","":"k","":"L","":"l","":"L","":"l","":"L","":"l","":"N","":"n","":"N","":"n","":"N","":"n","":"O","":"o","":"O","":"o","":"OE","":"oe","":"R","":"r","":"R","":"r","":"S","":"s","":"S","":"s","":"S","":"s","":"T","":"t","":"T","":"t","":"U","":"u","":"u","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"W","":"w","":"Y","":"y","":"Y","":"Z","":"z","":"Z","":"z","":"Z","":"z","":"E","":"f","":"O","":"o","":"U","":"u","":"LJ","":"lj","":"NJ","":"nj","":"S","":"s","":"T","":"t","":"e","":"o","":"A","":"E","":"H","":"I","":"O","":"Y","":"W","":"i","":"A","":"B","":"G","":"D","":"E","":"Z","":"H","":"8","":"I","":"K","":"L","":"M","":"N","":"3","":"O","":"P","":"R","":"S","":"T","":"Y","":"F","":"X","":"PS","":"W","":"I","":"Y","":"a","":"e","":"h","":"i","":"y","":"a","":"b","":"g","":"d","":"e","":"z","":"h","":"8","":"i","":"k","":"l","":"m","":"n","":"3","":"o","":"p","":"r","":"s","":"s","":"t","":"y","":"f","":"x","":"ps","":"w","":"i","":"y","":"o","":"y","":"w","":"Yo","":"DJ","":"Ye","":"I","":"Yi","":"J","":"LJ","":"NJ","":"C","":"DZ","":"A","":"B","":"V","":"G","":"D","":"E","":"Zh","":"Z","":"I","":"J","":"K","":"L","":"M","":"N","":"O","":"P","":"R","":"S","":"T","":"U","":"F","":"H","":"C","":"Ch","":"Sh","":"Sh","":"U","":"Y","":"","":"E","":"Yu","":"Ya","":"a","":"b","":"v","":"g","":"d","":"e","":"zh","":"z","":"i","":"j","":"k","":"l","":"m","":"n","":"o","":"p","":"r","":"s","":"t","":"u","":"f","":"h","":"c","":"ch","":"sh","":"sh","":"u","":"y","":"","":"e","":"yu","":"ya","":"yo","":"dj","":"ye","":"i","":"yi","":"j","":"lj","":"nj","":"c","":"u","":"dz","":"G","":"g","":"GH","":"gh","":"KH","":"kh","":"NG","":"ng","":"UE","":"ue","":"U","":"u","":"H","":"h","":"AE","":"ae","":"OE","":"oe","":"A","":"B","":"G","":"D","":"E","":"Z","":"E'","":"Y'","":"T'","":"JH","":"I","":"L","":"X","":"C'","":"K","":"H","":"D'","":"GH","":"TW","":"M","":"Y","":"N","":"SH","":"CH","":"P","":"J","":"R'","":"S","":"V","":"T","":"R","":"C","":"P'","":"Q'","":"O''","":"F","":"EV","":"a","":"aa","":"a","":"u","":"i","":"e","":"a","":"b","":"h","":"t","":"th","":"j","":"h","":"kh","":"d","":"th","":"r","":"z","":"s","":"sh","":"s","":"dh","":"t","":"z","":"a","":"gh","":"f","":"q","":"k","":"l","":"m","":"n","":"h","":"w","":"a","":"y","":"an","":"on","":"en","":"a","":"u","":"e","":"","":"0","":"1","":"2","":"3","":"4","":"5","":"6","":"7","":"8","":"9","":"p","":"ch","":"zh","":"k","":"g","":"y","":"0","":"1","":"2","":"3","":"4","":"5","":"6","":"7","":"8","":"9","":"baht","":"a","":"b","":"g","":"d","":"e","":"v","":"z","":"t","":"i","":"k","":"l","":"m","":"n","":"o","":"p","":"zh","":"r","":"s","":"t","":"u","":"f","":"k","":"gh","":"q","":"sh","":"ch","":"ts","":"dz","":"ts","":"ch","":"kh","":"j","":"h","":"S","":"s","":"W","":"w","":"W","":"w","":"W","":"w","":"SS","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"I","":"i","":"I","":"i","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"-","":"'","":"'","":"\\"","":"\\"","":"\\"","":"+","":"*","":"...","":"ecu","":"cruzeiro","":"french franc","":"lira","":"mill","":"naira","":"peseta","":"rupee","":"won","":"new shequel","":"dong","":"euro","":"kip","":"tugrik","":"drachma","":"penny","":"peso","":"guarani","":"austral","":"hryvnia","":"cedi","":"kazakhstani tenge","":"indian rupee","":"turkish lira","":"russian ruble","":"bitcoin","":"sm","":"tm","":"d","":"delta","":"sum","":"infinity","":"love","":"yuan","":"yen","":"rial","":"laa","":"laa","":"lai","":"la"}`)
        , t = JSON.parse(`{"bg":{"":"Y","":"Ts","":"Sht","":"A","":"Y","":"y","":"ts","":"sht","":"a","":"y"},"de":{"":"AE","":"ae","":"OE","":"oe","":"UE","":"ue","":"ss","%":"prozent","&":"und","|":"oder","":"summe","":"unendlich","":"liebe"},"es":{"%":"por ciento","&":"y","<":"menor que",">":"mayor que","|":"o","":"centavos","":"libras","":"moneda","":"francos","":"suma","":"infinito","":"amor"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","":"centime","":"livre","":"devise","":"franc","":"somme","":"infini","":"amour"},"pt":{"%":"porcento","&":"e","<":"menor",">":"maior","|":"ou","":"centavo","":"soma","":"libra","":"infinito","":"amor"},"uk":{"":"Y","":"y","":"Y","":"y","":"Ts","":"ts","":"Kh","":"kh","":"Shch","":"shch","":"H","":"h"},"vi":{"":"D","":"d"},"da":{"":"OE","":"oe","":"AA","":"aa","%":"procent","&":"og","|":"eller","$":"dollar","<":"mindre end",">":"strre end"},"nb":{"&":"og","":"AA","":"AE","":"OE","":"aa","":"ae","":"oe"},"it":{"&":"e"},"nl":{"&":"en"},"sv":{"&":"och","":"AA","":"AE","":"OE","":"aa","":"ae","":"oe"}}`);
      function n(n, r) {
          if (typeof n != `string`)
              throw Error(`slugify: string argument expected`);
          r = typeof r == `string` ? {
              replacement: r
          } : r || {};
          var i = t[r.locale] || {}
            , a = r.replacement === void 0 ? `-` : r.replacement
            , o = r.trim === void 0 ? !0 : r.trim
            , s = n.normalize().split(``).reduce(function(t, n) {
              var o = i[n];
              return o === void 0 && (o = e[n]),
              o === void 0 && (o = n),
              o === a && (o = ` `),
              t + o.replace(r.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, ``)
          }, ``);
          return r.strict && (s = s.replace(/[^A-Za-z0-9\s]/g, ``)),
          o && (s = s.trim()),
          s = s.replace(/\s+/g, a),
          r.lower && (s = s.toLowerCase()),
          s
      }
      return n.extend = function(t) {
          Object.assign(e, t)
      }
      ,
      n
  })
}
));
function Ms() {
  let e = String.raw
    , t = e`\p{Emoji}(?:\p{EMod}|[\u{E0020}-\u{E007E}]+\u{E007F}|\uFE0F?\u20E3?)`;
  return new RegExp(e`\p{RI}{2}|(?![#*\d](?!\uFE0F?\u20E3))${t}(?:\u200D${t})*`,`gu`)
}
var Ns = t(( () => {}
));
function Ane(e, t=` `) {
  if (!e)
      return ``;
  let {_firstAssociations: n, _nonFirstAssociations: r} = jne()
    , i = e.normalize()
    , a = ``
    , o = !1;
  for (let e = 0; e < i.length; e++) {
      let s = i[e] === i[e].toUpperCase()
        , c = i[e].toLowerCase();
      if (c === ` `) {
          a += t,
          o = !0;
          continue
      }
      let l;
      e === 0 || o ? (l = n[c],
      o = !1) : l = r[c],
      l === void 0 ? a += s ? c.toUpperCase() : c : s ? l.length > 1 ? a += l[0].toUpperCase() + l.slice(1) : a += l.toUpperCase() : a += l
  }
  return a
}
function jne() {
  let e = {
      : `a`,
      : `b`,
      : `v`,
      : `d`,
      : `z`,
      : `e`,
      : `y`,
      : `k`,
      : `l`,
      : `m`,
      : `n`,
      : `o`,
      : `p`,
      : `r`,
      : `s`,
      : `t`,
      : `u`,
      : `c`,
      : `f`,
      : ``
  };
  Object.assign(e, {
      : `g`,
      : `i`,
      : ``,
      : `i`,
      : `e`
  }),
  Object.assign(e, {
      : `g`,
      : `h`,
      : `i`,
      "'": ``,
      "": ``,
      : ``
  });
  let t = {
      : `ye`,
      : `yi`
  }
    , n = {
      : `yo`,
      : `zh`,
      : `kh`,
      : `ch`,
      : `sh`,
      : `shch`,
      : `yu`,
      : `ya`
  }
    , r = Object.assign({}, n, t)
    , i = Object.assign(e, r)
    , a = Object.assign({}, e, {
      : `i`,
      : `i`
  })
    , o = Object.assign(n, {});
  return {
      _firstAssociations: i,
      _nonFirstAssociations: Object.assign(a, o)
  }
}
var Mne = t(( () => {}
));
function Nne(e) {
  return /[\u0400-\u04FF]/u.test(e)
}
var Ps, Fs, Is = t(( () => {
  Ps = e(js(), 1),
  Ns(),
  Mne(),
  Fs = class e {
      static #e = this.maxGitBranchNameLength = 60;
      static #t = this.defaultFormat = `{username}/{issueIdentifier}-{issueTitle}`;
      static #n = this.validFormat = /^[^\/]?([a-z0-9\-\/]|\{username\}|\{issueIdentifier\}|\{issueTitle\})+$/;
      static #r = this.validTemplateVariables = /(\{issueIdentifier\}|\{issueTitle\}){1,}/;
      static branchName(t, n) {
          let r = /[=#%*+~\{\}\`\^\|.,;()\[\]\?\&\\$'"<>!:@\x00-\x1f\x7f\/]/g
            , i = (0,
          Ps.default)(n.username, {
              remove: r
          }).toLowerCase()
            , a = n.issueIdentifier.toLowerCase()
            , o = n.issueTitle.replace(r, ``).replace(Ms(), ``).trim().replace(/\s+(-||)\s+/g, ` `).replace(/\s+/g, `-`).replace(/\\/g, `-`).toLowerCase().normalize(`NFD`).replace(/[]/g, `ss`).replace(/[]/g, `ae`).replace(/[]/g, `oe`).replace(/[]/g, `aa`).replace(/[]/g, `ae`).replace(/[]/g, `oe`).replace(/[]/g, `oe`).replace(/[]/g, `l`).replace(/[]/g, `d`).replace(/[]/g, `h`).replace(/[]/g, `i`).replace(/[]/g, `ij`).replace(/[]/g, `l`).replace(/[]/g, `n`).replace(/[]/g, `n`).replace(/[]/g, `t`).replace(/[]/g, `s`).replace(/[\u0300-\u036f]/g, ``).replace(/[\u2000-\u2BFF]/g, ``).replace(/[\u00A1-\u00BF]/g, ``);
          Nne(o) && (o = Ane(o));
          let s = o.split(/-+/)
            , c = s.shift() || ``;
          for (; s.length && c.length + s[0].length < e.maxGitBranchNameLength; )
              c += `-` + s.shift();
          return c = c.slice(0, e.maxGitBranchNameLength),
          t.replace(/\{username\}/g, i).replace(/\{issueIdentifier\}/g, a).replace(/\{issueTitle\}/g, c).replace(/-+$/, ``).replace(/^[\-_]+/g, ``)
      }
  }
}
)), Ls, Rs, zs, T, Bs, Vs, Hs, Us, Ws, Gs, Ks, qs, Js, Ys, Xs = t(( () => {
  zn(),
  Ls = 40,
  Rs = `lin_integration_`,
  zs = `(?:${Rs})?[a-zA-Z0-9]{40}`,
  `${zs}`,
  T = function(e) {
      return e.airbyte = `airbyte`,
      e.discord = `discord`,
      e.figma = `figma`,
      e.figmaPlugin = `figmaPlugin`,
      e.front = `front`,
      e.github = `github`,
      e.gong = `gong`,
      e.githubEnterpriseServer = `githubEnterpriseServer`,
      e.githubCommit = `githubCommit`,
      e.githubImport = `githubImport`,
      e.githubPersonal = `githubPersonal`,
      e.githubCodeAccessPersonal = `githubCodeAccessPersonal`,
      e.gitlab = `gitlab`,
      e.googleCalendarPersonal = `googleCalendarPersonal`,
      e.googleSheets = `googleSheets`,
      e.intercom = `intercom`,
      e.jira = `jira`,
      e.jiraPersonal = `jiraPersonal`,
      e.launchDarkly = `launchDarkly`,
      e.launchDarklyPersonal = `launchDarklyPersonal`,
      e.loom = `loom`,
      e.notion = `notion`,
      e.opsgenie = `opsgenie`,
      e.pagerDuty = `pagerDuty`,
      e.salesforce = `salesforce`,
      e.slack = `slack`,
      e.slackAsks = `slackAsks`,
      e.slackCustomViewNotifications = `slackCustomViewNotifications`,
      e.slackOrgProjectUpdatesPost = `slackOrgProjectUpdatesPost`,
      e.slackOrgInitiativeUpdatesPost = `slackOrgInitiativeUpdatesPost`,
      e.slackPersonal = `slackPersonal`,
      e.slackPost = `slackPost`,
      e.slackProjectPost = `slackProjectPost`,
      e.slackProjectUpdatesPost = `slackProjectUpdatesPost`,
      e.slackInitiativePost = `slackInitiativePost`,
      e.sentry = `sentry`,
      e.zendesk = `zendesk`,
      e.email = `email`,
      e.mcpServerPersonal = `mcpServerPersonal`,
      e.mcpServer = `mcpServer`,
      e
  }({}),
  Bs = function(e) {
      return e.zapier = `zapier`,
      e
  }({}),
  T.discord,
  T.figma,
  T.gong,
  T.gitlab,
  T.googleCalendarPersonal,
  T.googleSheets,
  T.githubCommit,
  T.githubPersonal,
  T.githubCodeAccessPersonal,
  T.intercom,
  T.launchDarkly,
  T.launchDarklyPersonal,
  T.notion,
  T.opsgenie,
  T.pagerDuty,
  T.sentry,
  T.slackPersonal,
  T.slackPost,
  T.slackProjectPost,
  T.slackProjectUpdatesPost,
  T.slackOrgProjectUpdatesPost,
  T.slackOrgInitiativeUpdatesPost,
  T.slackInitiativePost,
  T.slackCustomViewNotifications,
  T.zendesk,
  T.front,
  T.loom,
  T.jira,
  T.jiraPersonal,
  T.airbyte,
  T.mcpServerPersonal,
  T.mcpServer,
  Vs = [T.slack, T.slackAsks, T.zendesk, T.salesforce, T.github, T.githubEnterpriseServer, T.githubImport],
  T.slackPersonal,
  T.googleCalendarPersonal,
  T.githubPersonal,
  T.githubCodeAccessPersonal,
  T.jiraPersonal,
  T.launchDarklyPersonal,
  T.mcpServerPersonal,
  T.jira,
  T.pagerDuty,
  T.opsgenie,
  Hs = e => e === T.pagerDuty || e === T.opsgenie,
  T.github,
  T.githubEnterpriseServer,
  T.githubCommit,
  T.gitlab,
  T.slack,
  T.slackOrgProjectUpdatesPost,
  T.slackOrgInitiativeUpdatesPost,
  T.slackInitiativePost,
  T.slackCustomViewNotifications,
  T.slackPersonal,
  T.slackPost,
  T.slackProjectPost,
  T.slackProjectUpdatesPost,
  T.githubPersonal,
  T.githubCodeAccessPersonal,
  T.slackPersonal,
  T.jiraPersonal,
  Us = function(e) {
      return e.app = `APP`,
      e.codeAccessApp = `CODE_ACCESS_APP`,
      e.importer = `IMPORTER`,
      e
  }({}),
  Ws = function(e) {
      return e[e.Linear = 0] = `Linear`,
      e[e.Asks = 1] = `Asks`,
      e
  }({}),
  Gs = function(e) {
      return e.LinearOnly = `LinearOnly`,
      e.SlackMembers = `SlackMembers`,
      e.SlackMembersAndGuests = `SlackMembersAndGuests`,
      e
  }({}),
  Ks = [`app.intercom.com`, `app.eu.intercom.com`, `app.au.intercom.com`],
  qs = [T.figmaPlugin, T.front, T.github, T.intercom, T.jira, T.salesforce, T.slack, T.slackAsks, T.sentry, T.zendesk],
  T.intercom,
  T.zendesk,
  T.salesforce,
  T.intercom,
  T.salesforce,
  T.front,
  T.zendesk,
  Js = [T.front, T.intercom, T.salesforce, T.zendesk],
  (function(e) {
      function t(e) {
          switch (e) {
          case T.airbyte:
              return `Airbyte`;
          case T.discord:
              return `Discord`;
          case T.figma:
          case T.figmaPlugin:
              return `Figma`;
          case T.front:
              return `Front`;
          case T.github:
          case T.githubCommit:
          case T.githubImport:
          case T.githubPersonal:
          case T.githubCodeAccessPersonal:
              return `GitHub`;
          case T.githubEnterpriseServer:
              return `GitHub Enterprise Server`;
          case T.gong:
              return `Gong`;
          case T.gitlab:
              return `GitLab`;
          case T.googleCalendarPersonal:
              return `Google Calendar`;
          case T.googleSheets:
              return `Google Sheets`;
          case T.intercom:
              return `Intercom`;
          case T.jira:
          case T.jiraPersonal:
              return `Jira`;
          case T.launchDarkly:
          case T.launchDarklyPersonal:
              return `LaunchDarkly`;
          case T.loom:
              return `Loom`;
          case T.notion:
              return `Notion`;
          case T.opsgenie:
              return `Opsgenie`;
          case T.pagerDuty:
              return `PagerDuty`;
          case T.salesforce:
              return `Salesforce`;
          case T.slackAsks:
              return `Asks`;
          case T.slack:
          case T.slackOrgProjectUpdatesPost:
          case T.slackOrgInitiativeUpdatesPost:
          case T.slackPersonal:
          case T.slackPost:
          case T.slackProjectPost:
          case T.slackProjectUpdatesPost:
          case T.slackCustomViewNotifications:
          case T.slackInitiativePost:
              return `Slack`;
          case T.sentry:
              return `Sentry`;
          case T.zendesk:
              return `Zendesk`;
          case T.email:
              return `Email`;
          case T.mcpServerPersonal:
          case T.mcpServer:
              return `MCP Server`;
          default:
              throw y(e)
          }
      }
      e.getDisplayName = t
  }
  )(Ys ||= {})
}
)), Zs, Qs = t(( () => {
  Zs = function(e) {
      return e.blocks = `blocks`,
      e.duplicate = `duplicate`,
      e.related = `related`,
      e.similar = `similar`,
      e
  }({})
}
)), $s, ec, tc, nc = t(( () => {
  $s = [1, 2, 3, 4, 5],
  ec = [0, 1, 2, 3, 4],
  tc = {
      MonToFri: $s,
      SunToThu: ec
  }
}
)), rc, ic = t(( () => {
  rc = function(e) {
      return e.all = `all`,
      e.onlyBusinessDays = `onlyBusinessDays`,
      e
  }({})
}
)), ac, oc = t(( () => {
  nc(),
  ic(),
  Yr(),
  zn(),
  (function(e) {
      e.Duration = {
          twelveHours: 12 * b.HOUR,
          twentyFourHours: b.DAY,
          fortyEightHours: 2 * b.DAY,
          oneWeek: b.WEEK,
          twoWeeks: 2 * b.WEEK,
          fourWeeks: 4 * b.WEEK
      },
      e.SLAStatusThresholdsInHours = {
          highRisk: 24,
          mediumRisk: 168
      };
      let t = function(e) {
          return e.Breached = `Breached`,
          e.HighRisk = `HighRisk`,
          e.MediumRisk = `MediumRisk`,
          e.LowRisk = `LowRisk`,
          e.Completed = `Completed`,
          e.Failed = `Failed`,
          e
      }({});
      e.Status = t,
      e.all = Object.values(t).filter(e => typeof e == `string`);
      function n(e) {
          switch (e) {
          case t.Breached:
              return `Breached`;
          case t.Completed:
              return `Achieved`;
          case t.Failed:
              return `Failed`;
          case t.HighRisk:
              return `High Risk`;
          case t.MediumRisk:
              return `Moderate Risk`;
          case t.LowRisk:
              return `Low Risk`;
          case null:
              return `No SLA`;
          default:
              Ln(e)
          }
      }
      e.getStatusLabel = n;
      function r(e) {
          switch (e) {
          case t.Breached:
              return 0;
          case t.HighRisk:
              return 1;
          case t.MediumRisk:
              return 2;
          case t.LowRisk:
              return 3;
          case t.Completed:
              return 4;
          case t.Failed:
              return 5;
          default:
              return y(e),
              6
          }
      }
      e.getSlaStatusOrder = r;
      function i(e) {
          let {slaBreachesAt: n, slaHighRiskAt: r, slaMediumRiskAt: i, completedAt: a, canceledAt: o} = e
            , s = new Date;
          if (!(!n && !r && !i || o))
              return a && n && n < a ? t.Failed : a && n && n >= a ? t.Completed : n && n <= s ? t.Breached : r && r <= s ? t.HighRisk : i && i <= s ? t.MediumRisk : t.LowRisk
      }
      e.getSlaStatus = i;
      function a(e, t, n, r=tc.MonToFri) {
          switch (e) {
          case void 0:
          case rc.all:
              return [t.offsetBySeconds(-ac.SLAStatusThresholdsInHours.mediumRisk * 3600), t.offsetBySeconds(-ac.SLAStatusThresholdsInHours.highRisk * 3600)];
          case rc.onlyBusinessDays:
              return [t.offsetByBusinessDays(-ac.SLAStatusThresholdsInHours.mediumRisk / 24, r, n), t.offsetByBusinessDays(-ac.SLAStatusThresholdsInHours.highRisk / 24, r, n)];
          default:
              Ln(e)
          }
      }
      e.calculateSLARiskThresholds = a
  }
  )(ac ||= {})
}
));
function Pne(e, t, n) {
  let r = e || 0
    , i = 1 << t;
  return n ? r |= i : r &= ~i,
  r === 0 ? null : r
}
function sc(e, t) {
  return ((e || 0) & 1 << t) > 0
}
var cc = t(( () => {}
)), lc, uc = t(( () => {
  lc = function(e) {
      return e[e.hasChildren = 0] = `hasChildren`,
      e[e.hasAttachments = 1] = `hasAttachments`,
      e[e.hasChildrenInDifferentTeam = 2] = `hasChildrenInDifferentTeam`,
      e[e.hasCustomerNeeds = 3] = `hasCustomerNeeds`,
      e[e.hasExternalEntityRelations = 4] = `hasExternalEntityRelations`,
      e[e.hasRelations = 5] = `hasRelations`,
      e[e.hasReverseRelations = 6] = `hasReverseRelations`,
      e[e.hasFormerAttachments = 7] = `hasFormerAttachments`,
      e[e.hasFormerCustomerNeeds = 8] = `hasFormerCustomerNeeds`,
      e[e.hasPullRequests = 9] = `hasPullRequests`,
      e[e.hasSuggestions = 10] = `hasSuggestions`,
      e[e.hasIncomingSuggestions = 11] = `hasIncomingSuggestions`,
      e[e.hasAiPromptProgress = 12] = `hasAiPromptProgress`,
      e[e.hasAgentSessions = 13] = `hasAgentSessions`,
      e[e.hasSummary = 14] = `hasSummary`,
      e[e.hasDocuments = 15] = `hasDocuments`,
      e[e.hasReleases = 16] = `hasReleases`,
      e
  }({})
}
)), dc, fc, pc, mc = t(( () => {
  dc = function(e) {
      return e.first = `first`,
      e.last = `last`,
      e.noAction = `noAction`,
      e
  }({}),
  fc = function(e) {
      return e.teamSetting = `teamSetting`,
      e
  }(fc || {}),
  pc = {
      ...dc,
      ...fc
  }
}
)), E, hc, gc = t(( () => {
  E = function(e) {
      return e.triage = `triage`,
      e.backlog = `backlog`,
      e.unstarted = `unstarted`,
      e.started = `started`,
      e.completed = `completed`,
      e.canceled = `canceled`,
      e
  }({}),
  (function(e) {
      e.statusOrdering = Object.freeze({
          [E.triage]: 0,
          [E.backlog]: 1,
          [E.unstarted]: 2,
          [E.started]: 3,
          [E.completed]: 4,
          [E.canceled]: 5
      }),
      e.customStatusOrdering = Object.freeze({
          [E.started]: 0,
          [E.unstarted]: 1,
          [E.backlog]: 2,
          [E.triage]: 3,
          [E.completed]: 4,
          [E.canceled]: 5
      }),
      e.allWithoutTriage = (e.all = Object.values(E).filter(e => typeof e == `string`)).filter(e => e !== E.triage),
      e.categoryNameMappings = {
          [E.triage]: [],
          [E.backlog]: [],
          [E.unstarted]: [],
          [E.started]: [],
          [E.completed]: [`done`, `resolved`],
          [E.canceled]: [`cancelled`]
      },
      e.closedStateTypes = [E.completed, E.canceled];
      function t(e) {
          switch (e) {
          case E.triage:
              return `Triage`;
          case E.backlog:
              return `Backlog`;
          case E.unstarted:
              return `Unstarted`;
          case E.started:
              return `Started`;
          case E.completed:
              return `Completed`;
          case E.canceled:
              return `Canceled`;
          default:
              return ``
          }
      }
      e.getStateTypeName = t
  }
  )(hc ||= {})
}
)), _c, vc = t(( () => {
  gc(),
  _c = class {
      static #e = this.maxNameLength = 30;
      static #t = this.maxDescriptionLength = 255;
      static getStateTypeOrder(e) {
          return hc.statusOrdering[e]
      }
      static isClosedState(e) {
          return e === E.completed || e === E.canceled
      }
      static isStateBefore(e, t) {
          let n = hc.statusOrdering[e.type]
            , r = hc.statusOrdering[t.type];
          return n < r || n === r && e.position < t.position
      }
      static getPositionOrder(e) {
          return hc.closedStateTypes.includes(e.type) ? -e.position : e.position
      }
      static #n = this.defaultDuplicateState = {
          type: E.canceled,
          name: `Duplicate`,
          color: `#95a2b3`
      };
      static #r = this.reviewState = {
          type: E.started,
          name: `In Review`,
          color: `#0f783c`,
          position: 2.5
      };
      static #i = this.defaultStates = [{
          type: E.backlog,
          name: `Backlog`,
          color: `#bec2c8`
      }, {
          type: E.unstarted,
          name: `Todo`,
          color: `#e2e2e2`
      }, {
          type: E.started,
          name: `In Progress`,
          color: `#f2c94c`
      }, {
          type: E.completed,
          name: `Done`,
          color: `#5e6ad2`
      }, {
          type: E.canceled,
          name: `Canceled`,
          color: `#95a2b3`
      }, this.defaultDuplicateState];
      static #a = this.defaultTriageState = {
          type: E.triage,
          name: `Triage`,
          color: `#FC7840`,
          position: 0
      }
  }
}
));
function Fne(e) {
  switch (e) {
  case 0:
      return `-`;
  case 1:
      return `XS`;
  case 2:
      return `S`;
  case 3:
      return `M`;
  case 5:
      return `L`;
  case 8:
      return `XL`;
  case 13:
      return `XXL`;
  case 21:
      return `XXXL`;
  default:
      return
  }
}
var yc, bc, xc = t(( () => {
  zn(),
  yc = function(e) {
      return e.notUsed = `notUsed`,
      e.exponential = `exponential`,
      e.fibonacci = `fibonacci`,
      e.linear = `linear`,
      e.tShirt = `tShirt`,
      e
  }({}),
  bc = class e {
      static get availableTypes() {
          return Object.values(yc).map(e => `"${e}"`).join(`, `)
      }
      static nameForType(e) {
          switch (e) {
          case yc.notUsed:
              return `Not in use`;
          case yc.exponential:
              return `Exponential`;
          case yc.fibonacci:
              return `Fibonacci`;
          case yc.linear:
              return `Linear`;
          case yc.tShirt:
              return `T-Shirt`;
          default:
              return y(e),
              `Unknown`
          }
      }
      static detailsForType(e, t, n) {
          switch (e) {
          case yc.notUsed:
              return ``;
          case yc.exponential:
              return `(${t ? `0, ` : ``}1, 2, 4, 8, 16 ${n ? `, 32, 64` : ``} Points)`;
          case yc.fibonacci:
              return `(${t ? `0, ` : ``}1, 2, 3, 5, 8 ${n ? `, 13, 21` : ``} Points)`;
          case yc.linear:
              return `(${t ? `0, ` : ``}1, 2, 3, 4, 5 ${n ? `, 6, 7` : ``} Points)`;
          case yc.tShirt:
              return `(${t ? `-, ` : ``}XS, S, M, L, XL ${n ? `, XXL, XXXL` : ``})`;
          default:
              return y(e),
              ``
          }
      }
      static keywordsForType(e, t) {
          switch (e) {
          case yc.notUsed:
          case yc.exponential:
          case yc.fibonacci:
          case yc.linear:
              return t ? [`none unestimated`] : [];
          case yc.tShirt:
              return [...t ? [`none unestimated`] : [], `extra small`, `small`, `medium`, `large`, `extra large`, `extra extra large`, `extra extra extra large`];
          default:
              return y(e),
              []
          }
      }
      static valuesForType(e, t, n) {
          let r = t ? [0] : [];
          switch (e) {
          case yc.notUsed:
              return [];
          case yc.exponential:
              return r.concat([1, 2, 4, 8, 16]).concat(n ? [32, 64] : []);
          case yc.fibonacci:
              return r.concat([1, 2, 3, 5, 8]).concat(n ? [13, 21] : []);
          case yc.linear:
              return r.concat([1, 2, 3, 4, 5]).concat(n ? [6, 7] : []);
          case yc.tShirt:
              return r.concat([1, 2, 3, 5, 8]).concat(n ? [13, 21] : []);
          default:
              return y(e),
              []
          }
      }
      static indexOfValueForType(t, n, r, i) {
          let a = e.valuesForType(n, r, i)
            , o = a.indexOf(t);
          if (o !== -1)
              return o;
          let s = t
            , c = Number.MAX_VALUE;
          for (let e of a) {
              let n = Math.abs(e - t);
              n <= c && (s = e,
              c = n)
          }
          return o = a.indexOf(s),
          o === -1 ? 0 : o
      }
      static transformValueBetweenConfigurations(t, n, r) {
          let i = e.valuesForType(r.type, r.allowZero, r.extended);
          if (n.type === r.type)
              return i[e.indexOfValueForType(t, r.type, r.allowZero, r.extended)];
          if (n.type === yc.notUsed && r.type !== yc.notUsed)
              return e.transformValueIntoConfiguration(t, r);
          if (n.type !== yc.notUsed && r.type === yc.notUsed)
              return t;
          let a = e.indexOfValueForType(t, n.type, n.allowZero, !0);
          return n.allowZero !== r.allowZero && (n.allowZero ? a-- : a++),
          a = Math.min(Math.max(a, 0), i.length - 1),
          i[a]
      }
      static transformValueIntoConfiguration(t, n) {
          let {type: r, allowZero: i, extended: a} = n;
          return e.valuesForType(r, i, a)[e.indexOfValueForType(t, r, i, a)]
      }
      static labelForValueAndType(e, t, n, r) {
          if (e === void 0)
              return `Estimate`;
          let i = this.labelsForType(t, n, r)
            , a = this.valuesForType(t, n, r).indexOf(e);
          if (a !== -1)
              return i[a];
          if (t === yc.tShirt) {
              let r = this.labelsForType(t, n, !0);
              return a = this.indexOfValueForType(e, t, n, !0),
              `~` + r[a]
          }
          return e + ` Point` + (e === 1 ? `` : `s`)
      }
      static shortLabelForValueAndType(e, t, n, r) {
          return e === void 0 ? `` : this.labelForValueAndType(e, t, n, r).replace(` Points`, ``).replace(` Point`, ``)
      }
      static labelsForType(e, t, n) {
          switch (e) {
          case yc.notUsed:
              return [];
          case yc.exponential:
          case yc.fibonacci:
          case yc.linear:
              return this.valuesForType(e, t, n).map(e => e === 1 ? `1 Point` : `${e} Points`);
          case yc.tShirt:
              return [...t ? [`-`] : [], `XS`, `S`, `M`, `L`, `XL`, ...n ? [`XXL`, `XXXL`] : []];
          default:
              return y(e),
              []
          }
      }
      static labelsForValues(e, t) {
          return e.map(e => {
              let n = t === `none` ? void 0 : Fne(e);
              return t === `only` ? n ?? `-` : `${e} Point${e === 1 ? `` : `s`}${n ? ` (${n})` : ``}`
          }
          )
      }
  }
}
)), Sc, Cc = t(( () => {
  xc(),
  gc(),
  (function(e) {
      function t(e) {
          return e >= 1
      }
      e.isCompletelyDone = t;
      function n(e) {
          return e === 0
      }
      e.isNotStarted = n;
      function r(e) {
          if (e.length === 0)
              return 0;
          let t = !1
            , n = 0
            , r = p(e, {
              estimationEnabled: !0
          });
          if (r === 0) {
              for (let i = 0, a = e.length; i < a; ++i) {
                  let a = e[i].state.type;
                  a !== E.canceled && a !== E.triage && (n += _[a],
                  r += 1),
                  a !== E.completed && a !== E.canceled && (t = !0)
              }
              if (r === 0)
                  return 0
          } else
              t = e.some(e => e.state.type !== E.completed && e.state.type !== E.canceled),
              n = f(e, !0);
          let i = n / r;
          return i === 1 && t ? .999 : i
      }
      e.progress = r;
      function i(e) {
          let t = (e.scopeEstimate || 0) - (e.cancelledEstimate || 0) - (e.triageEstimate || 0)
            , n = Sc.progressMultipliers[E.completed] * (e.completedEstimate || 0) + Sc.progressMultipliers[E.started] * (e.startedEstimate || 0);
          if (t === 0 && (t = (e.scopeCount || 0) - (e.cancelledIssueCount || 0) - (e.triageIssueCount || 0),
          n = Sc.progressMultipliers[E.completed] * (e.completedIssueCount || 0) + Sc.progressMultipliers[E.started] * (e.startedIssueCount || 0)),
          t === 0)
              return 0;
          let r = n / t;
          if (r > 1)
              return 1;
          let i = (e.startedIssueCount || 0) > 0 || (e.unstartedIssueCount || 0) > 0 || (e.backlogIssueCount || 0) > 0;
          return r === 1 && i ? .999 : r
      }
      e.completionProgress = i;
      function a(e, t) {
          return Array.isArray(e) ? Math.floor(e.reduce( (e, t) => {
              switch (t.state.type) {
              case E.started:
                  return e + h(t);
              default:
                  return e
              }
          }
          , 0)) : t ? e.startedEstimate || 0 : e.startedIssueCount || 0
      }
      e.inProgressEstimatePoints = a;
      function o(e) {
          return Array.isArray(e) ? e.filter(e => e.state.type === E.started).length : e.startedIssueCount || 0
      }
      e.inProgressIssueCount = o;
      function s(e, t) {
          return Array.isArray(e) ? Math.floor(e.reduce( (e, t) => {
              switch (t.state.type) {
              case E.triage:
                  return e + h(t);
              default:
                  return e
              }
          }
          , 0)) : t ? e.triageEstimate || 0 : e.triageIssueCount || 0
      }
      e.inTriageEstimatePoints = s;
      function c(e) {
          return Array.isArray(e) ? e.filter(e => e.state.type === E.triage).length : e.triageIssueCount || 0
      }
      e.inTriageIssueCount = c;
      function l(e, t) {
          return Array.isArray(e) ? Math.floor(e.reduce( (e, t) => {
              switch (t.state.type) {
              case E.completed:
                  return e + h(t);
              default:
                  return e
              }
          }
          , 0)) : t ? e.completedEstimate || 0 : e.completedIssueCount || 0
      }
      e.completedEstimatePoints = l;
      function u(e) {
          return Array.isArray(e) ? e.filter(e => e.state.type === E.completed).length : e.completedIssueCount || 0
      }
      e.completedIssueCount = u;
      function d(e) {
          let t = Math.round(e * 1e3) / 10;
          return t % 1 == 0 ? t.toFixed(0) : t.toFixed(1)
      }
      e.formatProgressToPercentage = d;
      function f(e, t) {
          return Array.isArray(e) ? e.reduce( (e, t) => e + h(t) * (_[t.state.type] ?? 0), 0) : t ? _[E.backlog] * (e.backlogEstimate || 0) + _[E.unstarted] * (e.unstartedEstimate || 0) + _[E.canceled] * (e.cancelledEstimate || 0) + _[E.triage] * (e.triageEstimate || 0) + _[E.completed] * (e.completedEstimate || 0) + _[E.started] * (e.startedEstimate || 0) : _[E.backlog] * (e.backlogIssueCount || 0) + _[E.unstarted] * (e.unstartedIssueCount || 0) + _[E.canceled] * (e.cancelledIssueCount || 0) + _[E.triage] * (e.triageIssueCount || 0) + _[E.completed] * (e.completedIssueCount || 0) + _[E.started] * (e.startedIssueCount || 0)
      }
      e.progressEstimatePoints = f;
      function p(e, t) {
          if (Array.isArray(e))
              return e.reduce( (e, n) => {
                  let r = 0;
                  return (n.state.type !== E.canceled || t?.includeCanceledStates) && (n.state.type !== E.triage || t?.includeTriaged) && (r = h(n)),
                  e + r
              }
              , 0);
          {
              if (!t.estimationEnabled) {
                  let n = e.scopeCount || 0;
                  return t?.includeCanceledStates || (n -= e.cancelledIssueCount || 0),
                  t?.includeTriaged || (n -= e.triageIssueCount || 0),
                  n
              }
              let n = e.scopeEstimate || 0;
              return t?.includeCanceledStates || (n -= e.cancelledEstimate || 0),
              t?.includeTriaged || (n -= e.triageEstimate || 0),
              n
          }
      }
      e.totalEstimatePoints = p;
      function m(e) {
          return Array.isArray(e) ? e.filter(e => e.state.type !== E.triage && e.state.type !== E.canceled).length : (e.scopeCount || 0) - (e.cancelledIssueCount || 0) - (e.triageIssueCount || 0)
      }
      e.totalIssueCount = m;
      function h(e) {
          return e.team.issueEstimationType === yc.notUsed ? 1 : e.estimate ?? e.team.defaultIssueEstimate
      }
      e.getEstimate = h;
      function g(e) {
          let t = Math.round(e * 100);
          return t === 100 && e !== 1 ? 99 : t
      }
      e.progressToPercent = g;
      let _ = e.progressMultipliers = {
          [E.backlog]: 0,
          [E.canceled]: 0,
          [E.completed]: 1,
          [E.started]: .25,
          [E.triage]: 0,
          [E.unstarted]: 0
      }
  }
  )(Sc ||= {})
}
)), wc, Tc, Ec, Dc, Oc, kc, Ac = t(( () => {
  Xs(),
  wc = class {
  }
  ,
  Tc = function(e) {
      return e.asana = `asana`,
      e.clubhouse = `clubhouse`,
      e.github = `github`,
      e.jira = `jira`,
      e.linear = `linear`,
      e.linearV2 = `linearV2`,
      e
  }({}),
  Ec = function(e) {
      return e.api = `api`,
      e.csv = `csv`,
      e
  }({}),
  Dc = function(e) {
      return e.expired = `expired`,
      e.complete = `complete`,
      e.error = `error`,
      e.inProcess = `inProcess`,
      e.inProgress = `inProgress`,
      e.notStarted = `notStarted`,
      e.deleting = `deleting`,
      e
  }({}),
  Oc = class e {
      static #e = this.importServiceToDisplayName = {
          [Tc.asana]: `Asana`,
          [Tc.clubhouse]: `Shortcut`,
          [Tc.github]: `GitHub`,
          [Tc.jira]: `Jira`,
          [Tc.linear]: `Linear`,
          [Tc.linearV2]: `Linear to Linear`
      };
      static extendedDisplayName({service: t, serviceMetadata: n}) {
          return t === Tc.linearV2 && n && n[Tc.linearV2] ? `linear.app/${n[Tc.linearV2].sourceOrganization.urlKey}` : e.importServiceToDisplayName[t]
      }
      static #t = this.importServiceToSyncIntegration = {
          [Tc.github]: T.github,
          [Tc.jira]: T.jira,
          [Tc.linearV2]: void 0,
          [Tc.clubhouse]: void 0,
          [Tc.asana]: void 0,
          [Tc.linear]: void 0
      };
      static #n = this.importStatusToDisplayText = {
          [Dc.expired]: `Expired`,
          [Dc.complete]: `Completed`,
          [Dc.error]: `Error`,
          [Dc.inProcess]: `Processing`,
          [Dc.inProgress]: `In progress`,
          [Dc.notStarted]: `Not started`,
          [Dc.deleting]: `Deleting`
      };
      static #r = this.importDataSourceToDisplayText = {
          [Ec.api]: `Provide API credentials`,
          [Ec.csv]: `Upload a CSV`
      };
      static #i = this.importDataTypeToDisplayText = {
          ImportIssueData: `Issues`,
          ImportProjectData: `Projects`,
          ImportEpicData: `Epics`,
          ImportIssueRelationData: `Issue Relations`
      }
  }
  ,
  kc = function(e) {
      return e.asanaNoOrgs = `ASANA_NO_ORGS`,
      e.invalidTeam = `INVALID_TEAM`,
      e.invalidProject = `INVALID_PROJECT`,
      e.invalidJiraHost = `INVALID_JIRA_HOST`,
      e.invalidJiraCredentials = `INVALID_JIRA_CREDENTIALS`,
      e.invalidAsanaToken = `INVALID_ASANA_TOKEN`,
      e.invalidShortcutToken = `INVALID_SHORTCUT_TOKEN`,
      e.noIssues = `NO_ISSUES`,
      e.unknownError = `UNKNOWN_ERROR`,
      e.invalidCsvRow = `INVALID_CSV_ROW`,
      e.quotaExceeded = `QUOTA_EXCEEDED`,
      e.userMigrationConflict = `USER_MIGRATION_CONFLICT`,
      e
  }({}),
  class extends wc {
      static #e = this.storageName = `issues`
  }
  ,
  class extends wc {
      static #e = this.storageName = `comments`
  }
  ,
  class extends wc {
      static #e = this.storageName = `users`
  }
  ,
  class extends wc {
      static #e = this.storageName = `labels`
  }
  ,
  class extends wc {
      static #e = this.storageName = `epics`
  }
  ,
  class extends wc {
      static #e = this.storageName = `projects`
  }
  ,
  class extends wc {
      static #e = this.storageName = `workflowStates`
  }
  ,
  class extends wc {
      static #e = this.storageName = `projectStatuses`
  }
  ,
  class extends wc {
      static #e = this.storageName = `teams`
  }
  ,
  class extends wc {
      static #e = this.storageName = `estimateScales`
  }
  ,
  class extends wc {
      static #e = this.storageName = `relations`
  }
}
)), jc, Mc, Nc, Pc, Fc = t(( () => {
  jc = e(ye(), 1),
  Xs(),
  Ac(),
  Mc = [`javascript`, `data`, `blob`, `file`, `vbscript`],
  Nc = {
      https: ``,
      http: ``,
      linear: `https://linear.app/login`,
      obsidian: `https://obsidian.md`,
      slack: `https://slack.com`,
      notion: `https://notion.so`,
      craftdocs: `https://craft.do`
  },
  Pc = class e {
      static #e = this.maxContentLength = 75e3;
      static #t = this.maxTitleLength = 512;
      static #n = this.maxSubtitleLength = 1024;
      static #r = this.URLDomainRegex = `.*:\\/\\/(?:.*\\.)?([^\\/\\.]+)\\.[a-z]{2,}(?:\\/|$)`;
      static getSourceType(e) {
          let {url: t, source: n} = e;
          return !n || n.type === `api` || n.type === `oauthClient` ? this.getSourceTypeFromUrl(t) || t : n.type
      }
      static userVisibleSourceName(e) {
          let {source: t} = e;
          if (!t || t.type === `api` || t.type === `oauthClient`) {
              let t = this.getSourceType(e);
              return this.getSourceTypeLabel(t)
          }
          return t.type === `import` ? `Migrated - ${Oc.importServiceToDisplayName[t.issueImportService]}` : t.type === `integration` ? (0,
          jc.default)(t.name) : t.type === T.figmaPlugin || t.type === T.figma ? `Figma` : t.type === T.githubCommit ? `GitHub commit` : t.type === T.github ? `GitHub` : t.type === T.gitlab ? `GitLab` : this.getSourceTypeLabel(t.type)
      }
      static getIframelyUrlForAttachmentLink(e) {
          switch (new URL(e).protocol.slice(0, -1)) {
          case `obsidian`:
              return Nc.obsidian;
          case `slack`:
              return Nc.slack;
          case `linear`:
              return Nc.linear;
          case `notion`:
              return Nc.notion;
          case `craftdocs`:
              return Nc.craftdocs;
          default:
              return e
          }
      }
      static getStrippedFirstAttachmentMessageBody(t) {
          let n = t?.metadata.messages || []
            , r = e.getSourceType(t);
          if (t && n.length > 0) {
              let e = n.find(e => e.body !== void 0)?.body;
              return r === T.slack && e && e.match(/^@[^\n]+ said:\n\n> /m) && (e = e.replace(/^@[^\n]+ said:\n\n> /m, ``).replace(/\n> /g, `
`)),
              e
          }
      }
      static getSourceTypeFromUrl(e) {
          try {
              let t = new URL(e).hostname.toLowerCase()
                , n = e => t === e || t.endsWith(`.${e}`);
              if (n(`frontapp.com`))
                  return `front`;
              if (n(`slack.com`))
                  return `slack`;
              if (t === `twitter.com` || t === `x.com` || t === `t.co`)
                  return `twitter`;
              if ((n(`atlassian.net`) || n(`atlassian.com`)) && e.includes(`/wiki`))
                  return `atlassian-confluence`;
              if (n(`jira.com`) || n(`atlassian.com`) && !e.includes(`/wiki`) || n(`atlassian.net`) && !e.includes(`/wiki`))
                  return `jira`;
              if (n(`incident.io`))
                  return `incident-io`;
              if (n(`launchdarkly.com`))
                  return `launch-darkly`;
              if (n(`linkedin.com`))
                  return `linked-in`;
              if (n(`youtube.com`) || t === `youtu.be`)
                  return `youtube`;
              if (t === `sheets.google.com`)
                  return `google-sheets`;
              if (t === `docs.google.com`)
                  return e.includes(`/spreadsheets/`) ? `google-sheets` : `google-docs`;
              if (t === `calendar.google.com`)
                  return `google-calendar`;
              if (n(`salesforce.com`) || n(`lightning.force.com`))
                  return `salesforce`;
              let r = t.split(`.`);
              return r.length >= 2 ? r[r.length - 2] : t
          } catch {
              let t = e.match(new RegExp(this.URLDomainRegex));
              return t ? t[1] : void 0
          }
      }
      static getSourceTypeLabel(e) {
          if (!e)
              return;
          let t = e.toLowerCase();
          switch (t) {
          case `github`:
              return `GitHub`;
          case `gitlab`:
              return `GitLab`;
          case `chatgpt`:
              return `ChatGPT`;
          case `chatprd`:
              return `ChatPRD`;
          case `usepylon`:
              return `Pylon`;
          case `datadoghq`:
              return `Datadog`;
          case `atlassian-confluence`:
              return `Confluence`;
          case `incident-io`:
              return `Incident.io`;
          case `launch-darkly`:
          case `launchdarkly`:
              return `LaunchDarkly`;
          case `linked-in`:
              return `LinkedIn`;
          case `youtube`:
              return `YouTube`;
          case `google-sheets`:
              return `Google Sheets`;
          case `google-docs`:
              return `Google Docs`;
          case `google-calendar`:
              return `Google Calendar`;
          case `helpscout`:
              return `Help Scout`;
          case `front`:
          case `frontapp`:
              return `Front`;
          case `hubspot`:
              return `HubSpot`;
          default:
              return t === e ? (0,
              jc.default)(e) : e
          }
      }
  }
}
));
function Ic(e, t={}) {
  if (typeof e != `string`)
      return;
  let n;
  try {
      n = new URL(e)
  } catch {
      return
  }
  let {allowedProtocols: r=[]} = t
    , i = n.protocol.slice(0, -1);
  if (!(Mc.includes(i) && !r.includes(i)))
      return e
}
var Lc = t(( () => {
  Fc()
}
)), Rc, zc, Bc = t(( () => {
  Rc = e(Ree(), 1),
  Lc(),
  zc = {
      link: {
          attrs: {
              href: {
                  default: null
              }
          },
          inclusive: !1,
          parseDOM: [{
              tag: `a[href]`,
              getAttrs: e => e.getAttribute(`data-type`) ? !1 : {
                  href: e.getAttribute(`href`)
              }
          }],
          toDOM: e => [`a`, {
              ...e.attrs,
              href: Ic(e.attrs.href),
              target: `_blank`,
              rel: `noopener noreferrer nofollow`
          }, 0]
      },
      attribution: {
          attrs: {
              userId: {
                  default: ``
              }
          },
          inclusive: !1,
          parseDOM: [{
              tag: `span.attr`,
              getAttrs: e => ({
                  userId: e.getAttribute(`data-user-id`)
              })
          }],
          toDOM: e => [`span`, {
              class: `attr`,
              "data-user-id": e.attrs.userId
          }, 0]
      },
      code: {
          excludes: `em underline strong placeholder code`,
          parseDOM: [{
              tag: `code`
          }],
          toDOM: () => [`code`, {
              spellcheck: `false`,
              class: `inline`
          }, 0]
      },
      inlineComment: {
          attrs: {
              commentId: {
                  default: null
              },
              createdBy: {
                  default: null
              },
              resolved: {
                  default: !1
              },
              block: {
                  default: !1
              }
          },
          excludes: ``,
          inclusive: !1,
          parseDOM: [{
              tag: `span.inline-comment`,
              getAttrs: e => ({
                  commentId: e.getAttribute(`data-comment-id`),
                  createdBy: e.getAttribute(`data-created-by`),
                  resolved: e.getAttribute(`data-comment-resolved`),
                  block: !1
              })
          }, {
              tag: `div.inline-comment`,
              getAttrs: e => ({
                  commentId: e.getAttribute(`data-comment-id`),
                  createdBy: e.getAttribute(`data-created-by`),
                  resolved: e.getAttribute(`data-comment-resolved`),
                  block: !0
              })
          }],
          toDOM: e => [e.attrs.block ? `div` : `span`, {
              class: `inline-comment`,
              "data-comment-resolved": e.attrs.resolved ?? `false`,
              "data-comment-id": e.attrs.commentId ?? `null`,
              ...e.attrs.createdBy ? {
                  "data-created-by": e.attrs.createdBy
              } : {}
          }, 0]
      },
      em: {
          parseDOM: [{
              tag: `i`
          }, {
              tag: `em`
          }, {
              style: `font-style=italic`
          }],
          toDOM: () => [`em`, 0]
      },
      strike: {
          parseDOM: [{
              tag: `s`
          }, {
              tag: `del`
          }, {
              tag: `strike`
          }, {
              style: `text-decoration`,
              getAttrs: e => e === `line-through` ? null : !1
          }],
          toDOM: () => [`s`, 0]
      },
      underline: {
          parseDOM: [{
              tag: `u`
          }, {
              style: `text-decoration`,
              getAttrs: e => e === `underline` ? null : !1
          }],
          toDOM: () => [`u`, 0]
      },
      strong: {
          parseDOM: [{
              tag: `strong`
          }, {
              tag: `b`,
              getAttrs: e => e.style.fontWeight !== `normal` && null
          }, {
              style: `font-weight`,
              getAttrs: e => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
          }],
          toDOM: () => [`strong`, 0]
      },
      placeholder: {
          parseDOM: [{
              tag: `span.template-placeholder`
          }],
          toDOM: () => [`span`, {
              class: `template-placeholder`,
              spellcheck: `false`
          }, 0]
      },
      word: {
          attrs: {
              id: {}
          },
          toDOM: () => [`span`, {
              class: `word`
          }, 0]
      },
      citation: {
          attrs: {
              url: {},
              entityType: {},
              entityId: {},
              text: {
                  default: null
              }
          },
          inclusive: !1,
          parseDOM: [{
              tag: `span.citation`,
              getAttrs: e => ({
                  url: e.getAttribute(`data-citation-url`),
                  entityType: e.getAttribute(`data-entity-type`),
                  entityId: e.getAttribute(`data-entity-id`),
                  text: e.getAttribute(`data-citation-text`)
              })
          }],
          toDOM: e => [`span`, {
              class: `citation`,
              "data-citation-url": Ic(e.attrs.url),
              "data-entity-type": e.attrs.entityType,
              "data-entity-id": e.attrs.entityId,
              "data-citation-text": e.attrs.text ? (0,
              Rc.encode)(e.attrs.text) : void 0
          }, 0]
      }
  }
}
)), Vc, Hc = t(( () => {
  Vc = class e {
      static #e = this.imageExtensions = {
          jpg: `image/jpeg`,
          jpeg: `image/jpeg`,
          png: `image/png`,
          gif: `image/gif`,
          webp: `image/webp`,
          avif: `image/avif`,
          svg: `image/svg+xml`,
          ico: `image/vnd.microsoft.icon`,
          heic: `image/heic`
      };
      static #t = this.videoExtensions = {
          mp4: `video/mp4`,
          mp4v: `video/mp4`,
          mpg4: `video/mp4`,
          webm: `video/webm`,
          mov: `video/quicktime`,
          avi: `video/x-msvideo`,
          mkv: `video/x-matroska`,
          mpeg: `video/mpeg`,
          mpg: `video/mpeg`,
          ogv: `video/ogg`
      };
      static #n = this.audioExtensions = {
          mp3: `audio/mpeg`,
          wav: `audio/wav`,
          ogg: `audio/ogg`,
          m4a: `audio/mp4`
      };
      static #r = this.documentExtensions = {
          pdf: `application/pdf`,
          doc: `application/msword`,
          docx: `application/vnd.openxmlformats-officedocument.wordprocessingml.document`,
          xls: `application/vnd.ms-excel`,
          xlsx: `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`,
          ppt: `application/vnd.ms-powerpoint`,
          pptx: `application/vnd.openxmlformats-officedocument.presentationml.presentation`,
          txt: `text/plain`,
          rtf: `application/rtf`
      };
      static #i = this.codeExtensions = {
          html: `text/html`,
          css: `text/css`,
          js: `application/javascript`,
          json: `application/json`,
          xml: `application/xml`
      };
      static #a = this.compressedExtensions = {
          zip: `application/zip`,
          rar: `application/vnd.rar`,
          tar: `application/x-tar`,
          gz: `application/gzip`
      };
      static #o = this.extensionToMime = {
          ...e.imageExtensions,
          ...e.videoExtensions,
          ...e.audioExtensions,
          ...e.documentExtensions,
          ...e.codeExtensions,
          ...e.compressedExtensions
      };
      static getMimeTypeFromExtension(t) {
          return e.extensionToMime[t.toLowerCase()]
      }
      static getMimeTypeFromFilename(t) {
          let n = t.toLowerCase().match(/\.([a-z0-9]+)(?:[?#].*)?$/);
          if (n)
              return e.getMimeTypeFromExtension(n[1])
      }
      static isImageExtension(t) {
          return t.toLowerCase()in e.imageExtensions
      }
      static isVideoExtension(t) {
          return t.toLowerCase()in e.videoExtensions
      }
      static isAudioExtension(t) {
          return t.toLowerCase()in e.audioExtensions
      }
      static isDocumentExtension(t) {
          return t.toLowerCase()in e.documentExtensions
      }
      static isCodeExtension(t) {
          return t.toLowerCase()in e.codeExtensions
      }
      static isCompressedExtension(t) {
          return t.toLowerCase()in e.compressedExtensions
      }
  }
}
)), Uc, Wc, Gc = t(( () => {
  zn(),
  Uc = `linear-region`,
  Wc = class e {
      static #e = this.allRegions = [`us-east1`, `europe-west1`, `us-central1`];
      static #t = this.allUserVisibleRegions = [`us-central1`, `europe-west1`];
      static #n = this.defaultRegion = `us-east1`;
      static #r = this.defaultRegionForNewWorkspaces = `us-central1`;
      static get defaultRegionForCurrentClient() {
          let t = new Date().getTimezoneOffset() / 60;
          return t <= 0 && t >= -7 ? `europe-west1` : e.defaultRegionForNewWorkspaces
      }
      static labelForRegion(e) {
          switch (e) {
          case `us-east1`:
          case `us-central1`:
              return `United States`;
          case `europe-west1`:
              return `European Union`;
          default:
              throw y(e)
          }
      }
      static getStatusPageComponentRegionPrefix(e) {
          switch (e) {
          case `us-east1`:
          case `us-central1`:
              return `US`;
          case `europe-west1`:
              return `EU`;
          default:
              throw y(e)
          }
      }
      static isValidRegion(t) {
          return e.allRegions.includes(t)
      }
  }
}
)), Kc, Ine = t(( () => {
  Gc(),
  Kc = class {
      static #e = this.allBucketTypes = [`uploads`, `imports`];
      static #t = this.defaultRegionBucketNames = {
          uploads: {
              production: `uploads.linear.app`,
              development: `uploads.linear.dev`
          },
          imports: {
              production: `imports.linear.app`,
              development: `imports.linear.dev`
          }
      };
      static bucketName(e, t, n) {
          return t === Wc.defaultRegion && this.defaultRegionBucketNames[n]?.[e] || `linear${e === `staging` ? `-staging` : ``}-${n}-${t}`
      }
      static bucketUrl(e, t, n) {
          return `https://storage.googleapis.com/${this.bucketName(e, t, n)}/`
      }
  }
}
)), qc, Jc = t(( () => {
  qc = function(e) {
      return e.month = `month`,
      e.quarter = `quarter`,
      e.halfYear = `halfYear`,
      e.year = `year`,
      e
  }({})
}
)), Yc, Xc, Zc = t(( () => {
  nt(),
  Yr(),
  zn(),
  Jc(),
  Yc = class {
      static format(e, t) {
          let {resolution: n} = e
            , {fiscalYearStartMonth: r, shortYear: i, hideYear: a} = t
            , o = e.date.toLocalDate();
          if (!n)
              return (t?.dateFormat || xr)(o);
          switch (n) {
          case qc.month:
              return Br(o, {
                  shortYear: i,
                  hideYear: a
              });
          case qc.quarter:
              return Vr(o, {
                  fiscalYearStartMonth: r,
                  shortYear: i,
                  hideYear: a
              });
          case qc.halfYear:
              return Hr(o, {
                  fiscalYearStartMonth: r,
                  shortYear: i,
                  hideYear: a
              });
          case qc.year:
              return Ur(o, {
                  fiscalYearStartMonth: r,
                  shortYear: i
              });
          default:
              throw new Rn(n)
          }
      }
      static isEqual(e, t) {
          return !e && !t ? !0 : !e || !t ? !1 : e.date === t.date && e.resolution === t.resolution
      }
      static toInterval(e, t) {
          let {resolution: n} = e, r = this.leadingDateInInterval({
              date: e.date,
              resolution: e.resolution,
              fiscalYearStartMonth: t
          }), i;
          switch (n) {
          case qc.month:
              i = Re(r, 1);
              break;
          case qc.quarter:
              i = Re(r, 3);
              break;
          case qc.halfYear:
              i = Re(r, 6);
              break;
          case qc.year:
              i = Re(r, 12);
              break;
          default:
              throw new Rn(n)
          }
          return [r.toTimelessDate(), i.toTimelessDate()]
      }
      static fromInterval(e, t) {
          let n = this.getResolutionFromInterval(e, t);
          return n ? {
              date: e[0],
              resolution: n
          } : null
      }
      static getResolutionFromInterval(e, t) {
          let[n,r] = e.map(e => e.toLocalDate())
            , [i,a] = e.map(e => Xc.toFiscalYear(e.toLocalDate(), t));
          return Ue(Qe(n), n) ? Ue(Re(n, 1), r) ? qc.month : Ue(rt(i), i) && Ue(Re(i, 3), a) ? qc.quarter : Ae(i) % 6 == 0 && Ue(Re(i, 6), a) ? qc.halfYear : Ue(He(i), i) && Ue(Re(i, 12), a) ? qc.year : null : null
      }
      static #e = this.leadingDateInInterval = e => {
          let {date: t, resolution: n, fiscalYearStartMonth: r} = e
            , i = t.toLocalDate();
          if (n === qc.month)
              return Qe(i);
          let a = Xc.toFiscalYear(i, r), o;
          if (n === qc.quarter)
              o = rt(a);
          else if (n === qc.halfYear) {
              let e = He(a);
              o = Ae(a) < 6 ? e : Re(e, 6)
          } else if (n === qc.year)
              o = He(a);
          else
              throw new Rn(n);
          return Xc.toCalendarYear(o, r)
      }
      ;
      static #t = this.trailingDateInInterval = e => {
          let {date: t, resolution: n, fiscalYearStartMonth: r} = e
            , i = t.toLocalDate();
          if (n === qc.month)
              return ot(i);
          let a = Xc.toFiscalYear(i, r), o;
          if (n === qc.quarter)
              o = ot(lee(a));
          else if (n === qc.halfYear) {
              let e = He(a);
              o = ot(Ae(a) < 6 ? ot(Re(e, 5)) : ke(a))
          } else if (n === qc.year)
              o = ot(ke(a));
          else
              throw new Rn(n);
          return ot(Xc.toCalendarYear(o, r))
      }
      ;
      static isSameFiscalYear(e, t, n) {
          return Je(Xc.toFiscalYear(e, n), Xc.toFiscalYear(t, n))
      }
      static #n = this.isSameHalfYear = (e, t) => e.getFullYear() === t.getFullYear() && e.getMonth() < 6 == t.getMonth() < 6;
      static #r = this.isCurrentTimeframe = (e, t) => {
          switch (t) {
          case qc.month:
              return ree(e, new Date);
          case qc.quarter:
              return dee(e, new Date);
          case qc.halfYear:
              return this.isSameHalfYear(e, new Date);
          case qc.year:
              return Je(e, new Date);
          default:
              throw new Rn(t)
          }
      }
      ;
      static ensureDateResolutionConsistency(e) {
          let {entity: t, dateProperty: n, fiscalYearStartMonth: r} = e
            , i = `${n}Resolution`
            , a = t[i];
          if (!a)
              return !1;
          let o = t[n];
          if (!o)
              return t[i] = null,
              !0;
          let s = (n === `targetDate` ? this.trailingDateInInterval({
              date: o,
              resolution: a,
              fiscalYearStartMonth: r
          }) : this.leadingDateInInterval({
              date: o,
              resolution: a,
              fiscalYearStartMonth: r
          })).toTimelessDate();
          return o === s ? !1 : (t[n] = s,
          !0)
      }
  }
  ,
  Xc = class {
      static toFiscalYear(e, t) {
          return at(e, t)
      }
      static toCalendarYear(e, t) {
          return Re(e, t)
      }
  }
}
)), Qc, $c, el = t(( () => {
  nt(),
  Zc(),
  Qc = /^(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})$/,
  $c = class {
      static validate(e) {
          if (this.isTimelessDate(e))
              return e
      }
      static format(e, t) {
          if (t?.allowRelative) {
              let t = e.toLocalDate();
              if (uee(t))
                  return `Today`;
              if (cee(t))
                  return `Yesterday`;
              if (iee(t))
                  return `Tomorrow`
          }
          return Yc.format({
              date: e
          }, {
              fiscalYearStartMonth: 0
          })
      }
      static isTimelessDate(e) {
          return !(!e || !Qc.test(e))
      }
  }
}
)), tl, nl = t(( () => {
  tl = class {
      static remoteCursorClass = `remote-cursor`;
      static selectedNodeClass = `selected-node`;
      static nodeViewControlsClass = `node-controls`;
      static listNodeClass = `list-node`;
      static headingNodeClass = `heading-node`;
      static headingMenuButtonContainerClass = `heading-menu-button-container`;
      static textNodeClass = `text-node`;
      static blockNodeClass = `block-node`;
      static diagramNodeClass = `diagram-container`;
      static diagramControlsDecorationClass = `diagram-controls-decoration`;
      static diagramSourceEditorClass = `diagram-source-editor`;
      static diagramSourceNodeClass = `diagram-source-node`;
      static diagramConsoleDecorationsClass = `diagram-console-decorations`;
      static autocompleteInputClass = `aci`;
      static tableNodeClass = `tableContainer`;
      static tableWrapperClass = `table-wrapper`;
      static tableCellContentClass = `cell-content`;
      static invisibleParagraphClass = `invisible-paragraph`;
      static codeBlockCopyButtonClass = `cb-copy`;
      static codeBlockExpandCollapseButtonClass = `cb-ex-col`;
      static linkActiveClass = `link-active`;
      static displayFocusClass = `display-focus`;
      static inlineCommentClass = `inline-comment`;
      static collapsibleSectionClass = `collapsible-section`;
      static collapsibleHeadingClass = `collapsible-heading`;
      static entityEmbedClass = `nodeview-entityEmbed`;
      static entityMentionClass = `nodeview-entityMention`
  }
}
)), rl, il = t(( () => {
  rl = e => {
      if (e != null)
          return Number.isFinite(+e) ? +e : void 0
  }
}
)), al, ol = t(( () => {
  mn(),
  al = zee({
      tableGroup: `block`,
      cellContent: `allowedInTable+`,
      cellAttributes: {
          colwidth: {
              default: [200]
          }
      }
  }),
  al.table.draggable = !0,
  al.table_cell.marks = `inlineComment`,
  al.table_header.marks = `inlineComment`
}
)), sl, cl, ll, ul = t(( () => {
  Hc(),
  Ine(),
  el(),
  nl(),
  Lc(),
  il(),
  ol(),
  sl = [1, 2, 3, 4, 5, 6],
  cl = function(e) {
      return e[e.LOW = 49] = `LOW`,
      e[e.REGULAR = 50] = `REGULAR`,
      e[e.HIGH = 51] = `HIGH`,
      e
  }(cl || {}),
  ll = {
      doc: {
          content: `block+`,
          marks: `inlineComment`
      },
      paragraph: {
          content: `inline*`,
          group: `block allowedInTable firstInListItem`,
          draggable: !1,
          parseDOM: [{
              tag: `p`
          }],
          toDOM: () => [`p`, {
              class: tl.textNodeClass
          }, 0]
      },
      pending_file: {
          attrs: {
              fileName: {
                  default: ``
              },
              uploadId: {
                  default: null
              },
              nodeType: {
                  default: `file`
              },
              blobUrl: {
                  default: ``
              },
              fileSize: {
                  default: 0
              },
              mimeType: {
                  default: ``
              },
              width: {
                  default: null
              },
              height: {
                  default: null
              }
          },
          group: `block allowedInTable firstInListItem`,
          selectable: !0,
          draggable: !0,
          atom: !0,
          parseDOM: [{
              tag: `[data-type=pending_file]`,
              getAttrs: e => ({
                  fileName: e.getAttribute(`data-file-name`) || ``,
                  uploadId: e.getAttribute(`data-upload-id`) || ``,
                  nodeType: e.getAttribute(`data-node-type`) || `file`,
                  blobUrl: e.getAttribute(`data-blob-url`) || ``,
                  fileSize: parseInt(e.getAttribute(`data-file-size`) || `0`, 10),
                  mimeType: e.getAttribute(`data-mime-type`) || ``,
                  width: e.getAttribute(`data-width`) ? parseInt(e.getAttribute(`data-width`) || `0`, 10) : null,
                  height: e.getAttribute(`data-height`) ? parseInt(e.getAttribute(`data-height`) || `0`, 10) : null
              })
          }],
          toDOM: e => [`div`, {
              "data-type": `pending_file`,
              "data-file-name": e.attrs.fileName,
              "data-upload-id": e.attrs.uploadId,
              "data-node-type": e.attrs.nodeType,
              "data-blob-url": e.attrs.blobUrl,
              "data-file-size": e.attrs.fileSize,
              "data-mime-type": e.attrs.mimeType,
              "data-width": e.attrs.width,
              "data-height": e.attrs.height
          }, `<pending file${e.attrs.fileName ? `: ${e.attrs.fileName}` : ``}>`],
          toPlainText: e => `<pending file${e.attrs.fileName ? `: ${e.attrs.fileName}` : ``}>`
      },
      blockquote: {
          content: `block+`,
          marks: `inlineComment`,
          group: `block allowedInTable firstInListItem`,
          defining: !0,
          draggable: !1,
          parseDOM: [{
              tag: `blockquote`
          }],
          toDOM: () => [`blockquote`, {
              class: tl.blockNodeClass
          }, 0]
      },
      bullet_list: {
          content: `list_item+`,
          group: `block list allowedInTable`,
          selectable: !1,
          parseDOM: [{
              tag: `ul`
          }],
          toDOM: () => [`ul`, {
              class: tl.listNodeClass
          }, 0]
      },
      code_block: {
          content: `text*`,
          attrs: {
              language: {
                  default: null
              },
              id: {
                  default: void 0
              }
          },
          marks: `inlineComment word`,
          group: `block allowedInTable firstInListItem`,
          code: !0,
          defining: !0,
          draggable: !1,
          parseDOM: [{
              tag: `pre`,
              preserveWhitespace: `full`,
              getAttrs: e => ({
                  language: e.getAttribute(`data-language`) ?? null,
                  id: e.getAttribute(`id`)
              })
          }],
          toDOM: e => [`pre`, {
              spellcheck: `false`,
              autocapitalize: `off`,
              class: tl.blockNodeClass,
              "data-language": e.attrs.language,
              id: e.attrs.id
          }, [`code`, 0]]
      },
      diagram: {
          content: `text*`,
          attrs: {
              language: {
                  default: `mermaid`
              },
              id: {
                  default: void 0
              },
              width: {
                  default: void 0
              },
              height: {
                  default: void 0
              }
          },
          marks: `inlineComment word`,
          group: `block allowedInCollapsible`,
          code: !0,
          defining: !0,
          draggable: !0,
          selectable: !0,
          parseDOM: [{
              tag: `pre[data-type=diagram]`,
              priority: cl.HIGH,
              preserveWhitespace: `full`,
              getAttrs: e => ({
                  language: e.getAttribute(`data-language`) ?? `mermaid`,
                  id: e.getAttribute(`id`),
                  width: e.getAttribute(`data-width`) ? parseInt(e.getAttribute(`data-width`), 10) : void 0,
                  height: e.getAttribute(`data-height`) ? parseInt(e.getAttribute(`data-height`), 10) : void 0
              })
          }],
          toDOM: e => [`pre`, {
              spellcheck: `false`,
              autocapitalize: `off`,
              class: `${tl.blockNodeClass} ${tl.diagramNodeClass}`,
              "data-type": `diagram`,
              "data-language": e.attrs.language,
              id: e.attrs.id,
              "data-width": e.attrs.width,
              "data-height": e.attrs.height
          }, [`code`, 0]]
      },
      diagram_source: {
          content: `text*`,
          attrs: {
              language: {
                  default: `mermaid`
              },
              id: {
                  default: void 0
              }
          },
          marks: `inlineComment word`,
          group: `block`,
          code: !0,
          defining: !0,
          draggable: !1,
          selectable: !0,
          parseDOM: [{
              tag: `pre[data-type=diagram_source]`,
              preserveWhitespace: `full`,
              getAttrs: e => ({
                  language: e.getAttribute(`data-language`) ?? `mermaid`,
                  id: e.getAttribute(`id`)
              })
          }],
          toDOM: e => [`pre`, {
              spellcheck: `false`,
              autocapitalize: `off`,
              class: `${tl.blockNodeClass} ${tl.diagramSourceNodeClass}`,
              "data-type": `diagram_source`,
              "data-language": e.attrs.language,
              id: e.attrs.id
          }, [`code`, 0]]
      },
      embed: {
          attrs: {
              type: {
                  default: `rich`
              },
              embedView: {
                  default: `embed`
              },
              src: {
                  default: null
              },
              title: {
                  default: null
              },
              description: {
                  default: null
              },
              authorName: {
                  default: null
              },
              thumbnailUrl: {
                  default: null
              },
              thumbnailWidth: {
                  default: null
              },
              thumbnailHeight: {
                  default: null
              },
              href: {
                  default: null
              },
              service: {
                  default: null
              },
              border: {
                  default: !1
              },
              width: {
                  default: `100%`
              },
              height: {
                  default: `400px`
              }
          },
          group: `block allowedInTable firstInListItem`,
          selectable: !0,
          hasExternalContent: !0,
          parseDOM: [{
              tag: `[data-type=embed]`,
              priority: cl.HIGH,
              getAttrs: e => JSON.parse(e.getAttribute(`data-json`) || `{}`)
          }],
          toDOM: e => [`a`, {
              href: Ic(e.attrs.href),
              "data-type": `embed`,
              "data-json": JSON.stringify(e.attrs)
          }, String(e.attrs.title || e.attrs.href)],
          toPlainText: e => `${e.attrs.href}

`
      },
      file: {
          attrs: {
              uploadState: {
                  default: `finished`
              },
              uploadId: {
                  default: null
              },
              href: {
                  default: null,
                  validate: e => {
                      if (e == null || Object.values(Kc.defaultRegionBucketNames.uploads).some(t => e.startsWith(`https://${t}/`)))
                          return !0;
                      throw Error(`File's href attribute must be a Linear upload URL`)
                  }
              },
              name: {
                  default: ``
              },
              size: {
                  default: 0
              },
              mimetype: {
                  default: null
              }
          },
          group: `block allowedInTable firstInListItem`,
          selectable: !0,
          draggable: !1,
          parseDOM: [{
              tag: `[data-type=file]`,
              priority: cl.HIGH,
              getAttrs: e => ({
                  href: e.getAttribute(`href`),
                  name: e.textContent,
                  size: +(e.getAttribute(`data-size`) || 0),
                  mimetype: e.getAttribute(`data-mimetype`) ?? Vc.getMimeTypeFromFilename(e.getAttribute(`href`) || ``)
              })
          }],
          toDOM: e => [`a`, {
              "data-type": `file`,
              "data-size": e.attrs.size,
              "data-mimetype": e.attrs.mimetype,
              href: Ic(e.attrs.href),
              target: `_blank`
          }, String(e.attrs.name)],
          toPlainText: e => `${e.attrs.name}: ${e.attrs.href}`
      },
      figma: {
          attrs: {
              href: {
                  default: null
              },
              title: {
                  default: null
              },
              nodeName: {
                  default: null
              },
              embedUrl: {
                  default: null
              },
              screenshotUrl: {
                  default: null
              },
              file: {
                  default: null
              },
              nodeId: {
                  default: null
              },
              fetched: {
                  default: !1
              }
          },
          group: `block allowedInTable firstInListItem`,
          selectable: !0,
          hasExternalContent: !0,
          parseDOM: [{
              tag: `[data-type=figma]`,
              priority: cl.HIGH,
              getAttrs: e => JSON.parse(e.getAttribute(`data-json`) || `{}`)
          }],
          toDOM: e => [`a`, {
              href: Ic(e.attrs.href),
              "data-type": `figma`,
              "data-json": JSON.stringify(e.attrs)
          }, String(e.attrs.title)],
          toPlainText: e => `${e.attrs.nodeName}: ${e.attrs.href}`
      },
      hard_break: {
          inline: !0,
          group: `inline`,
          selectable: !1,
          parseDOM: [{
              tag: `br`
          }, {
              tag: `[data-stringify-type="paragraph-break"]`
          }],
          toDOM: () => [`span`, [`br`]],
          toPlainText: () => `
`
      },
      heading: {
          attrs: {
              level: {
                  default: 1
              },
              id: {
                  default: void 0
              }
          },
          content: `inline*`,
          group: `block allowedInTable`,
          defining: !0,
          draggable: !1,
          parseDOM: sl.map(e => ({
              tag: `h${e}`,
              getAttrs: t => ({
                  id: t.getAttribute(`id`),
                  level: e
              })
          })),
          toDOM: e => [`h${e.attrs.level}`, {
              id: e.attrs.id,
              class: tl.headingNodeClass
          }, 0]
      },
      horizontal_rule: {
          group: `block allowedInCollapsible`,
          parseDOM: [{
              tag: `hr`
          }],
          toDOM: () => [`hr`]
      },
      iframe: {
          attrs: {
              src: {
                  default: null
              }
          },
          group: `block allowedInCollapsible firstInListItem`,
          selectable: !0,
          hasExternalContent: !0,
          parseDOM: [{
              tag: `iframe`,
              priority: cl.LOW,
              getAttrs: e => ({
                  src: e.getAttribute(`src`)
              })
          }],
          toDOM: e => [`iframe`, {
              src: Ic(e.attrs.src),
              frameborder: `0`,
              allowfullscreen: `true`
          }]
      },
      list_item: {
          content: `(firstInListItem block*) | list`,
          marks: `inlineComment`,
          defining: !0,
          draggable: !1,
          selectable: !1,
          parseDOM: [{
              tag: `li`
          }],
          toDOM: () => [`li`, 0]
      },
      image: {
          attrs: {
              uploadState: {
                  default: `finished`
              },
              uploadId: {
                  default: null
              },
              src: {
                  default: null
              },
              alt: {
                  default: null
              },
              title: {
                  default: null
              },
              attribution: {
                  default: null
              },
              originalSrc: {
                  default: null
              },
              width: {
                  default: null
              },
              height: {
                  default: null
              },
              displayWidth: {
                  default: null
              }
          },
          group: `block allowedInTable firstInListItem`,
          selectable: !0,
          draggable: !0,
          commentable: !0,
          hasExternalContent: !0,
          parseDOM: [{
              tag: `img`,
              getAttrs: e => ({
                  src: e.getAttribute(`src`),
                  title: e.getAttribute(`title`),
                  alt: e.getAttribute(`alt`),
                  width: rl(e.getAttribute(`width`)),
                  height: rl(e.getAttribute(`height`)),
                  displayWidth: rl(e.getAttribute(`displayWidth`))
              })
          }],
          toDOM: e => [`img`, {
              src: Ic(e.attrs.src),
              title: e.attrs.title,
              alt: e.attrs.alt,
              width: e.attrs.width,
              height: e.attrs.height,
              displayWidth: e.attrs.displayWidth
          }]
      },
      image_group: {
          content: `image{0,3}`,
          group: `block allowedInCollapsible firstInListItem`,
          selectable: !1,
          parseDOM: [{
              tag: `div.image-group`
          }],
          toDOM: () => [`div`, {
              class: `image-group`
          }, 0]
      },
      ordered_list: {
          attrs: {
              order: {
                  default: 1
              }
          },
          content: `list_item+`,
          group: `block list allowedInTable`,
          selectable: !1,
          parseDOM: [{
              tag: `ol`,
              getAttrs: e => ({
                  order: +(e.getAttribute(`start`) || 1)
              })
          }],
          toDOM: e => e.attrs.order === 1 ? [`ol`, {
              class: tl.listNodeClass
          }, 0] : [`ol`, {
              start: e.attrs.order,
              class: tl.listNodeClass,
              style: `--start:${e.attrs.order}`
          }, 0]
      },
      collapsible_section: {
          attrs: {
              id: {
                  default: void 0
              },
              wasCopiedWhileOpen: {
                  default: void 0
              }
          },
          content: `collapsible_heading (paragraph | table | allowedInTable | allowedInCollapsible)+`,
          marks: `inlineComment`,
          draggable: !0,
          selectable: !0,
          group: `block allowedInCollapsible`,
          parseDOM: [{
              tag: `details`,
              getAttrs: e => ({
                  id: e.getAttribute(`id`) || void 0,
                  wasCopiedWhileOpen: e.getAttribute(`data-was-copied-while-open`) === `true`
              })
          }],
          toDOM: e => [`details`, {
              id: e.attrs.id,
              class: `${tl.blockNodeClass} ${tl.collapsibleSectionClass}`,
              "data-was-copied-while-open": e.attrs.wasCopiedWhileOpen
          }, 0]
      },
      collapsible_heading: {
          content: `paragraph | heading`,
          defining: !0,
          selectable: !0,
          parseDOM: [{
              tag: `summary`
          }],
          toDOM: () => [`summary`, 0]
      },
      text: {
          group: `inline`
      },
      todo_item: {
          attrs: {
              done: {
                  default: !1
              }
          },
          defining: !0,
          draggable: !0,
          content: `(firstInListItem block*) | list`,
          marks: `inlineComment`,
          toDOM: e => {
              let {done: t} = e.attrs;
              return [`li`, {
                  "data-type": `todo_item`,
                  "data-done": t.toString()
              }, [`span`, {
                  class: `todo-checkbox ${t ? `todo-checkbox-checked` : `todo-checkbox-unchecked`}`,
                  contenteditable: `false`
              }], [`div`, {
                  class: `todo-content`
              }, 0]]
          }
          ,
          parseDOM: [{
              priority: cl.HIGH,
              tag: `[data-type=todo_item]`,
              getAttrs: e => ({
                  done: e.getAttribute(`data-done`) === `true`
              })
          }]
      },
      todo_list: {
          group: `block list allowedInTable`,
          content: `(todo_item | list_item)+`,
          toDOM: () => [`ul`, {
              "data-type": `todo_list`,
              class: tl.listNodeClass
          }, 0],
          parseDOM: [{
              priority: cl.HIGH,
              tag: `[data-type=todo_list]`
          }]
      },
      video: {
          attrs: {
              uploadState: {
                  default: `finished`
              },
              uploadId: {
                  default: null
              },
              src: {
                  default: null
              },
              title: {
                  default: null
              },
              size: {
                  default: null
              },
              controls: {
                  default: !0
              },
              height: {
                  default: null
              },
              width: {
                  default: null
              },
              metadataId: {
                  default: null
              },
              mimetype: {
                  default: null,
                  validate: e => {
                      if (e && !e.startsWith(`video/`))
                          throw Error(`Video MIME type must start with 'video/'`)
                  }
              }
          },
          group: `block allowedInTable firstInListItem`,
          selectable: !0,
          draggable: !0,
          hasExternalContent: !0,
          parseDOM: [{
              tag: `video`,
              getAttrs: e => ({
                  src: e.getAttribute(`src`),
                  title: e.getAttribute(`title`),
                  size: +(e.getAttribute(`data-size`) || 0),
                  metadataId: e.getAttribute(`data-metadata-id`),
                  mimetype: e.getAttribute(`data-mimetype`) ?? Vc.getMimeTypeFromFilename(e.getAttribute(`src`) || ``)
              })
          }],
          toDOM: e => [`video`, {
              controls: `true`,
              src: e.attrs.src,
              title: e.attrs.title,
              width: e.attrs.width,
              height: e.attrs.height,
              "data-metadata-id": e.attrs.metadataId,
              "data-size": e.attrs.size,
              "data-mimetype": e.attrs.mimetype
          }],
          toPlainText: e => `${e.attrs.title}: ${e.attrs.src}`
      },
      audio: {
          attrs: {
              uploadState: {
                  default: `finished`
              },
              uploadId: {
                  default: null
              },
              src: {
                  default: null
              },
              title: {
                  default: null
              },
              size: {
                  default: 0
              },
              mimetype: {
                  default: null,
                  validate: e => {
                      if (e && !e.startsWith(`audio/`))
                          throw Error(`Audio MIME type must start with 'audio/'`)
                  }
              },
              controls: {
                  default: !0
              }
          },
          group: `block allowedInTable firstInListItem`,
          selectable: !0,
          draggable: !0,
          hasExternalContent: !0,
          parseDOM: [{
              tag: `audio`,
              getAttrs: e => ({
                  src: e.getAttribute(`src`),
                  title: e.getAttribute(`title`),
                  size: +(e.getAttribute(`data-size`) || 0),
                  mimetype: e.getAttribute(`data-mimetype`) ?? Vc.getMimeTypeFromFilename(e.getAttribute(`src`) || ``)
              })
          }],
          toDOM: e => [`audio`, {
              src: e.attrs.src,
              title: e.attrs.title,
              controls: e.attrs.controls,
              "data-size": e.attrs.size,
              "data-mimetype": e.attrs.mimetype
          }],
          toPlainText: e => `${e.attrs.title}: ${e.attrs.src}`
      },
      suggestion_userMentions: {
          attrs: {
              id: {},
              label: {}
          },
          group: `inline`,
          inline: !0,
          selectable: !1,
          atom: !0,
          parseDOM: [{
              tag: `[data-mention-type=userMentions]`,
              getAttrs: e => ({
                  id: e.getAttribute(`data-mention-id`),
                  label: e.textContent?.replace(/^@/, ``)
              })
          }],
          toDOM: e => [`span`, {
              class: `mention`,
              "data-mention-id": e.attrs.id,
              "data-mention-type": `userMentions`
          }, `@${e.attrs.label}`],
          toPlainText: e => `@${e.attrs.label}`,
          leafText: e => `@${e.attrs.label}`
      },
      issueMention: {
          attrs: {
              id: {},
              label: {},
              href: {},
              title: {
                  default: null
              }
          },
          group: `inline`,
          inline: !0,
          selectable: !1,
          draggable: !0,
          atom: !0,
          parseDOM: [{
              priority: cl.HIGH,
              tag: `[data-mention-type=issueMention]`,
              getAttrs: e => ({
                  id: e.getAttribute(`id`),
                  href: e.getAttribute(`href`),
                  label: e.textContent
              })
          }],
          toDOM: e => [`a`, {
              href: Ic(e.attrs.href),
              id: e.attrs.id,
              target: `_blank`,
              "data-mention-type": `issueMention`
          }, String(e.attrs.label)],
          toPlainText: e => e.attrs.label,
          leafText: e => e.attrs.label
      },
      codeSelectionLine: {
          attrs: {
              filePath: {
                  default: ``
              },
              lineRange: {
                  default: ``
              },
              tempId: {
                  default: ``
              }
          },
          group: `inline`,
          inline: !0,
          selectable: !1,
          draggable: !0,
          atom: !0,
          parseDOM: [{
              priority: cl.HIGH,
              tag: `[data-mention-type=codeSelectionLine]`,
              getAttrs: e => ({
                  filePath: e.getAttribute(`data-file-path`) || ``,
                  lineRange: e.getAttribute(`data-line-range`) || ``,
                  tempId: e.getAttribute(`data-temp-id`) || ``
              })
          }],
          toDOM: e => [`span`, {
              "data-mention-type": `codeSelectionLine`,
              "data-file-path": e.attrs.filePath,
              "data-line-range": e.attrs.lineRange,
              "data-temp-id": e.attrs.tempId
          }, e.attrs.filePath && e.attrs.lineRange ? `${encodeURIComponent(e.attrs.filePath)}#${e.attrs.lineRange}` : ``],
          toPlainText: e => e.attrs.filePath && e.attrs.lineRange ? `${encodeURIComponent(e.attrs.filePath)}#${e.attrs.lineRange}` : ``
      },
      entityMention: {
          attrs: {
              id: {},
              label: {},
              href: {}
          },
          group: `inline`,
          inline: !0,
          selectable: !1,
          draggable: !0,
          atom: !0,
          parseDOM: [{
              priority: cl.HIGH,
              tag: `[data-mention-type=entityMention]`,
              getAttrs: e => ({
                  id: e.getAttribute(`id`),
                  href: e.getAttribute(`href`),
                  label: e.textContent
              })
          }],
          toDOM: e => [`a`, {
              href: Ic(e.attrs.href),
              id: e.attrs.id,
              target: `_blank`,
              "data-mention-type": `entityMention`
          }, String(e.attrs.label)],
          toPlainText: e => e.attrs.label,
          leafText: e => e.attrs.label
      },
      entityEmbed: {
          attrs: {
              id: {},
              modelName: {},
              label: {},
              href: {}
          },
          group: `block firstInListItem`,
          selectable: !0,
          draggable: !0,
          parseDOM: [{
              priority: cl.HIGH,
              tag: `[data-mention-type=entityEmbed]`,
              getAttrs: e => ({
                  id: e.getAttribute(`id`),
                  modelName: e.getAttribute(`data-model-name`),
                  variant: e.getAttribute(`data-variant`),
                  href: e.getAttribute(`href`),
                  label: e.textContent
              })
          }],
          toDOM: e => [`a`, {
              href: Ic(e.attrs.href),
              id: e.attrs.id,
              "data-mention-type": `entityEmbed`,
              "data-model-name": e.attrs.modelName,
              "data-variant": e.attrs.variant
          }, String(e.attrs.label)],
          toPlainText: e => e.attrs.label,
          leafText: e => e.attrs.label
      },
      documentMention: {
          attrs: {
              id: {},
              label: {},
              href: {}
          },
          group: `inline`,
          inline: !0,
          selectable: !1,
          atom: !0,
          parseDOM: [{
              tag: `[data-mention-type=documentMention]`,
              getAttrs: e => ({
                  href: e.getAttribute(`href`),
                  label: e.textContent
              })
          }],
          toDOM: e => [`a`, {
              href: Ic(e.attrs.href),
              target: `_blank`,
              "data-mention-type": `documentMention`
          }, String(e.attrs.label)],
          toPlainText: e => e.attrs.label,
          leafText: e => e.attrs.label
      },
      emoji: {
          attrs: {
              label: {
                  default: null
              },
              type: {
                  default: null
              },
              src: {
                  default: null
              },
              name: {
                  default: null
              }
          },
          group: `inline`,
          inline: !0,
          draggable: !1,
          selectable: !1,
          atom: !0,
          parseDOM: [{
              tag: `span[data-emoji]`,
              getAttrs: e => ({
                  type: `native`,
                  name: e.getAttribute(`data-emoji`),
                  label: e.textContent
              })
          }, {
              tag: `img[data-emoji]`,
              priority: cl.HIGH,
              getAttrs: e => ({
                  src: e.getAttribute(`src`),
                  name: e.getAttribute(`data-emoji`)
              })
          }],
          toDOM: e => {
              let t = Ic(e.attrs.src);
              return e.attrs.type === `native` ? [`span`, {
                  "data-emoji": e.attrs.name,
                  class: `emoji`
              }, String(e.attrs.label)] : [`img`, {
                  src: t,
                  alt: `Custom emoji ${e.attrs.name}`,
                  title: e.attrs.name,
                  class: `emoji custom-emoji`,
                  "data-emoji": e.attrs.name,
                  style: t ? `background-image: url(${t})` : void 0
              }]
          }
          ,
          toPlainText: e => e.attrs.label || e.attrs.name,
          leafText: e => e.attrs.label || ``
      },
      date: {
          attrs: {
              date: {}
          },
          group: `inline`,
          inline: !0,
          draggable: !0,
          selectable: !0,
          atom: !0,
          parseDOM: [{
              tag: `span[data-date]`,
              getAttrs: e => ({
                  date: $c.validate(e.getAttribute(`data-date`))
              })
          }],
          toDOM: e => [`span`, {
              "data-date": e.attrs.date
          }, $c.format(e.attrs.date)],
          toPlainText: e => $c.format(e.attrs.date),
          leafText: e => $c.format(e.attrs.date)
      },
      ...al,
      unsupported_block_node: {
          attrs: {
              originalNodeData: {
                  default: null
              }
          },
          group: `block allowedInTable allowedInCollapsible firstInListItem`,
          content: ``,
          atom: !0,
          selectable: !0,
          draggable: !1,
          toDOM: e => [`div`, {
              "data-unsupported-block-node": JSON.stringify(e.attrs.originalNodeData)
          }],
          parseDOM: [{
              tag: `div[data-unsupported-block-node]`,
              getAttrs: e => ({
                  originalNodeData: JSON.parse(e.getAttribute(`data-unsupported-block-node`) || `null`)
              })
          }]
      },
      unsupported_inline_node: {
          attrs: {
              originalNodeData: {
                  default: null
              }
          },
          group: `inline`,
          content: ``,
          atom: !0,
          inline: !0,
          selectable: !1,
          toDOM: e => [`span`, {
              "data-unsupported-inline-node": JSON.stringify(e.attrs.originalNodeData)
          }],
          parseDOM: [{
              tag: `span[data-unsupported-inline-node]`,
              getAttrs: e => ({
                  originalNodeData: JSON.parse(e.getAttribute(`data-unsupported-inline-node`) || `null`)
              })
          }]
      }
  }
}
)), dl, fl = t(( () => {
  pn(),
  Bc(),
  ul(),
  dl = new Fee({
      nodes: ll,
      marks: zc
  })
}
));
function pl() {
  return {
      type: `doc`,
      content: [{
          type: `paragraph`
      }]
  }
}
var Lne = t(( () => {}
))
, ml = t(( () => {
  fl(),
  Lne()
}
));
function Rne(e) {
  return ![hl.merged, hl.closed].includes(e)
}
var hl, gl, _l, vl = t(( () => {
  hl = function(e) {
      return e.draft = `draft`,
      e.open = `open`,
      e.reopened = `reopened`,
      e.inReview = `inReview`,
      e.merged = `merged`,
      e.closed = `closed`,
      e
  }({}),
  gl = function(e) {
      return e.closes = `closes`,
      e.contributes = `contributes`,
      e.links = `links`,
      e
  }({}),
  _l = function(e) {
      return e.changesRequested = `changes_requested`,
      e.approved = `approved`,
      e.commented = `commented`,
      e.dismissed = `dismissed`,
      e.pending = `pending`,
      e
  }({})
}
)), yl, bl = t(( () => {
  yl = class {
      static #e = this.visibleTitleLengthInMenus = 100;
      static #t = this.sensibleTitleLength = 200;
      static #n = this.maxTitleLength = 512;
      static #r = this.maxKeyLength = 7;
      static fixupTitle(e) {
          return e.replace(/[\n\t]/g, ` `).replace(/( ){2,}/g, ` `).trim()
      }
      static identifierRegexCoreString(e) {
          let t = e?.matchWithoutHyphen ? `[- ]?` : `-`;
          return `((${e?.teamKeys ? e.teamKeys.join(`|`) : `\\w{1,${this.maxKeyLength}}`})${t}([0-9]{1,9}))`
      }
      static identifierRegexString(e) {
          let t = this.identifierRegexCoreString(e);
          if (e?.open)
              return t;
          if (e?.exact)
              return `^${t}$`;
          let n = `(?:^|\\b|(?<=_))`
            , r = `(?:$|\\b|(?=_))`;
          return e?.excludedWordBoundaries && e.excludedWordBoundaries.length > 0 ? `${n}(?<![${e.excludedWordBoundaries.join(``)}])${t}${r}(?![${e.excludedWordBoundaries.join(``)}])` : `${n}${t}${r}`
      }
      static identifierRegex(e) {
          return new RegExp(this.identifierRegexString(e),e?.flags ?? `i`)
      }
      static parseIdentifierMatch(e) {
          let[,t,n,r] = e;
          if (!t || !n || !r || Number(r).toString().length !== r.length)
              return;
          let i = n.toUpperCase()
            , a = Number(r);
          return {
              rawIdentifier: t,
              identifier: this.formatIssueIdentifier(i, a),
              teamKey: i,
              number: a
          }
      }
      static possibleIdentifier(e) {
          return !!e.match(new RegExp(String.raw`^([A-Za-z]{2,${this.maxKeyLength}}[-\s]?)?\d{1,8}$`,`g`))?.join(`-`)
      }
      static identifierMatch(e, t) {
          let n = e.match(this.identifierRegex(t));
          if (n)
              return this.parseIdentifierMatch(n)
      }
      static identifierMatchAll(e, t) {
          let n = t?.flags ?? `gi`
            , r = this.regexMatchFirstCaptureGroup(new RegExp(this.identifierRegexString(t),n), e);
          if (!r)
              return [];
          let i = n.replace(/g/gi, ``);
          return r.map(e => this.identifierMatch(e, {
              ...t,
              exact: !0,
              flags: i || void 0
          })).filter(this.isIdentifierMatchResult)
      }
      static isIdentifierMatchResult(e) {
          return !!e
      }
      static formatIssueIdentifier(e, t) {
          return `${e}-${t}`
      }
      static getPossiblePreviousIssueNumberForTeam(e, t) {
          for (let n = e.length - 1; n >= 0; n--) {
              let r = e[n];
              if (r.startsWith(`${t}-`))
                  return Number(r.split(`-`)[1])
          }
      }
      static regexMatchFirstCaptureGroup(e, t) {
          let n, r = [];
          for (; (n = e.exec(t)) !== null; )
              r.push(n[1]);
          return r
      }
      static #i = this.activitySummaryCommentCountThreshold = 3
  }
}
)), D, zne, xl, Bne, Sl = t(( () => {
  D = function(e) {
      return e.assignments = `assignments`,
      e.statusChanges = `statusChanges`,
      e.commentsAndReplies = `commentsAndReplies`,
      e.mentions = `mentions`,
      e.reactions = `reactions`,
      e.subscriptions = `subscriptions`,
      e.documentChanges = `documentChanges`,
      e.postsAndUpdates = `postsAndUpdates`,
      e.reminders = `reminders`,
      e.reviews = `reviews`,
      e.appsAndIntegrations = `appsAndIntegrations`,
      e.triage = `triage`,
      e.customers = `customers`,
      e.feed = `feed`,
      e.system = `system`,
      e
  }({}),
  zne = {
      [D.assignments]: `Assignments`,
      [D.statusChanges]: `Status changes`,
      [D.commentsAndReplies]: `Comments and replies`,
      [D.mentions]: `Mentions`,
      [D.reactions]: `Reactions`,
      [D.subscriptions]: `Subscriptions`,
      [D.documentChanges]: `Document changes`,
      [D.postsAndUpdates]: `Updates`,
      [D.reminders]: `Reminders and deadlines`,
      [D.reviews]: `Reviews`,
      [D.appsAndIntegrations]: `Apps and integrations`,
      [D.triage]: `Triage`,
      [D.customers]: `Customer requests`,
      [D.system]: `System notifications`,
      [D.feed]: `Pulse summaries`
  },
  xl = {
      [D.assignments]: `Assignments, unassignments, and membership changes`,
      [D.statusChanges]: `Changes to the status, priority, and blocking relationships of issues`,
      [D.commentsAndReplies]: `Comments, replies, and thread resolutions`,
      [D.mentions]: `Mentions in comments or content`,
      [D.reactions]: `Emoji reactions to your content`,
      [D.subscriptions]: `Issues, projects, initiatives, teams, and views you're subscribed to`,
      [D.documentChanges]: `Changes to document content, location, and subscriptions`,
      [D.postsAndUpdates]: `New project & initiative updates and reminders to post an update`,
      [D.reminders]: `Reminders, due dates, and SLA updates`,
      [D.reviews]: `Pull requests activity, including mentions and comments in reviews`,
      [D.triage]: `Issues added to triage`,
      [D.customers]: `Requests from your customers`,
      [D.appsAndIntegrations]: `Requests related to OAuth apps and integrations`,
      [D.system]: `Important system-level notifications`,
      [D.feed]: `Daily or weekly summaries of your subscribed updates`
  },
  Bne = class {
      static labelForCategory(e) {
          return zne[e]
      }
      static descriptionForCategory(e, t) {
          let {hasTeamUpdates: n, feedSummarySchedule: r} = t;
          if (e === D.postsAndUpdates)
              return n ? `New project, initiative, and team updates and reminders to post an update` : xl[e];
          if (e === D.feed) {
              let e = r && [`Daily`, `Weekly`].includes(r) ? r : `Daily or weekly`;
              return n ? `${e} summaries of your subscribed project, initiative, and team updates` : `${e} summaries of your subscribed project and initiative updates`
          }
          return xl[e]
      }
  }
}
)), Cl, wl, Tl = t(( () => {
  Cl = function(e) {
      return e.activeIssues = `activeIssues`,
      e.activeCycle = `activeCycle`,
      e.upcomingCycle = `upcomingCycle`,
      e.backlog = `backlog`,
      e.triage = `triage`,
      e
  }({}),
  wl = function(e) {
      return e.assigned = `assigned`,
      e
  }({})
}
)), O, El, Dl = t(( () => {
  zn(),
  Sl(),
  Tl(),
  O = function(e) {
      return e.issueCreated = `issueCreated`,
      e.issueMention = `issueMention`,
      e.issueAddedToTriage = `issueAddedToTriage`,
      e.issueAssignedToYou = `issueAssignedToYou`,
      e.issueAddedToView = `issueAddedToView`,
      e.issueUnassignedFromYou = `issueUnassignedFromYou`,
      e.issueNewComment = `issueNewComment`,
      e.issueCommentMention = `issueCommentMention`,
      e.issueCommentReaction = `issueCommentReaction`,
      e.issueThreadResolved = `issueThreadResolved`,
      e.issueEmojiReaction = `issueEmojiReaction`,
      e.issuePriorityUrgent = `issuePriorityUrgent`,
      e.issueSubscribed = `issueSubscribed`,
      e.issueUnsubscribed = `issueUnsubscribed`,
      e.issueBlocking = `issueBlocking`,
      e.issueUnblocked = `issueUnblocked`,
      e.issueReminder = `issueReminder`,
      e.issueStatusChangedDone = `issueStatusChanged`,
      e.issueStatusChangedAll = `issueStatusChangedAll`,
      e.issueReopened = `issueReopened`,
      e.issueDue = `issueDue`,
      e.issueSlackThreadSynced = `issueSlackThreadSynced`,
      e.oauthClientApprovalCreated = `oauthClientApprovalCreated`,
      e.triageResponsibilityIssueAddedToTriage = `triageResponsibilityIssueAddedToTriage`,
      e.issueSlaHighRisk = `issueSlaHighRisk`,
      e.issueSlaBreached = `issueSlaBreached`,
      e.initiativeAddedAsOwner = `initiativeAddedAsOwner`,
      e.initiativeCommentMention = `initiativeCommentMention`,
      e.initiativeNewComment = `initiativeNewComment`,
      e.initiativeThreadResolved = `initiativeThreadResolved`,
      e.initiativeCommentReaction = `initiativeCommentReaction`,
      e.initiativeMention = `initiativeMention`,
      e.initiativeDescriptionContentChange = `initiativeDescriptionContentChange`,
      e.initiativeReminder = `initiativeReminder`,
      e.initiativeDeleted = `initiativeDeleted`,
      e.initiativeRestored = `initiativeRestored`,
      e.initiativeMoved = `initiativeMoved`,
      e.projectAddedAsMember = `projectAddedAsMember`,
      e.projectAddedAsLead = `projectAddedAsLead`,
      e.projectCommentMention = `projectCommentMention`,
      e.projectNewComment = `projectNewComment`,
      e.projectThreadResolved = `projectThreadResolved`,
      e.projectCommentReaction = `projectCommentReaction`,
      e.projectMention = `projectMention`,
      e.projectDescriptionContentChange = `projectDescriptionContentChange`,
      e.projectReminder = `projectReminder`,
      e.projectDeleted = `projectDeleted`,
      e.projectRestored = `projectRestored`,
      e.projectMilestoneCommentMention = `projectMilestoneCommentMention`,
      e.projectMilestoneNewComment = `projectMilestoneNewComment`,
      e.projectMilestoneThreadResolved = `projectMilestoneThreadResolved`,
      e.projectMilestoneCommentReaction = `projectMilestoneCommentReaction`,
      e.projectMilestoneMention = `projectMilestoneMention`,
      e.projectMilestoneDescriptionContentChange = `projectMilestoneDescriptionContentChange`,
      e.documentMention = `documentMention`,
      e.documentCommentMention = `documentCommentMention`,
      e.documentNewComment = `documentNewComment`,
      e.documentThreadResolved = `documentThreadResolved`,
      e.documentCommentReaction = `documentCommentReaction`,
      e.documentReminder = `documentReminder`,
      e.documentMoved = `documentMoved`,
      e.documentDeleted = `documentDeleted`,
      e.documentRestored = `documentRestored`,
      e.documentSubscribed = `documentSubscribed`,
      e.documentUnsubscribed = `documentUnsubscribed`,
      e.documentContentChange = `documentContentChange`,
      e.projectUpdateCreated = `projectUpdateCreated`,
      e.projectUpdatePrompt = `projectUpdatePrompt`,
      e.projectUpdateMention = `projectUpdateMentionPrompt`,
      e.projectUpdateReaction = `projectUpdateReaction`,
      e.projectUpdateNewComment = `projectUpdateNewComment`,
      e.projectUpdateCommentMention = `projectUpdateCommentMention`,
      e.projectUpdateCommentReaction = `projectUpdateCommentReaction`,
      e.initiativeUpdateCreated = `initiativeUpdateCreated`,
      e.initiativeUpdatePrompt = `initiativeUpdatePrompt`,
      e.initiativeUpdateReaction = `initiativeUpdateReaction`,
      e.initiativeUpdateMention = `initiativeUpdateMention`,
      e.initiativeUpdateNewComment = `initiativeUpdateNewComment`,
      e.initiativeUpdateCommentMention = `initiativeUpdateCommentMention`,
      e.initiativeUpdateCommentReaction = `initiativeUpdateCommentReaction`,
      e.teamUpdateNewComment = `teamUpdateNewComment`,
      e.teamUpdateCommentMention = `teamUpdateCommentMention`,
      e.teamUpdateCommentReaction = `teamUpdateCommentReaction`,
      e.teamUpdateCreated = `teamUpdateCreated`,
      e.teamUpdateMention = `teamUpdateMention`,
      e.teamUpdateReaction = `teamUpdateReaction`,
      e.feedSummaryGenerated = `feedSummaryGenerated`,
      e.pullRequestReviewRequested = `pullRequestReviewRequested`,
      e.pullRequestReviewRerequested = `pullRequestReviewRerequested`,
      e.pullRequestApproved = `pullRequestApproved`,
      e.pullRequestChangesRequested = `pullRequestChangesRequested`,
      e.pullRequestCommented = `pullRequestCommented`,
      e.pullRequestChecksFailed = `pullRequestChecksFailed`,
      e.pullRequestMention = `pullRequestMention`,
      e.pullRequestCommentMention = `pullRequestCommentMention`,
      e.pullRequestRemovedFromMergeQueue = `pullRequestRemovedFromMergeQueue`,
      e.customerAddedAsOwner = `customerAddedAsOwner`,
      e.customerNeedCreated = `customerNeedCreated`,
      e.customerNeedMarkedAsImportant = `customerNeedMarkedAsImportant`,
      e.customerNeedResolved = `customerNeedResolved`,
      e.system = `system`,
      e
  }({}),
  El = class e {
      static categoryForType(e) {
          switch (e) {
          case O.issueReopened:
              return D.assignments;
          case O.issuePriorityUrgent:
              return D.statusChanges;
          case O.issueDue:
              return D.reminders;
          case O.oauthClientApprovalCreated:
              return D.appsAndIntegrations;
          case O.system:
              return D.system;
          case O.issueStatusChangedDone:
          case O.issueStatusChangedAll:
              return D.statusChanges;
          case O.pullRequestReviewRequested:
          case O.pullRequestReviewRerequested:
          case O.pullRequestApproved:
          case O.pullRequestChangesRequested:
          case O.pullRequestChecksFailed:
          case O.pullRequestMention:
          case O.pullRequestCommentMention:
          case O.pullRequestCommented:
          case O.pullRequestRemovedFromMergeQueue:
          case O.initiativeUpdatePrompt:
          case O.initiativeUpdateCreated:
          case O.initiativeUpdateReaction:
          case O.initiativeUpdateMention:
          case O.initiativeUpdateNewComment:
          case O.initiativeUpdateCommentMention:
          case O.initiativeUpdateCommentReaction:
          case O.projectUpdatePrompt:
          case O.projectUpdateCreated:
          case O.projectUpdateReaction:
          case O.projectUpdateMention:
          case O.projectUpdateNewComment:
          case O.projectUpdateCommentMention:
          case O.projectUpdateCommentReaction:
          case O.issueAssignedToYou:
          case O.issueUnassignedFromYou:
          case O.projectAddedAsMember:
          case O.projectAddedAsLead:
          case O.projectCommentMention:
          case O.projectNewComment:
          case O.projectThreadResolved:
          case O.projectCommentReaction:
          case O.projectMention:
          case O.projectDescriptionContentChange:
          case O.projectDeleted:
          case O.projectRestored:
          case O.initiativeAddedAsOwner:
          case O.initiativeCommentMention:
          case O.initiativeNewComment:
          case O.initiativeThreadResolved:
          case O.initiativeCommentReaction:
          case O.initiativeMention:
          case O.initiativeDescriptionContentChange:
          case O.initiativeDeleted:
          case O.initiativeRestored:
          case O.initiativeMoved:
          case O.issueSlaHighRisk:
          case O.issueSlaBreached:
          case O.customerNeedCreated:
          case O.customerNeedMarkedAsImportant:
          case O.customerNeedResolved:
          case O.customerAddedAsOwner:
          case O.projectMilestoneCommentMention:
          case O.projectMilestoneNewComment:
          case O.projectMilestoneThreadResolved:
          case O.projectMilestoneCommentReaction:
          case O.projectMilestoneMention:
          case O.projectMilestoneDescriptionContentChange:
          case O.documentCommentMention:
          case O.documentNewComment:
          case O.documentThreadResolved:
          case O.documentCommentReaction:
          case O.documentMention:
          case O.documentContentChange:
          case O.documentMoved:
          case O.documentDeleted:
          case O.documentReminder:
          case O.documentRestored:
          case O.documentSubscribed:
          case O.documentUnsubscribed:
          case O.issueCommentMention:
          case O.issueNewComment:
          case O.issueThreadResolved:
          case O.issueCommentReaction:
          case O.teamUpdateNewComment:
          case O.teamUpdateCommentMention:
          case O.teamUpdateCommentReaction:
          case O.teamUpdateCreated:
          case O.teamUpdateMention:
          case O.teamUpdateReaction:
          case O.feedSummaryGenerated:
          case O.triageResponsibilityIssueAddedToTriage:
          case O.issueAddedToTriage:
          case O.issueAddedToView:
          case O.issueCreated:
          case O.issueMention:
          case O.initiativeReminder:
          case O.projectReminder:
          case O.issueSubscribed:
          case O.issueUnsubscribed:
          case O.issueEmojiReaction:
          case O.issueBlocking:
          case O.issueUnblocked:
          case O.issueReminder:
          case O.issueSlackThreadSynced:
              throw Error(`${e} should not be handled here`);
          default:
              throw y(e)
          }
      }
      static toNotificationPresenter(e) {
          return `${e.capitalize()}NotificationPresenter`
      }
      static get allValues() {
          return Object.values(O).filter(e => typeof e == `string`)
      }
      static getShortLabel(e) {
          switch (e) {
          case O.issuePriorityUrgent:
              return `Urgent priority`;
          case O.issueStatusChangedDone:
          case O.issueStatusChangedAll:
              return `Status updated`;
          case O.issueReopened:
              return `Reopened`;
          case O.issueDue:
              return `Due`;
          case O.oauthClientApprovalCreated:
              return `Application install request`;
          case O.system:
              return `Message from Linear`;
          case O.pullRequestApproved:
          case O.pullRequestReviewRequested:
          case O.pullRequestReviewRerequested:
          case O.pullRequestCommented:
          case O.pullRequestMention:
          case O.pullRequestChangesRequested:
          case O.pullRequestChecksFailed:
          case O.pullRequestCommentMention:
          case O.pullRequestRemovedFromMergeQueue:
          case O.projectUpdatePrompt:
          case O.projectUpdateCreated:
          case O.projectUpdateMention:
          case O.projectUpdateReaction:
          case O.projectUpdateNewComment:
          case O.projectUpdateCommentMention:
          case O.projectUpdateCommentReaction:
          case O.initiativeUpdatePrompt:
          case O.initiativeUpdateCreated:
          case O.initiativeUpdateReaction:
          case O.initiativeUpdateMention:
          case O.initiativeUpdateNewComment:
          case O.initiativeUpdateCommentMention:
          case O.initiativeUpdateCommentReaction:
          case O.issueAssignedToYou:
          case O.issueUnassignedFromYou:
          case O.projectAddedAsMember:
          case O.projectAddedAsLead:
          case O.projectCommentMention:
          case O.projectNewComment:
          case O.projectThreadResolved:
          case O.projectCommentReaction:
          case O.projectMention:
          case O.projectDescriptionContentChange:
          case O.projectDeleted:
          case O.projectRestored:
          case O.initiativeAddedAsOwner:
          case O.initiativeCommentMention:
          case O.initiativeNewComment:
          case O.initiativeThreadResolved:
          case O.initiativeCommentReaction:
          case O.initiativeMention:
          case O.initiativeDescriptionContentChange:
          case O.initiativeDeleted:
          case O.initiativeRestored:
          case O.initiativeMoved:
          case O.issueSlaHighRisk:
          case O.issueSlaBreached:
          case O.customerNeedCreated:
          case O.customerNeedMarkedAsImportant:
          case O.customerNeedResolved:
          case O.customerAddedAsOwner:
          case O.projectMilestoneCommentMention:
          case O.projectMilestoneNewComment:
          case O.projectMilestoneThreadResolved:
          case O.projectMilestoneCommentReaction:
          case O.projectMilestoneMention:
          case O.projectMilestoneDescriptionContentChange:
          case O.documentCommentMention:
          case O.documentNewComment:
          case O.documentThreadResolved:
          case O.documentCommentReaction:
          case O.documentMention:
          case O.documentContentChange:
          case O.documentMoved:
          case O.documentDeleted:
          case O.documentRestored:
          case O.documentReminder:
          case O.documentSubscribed:
          case O.documentUnsubscribed:
          case O.issueCommentMention:
          case O.issueNewComment:
          case O.issueThreadResolved:
          case O.issueCommentReaction:
          case O.teamUpdateNewComment:
          case O.teamUpdateCommentMention:
          case O.teamUpdateCommentReaction:
          case O.teamUpdateCreated:
          case O.teamUpdateMention:
          case O.teamUpdateReaction:
          case O.feedSummaryGenerated:
          case O.issueAddedToTriage:
          case O.triageResponsibilityIssueAddedToTriage:
          case O.issueAddedToView:
          case O.issueCreated:
          case O.issueMention:
          case O.initiativeReminder:
          case O.projectReminder:
          case O.issueSubscribed:
          case O.issueUnsubscribed:
          case O.issueEmojiReaction:
          case O.issueBlocking:
          case O.issueUnblocked:
          case O.issueReminder:
          case O.issueSlackThreadSynced:
              throw Error(`${e} should not be handled here`);
          default:
              throw y(e)
          }
      }
      static #e = this.viewNotificationTypes = [O.issueAddedToView, O.issueStatusChangedDone];
      static get customerNotificationTypes() {
          return [O.customerNeedCreated, O.customerNeedMarkedAsImportant, O.customerNeedResolved]
      }
      static get customViewNotificationTypes() {
          return this.viewNotificationTypes
      }
      static get cycleNotificationTypes() {
          return this.viewNotificationTypes
      }
      static get labelNotificationTypes() {
          return this.viewNotificationTypes
      }
      static get newProjectNotificationTypes() {
          return [O.issueAddedToView, O.issueStatusChangedDone, O.projectUpdateCreated, O.projectNewComment, O.projectMilestoneNewComment]
      }
      static get projectNotificationTypes() {
          return [O.issueCreated, O.issueStatusChangedDone, O.projectUpdateCreated, O.projectNewComment, O.projectMilestoneNewComment, O.projectDescriptionContentChange, O.projectMilestoneDescriptionContentChange, O.customerNeedCreated]
      }
      static get initiativeNotificationTypes() {
          return [O.initiativeNewComment, O.initiativeDescriptionContentChange, O.initiativeUpdateCreated, O.initiativeUpdatePrompt]
      }
      static get teamNotificationTypes() {
          return [O.issueCreated, O.issueStatusChangedDone, O.issueAddedToTriage, O.issueSlaHighRisk, O.issueSlaBreached, O.teamUpdateCreated]
      }
      static teamContextViewNotificationTypes(e) {
          switch (e) {
          case Cl.activeCycle:
          case Cl.activeIssues:
          case Cl.backlog:
          case Cl.upcomingCycle:
              return [O.issueAddedToView, O.issueStatusChangedDone];
          case Cl.triage:
              return [O.issueAddedToTriage];
          case void 0:
              return [O.issueAddedToView, O.issueStatusChangedDone, O.issueAddedToTriage, O.issueSlaHighRisk, O.issueSlaBreached];
          default:
              throw new Rn(e)
          }
      }
      static get userNotificationTypes() {
          return this.viewNotificationTypes
      }
      static get allTypesValidForNotificationSubscriptions() {
          return [...new Set([...this.teamNotificationTypes, ...this.viewNotificationTypes, ...this.projectNotificationTypes, ...this.newProjectNotificationTypes, ...this.initiativeNotificationTypes, ...this.customerNotificationTypes])]
      }
      static get allMentionNotificationTypes() {
          return [O.issueMention, O.issueCommentMention, O.initiativeMention, O.initiativeCommentMention, O.initiativeUpdateMention, O.initiativeUpdateCommentMention, O.projectMention, O.projectMilestoneMention, O.projectCommentMention, O.projectMilestoneCommentMention, O.documentMention, O.documentCommentMention, O.projectUpdateMention, O.projectUpdateCommentMention, O.teamUpdateCommentMention, O.teamUpdateMention]
      }
      static get allCommentNotificationTypes() {
          return [O.issueNewComment, O.projectNewComment, O.documentNewComment, O.projectUpdateNewComment, O.projectMilestoneNewComment, O.initiativeNewComment, O.teamUpdateNewComment]
      }
      static get allReactionNotificationTypes() {
          return [O.issueEmojiReaction, O.issueCommentReaction, O.projectCommentReaction, O.projectMilestoneCommentReaction, O.documentCommentReaction, O.projectUpdateCommentReaction, O.projectUpdateReaction, O.initiativeUpdateCommentReaction, O.initiativeUpdateReaction, O.initiativeCommentReaction, O.teamUpdateCommentReaction, O.teamUpdateReaction]
      }
      static get allThreadResolvedNotificationTypes() {
          return [O.issueThreadResolved, O.initiativeThreadResolved, O.projectThreadResolved, O.projectMilestoneThreadResolved, O.documentThreadResolved]
      }
      static get allCommunicationNotificationTypes() {
          return [...e.allCommentNotificationTypes, ...e.allMentionNotificationTypes, ...e.allThreadResolvedNotificationTypes, ...e.allReactionNotificationTypes]
      }
      static get allReminderNotificationTypes() {
          return [O.issueReminder, O.documentReminder]
      }
  }
}
));
function Vne(e) {
  switch (e) {
  case jl.before:
      return `Planned`;
  case jl.during:
      return `During cycle`;
  case jl.after:
      return `After cycle`;
  default:
      return y(e),
      `Unknown`
  }
}
var Hne, Une, Ol, kl, Wne, Al, jl, Gne, Ml = t(( () => {
  nt(),
  zn(),
  Hne = /^(.+?)([\s/-])(\d+)$/m,
  Une = /^(Cycle|Sprint)([\s/-])(\d+)(.*)/i,
  Ol = `(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)`,
  kl = `[\\/\\-\\.]`,
  Wne = [RegExp(`\\b20[2-9][0-9]$`), RegExp(`\\b${Ol}\\s+\\d{4}$`), RegExp(`\\b${Ol}\\s+\\d{1,2}[-,\\s]\\d{1,2},\\s+\\d{4}$`), RegExp(`\\b${Ol}\\s+\\d{1,2}$`), RegExp(`\\b${Ol}\\s+\\d{1,2}\\s?[-,\\s]\\s?${Ol}?\\s?\\d{1,2}`), RegExp(`\\b[0-3][0-9]${kl}[0-3][0-9]${kl}(20)?[2-9][0-9]$`), RegExp(`\\b[QH][1-4](?:[/-]\\d{2,4})?\\b`)],
  Al = class {
      static #e = this.minTitleLength = 1;
      static #t = this.maxTitleLength = 64;
      static #n = this.minDescriptionLength = 1;
      static #r = this.maxDescriptionLength = 255;
      static parseCycleNameAndNumber(e) {
          let t = e.match(Une);
          if (t) {
              let[,e,n,r,i] = t;
              return {
                  label: e,
                  separator: n,
                  number: Number(r),
                  trailing: i
              }
          }
          let n = e.match(Hne);
          if (n) {
              for (let t of Wne)
                  if (t.test(e))
                      return;
              let[,t,r,i] = n;
              return {
                  label: t,
                  separator: r,
                  number: Number(i),
                  trailing: ``
              }
          }
      }
      static offsetByDaysAccountingForDST(e, t, n) {
          let r = e.offsetByDays(t, n);
          return r.getHours() === 23 ? r = r.offsetByHours(1) : r.getHours() === 1 && (r = r.offsetByHours(-1)),
          r
      }
      static getAddedToCyclePeriod(e, t, n) {
          return e < eee(t, 24).getTime() ? jl.before : e < n.getTime() ? jl.during : jl.after
      }
  }
  ,
  jl = function(e) {
      return e.before = `before`,
      e.during = `during`,
      e.after = `after`,
      e
  }({}),
  Gne = [jl.before, jl.during, jl.after]
}
)), Nl, Pl, Kne, Fl, Il = t(( () => {
  Nl = function(e) {
      return e.team = `team`,
      e.project = `project`,
      e.assignee = `assignee`,
      e.label = `label`,
      e.similarIssue = `similarIssue`,
      e.relatedIssue = `relatedIssue`,
      e
  }({}),
  Pl = function(e) {
      return e.active = `active`,
      e.stale = `stale`,
      e.accepted = `accepted`,
      e.dismissed = `dismissed`,
      e
  }({}),
  Kne = {
      [Nl.team]: 0,
      [Nl.assignee]: 1,
      [Nl.project]: 2,
      [Nl.label]: 3,
      [Nl.similarIssue]: 4,
      [Nl.relatedIssue]: 5
  },
  Fl = {
      [Pl.accepted]: 0,
      [Pl.active]: 1,
      [Pl.dismissed]: 2,
      [Pl.stale]: 3
  }
}
)), Ll, Rl = t(( () => {
  Ll = class {
      constructor(e, t) {
          this.name = e,
          this.priority = t
      }
      get filterValue() {
          return this.priority
      }
      get isNoPriority() {
          return this.priority === 0
      }
      get isUrgent() {
          return this.priority === 1
      }
      get isHigh() {
          return this.priority === 2
      }
      get isMedium() {
          return this.priority === 3
      }
      get isLow() {
          return this.priority === 4
      }
      get id() {
          return this.priority.toString()
      }
      get orderedPriority() {
          return this.priority === 0 ? 100 : this.priority
      }
  }
}
)), zl, Bl = t(( () => {
  Rl(),
  zl = class e extends Ll {
      static #e = this.NoPriority = new e(`No priority`,0);
      static #t = this.Urgent = new e(`Urgent`,1);
      static #n = this.High = new e(`High`,2);
      static #r = this.Medium = new e(`Medium`,3);
      static #i = this.Low = new e(`Low`,4);
      static createFromPriority(t) {
          switch (t) {
          case 1:
              return e.Urgent;
          case 2:
              return e.High;
          case 3:
              return e.Medium;
          case 4:
              return e.Low;
          case 0:
          default:
              return e.NoPriority
          }
      }
      static createFromName(e) {
          for (let t of this.allPriorities)
              if (t.name.toLowerCase() === e.toLowerCase() || Number(e) === t.priority)
                  return t
      }
      static get allPriorities() {
          return [e.NoPriority, e.Urgent, e.High, e.Medium, e.Low]
      }
  }
}
)), Vl, Hl, Ul = t(( () => {
  Xs(),
  Vl = function(e) {
      return e.slackMessage = `slackMessage`,
      e.slackChannel = `slackChannel`,
      e.githubComment = `githubComment`,
      e.githubIssue = `githubIssue`,
      e.githubIssueFailure = `githubIssueFailure`,
      e.githubPullRequest = `githubPullRequest`,
      e.githubPullRequestReview = `githubPullRequestReview`,
      e.githubPullRequestReviewComment = `githubPullRequestReviewComment`,
      e.gitlabMergeRequest = `gitlabMergeRequest`,
      e.gitlabNote = `gitlabNote`,
      e.jiraIssue = `jiraIssue`,
      e.jiraEpic = `jiraEpic`,
      e.jiraIssueFailure = `jiraIssueFailure`,
      e.jiraEpicFailure = `jiraEpicFailure`,
      e.jiraComment = `jiraComment`,
      e.jiraComponent = `jiraComponent`,
      e.notionUnfurl = `notionUnfurl`,
      e.emailMessage = `emailMessage`,
      e.gongCall = `gongCall`,
      e
  }({}),
  Hl = function(e) {
      return e[e.jira = T.jira] = `jira`,
      e[e.github = T.github] = `github`,
      e[e.slack = T.slack] = `slack`,
      e
  }({})
}
)), Wl, Gl = t(( () => {
  Wl = class e {
      static getStateCompositeKey(e) {
          return `${e.type}:${e.name.toLowerCase()}`
      }
      static getAggregatedTimeByState(t, n, r) {
          let i = new Map
            , a = t?.accumulatedTimeByState;
          if (a == null)
              return i;
          for (let t in a) {
              let o = n(t);
              if (o) {
                  let n = o.compositeKey ?? e.getStateCompositeKey(o)
                    , s = i.get(n);
                  s ? (s.duration += a[t],
                  r(s.state, o) && (s.state = o)) : i.set(n, {
                      state: o,
                      duration: a[t]
                  })
              }
          }
          return i
      }
  }
}
)), Kl, ql, Jl = t(( () => {
  Kl = function(e) {
      return e.none = `none`,
      e.due = `due`,
      e.dueSoon = `dueSoon`,
      e.dueToday = `dueToday`,
      e.overdue = `overdue`,
      e
  }({}),
  ql = class {
      static qualifierForDueDate(e, t) {
          if (!e)
              return Kl.none;
          let n = t ?? new Date
            , r = e instanceof Date ? e : e.toLocalDate()
            , i = n.midnight().daysTo(r.midnight());
          return t ? i >= 0 ? Kl.none : Kl.overdue : i > 7 ? Kl.due : i > 0 ? Kl.dueSoon : i === 0 ? Kl.dueToday : Kl.overdue
      }
      static get allDueDateQualifierTypes() {
          return [Kl.none, Kl.due, Kl.dueSoon, Kl.dueToday, Kl.overdue]
      }
  }
}
)), Yl, Xl, Zl = t(( () => {
  Yl = function(e) {
      return e.confirm = `confirm`,
      e.cancel = `cancel`,
      e.reject = `reject`,
      e
  }({}),
  Xl = class e {
      constructor(t) {
          if (!e.implementation)
              throw Error(`AlertDialog implementation not registered. Call AlertDialog.register() first.`);
          this.instance = new e.implementation(t)
      }
      show() {
          return this.instance.show()
      }
      static register(t) {
          e.implementation = t
      }
  }
}
)), Ql, $l, eu = t(( () => {
  Ql = e(le(), 1),
  $l = e => (0,
  Ql.default)(e?.normalize(`NFKD`))
}
)), tu, nu, ru, iu = t(( () => {
  tu = e(ye(), 1),
  nu = e(be(), 1),
  ru = class {
      static #e = this.txtPrefix = `linear-domain-verification`;
      static #t = this.domainRegexp = /^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$/i;
      static #n = this.superUserDomains = [`linear.app`, `artman.fi`, `eldh.co`];
      static #r = this.superUserUrlKeys = [`linear`, `linear-xl`];
      static validVerificationEmailForDomain(e, t) {
          let n = RegExp(`^[-!#$%&'*+/0-9=?A-Z^_a-z{|}~](.?[-!#$%&'*+/0-9=?A-Z^_a-z{|}~])*@` + (0,
          nu.default)(e) + `$`, `i`);
          return !!t.match(n)
      }
      static nameFromDomain(e) {
          return (0,
          tu.default)(e.slice(0, e.lastIndexOf(`.`)))
      }
      static verificationValue(e) {
          return `${this.txtPrefix}=${e}`
      }
      static #i = this.PUBLIC_DOMAINS = `10mail.org,10mail.xyz,163.com,alice.it,aol.com,appleid.com,att.net,bigpond.com,comcast.net,cox.net,dropmail.me,duck.com,emlhub.com,emlpro.com,emltmp.com,facebook.com,fastmail.com,flymail.tk,free.fr,freeml.net,gmail.com,gmx.de,googlemail.com,hey.com,hotmail.co.uk,hotmail.com,hotmail.fr,hotmail.it,icloud.com,ig.com.br,laposte.net,laste.ml,libero.it,live.co.uk,live.com,live.fr,live.nl,mac.com,mail.ru,me.com,minimail.gq,msn.com,neuf.fr,outlook.com,outlook.de,outlook.es,outlook.fr,outlook.it,outlook.nl,pm.me,privaterelay.appleid.com,proton.me,protonmail.com,qq.com,rocketmail.com,sbcglobal.net,sfr.fr,simplelogin.com,spymail.one,terra.com.br,verizon.net,web.de,yahoo.com,yahoo.de,yahoo.es,yahoo.fr,yahoo.it,yahoo.nl,yandex.ru,ymail.com,yomail.info,yopmail.com`.split(`,`);
      static sanitizeDomain(e) {
          if (!e)
              return e;
          try {
              return new URL(e).hostname.toLowerCase()
          } catch {
              return e.trim().toLowerCase()
          }
      }
  }
}
));
function qne(e) {
  switch (e) {
  case au.adminSuspended:
      return `Suspended by admin`;
  case au.downgraded:
      return `Disabled due to plan downgrade`;
  case au.invitePending:
      return `Invite pending`;
  case au.leftWorkspace:
      return `Left workspace`;
  case au.notInGoogleHostedDomain:
      return `Disabled as email does not belong to the Google workspace`;
  default:
      throw new Rn(e)
  }
}
var au, ou = t(( () => {
  zn(),
  au = function(e) {
      return e.adminSuspended = `adminSuspended`,
      e.downgraded = `downgraded`,
      e.invitePending = `invitePending`,
      e.leftWorkspace = `leftWorkspace`,
      e.notInGoogleHostedDomain = `notInGoogleHostedDomain`,
      e
  }({})
}
)), su, cu, lu, uu, du = t(( () => {
  zn(),
  su = function(e) {
      return e.owner = `owner`,
      e.admin = `admin`,
      e.guest = `guest`,
      e.user = `user`,
      e.app = `app`,
      e
  }({}),
  cu = {
      [su.owner]: [su.admin, su.user],
      [su.admin]: [su.owner, su.user],
      [su.user]: [su.owner, su.admin, su.guest],
      [su.guest]: [su.user],
      [su.app]: []
  },
  lu = [su.owner, su.admin, su.user, su.app, su.guest],
  (function(e) {
      function t(e) {
          if (cu[e])
              return cu[e];
          throw new Rn(e)
      }
      e.getEligibleUserRoleChanges = t;
      function n(e) {
          let t = lu.indexOf(e);
          if (t === -1)
              throw new Rn(e);
          return lu.slice(0, t + 1)
      }
      e.rolesEqualToOrHigherThanRole = n;
      function r(e, t) {
          return e === su.app ? !1 : n(e).includes(t) && e !== t
      }
      e.isPromoting = r;
      function i(e, t={}) {
          let n = [su.owner, su.admin, su.app].includes(e) ? `an` : `a`
            , r = e === su.user ? `member` : e;
          return t.article ? `${n} ${r}` : r
      }
      e.getRoleString = i
  }
  )(uu ||= {})
}
)), fu, pu = t(( () => {
  fu = e => {
      let t = /^\p{Letter}/u
        , n = e.includes(`@`) ? e.split(`@`)[0].replace(/\./, ` `) : e
        , r = (n.match(/\S+/g) || []).filter(e => t.test(e));
      return r.length > 1 ? `${r[0]?.[0]}${r[r.length - 1]?.[0]}`.toUpperCase() : n.slice(0, 2).toUpperCase()
  }
}
)), mu, hu, gu, _u = t(( () => {
  mu = function(e) {
      return e.updatedSlackThreadSyncIntegration = `updatedSlackThreadSyncIntegration`,
      e.completedOnboarding = `completedOnboarding`,
      e.desktopInstalled = `desktopInstalled`,
      e.teamsPageIntroductionDismissed = `teamsPageIntroductionDismissed`,
      e.joinTeamIntroductionDismissed = `joinTeamIntroductionDismissed`,
      e.desktopDownloadToastDismissed = `desktopDownloadToastDismissed`,
      e.emptyBacklogDismissed = `emptyBacklogDismissed`,
      e.emptyCustomViewsDismissed = `emptyCustomViewsDismissed`,
      e.emptyActiveIssuesDismissed = `emptyActiveIssuesDismissed`,
      e.emptyMyIssuesDismissed = `emptyMyIssuesDismissed`,
      e.triageWelcomeDismissed = `triageWelcomeDismissed`,
      e.cycleWelcomeDismissed = `cycleWelcomeDismissed`,
      e.projectWelcomeDismissed = `projectWelcomeDismissed`,
      e.projectBacklogWelcomeDismissed = `projectBacklogWelcomeDismissed`,
      e.projectUpdatesWelcomeDismissed = `projectUpdatesWelcomeDismissed`,
      e.pulseWelcomeDismissed = `pulseWelcomeDismissed`,
      e.analyticsWelcomeDismissed = `analyticsWelcomeDismissed`,
      e.insightsWelcomeDismissed = `insightsWelcomeDismissed`,
      e.insightsHelpDismissed = `insightsHelpDismissed`,
      e.figmaPromptDismissed = `figmaPromptDismissed`,
      e.issueMovePromptCompleted = `issueMovePromptCompleted`,
      e.migrateThemePreference = `migrateThemePreference`,
      e.listSelectionTip = `listSelectionTip`,
      e.emptyParagraphSlashCommandTip = `emptyParagraphSlashCommandTip`,
      e.editorSlashCommandUsed = `editorSlashCommandUsed`,
      e.canPlaySnake = `canPlaySnake`,
      e.canPlayTetris = `canPlayTetris`,
      e.importBannerDismissed = `importBannerDismissed`,
      e.tryInvitePeopleDismissed = `tryInvitePeopleDismissed`,
      e.tryRoadmapsDismissed = `tryRoadmapsDismissed`,
      e.tryCyclesDismissed = `tryCyclesDismissed`,
      e.tryTriageDismissed = `tryTriageDismissed`,
      e.tryGithubDismissed = `tryGithubDismissed`,
      e.rewindBannerDismissed = `rewindBannerDismissed`,
      e.helpIslandFeatureInsightsDismissed = `helpIslandFeatureInsightsDismissed`,
      e.dueDateShortcutMigration = `dueDateShortcutMigration`,
      e.slackCommentReactionTipShown = `slackCommentReactionTipShown`,
      e.issueLabelSuggestionUsed = `issueLabelSuggestionUsed`,
      e.threadedCommentsNudgeIsSeen = `threadedCommentsNudgeIsSeen`,
      e.desktopTabsOnboardingDismissed = `desktopTabsOnboardingDismissed`,
      e.milestoneOnboardingIsSeenAndDismissed = `milestoneOnboardingIsSeenAndDismissed`,
      e.projectBoardOnboardingIsSeenAndDismissed = `projectBoardOnboardingIsSeenAndDismissed`,
      e.figmaPluginBannerDismissed = `figmaPluginBannerDismissed`,
      e.initiativesBannerDismissed = `initiativesBannerDismissed`,
      e.commandMenuClearShortcutTip = `commandMenuClearShortcutTip`,
      e.slackBotWelcomeMessageShown = `slackBotWelcomeMessageShown`,
      e.slackAgentPromoFromCreateNewIssueShown = `slackAgentPromoFromCreateNewIssueShown`,
      e
  }({}),
  (function(e) {
      e.all = () => Object.values(mu).filter(e => typeof e == `string`)
  }
  )(mu ||= {}),
  hu = {
      [mu.editorSlashCommandUsed]: 5,
      [mu.emptyParagraphSlashCommandTip]: 50,
      [mu.commandMenuClearShortcutTip]: 20
  },
  gu = function(e) {
      return e.incr = `incr`,
      e.decr = `decr`,
      e.clear = `clear`,
      e.lock = `lock`,
      e
  }({})
}
)), vu, Jne = t(( () => {
  vu = {
      start: 8,
      end: 18
  }
}
));
function yu(e) {
  return `end`in e && `start`in e
}
function bu(e) {
  return {
      start: e,
      end: e
  }
}
var xu, Su, Cu, wu = t(( () => {
  nt(),
  Oe(),
  Yr(),
  Un(),
  Jne(),
  xu = function(e) {
      return e.outOfOffice = `outOfOffice`,
      e
  }({}),
  Su = class {
      static #e = this.LEAVING_OOO_THRESHOLD_HOURS = 1;
      static #t = this.ENTERING_OOO_THRESHOLD_HOURS = 2;
      static #n = this.NEXT_INTERVAL_LOOKAHEAD_HOURS = 24;
      static #r = this.NEXT_INTERVAL_THRESHOLD_HOURS = 36;
      static #i = this.SHORT_EVENT_IN_HOURS = 4;
      static #a = this.EVENT_IS_FULL_DAY_HOURS = 6;
      static #o = this.WORKING_HOURS_START_TOLERANCE_HOURS = 2;
      static #s = this.WORKING_HOURS_END_TOLERANCE_HOURS = 4;
      static humanizeEventsInterval(e, t, n) {
          let r = this.getEventsIntervalAtDate(e, t, n)
            , i = this.getNextEventsIntervalFromDate(e, t, n);
          if (r) {
              let t = new Date(r.end);
              return this.getOutOfOfficeDuration(e, t)
          } else if (i) {
              if (Ze(i.start, e) > this.NEXT_INTERVAL_LOOKAHEAD_HOURS)
                  return;
              let t = new Date(i.start)
                , n = new Date(i.end)
                , r = Ze(t, e)
                , a = Ze(i.end, i.start);
              return r < this.ENTERING_OOO_THRESHOLD_HOURS && a > this.SHORT_EVENT_IN_HOURS ? this.getOutOfOfficeDuration(e, n) : a <= this.NEXT_INTERVAL_THRESHOLD_HOURS ? void 0 : `${this.getOutOfOfficeDuration(t, new Date(i.end))} starting ${Ve(t) === Ve(e) ? `today` : `tomorrow`}`
          }
      }
      static getEventsIntervalAtDate(e, t, n) {
          let r = yu(e) ? e : bu(e);
          for (let[e,i] of t.map(e => [e.startsAt, e.endsAt]))
              if (ct(r, {
                  start: e,
                  end: i
              }, {
                  inclusive: !0
              }))
                  return this.expandIntervalThroughEvents({
                      start: e,
                      end: i
                  }, t, n)
      }
      static getNextEventsIntervalFromDate(e, t, n) {
          let r = yu(e) ? e : bu(e);
          for (let[e,i] of t.map(e => [e.startsAt, e.endsAt]))
              if (Ne(r.end, e))
                  return this.expandIntervalThroughEvents({
                      start: e,
                      end: i
                  }, t, n)
      }
      static isShortEvent(e) {
          return Ze(e.endsAt, e.startsAt) <= this.SHORT_EVENT_IN_HOURS
      }
      static isOutOfOfficeBasedOnTitle(e) {
          return Cu.test(e)
      }
      static expandIntervalThroughEvents(e, t, n) {
          let r = {
              ...e
          };
          for (let[e,i] of t.map(e => [e.startsAt, e.endsAt]))
              if (ct(r, {
                  start: e,
                  end: i
              }, {
                  inclusive: !0
              }))
                  je(i, r.end) && (r.end = i);
              else {
                  let t = De(r.end, n)
                    , a = De(e, n)
                    , o = vu.start + this.WORKING_HOURS_START_TOLERANCE_HOURS
                    , s = vu.end - this.WORKING_HOURS_END_TOLERANCE_HOURS;
                  (t.hour() >= s || t.hour() === 0) && a.hour() <= o && Ze(e, r.end) <= 20 ? je(i, r.end) && (r.end = i) : (t.day() === Vn.Friday && t.hour() >= s || t.day() > Vn.Friday) && a.day() === Vn.Monday && a.hour() <= o && $e(e, r.end) <= 3 && je(i, r.end) && (r.end = i)
              }
          return r
      }
      static getOutOfOfficeDuration(e, t) {
          let n = Ze(t, e)
            , r = lt(t, e)
            , i = vu.end - this.WORKING_HOURS_END_TOLERANCE_HOURS;
          if (r >= 7)
              return `until ${xr(t)}`;
          if (r > 1)
              return `until ${Bn((t.getHours() >= i ? ze(t, 1) : t).getDay()).substring(0, 3)}`;
          if (t.getDay() !== e.getDay() && t.getHours() >= i)
              return `two days`;
          if (n >= this.EVENT_IS_FULL_DAY_HOURS)
              return `today`;
          if (n > this.LEAVING_OOO_THRESHOLD_HOURS)
              return `${n} hours`
      }
  }
  ,
  Cu = /\b(ooo|out\s+of\s+(the\s+)?office|pto|vacation(ing)?|holiday(ing|s)?)\b/i
}
)), Tu, Eu, Du = t(( () => {
  Tu = function(e) {
      return e.pending = `pending`,
      e.accepted = `accepted`,
      e.expired = `expired`,
      e
  }({}),
  Eu = new Date(`2023-09-01`)
}
)), Ou, ku = t(( () => {
  Ou = function(e) {
      return e.project = `project`,
      e.cycle = `cycle`,
      e.label = `label`,
      e.projectLabel = `projectLabel`,
      e.issue = `issue`,
      e.customView = `customView`,
      e.predefinedView = `predefinedView`,
      e.document = `document`,
      e.initiative = `initiative`,
      e.folder = `folder`,
      e.user = `user`,
      e.facet = `facet`,
      e.customer = `customer`,
      e.dashboard = `dashboard`,
      e.pullRequest = `pullRequest`,
      e
  }({})
}
)), Au, ju, Mu = t(( () => {
  Au = e(js(), 1),
  Ns(),
  ju = (e, t=70) => {
      let n = (0,
      Au.default)(e, {
          replacement: `-`,
          remove: /[*+~%\<\>\\/;.(){}?,'"`!:@#^|\[\]]/g,
          lower: !0
      }).toLowerCase();
      Au.default.extend({
          "<": ``
      }),
      Au.default.extend({
          ">": ``
      }),
      Au.default.extend({
          "": `-`
      }),
      Au.default.extend({
          _: `-`
      });
      let r = n.split(`-`).map(e => e.replace(Ms(), ``)).filter(Boolean);
      if (r.length > 0 && r[0].length > t)
          return r[0].slice(0, t);
      let i = [];
      for (let e of r)
          if ([...i, e].join(`-`).length <= t)
              i.push(e);
          else
              break;
      let a = i.join(`-`);
      return a ? a === `edit` ? `edt` : a : `untitled`
  }
}
)), Nu, Pu, Fu, Iu, Lu, Ru = t(( () => {
  Nu = e(h(), 1),
  Mu(),
  Pu = function(e) {
      return e.team = `team`,
      e.template = `template`,
      e.asks = `asks`,
      e
  }({}),
  Fu = 64,
  Iu = {
      issueCreated: {
          title: `Created issue auto-reply`,
          template: `An issue ({{issue.identifier}}) has been created from your email.

You can reply with any additional information.`,
          variables: [`issue.identifier`, `issue.title`],
          autoReplyField: `issueCreatedAutoReply`,
          autoReplyToggleField: `issueCreatedAutoReplyEnabled`,
          required: !1
      },
      issueCompleted: {
          title: `Completed issue auto-reply`,
          template: `{{user.name}} changed status to {{issue.state}}.`,
          variables: [`issue.state`, `issue.identifier`, `issue.title`, `user.name`],
          autoReplyField: `issueCompletedAutoReply`,
          autoReplyToggleField: `issueCompletedAutoReplyEnabled`,
          required: !1
      },
      issueCanceled: {
          title: `Canceled issue auto-reply`,
          template: `{{user.name}} changed status to {{issue.state}}.`,
          variables: [`issue.state`, `issue.identifier`, `issue.title`, `user.name`],
          autoReplyField: `issueCanceledAutoReply`,
          autoReplyToggleField: `issueCanceledAutoReplyEnabled`,
          required: !1
      }
  },
  Lu = class e {
      static #e = this.emailRegexp = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      static isEmail(e) {
          return this.emailRegexp.test(e)
      }
      static parseDomain(e) {
          return e.split(`@`).pop()
      }
      static formatEmailAddress(e, t={
          bracketStyle: `chevrons`
      }) {
          if (e.name) {
              let n = e.name.replace(/^"+|"+$/g, ``);
              if (t.bracketStyle === `chevrons`) {
                  let t = n.replace(/\\/g, `\\\\`).replace(/"/g, `\\"`);
                  return `${/[",;:<>\@\(\)\[\]\\]/.test(n) || /\s/.test(n) ? `"${t}"` : t} <${e.address}>`
              } else
                  return `${n} (${e.address})`
          }
          return e.address
      }
      static isExternalEmail(e, t) {
          if (!this.emailRegexp.test(t))
              return !1;
          let n = this.parseDomain(t);
          return n ? !e.includes(n) : !1
      }
      static getAddressFromEmailAddress(e) {
          return e.toLowerCase().split(`@`)[0].split(`-`).pop()
      }
      static emailIntakeAddressToEmailAddress(e) {
          let {address: t, template: n, team: r, emailIntakeHostname: i, type: a, staticSlug: o} = e;
          if (o)
              return `${o}-${t}@${i}`;
          if (a === Pu.asks)
              return `${t}@${i}`;
          let s = ju((n ? n.name : r ? r.name : `linear`).replace(/[^a-zA-Z0-9 \-_]/g, ``), Fu - 1 - t.length);
          return `${s ? s + `-` : ``}${t}@${i}`
      }
      static getToEmail(e) {
          return e.emailDirection === `outbound` && e.to?.[0] ? e.to[0] : e.replyTo?.[0] ? e.replyTo?.[0] : e.from
      }
      static getCcEmails(t, n, r) {
          let i = t.emailDirection === `outbound` ? t.cc ?? [] : [...t.to ?? [], ...t.cc ?? []];
          n && i.push(n);
          let a = [];
          for (let t of i)
              e.matchAddress(t.address, r) || a.push(t);
          return (0,
          Nu.default)(a, e => e.address.toLowerCase())
      }
      static matchAddress(t, n) {
          for (let r of n)
              if (`emailAddress`in r) {
                  if (t.toLowerCase().trim() === r.emailAddress.toLowerCase().trim())
                      return !0
              } else if (e.parseDomain(t) === r.domain && e.getAddressFromEmailAddress(t)?.toLowerCase() === r.address)
                  return !0;
          return !1
      }
  }
}
)), k, zu, Bu = t(( () => {
  k = function(e) {
      return e.inbox = `inbox`,
      e.myIssues = `myIssues`,
      e.myIssuesCreatedByMe = `myIssuesCreatedByMe`,
      e.myIssuesSubscribedTo = `myIssuesSubscribedTo`,
      e.myIssuesActivity = `myIssuesActivity`,
      e.userProfile = `userProfile`,
      e.userProfileCreatedByUser = `userProfileCreatedByUser`,
      e.board = `board`,
      e.completedCycle = `completedCycle`,
      e.cycle = `cycle`,
      e.release = `release`,
      e.project = `project`,
      e.projectDocuments = `projectDocuments`,
      e.label = `label`,
      e.triage = `triage`,
      e.activeIssues = `activeIssues`,
      e.backlog = `backlog`,
      e.subIssues = `subIssues`,
      e.allIssues = `allIssues`,
      e.dashboards = `dashboards`,
      e.customView = `customView`,
      e.customViews = `customViews`,
      e.initiative = `initiative`,
      e.initiativeOverview = `initiativeOverview`,
      e.initiativeOverviewSubInitiatives = `initiativeOverviewSubInitiatives`,
      e.initiatives = `initiatives`,
      e.initiativesPlanned = `initiativesPlanned`,
      e.initiativesCompleted = `initiativesCompleted`,
      e.projects = `projects`,
      e.projectsAll = `projectsAll`,
      e.projectsBacklog = `projectsBacklog`,
      e.projectsClosed = `projectsClosed`,
      e.projectLabel = `projectLabel`,
      e.search = `search`,
      e.splitSearch = `splitSearch`,
      e.teams = `teams`,
      e.archive = `archive`,
      e.quickView = `quickView`,
      e.issueIdentifiers = `issueIdentifiers`,
      e.customers = `customers`,
      e.customer = `customer`,
      e.embeddedCustomerNeeds = `embeddedCustomerNeeds`,
      e.projectCustomerNeeds = `projectCustomerNeeds`,
      e.reviews = `reviews`,
      e.myReviews = `myReviews`,
      e.agents = `agents`,
      e.feedAll = `feedAll`,
      e.feedCreated = `feedCreated`,
      e.feedFollowing = `feedFollowing`,
      e.feedPopular = `feedPopular`,
      e.workspaceMembers = `workspaceMembers`,
      e.roadmapAll = `roadmapAll`,
      e.roadmap = `roadmap`,
      e.roadmaps = `roadmaps`,
      e.roadmapClosed = `roadmapClosed`,
      e.roadmapBacklog = `roadmapBacklog`,
      e
  }({}),
  k.subIssues,
  k.customer,
  k.embeddedCustomerNeeds,
  zu = [k.subIssues, k.embeddedCustomerNeeds, k.myIssues, k.myIssuesCreatedByMe, k.myIssuesSubscribedTo, k.myIssuesActivity, k.inbox, k.splitSearch, k.search, k.quickView, k.customViews, k.dashboards, k.myReviews, k.agents]
}
)), Vu, Hu, Uu, Wu, Gu, Ku, qu, Ju = t(( () => {
  Vu = function(e) {
      return e.read = `read`,
      e.write = `write`,
      e.admin = `admin`,
      e.owner = `owner`,
      e[`issues:create`] = `issues:create`,
      e[`comments:create`] = `comments:create`,
      e[`timeSchedule:write`] = `timeSchedule:write`,
      e.webhook = `webhook`,
      e[`app:mentionable`] = `app:mentionable`,
      e[`app:assignable`] = `app:assignable`,
      e[`customer:read`] = `customer:read`,
      e[`customer:write`] = `customer:write`,
      e[`initiative:read`] = `initiative:read`,
      e[`initiative:write`] = `initiative:write`,
      e
  }({}),
  Hu = Object.values(Vu),
  Uu = Hu.filter(e => e !== Vu.owner),
  Wu = {
      [Vu.read]: Vu.read,
      [Vu.write]: Vu.write,
      [Vu.admin]: Vu.admin,
      [Vu[`issues:create`]]: Vu[`issues:create`],
      [Vu[`comments:create`]]: Vu[`comments:create`]
  },
  Gu = {
      [Vu.read]: `Read`,
      [Vu.write]: `Write`,
      [Vu.admin]: `Admin`,
      [Vu[`issues:create`]]: `Create issues`,
      [Vu[`comments:create`]]: `Create comments`,
      [Vu[`timeSchedule:write`]]: `Create time schedules`,
      [Vu.webhook]: `Create webhooks`,
      [Vu[`app:mentionable`]]: `Mention the app`,
      [Vu[`app:assignable`]]: `Assign issues and projects to the app`,
      [Vu[`customer:read`]]: `Read data about customers`,
      [Vu[`customer:write`]]: `Read and write data about customers`,
      [Vu[`initiative:read`]]: `Read data about initiatives`,
      [Vu[`initiative:write`]]: `Read and write data about initiatives`
  },
  Ku = {
      [Vu.read]: `Read all workspace data available to you`,
      [Vu.write]: `Read and write all workspace data available to you`,
      [Vu.admin]: `Access admin-only API features`,
      [Vu[`issues:create`]]: `Create and update issues`,
      [Vu[`comments:create`]]: `Create and update issue comments`,
      [Vu[`timeSchedule:write`]]: `Create and update time schedules`,
      [Vu.webhook]: `Create webhooks`,
      [Vu[`app:mentionable`]]: `Mention the app`,
      [Vu[`app:assignable`]]: `Delegate issues to the app or add the app as a project member`,
      [Vu[`customer:read`]]: `Read data about customers in the workspace`,
      [Vu[`customer:write`]]: `Read and write data about customers in the workspace`,
      [Vu[`initiative:read`]]: `Read data about initiatives in the workspace`,
      [Vu[`initiative:write`]]: `Read and write data about initiatives in the workspace`
  },
  qu = [Vu[`initiative:read`], Vu[`initiative:write`], Vu[`customer:read`], Vu[`customer:write`], Vu[`app:mentionable`], Vu[`app:assignable`]]
}
)), Yu, Yne = t(( () => {
  Ju(),
  (function(e) {
      function t(e) {
          let {isAppUser: t, appScopes: n} = e;
          return !t || t && !!n?.includes(Vu[`app:mentionable`])
      }
      e.isMentionable = t;
      function n(e) {
          let {isAppUser: t, appScopes: n} = e;
          return !t || t && !!n?.includes(Vu[`app:assignable`])
      }
      e.isAssignable = n
  }
  )(Yu ||= {})
}
));
function Xu(e) {
  return e != null
}
function Zu(e) {
  if (!Xu(e))
      throw Error(`Value of type ${typeof e} expected to be defined`)
}
function Qu(e) {
  return Object.keys(e)
}
function $u(e) {
  return Object.entries(e)
}
var ed = t(( () => {}
)), td, nd, rd, id, ad = t(( () => {
  td = function(e) {
      return e.activeIssueCount = `activeIssueCount`,
      e.fileUploadVolume = `fileUploadVolume`,
      e.singleFileUploadSize = `singleFileUploadSize`,
      e.pendingInviteCount = `pendingInviteCount`,
      e.teamCount = `teamCount`,
      e
  }({}),
  nd = function(e) {
      return e.under = `under`,
      e.nearing = `nearing`,
      e.exceeded = `exceeded`,
      e.overlyExceeded = `overlyExceeded`,
      e
  }({}),
  rd = [nd.under, nd.nearing, nd.exceeded, nd.overlyExceeded],
  id = class e {
      static #e = this.SUPPORT_FORM_FILE_SIZE_LIMIT_MB = 250;
      static #t = this.NEARING_LIMIT_THRESHOLD = .9;
      static #n = this.OVERLY_EXCEEDING_MULTIPLIER = 1.1;
      static #r = this.limits = {
          [td.activeIssueCount]: 250,
          [td.fileUploadVolume]: 150,
          [td.singleFileUploadSize]: 10,
          [td.pendingInviteCount]: 25,
          [td.teamCount]: 2
      };
      static isFileUploadAllowedForSupportForm(e) {
          return e <= this.SUPPORT_FORM_FILE_SIZE_LIMIT_MB
      }
      static isFileUploadAllowed(t) {
          let n = e.limits[td.singleFileUploadSize];
          return {
              exceedsLimit: t > n,
              allowed: t <= n * e.OVERLY_EXCEEDING_MULTIPLIER
          }
      }
      static isPendingInviteAllowed(t) {
          return t <= e.limits[td.pendingInviteCount]
      }
      static getUsageMetricStatus(t, n, r) {
          let i;
          return r ? n >= r * e.OVERLY_EXCEEDING_MULTIPLIER ? i = nd.overlyExceeded : n >= r ? i = nd.exceeded : n >= e.NEARING_LIMIT_THRESHOLD * r && (i = nd.nearing) : i = nd.under,
          {
              metric: t,
              currentValue: n,
              maximumValue: r,
              percentage: r ? Math.round(n / r * 100) : 0,
              flag: i
          }
      }
      static isAboveOrEqual(e, t) {
          return rd.indexOf(e) >= rd.indexOf(t)
      }
      static isBelowOrEqual(e, t) {
          return rd.indexOf(e) <= rd.indexOf(t)
      }
  }
}
)), od, A, sd, cd, ld, j, ud, dd, fd, pd, md, hd = t(( () => {
  od = e(ye(), 1),
  zn(),
  A = function(e) {
      return e.free = `free`,
      e.basic = `basic`,
      e.business = `business`,
      e.businessPlus = `businessPlus`,
      e.enterprise = `enterprise`,
      e.standard = `standard`,
      e.plus = `plus`,
      e
  }({}),
  sd = {
      [A.plus]: A.plus,
      [A.business]: A.business,
      [A.enterprise]: A.enterprise
  },
  cd = function(e) {
      return e.month = `month`,
      e.year = `year`,
      e.quarter = `quarter`,
      e
  }({}),
  ld = function(e) {
      return e.automatic = `charge_automatically`,
      e.invoice = `send_invoice`,
      e
  }({}),
  j = function(e) {
      return e.free = `free`,
      e.basic_monthly = `basic_monthly`,
      e.basic_monthly_12 = `basic_monthly_12`,
      e.basic_yearly = `basic_yearly`,
      e.basic_yearly_10 = `basic_yearly_10`,
      e.business_monthly = `business_monthly`,
      e.business_monthly_16 = `business_monthly_16`,
      e.business_monthly_18 = `business_monthly_18`,
      e.business_yearly = `business_yearly`,
      e.business_yearly_14 = `business_yearly_14`,
      e.business_yearly_16 = `business_yearly_16`,
      e.business_plus_monthly = `business_plus_monthly`,
      e.business_plus_monthly_20 = `business_plus_monthly_20`,
      e.business_plus_monthly_22 = `business_plus_monthly_22`,
      e.business_plus_yearly = `business_plus_yearly`,
      e.business_plus_yearly_17 = `business_plus_yearly_17`,
      e.business_plus_yearly_19 = `business_plus_yearly_19`,
      e.enterprise_monthly_30 = `enterprise_monthly_30`,
      e.enterprise_yearly_19 = `enterprise_yearly_19`,
      e.enterprise_yearly_20 = `enterprise_yearly_20`,
      e.enterprise_yearly_25 = `enterprise_yearly_25`,
      e.enterprise_self_serve_yearly_25 = `enterprise_self_serve_yearly_25`,
      e.enterprise_self_serve_yearly_30 = `enterprise_self_serve_yearly_30`,
      e.enterprise_yearly_30 = `enterprise_yearly_30`,
      e.enterprise_yearly_20_tax_excluded = `price_1Pidh8HjtSHLbR6BoACWgQ1I`,
      e.enterprise_quarterly_22 = `enterprise_quarterly_22`,
      e.enterprise_quarterly_25 = `enterprise_quarterly_25`,
      e.enterprise_quarterly_30 = `enterprise_quarterly_30`,
      e.beta_8 = `beta_8`,
      e.standard_monthly_10 = `standard_monthly_10`,
      e.standard_yearly = `standard_yearly`,
      e.plus_monthly_15 = `plus_monthly_15`,
      e.plus_monthly_15_te = `plus_monthly_15_te`,
      e.plus_yearly = `plus_yearly`,
      e.plus_yearly_te = `plus_yearly_te`,
      e.plus_yearly_14 = `plus_yearly_14`,
      e.plus_yearly_14_te = `plus_yearly_14_te`,
      e.plus_monthly_17 = `plus_monthly_17`,
      e.plus_yearly_15 = `price_1NhzFsHjtSHLbR6B9yKveXe4`,
      e.plus_yearly_15_te = `plus_yearly_15_te`,
      e.plus_yearly_16 = `plus_yearly_16`,
      e
  }({}),
  ud = function(e) {
      return e.salesforce = `salesforce`,
      e
  }({}),
  dd = function(e) {
      return e.salesforce_quarterly_5 = `addon_salesforce_quarterly_5`,
      e.salesforce_yearly_5 = `addon_salesforce_yearly_5`,
      e
  }({}),
  fd = function(e) {
      return e.plan = `plan`,
      e.addOn = `addon`,
      e
  }({}),
  pd = {
      [A.plus]: {
          [A.business]: {
              [cd.month]: {
                  couponCode: `vCTRcaG1`,
                  finalPrice: 16
              },
              [cd.year]: {
                  couponCode: `h8QL1tWT`,
                  finalPrice: 14
              }
          },
          [A.businessPlus]: {
              [cd.month]: {
                  couponCode: `8enu7ZOt`,
                  finalPrice: 18
              },
              [cd.year]: {
                  couponCode: `6228w6y3`,
                  finalPrice: 15
              }
          },
          [A.enterprise]: {
              [cd.month]: {
                  couponCode: `XgZIf1z9`,
                  finalPrice: 20
              },
              [cd.year]: {
                  couponCode: `XgZIf1z9`,
                  finalPrice: 20
              }
          }
      },
      [A.standard]: {
          [A.business]: {
              [cd.month]: {
                  couponCode: `uA0ShSkL`,
                  finalPrice: 14
              },
              [cd.year]: {
                  couponCode: `GmgFwAKf`,
                  finalPrice: 12
              }
          },
          [A.enterprise]: {
              [cd.year]: {
                  couponCode: `XgZIf1z9`,
                  finalPrice: 20
              }
          }
      }
  },
  md = class e {
      static isValidPlan(e) {
          return this.allPaidSubscriptionTypes.includes(e)
      }
      static isValidAddOnPrice(e) {
          return Object.values(dd).includes(e)
      }
      static #e = this.allPaidSubscriptionTypes = Object.values(j).filter(e => e !== j.free);
      static #t = this.currentPaidSubscriptionTypes = [j.basic_monthly_12, j.basic_yearly_10, j.business_monthly_18, j.business_yearly_16, j.business_plus_monthly_22, j.business_plus_yearly_19, j.enterprise_monthly_30, j.enterprise_yearly_19, j.enterprise_yearly_20, j.enterprise_yearly_25, j.enterprise_self_serve_yearly_25, j.enterprise_self_serve_yearly_30, j.enterprise_yearly_30, j.enterprise_yearly_20_tax_excluded, j.enterprise_quarterly_22, j.enterprise_quarterly_25, j.enterprise_quarterly_30];
      static #n = this.deprecatedSubscriptionTypes = () => this.allPaidSubscriptionTypes.filter(e => this.currentPaidSubscriptionTypes.indexOf(e) === -1);
      static billingPeriodForSubscription(e) {
          switch (e) {
          case j.enterprise_quarterly_22:
          case j.enterprise_quarterly_25:
          case j.enterprise_quarterly_30:
              return cd.quarter;
          case j.standard_yearly:
          case j.plus_yearly_14:
          case j.plus_yearly_14_te:
          case j.plus_yearly_15:
          case j.plus_yearly_15_te:
          case j.plus_yearly_16:
          case j.plus_yearly:
          case j.plus_yearly_te:
          case j.enterprise_yearly_19:
          case j.enterprise_yearly_20:
          case j.enterprise_yearly_20_tax_excluded:
          case j.enterprise_yearly_25:
          case j.enterprise_self_serve_yearly_25:
          case j.enterprise_self_serve_yearly_30:
          case j.enterprise_yearly_30:
          case j.basic_yearly:
          case j.basic_yearly_10:
          case j.business_yearly:
          case j.business_yearly_14:
          case j.business_yearly_16:
          case j.business_plus_yearly:
          case j.business_plus_yearly_17:
          case j.business_plus_yearly_19:
              return cd.year;
          default:
              return cd.month
          }
      }
      static monthsInBillingPeriod(e) {
          switch (e) {
          case cd.year:
              return 12;
          case cd.quarter:
              return 3;
          case cd.month:
              return 1;
          default:
              throw new Rn(e)
          }
      }
      static pricePerSeatForSubscription(e) {
          switch (e) {
          case j.free:
              return 0;
          case j.beta_8:
              return 8;
          case j.standard_monthly_10:
              return 10;
          case j.standard_yearly:
              return 8;
          case j.plus_monthly_15:
          case j.plus_monthly_15_te:
              return 15;
          case j.plus_monthly_17:
              return 17;
          case j.plus_yearly_14:
          case j.plus_yearly_14_te:
              return 14;
          case j.plus_yearly_15:
          case j.plus_yearly_15_te:
              return 15;
          case j.plus_yearly_16:
              return 16;
          case j.plus_yearly:
          case j.plus_yearly_te:
              return 12;
          case j.enterprise_monthly_30:
              return 30;
          case j.enterprise_yearly_19:
              return 18.75;
          case j.enterprise_yearly_20:
          case j.enterprise_yearly_20_tax_excluded:
              return 20;
          case j.enterprise_yearly_25:
          case j.enterprise_self_serve_yearly_25:
              return 25;
          case j.enterprise_yearly_30:
          case j.enterprise_self_serve_yearly_30:
              return 30;
          case j.basic_monthly:
              return 10;
          case j.basic_monthly_12:
              return 12;
          case j.basic_yearly:
              return 8;
          case j.basic_yearly_10:
              return 10;
          case j.business_monthly:
              return 15;
          case j.business_monthly_16:
              return 16;
          case j.business_monthly_18:
              return 18;
          case j.business_yearly:
              return 12;
          case j.business_yearly_14:
              return 14;
          case j.business_yearly_16:
              return 16;
          case j.business_plus_monthly:
              return 18;
          case j.business_plus_monthly_20:
              return 20;
          case j.business_plus_monthly_22:
              return 22;
          case j.business_plus_yearly:
              return 15;
          case j.business_plus_yearly_17:
              return 17;
          case j.business_plus_yearly_19:
              return 19;
          case j.enterprise_quarterly_22:
              return 22;
          case j.enterprise_quarterly_25:
              return 25;
          case j.enterprise_quarterly_30:
              return 30;
          default:
              throw new Rn(e)
          }
      }
      static planName(e) {
          return e === A.businessPlus ? `Business+` : (0,
          od.default)(e)
      }
      static planDisplayName(e) {
          let {type: t, includeLinear: n, includeDefaultBillingPeriod: r=!0} = e
            , i = e.billingPeriod || t && r && this.billingPeriodForSubscription(t)
            , a = t ? this.planName(this.planForSubscriptionType(t)) : `Free`
            , o = t && t !== j.free && i ? ` ${(0,
          od.default)(i || this.billingPeriodForSubscription(t))}ly` : ``;
          return `${n ? `Linear ` : ``}${a}${o}`
      }
      static planForSubscriptionType(e) {
          switch (e) {
          case j.standard_monthly_10:
          case j.standard_yearly:
              return A.standard;
          case j.plus_monthly_15:
          case j.plus_monthly_15_te:
          case j.plus_monthly_17:
          case j.plus_yearly_14:
          case j.plus_yearly_14_te:
          case j.plus_yearly_15:
          case j.plus_yearly_15_te:
          case j.plus_yearly_16:
          case j.plus_yearly:
          case j.plus_yearly_te:
              return A.plus;
          case j.basic_monthly:
          case j.basic_monthly_12:
          case j.basic_yearly:
          case j.basic_yearly_10:
              return A.basic;
          case j.business_monthly:
          case j.business_monthly_16:
          case j.business_monthly_18:
          case j.business_yearly:
          case j.business_yearly_14:
          case j.business_yearly_16:
              return A.business;
          case j.business_plus_monthly:
          case j.business_plus_monthly_20:
          case j.business_plus_monthly_22:
          case j.business_plus_yearly:
          case j.business_plus_yearly_17:
          case j.business_plus_yearly_19:
              return A.businessPlus;
          case j.enterprise_monthly_30:
          case j.enterprise_yearly_19:
          case j.enterprise_yearly_20:
          case j.enterprise_yearly_20_tax_excluded:
          case j.enterprise_quarterly_22:
          case j.enterprise_quarterly_25:
          case j.enterprise_quarterly_30:
          case j.enterprise_yearly_25:
          case j.enterprise_self_serve_yearly_25:
          case j.enterprise_self_serve_yearly_30:
          case j.enterprise_yearly_30:
              return A.enterprise;
          case j.free:
              return A.free;
          default:
              return this.allPaidSubscriptionTypes.indexOf(e) === -1 ? A.free : A.standard
          }
      }
      static addOnForPrice(e) {
          switch (e) {
          case dd.salesforce_yearly_5:
          case dd.salesforce_quarterly_5:
              return ud.salesforce;
          default:
              throw new Rn(e)
          }
      }
      static canSelfManageSubscriptionType(e) {
          switch (e) {
          case j.enterprise_yearly_19:
          case j.enterprise_yearly_20:
          case j.enterprise_yearly_20_tax_excluded:
          case j.enterprise_quarterly_22:
          case j.enterprise_quarterly_25:
          case j.enterprise_quarterly_30:
          case j.enterprise_yearly_25:
          case j.enterprise_yearly_30:
              return !1;
          case j.enterprise_monthly_30:
          case j.enterprise_self_serve_yearly_25:
          case j.enterprise_self_serve_yearly_30:
          default:
              return !0
          }
      }
      static canSelfServeUpgradeToSubscriptionType(e) {
          switch (e) {
          case j.free:
          case j.basic_monthly:
          case j.basic_monthly_12:
          case j.basic_yearly:
          case j.basic_yearly_10:
          case j.business_monthly:
          case j.business_monthly_16:
          case j.business_monthly_18:
          case j.business_yearly:
          case j.business_yearly_14:
          case j.business_yearly_16:
          case j.enterprise_self_serve_yearly_30:
              return !0;
          case j.business_plus_monthly:
          case j.business_plus_monthly_20:
          case j.business_plus_monthly_22:
          case j.business_plus_yearly:
          case j.business_plus_yearly_17:
          case j.business_plus_yearly_19:
          case j.enterprise_monthly_30:
          case j.enterprise_yearly_19:
          case j.enterprise_yearly_20:
          case j.enterprise_yearly_25:
          case j.enterprise_yearly_30:
          case j.enterprise_yearly_20_tax_excluded:
          case j.enterprise_quarterly_22:
          case j.enterprise_quarterly_25:
          case j.enterprise_quarterly_30:
              return !1;
          case j.beta_8:
          case j.standard_monthly_10:
          case j.standard_yearly:
          case j.plus_monthly_15:
          case j.plus_monthly_15_te:
          case j.plus_monthly_17:
          case j.plus_yearly_14:
          case j.plus_yearly_14_te:
          case j.plus_yearly_15:
          case j.plus_yearly_15_te:
          case j.plus_yearly_16:
          case j.plus_yearly:
          case j.plus_yearly_te:
          case j.enterprise_self_serve_yearly_25:
              return !1;
          default:
              throw new Rn(e)
          }
      }
      static canChangeBillingPeriod(e) {
          return ![A.free, A.plus, A.enterprise, A.standard].filter(Boolean).includes(e)
      }
      static subscriptionTypeFor({currentSubscriptionType: t, allowTeamToSelfUpgrade: n, planType: r, billingPeriod: i, billedUserCount: a=0, useLegacySubscriptionType: o=!1}) {
          if (r === A.free)
              return j.free;
          if (r === A.standard)
              return i === cd.year ? j.standard_yearly : j.standard_monthly_10;
          if (r === A.enterprise)
              return this.isEligibleForEnterpriseMonthly(t, a) ? i === cd.month ? j.enterprise_monthly_30 : j.enterprise_self_serve_yearly_30 : this.legacyPlanTypes.includes(this.planForSubscriptionType(t)) ? j.enterprise_self_serve_yearly_30 : i === cd.quarter ? j.enterprise_quarterly_22 : e.canSelfServeUpgrade({
                  currentSubscriptionType: t,
                  allowTeamToSelfUpgrade: n,
                  subscriptionType: j.enterprise_self_serve_yearly_30,
                  billedUserCount: a
              }) ? j.enterprise_self_serve_yearly_30 : j.enterprise_yearly_19;
          if (r === A.plus)
              return j.plus_yearly_14;
          if (r === A.basic)
              return i === cd.year ? o ? j.basic_yearly : j.basic_yearly_10 : o ? j.basic_monthly : j.basic_monthly_12;
          if (r === A.business)
              return i === cd.year ? o ? j.business_yearly_14 : j.business_yearly_16 : o ? j.business_monthly_16 : j.business_monthly_18;
          if (r === A.businessPlus)
              return i === cd.year ? o ? j.business_plus_yearly : j.business_plus_yearly_19 : o ? j.business_plus_monthly : j.business_plus_monthly_22;
          throw Error(`Can't find subscription type for ${r}/${i}`)
      }
      static planHasMonthlyBilling(e) {
          return ![A.free, A.enterprise].includes(e)
      }
      static canSelfServeUpgrade({currentSubscriptionType: e, allowTeamToSelfUpgrade: t, subscriptionType: n, billedUserCount: r}) {
          return n === j.enterprise_self_serve_yearly_30 ? e === j.free ? t : r < 100 : n === j.enterprise_monthly_30 && this.isEligibleForEnterpriseMonthly(e, r) ? r < 100 : this.canSelfServeUpgradeToSubscriptionType(n)
      }
      static isSubscriptionTypeAvailable(e) {
          let {type: t, currentSubscriptionType: n} = e
            , r = n ? this.planForSubscriptionType(n) : A.free;
          switch (t) {
          case j.free:
          case j.beta_8:
          case j.standard_monthly_10:
          case j.standard_yearly:
          case j.business_monthly:
          case j.business_yearly:
          case j.business_plus_monthly:
          case j.business_plus_yearly:
          case j.plus_monthly_15:
          case j.plus_monthly_15_te:
          case j.plus_monthly_17:
          case j.plus_yearly_14:
          case j.plus_yearly_14_te:
          case j.plus_yearly_15:
          case j.plus_yearly_15_te:
          case j.plus_yearly_16:
          case j.plus_yearly:
          case j.plus_yearly_te:
              return !1;
          case j.basic_monthly:
          case j.basic_yearly:
          case j.business_monthly_16:
          case j.business_yearly_14:
          case j.business_plus_yearly_17:
          case j.business_plus_monthly_20:
              return !!(n && r === this.planForSubscriptionType(t));
          case j.basic_monthly_12:
          case j.basic_yearly_10:
          case j.business_monthly_18:
          case j.business_yearly_16:
          case j.business_plus_monthly_22:
          case j.business_plus_yearly_19:
          case j.enterprise_monthly_30:
          case j.enterprise_quarterly_22:
          case j.enterprise_quarterly_25:
          case j.enterprise_quarterly_30:
          case j.enterprise_yearly_19:
          case j.enterprise_yearly_20:
          case j.enterprise_yearly_20_tax_excluded:
          case j.enterprise_yearly_25:
          case j.enterprise_self_serve_yearly_25:
          case j.enterprise_yearly_30:
          case j.enterprise_self_serve_yearly_30:
              return !0;
          default:
              throw new Rn(t)
          }
      }
      static isEligibleForEnterpriseMonthly(e, t) {
          return !!([j.plus_monthly_15, j.plus_monthly_15_te, j.plus_monthly_17].includes(e) && t < 100)
      }
      static getLegacyMigrationCoupon(e, t, n) {
          return pd[e]?.[t]?.[n]
      }
      static getLegacyMigrationSwitchPlans(e, t, n) {
          if (!this.legacyPlanTypes.includes(e))
              return;
          let {currentSeatCount: r, usesTriageResponsibility: i, usesPrivateTeams: a, usesGuestAccounts: o, usesAdvancedAuth: s, usesAdvancedAsks: c, usesSAML: l, usesSupportIntegrations: u} = n
            , d = s || u || a || o || i
            , f = c || l
            , p = t === cd.month ? j.basic_monthly_12 : j.basic_yearly_10
            , m = t === cd.month ? j.business_monthly_18 : j.business_yearly_16
            , h = t === cd.month ? j.enterprise_monthly_30 : j.enterprise_yearly_30;
          if (e === A.standard)
              return {
                  recommendedPlanType: d ? m : p,
                  autoSwitchPlan: p,
                  selfServe: !0
              };
          if (e === A.plus)
              return f ? {
                  recommendedPlanType: h,
                  autoSwitchPlan: m,
                  selfServe: r < 100
              } : {
                  recommendedPlanType: m,
                  autoSwitchPlan: m,
                  selfServe: !0
              }
      }
      static #r = this.legacyPlanTypes = [A.standard, A.plus];
      static #i = this.salesOnlyPlanTypes = [A.businessPlus];
      static #a = this.publicPlanTypes = [A.free, A.basic, A.business, A.enterprise]
  }
}
)), gd, _d, vd = t(( () => {
  ed(),
  $r(),
  ad(),
  hd(),
  gd = function(e) {
      return e.createUsers = `createUsers`,
      e.createTeams = `createTeams`,
      e.createIssues = `createIssues`,
      e.fileUploads = `fileUploads`,
      e.triage = `triage`,
      e.issueSync = `issueSync`,
      e.manageAdministrators = `manageAdministrators`,
      e.saml = `saml`,
      e.scim = `scim`,
      e.multiSaml = `multiSaml`,
      e.authMethodRestrictions = `authMethodRestrictions`,
      e.ipRestrictions = `ipRestrictions`,
      e.fileUploadRestrictions = `fileUploadRestrictions`,
      e.privateTeams = `privateTeams`,
      e.auditLog = `auditLog`,
      e.reducedPersonalInformation = `reducedPersonalInformation`,
      e.dataExport = `dataExport`,
      e.guestAccounts = `guestAccounts`,
      e.oauthAppReview = `oauthAppReview`,
      e.domainClaim = `domainClaim`,
      e.sla = `sla`,
      e.insights = `insights`,
      e.dashboards = `dashboards`,
      e.asks = `asks`,
      e.asksLimited = `asksLimited`,
      e.initiatives = `initiatives`,
      e.subInitiatives = `subInitiatives`,
      e.triageResponsibility = `triageResponsibility`,
      e.triageRules = `triageRules`,
      e.premiumIntegrations = `premiumIntegrations`,
      e.gongIntegration = `gongIntegration`,
      e.projectUpdates = `projectUpdates`,
      e.prioritySupport = `prioritySupport`,
      e.accountManager = `accountManager`,
      e.customTerms = `customTerms`,
      e.uptimeSla = `uptimeSla`,
      e.multipleSlackWorkspaces = `multipleSlackWorkspaces`,
      e.hipaaCompliance = `hipaaCompliance`,
      e.subTeams = `subTeams`,
      e.customers = `customers`,
      e.restrictTeamCreation = `restrictTeamCreation`,
      e.restrictInvites = `restrictInvites`,
      e.restrictLabelManagement = `restrictLabelManagement`,
      e.restrictTemplateManagement = `restrictTemplateManagement`,
      e.feed = `feed`,
      e.issueActivitySummary = `issueActivitySummary`,
      e.basicAIAddon = `basicAIAddon`,
      e.restrictAgentInvocationToMembers = `restrictAgentInvocationToMembers`,
      e.salesforceIntegration = `salesforceIntegration`,
      e.linearAgents = `linearAgents`,
      e.MCP = `MCP`,
      e.productIntelligence = `productIntelligence`,
      e.issueDiscussionSummaries = `issueDiscussionSummaries`,
      e.linearAi = `linearAi`,
      e.linearSlackAgent = `linearSlackAgent`,
      e.linearSupportAgent = `linearSupportAgent`,
      e.workspaceOwners = `workspaceOwners`,
      e.teamOwners = `teamOwners`,
      e
  }({}),
  _d = class {
      static getFeature(e) {
          return this.spec[e]
      }
      static tierName(e) {
          return md.planName(e)
      }
      static canAccess(e, t, n) {
          let {tierValue: r, addOns: i, ignoreAddOns: a} = n ?? {}
            , o = this.isPlanEqualOrBetterThan(t, this.getFeature(e).minimumPlan)
            , s = this.getFeature(e)
            , c = s.includeLegacyPlans === !1 && md.legacyPlanTypes.includes(t)
            , l = s.addOns?.length && !a
            , u = (o || !!s.plans?.includes(t)) && !c && (!l || !!i?.find(e => s.addOns?.includes(e)));
          return s.tiers && r !== void 0 ? u && r < Number(s.tiers[t]) : u
      }
      static minimumPlanForFeature(e, t) {
          let n = this.getFeature(e)
            , r = n.minimumPlan;
          if (n.tiers && t !== void 0)
              r = Object.entries(n.tiers).find( ([e,n]) => !md.legacyPlanTypes.includes(e) && Number(n) > t)?.[0];
          else if (md.legacyPlanTypes.includes(r)) {
              for (let e of this.planTypeTiers)
                  if (this.isPlanEqualOrBetterThan(e, r) && !md.legacyPlanTypes.includes(e)) {
                      r = e;
                      break
                  }
          }
          return r
      }
      static errorMessageForFeature(e, t, n) {
          let r = this.getFeature(e)
            , i = this.minimumPlanForFeature(e, t);
          return `Subscribe to the ${md.planName(i)} plan to access ${n || r.name.toLowerCase()} in your workspace.`
      }
      static availabilityMessageForFeature(e, t) {
          let n = this.minimumPlanForFeature(e, t);
          return `Available on ${md.planName(n)}`
      }
      static isPlanEqualOrBetterThan(e, t) {
          return this.planTypeTiers.indexOf(e) >= this.planTypeTiers.indexOf(t)
      }
      static getNextUpgradePlan(e) {
          let t = this.planTypeTiers.indexOf(e);
          for (let e = t + 1; e < this.planTypeTiers.length; e++) {
              let t = this.planTypeTiers[e];
              if (!md.legacyPlanTypes.includes(t) && !md.salesOnlyPlanTypes.includes(t))
                  return t
          }
      }
      static getPreviousPlan(e) {
          let t = this.planTypeTiers.indexOf(e);
          for (let e = t - 1; e >= 0; e--) {
              let t = this.planTypeTiers[e];
              if (!md.legacyPlanTypes.includes(t) && !md.salesOnlyPlanTypes.includes(t))
                  return t
          }
      }
      static getFeaturesInUpgrade({currentPlan: e, upgradePlan: t, isFeatureEnabled: n}) {
          return Qu(this.spec).filter(r => {
              let i = this.getFeature(r);
              return !(!i.featureFlag || (typeof i.featureFlag == `function` ? i.featureFlag(n) : n(i.featureFlag))) || i.showInUI === !1 ? !1 : this.canAccess(r, t, {
                  ignoreAddOns: !0
              }) && !this.canAccess(r, e) || i.tiers && this.upgradeHasHigherFeatureTier({
                  feature: r,
                  currentPlan: e,
                  upgradePlan: t
              })
          }
          )
      }
      static upgradeHasHigherFeatureTier({feature: e, currentPlan: t, upgradePlan: n}) {
          let r = this.getFeature(e);
          if (!r.tiers)
              return !1;
          let i = r.tiers[t]
            , a = r.tiers[n];
          if (typeof i == `number` && typeof a == `number`)
              return i < a;
          if (a === this.unlimited && i !== this.unlimited)
              return !0;
          if (typeof i == `string` && typeof a == `string`)
              throw Error(`Not implemented`);
          return !1
      }
      static #e = this.unlimited = 1e6;
      static #t = this.spec = {
          [gd.createUsers]: {
              name: `Members`,
              description: `A member has access to the workspace and can create and edit issues`,
              minimumPlan: A.free,
              tiers: {
                  [A.free]: this.unlimited,
                  [A.basic]: this.unlimited,
                  [A.standard]: this.unlimited,
                  [A.business]: this.unlimited,
                  [A.businessPlus]: this.unlimited,
                  [A.plus]: this.unlimited,
                  [A.enterprise]: this.unlimited
              },
              includeLegacyPlans: !0
          },
          [gd.createTeams]: {
              name: `Teams`,
              description: `Organize your workspace into teams`,
              minimumPlan: A.free,
              tiers: {
                  [A.free]: 2,
                  [A.basic]: 5,
                  [A.standard]: this.unlimited,
                  [A.business]: this.unlimited,
                  [A.businessPlus]: this.unlimited,
                  [A.plus]: this.unlimited,
                  [A.enterprise]: this.unlimited
              },
              includeLegacyPlans: !0
          },
          [gd.fileUploads]: {
              name: `File upload size`,
              description: `Applies to any files you upload to issues or comments`,
              minimumPlan: A.free,
              tiers: {
                  [A.free]: id.limits[td.singleFileUploadSize] + `MB`,
                  [A.basic]: this.unlimited,
                  [A.standard]: this.unlimited,
                  [A.business]: this.unlimited,
                  [A.businessPlus]: this.unlimited,
                  [A.plus]: this.unlimited,
                  [A.enterprise]: this.unlimited
              },
              includeLegacyPlans: !0
          },
          [gd.createIssues]: {
              name: `Issues (excluding archive)`,
              description: `Applies to all non-archived issues`,
              minimumPlan: A.free,
              tiers: {
                  [A.free]: id.limits[td.activeIssueCount],
                  [A.basic]: this.unlimited,
                  [A.standard]: this.unlimited,
                  [A.business]: this.unlimited,
                  [A.businessPlus]: this.unlimited,
                  [A.plus]: this.unlimited,
                  [A.enterprise]: this.unlimited
              },
              includeLegacyPlans: !0
          },
          [gd.projectUpdates]: {
              name: `Project updates`,
              description: `Post updates to projects`,
              minimumPlan: A.free,
              includeLegacyPlans: !0
          },
          [gd.triage]: {
              name: `Triage`,
              description: `A special inbox to manage issues created by other teams`,
              minimumPlan: A.free,
              includeLegacyPlans: !0
          },
          [gd.issueSync]: {
              name: `Issue sync`,
              description: `Sync issues bidirectionally with Jira and GitHub`,
              minimumPlan: A.free,
              includeLegacyPlans: !0
          },
          [gd.initiatives]: {
              name: `Initiatives`,
              description: `Track and manage initiatives`,
              minimumPlan: A.free,
              includeLegacyPlans: !0
          },
          [gd.subInitiatives]: {
              name: `Sub-initiatives`,
              description: `Split large initiatives into smaller, nested initiatives`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !0
          },
          [gd.customers]: {
              name: `Customer requests`,
              description: `Bring feature requests from customers into Linear`,
              minimumPlan: A.free,
              includeLegacyPlans: !1
          },
          [gd.feed]: {
              name: `Pulse`,
              description: `A personalized feed for product updates and discussions`,
              minimumPlan: A.free,
              includeLegacyPlans: !0
          },
          [gd.linearAgents]: {
              name: `Agent platform`,
              description: `Delegate work to AI agents`,
              minimumPlan: A.free,
              includeLegacyPlans: !0
          },
          [gd.MCP]: {
              name: `MCP access`,
              description: `Give AI models and agents access to your Linear data`,
              minimumPlan: A.free,
              includeLegacyPlans: !0
          },
          [gd.manageAdministrators]: {
              name: `Admin roles`,
              description: `Control who are admins in the workspace`,
              minimumPlan: A.basic,
              includeLegacyPlans: !0
          },
          [gd.privateTeams]: {
              name: `Private teams`,
              description: `Restrict access to private teams`,
              minimumPlan: A.standard,
              includeLegacyPlans: !0
          },
          [gd.guestAccounts]: {
              name: `Guest accounts`,
              description: `Guests are paid users with restricted access to designated teams in a workspace`,
              minimumPlan: A.standard,
              includeLegacyPlans: !0
          },
          [gd.authMethodRestrictions]: {
              name: `Advanced authentication`,
              description: `Restrict logins to the workspace to Google and other login methods`,
              minimumPlan: A.standard,
              includeLegacyPlans: !0
          },
          [gd.premiumIntegrations]: {
              name: `Support integrations`,
              description: `Integrate with Zendesk, Intercom, and Front`,
              minimumPlan: A.standard,
              includeLegacyPlans: !0
          },
          [gd.gongIntegration]: {
              name: `Gong integration`,
              description: `Integrate with Gong to ingest call recordings and create feature requests`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !1,
              featureFlag: Xr.gongIntegration
          },
          [gd.triageResponsibility]: {
              name: `Triage responsibility`,
              description: `Schedule triage responsibility for your workspace`,
              minimumPlan: A.standard,
              includeLegacyPlans: !0
          },
          [gd.triageRules]: {
              name: `Triage routing`,
              description: `Automatically route issues to the right triage team based on predefined rules`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !1
          },
          [gd.insights]: {
              name: `Insights`,
              description: `Advanced analytics and reporting for all your workspace data`,
              minimumPlan: A.business,
              includeLegacyPlans: !0
          },
          [gd.restrictTeamCreation]: {
              name: `Restrict team creation`,
              description: `Restrict team creation to workspace admins`,
              minimumPlan: A.business,
              includeLegacyPlans: !0
          },
          [gd.restrictLabelManagement]: {
              name: `Restrict label management`,
              description: `Restrict workspace-level label creation, update, and deletion to workspace admins`,
              minimumPlan: A.business,
              includeLegacyPlans: !0
          },
          [gd.restrictTemplateManagement]: {
              name: `Restrict template management`,
              description: `Restrict workspace-level template creation, update, and deletion to workspace admins`,
              minimumPlan: A.business,
              includeLegacyPlans: !0
          },
          [gd.productIntelligence]: {
              name: `Triage Intelligence`,
              description: `AI assistance for routine, manual tasks`,
              minimumPlan: A.business,
              includeLegacyPlans: !1
          },
          [gd.issueDiscussionSummaries]: {
              name: `Issue discussion summaries`,
              description: `Generate summaries for issue activity and comments`,
              minimumPlan: A.business,
              includeLegacyPlans: !1
          },
          [gd.saml]: {
              name: `SAML authentication`,
              description: `Enable SAML authentication for your workspace`,
              minimumPlan: A.plus,
              plans: [A.businessPlus],
              includeLegacyPlans: !0
          },
          [gd.domainClaim]: {
              name: `Domain claiming`,
              description: `Prevent creation of unsanctioned workspaces`,
              minimumPlan: A.plus,
              plans: [A.businessPlus],
              includeLegacyPlans: !0
          },
          [gd.auditLog]: {
              name: `Audit log`,
              description: `Availability of workspace level audit log for admins`,
              minimumPlan: A.plus,
              includeLegacyPlans: !0
          },
          [gd.reducedPersonalInformation]: {
              name: `Reduced personal information`,
              description: `Control personal information stored from integrations`,
              minimumPlan: A.plus,
              includeLegacyPlans: !0
          },
          [gd.dataExport]: {
              name: `Data warehouse sync`,
              description: `Consolidate your data in data warehouses, lakes, and databases via Airbyte`,
              minimumPlan: A.plus,
              includeLegacyPlans: !0
          },
          [gd.oauthAppReview]: {
              name: `Third-party app management`,
              description: `Admins can view and manage approved OAuth applications`,
              minimumPlan: A.plus,
              includeLegacyPlans: !0
          },
          [gd.sla]: {
              name: `Issue SLAs`,
              description: `Set time-based deadlines with service level agreements`,
              minimumPlan: A.business,
              includeLegacyPlans: !0
          },
          [gd.asks]: {
              name: `Linear Asks`,
              description: `Create and manage workplace requests from Slack`,
              minimumPlan: A.plus,
              includeLegacyPlans: !0
          },
          [gd.asksLimited]: {
              name: `Asks`,
              description: `Ask questions and get answers from your team, with limited configuration options`,
              minimumPlan: A.business,
              includeLegacyPlans: !0
          },
          [gd.prioritySupport]: {
              name: `Priority support`,
              description: `Faster replies to support questions`,
              minimumPlan: A.plus,
              includeLegacyPlans: !0
          },
          [gd.multiSaml]: {
              name: `Multi-SAML authentication`,
              description: `Enable multiple SAML IdPs for your workspace`,
              minimumPlan: A.enterprise,
              plans: [A.businessPlus],
              includeLegacyPlans: !0
          },
          [gd.ipRestrictions]: {
              name: `IP restrictions`,
              description: `Restrict workspace access to your private network`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !0
          },
          [gd.fileUploadRestrictions]: {
              name: `Allowed file upload content types`,
              description: `Restrict file upload types`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !1
          },
          [gd.scim]: {
              name: `SCIM provisioning`,
              description: `Automate user provisioning and deprovisioning with SCIM`,
              minimumPlan: A.enterprise,
              plans: [A.businessPlus],
              includeLegacyPlans: !0
          },
          [gd.accountManager]: {
              name: `Account manager*`,
              description: `Work with a dedicated Customer Success Manager to help you get the most out of Linear (*for accounts above 200 seats)`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !0
          },
          [gd.customTerms]: {
              name: `Custom terms*`,
              description: `Establish custom contractual terms that suit your organization (*for accounts above 200 seats)`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !0
          },
          [gd.uptimeSla]: {
              name: `Uptime SLA*`,
              description: `Receive a Service Level Agreement for uptime of the Linear application (*for accounts above 200 seats)`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !0
          },
          [gd.multipleSlackWorkspaces]: {
              name: `Multiple Slack workspaces`,
              description: `Connect multiple Slack workspaces to your Linear workspace`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !0
          },
          [gd.hipaaCompliance]: {
              name: `HIPAA compliance`,
              description: `Privacy and security measures to ensure that Protected Health Information (PHI) is appropriately safeguarded`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !0
          },
          [gd.subTeams]: {
              name: `Sub-teams`,
              description: `Align workflows across multiple teams with shared statuses, cycles, and labels`,
              minimumPlan: A.business,
              includeLegacyPlans: !1
          },
          [gd.restrictInvites]: {
              name: `Restrict new user invitations`,
              description: `Restrict user invites to workspace admins`,
              minimumPlan: A.basic,
              includeLegacyPlans: !0
          },
          [gd.issueActivitySummary]: {
              name: `Issue activity summary`,
              description: `AI-generated issue activity summary`,
              minimumPlan: A.business,
              includeLegacyPlans: !1
          },
          [gd.basicAIAddon]: {
              name: `Basic AI add-on`,
              description: `AI features to improve your workflow`,
              minimumPlan: A.business,
              includeLegacyPlans: !1,
              showInUI: !1
          },
          [gd.restrictAgentInvocationToMembers]: {
              name: `Restrict agent invocation to full workspace members`,
              description: `Prevents guests from invoking agents in the workspace`,
              minimumPlan: A.basic,
              includeLegacyPlans: !0
          },
          [gd.salesforceIntegration]: {
              name: `Salesforce integration`,
              description: `Create customer requests and sync customer data`,
              asterisk: `paid add-on`,
              minimumPlan: A.enterprise,
              addOns: [ud.salesforce],
              includeLegacyPlans: !1
          },
          [gd.dashboards]: {
              name: `Dashboards`,
              description: `Combine insights into custom dashboards`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !1
          },
          [gd.linearAi]: {
              name: `Linear AI`,
              description: `AI agent for your workspace`,
              minimumPlan: A.business,
              includeLegacyPlans: !1,
              featureFlag: e => e(Xr.linearAi)
          },
          [gd.linearSlackAgent]: {
              name: `Linear Agent for Slack`,
              description: `Tag @linear in Slack discussions to create issues using your conversations context`,
              minimumPlan: A.business,
              includeLegacyPlans: !1
          },
          [gd.linearSupportAgent]: {
              name: `Linear Agent for support integrations`,
              description: `Automatically create issues from support tickets in Zendesk and Intercom`,
              minimumPlan: A.business,
              includeLegacyPlans: !1,
              featureFlag: e => e(Xr.intercomAiIntake) || e(Xr.zendeskAiIntake)
          },
          [gd.workspaceOwners]: {
              name: `Workspace owners`,
              description: `Support owner roles for users in the workspace`,
              minimumPlan: A.enterprise,
              includeLegacyPlans: !1
          },
          [gd.teamOwners]: {
              name: `Team owners`,
              description: `Support owner roles for users in teams`,
              minimumPlan: A.business,
              includeLegacyPlans: !1,
              featureFlag: Xr.teamOwners
          }
      };
      static #n = this.planTypeTiers = [A.free, A.basic, A.standard, A.business, A.businessPlus, A.plus, A.enterprise]
  }
}
)), yd, bd = t(( () => {
  yd = (e, t=`and`) => {
      if (e.length <= 2)
          return e.join(` ${t} `);
      let n = e.slice(0, -1);
      return n.push(t),
      `${n.join(`, `)} ${e.slice(-1)[0]}`
  }
}
)), xd, Sd, Cd, wd, Td, Ed, Dd, Od = t(( () => {
  xd = e(Gt(), 1),
  Sd = e(xe(), 1),
  vd(),
  bd(),
  hd(),
  du(),
  Cd = function(e) {
      return e.adminApiKeyScope = `adminApiKeyScope`,
      e.agentGuidance = `agentGuidance`,
      e.aiFeatures = `aiFeatures`,
      e.api = `api`,
      e.apiKeyCreation = `apiKeyCreation`,
      e.appManagement = `appManagement`,
      e.auditLog = `auditLog`,
      e.billing = `billing`,
      e.customers = `customers`,
      e.entityManagement = `entityManagement`,
      e.featureFlags = `featureFlags`,
      e.import = `import`,
      e.export = `export`,
      e.integrations = `integrations`,
      e.invitations = `invitations`,
      e.inviteLink = `inviteLink`,
      e.labelManagement = `labelManagement`,
      e.memberManagement = `memberManagement`,
      e.projectStatusManagement = `projectStatusManagement`,
      e.security = `security`,
      e.slas = `slas`,
      e.teamManagement = `teamManagement`,
      e.teamCreation = `teamCreation`,
      e.templateManagement = `templateManagement`,
      e.workspaceSettings = `workspaceSettings`,
      e.workspaceCreation = `workspaceCreation`,
      e
  }({}),
  wd = Object.values(Cd),
  Td = {
      [su.owner]: wd,
      [su.admin]: wd,
      [su.user]: [Cd.agentGuidance],
      [su.app]: [],
      [su.guest]: []
  },
  Ed = {
      [A.enterprise]: {
          [su.owner]: wd,
          [su.admin]: [Cd.adminApiKeyScope, Cd.agentGuidance, Cd.aiFeatures, Cd.api, Cd.apiKeyCreation, Cd.customers, Cd.entityManagement, Cd.featureFlags, Cd.import, Cd.invitations, Cd.integrations, Cd.inviteLink, Cd.labelManagement, Cd.memberManagement, Cd.projectStatusManagement, Cd.slas, Cd.teamCreation, Cd.teamManagement, Cd.templateManagement],
          [su.user]: [Cd.agentGuidance],
          [su.app]: [],
          [su.guest]: []
      }
  },
  Dd = class {
      static hasPermission(e, t, n, r) {
          let i = this.coerceRole(t, n)
            , a = Ed[n]
            , o = a ? a[i].includes(e) : Td[i].includes(e)
            , s = r?.[e];
          return s === null ? !1 : s ? uu.rolesEqualToOrHigherThanRole(this.coerceRole(s, n)).includes(i) : o
      }
      static getAllowedRolesForPermission(e, t, n, r={}) {
          let i = [su.owner, su.admin, su.user, su.app, su.guest]
            , a = Array.isArray(e) ? e : [e]
            , o = i.filter(e => a.every(r => this.hasPermission(r, e, t, n)));
          return r.hideUnsurfacedOwners ? o.filter(e => e !== su.owner || _d.canAccess(gd.workspaceOwners, t)) : o
      }
      static formatPermissionsMessageWithAllowedRoles(e, t, n, r, i={}) {
          let {plural: a, conjunction: o, fallback: s} = i
            , c = this.getAllowedRolesForPermission(t, n, r, {
              hideUnsurfacedOwners: !0
          });
          if (!c.length)
              return {
                  message: s ?? e.replace(`[role]`, `admin`),
                  allowedRoles: []
              };
          let l = yd(a ? c.map(e => (0,
          xd.default)(e)) : c, o)
            , u = i.capitalize ? (0,
          Sd.default)(l) : l;
          return {
              message: e.replace(`[role]`, u),
              allowedRoles: c
          }
      }
      static mergeOverrides(e) {
          if (!e.length)
              return {};
          let t = {
              ...e[0]
          };
          for (let n = 1; n < e.length; n++) {
              let r = e[n]
                , i = Object.keys(r);
              for (let e of i) {
                  let n = r[e];
                  (!t[e] || n === null || n && t[e] !== null && !uu.rolesEqualToOrHigherThanRole(t[e]).includes(n)) && (t[e] = n)
              }
          }
          return t
      }
      static coerceRole(e, t) {
          return e === su.owner && !_d.canAccess(gd.workspaceOwners, t) ? su.admin : e
      }
  }
}
)), kd, Ad, jd, Md = t(( () => {
  zn(),
  kd = function(e) {
      return e.owner = `owner`,
      e.member = `member`,
      e
  }({}),
  Ad = [kd.owner, kd.member],
  (function(e) {
      function t(e) {
          let t = Ad.indexOf(e);
          if (t === -1)
              throw new Rn(e);
          return Ad.slice(0, t + 1)
      }
      e.rolesEqualToOrHigherThanRole = t;
      function n(e, t, n) {
          if (!e.guest) {
              if (n)
                  return kd.owner;
              if (t)
                  return t.owner ? kd.owner : kd.member
          }
      }
      e.getUserRoleOnTeam = n
  }
  )(jd ||= {})
}
)), Nd, Pd, Fd, Id, Ld = t(( () => {
  vd(),
  Md(),
  Nd = function(e) {
      return e.dangerousOperations = `dangerousOperations`,
      e.guestManagement = `guestManagement`,
      e.labelManagement = `labelManagement`,
      e.memberManagement = `memberManagement`,
      e.teamManagement = `teamManagement`,
      e.templateManagement = `templateManagement`,
      e
  }({}),
  Pd = [Nd.dangerousOperations, Nd.guestManagement],
  Fd = {
      public: {
          [Nd.dangerousOperations]: kd.owner,
          [Nd.guestManagement]: kd.owner,
          [Nd.labelManagement]: kd.member,
          [Nd.memberManagement]: kd.member,
          [Nd.teamManagement]: kd.member,
          [Nd.templateManagement]: kd.member
      },
      private: {
          [Nd.dangerousOperations]: kd.owner,
          [Nd.guestManagement]: kd.owner,
          [Nd.labelManagement]: kd.member,
          [Nd.memberManagement]: kd.owner,
          [Nd.teamManagement]: kd.member,
          [Nd.templateManagement]: kd.member
      }
  },
  Id = class {
      static shouldSurfaceTeamOwners(e, t) {
          return t && _d.canAccess(gd.teamOwners, e)
      }
      static getRequiredRoleForPermission(e, t, n, r) {
          let i = Fd[r.private ? `private` : `public`][e]
            , a = Pd.includes(e);
          return !this.shouldSurfaceTeamOwners(t, n) || a ? i : r.securitySettings?.[e] ?? i
      }
      static hasPermission(e, t, n, r, i) {
          let a = this.getRequiredRoleForPermission(e, n, r, i);
          return jd.rolesEqualToOrHigherThanRole(a).includes(t)
      }
  }
}
)), Rd, zd = t(( () => {
  Rd = function(e) {
      return e[e.hasFacet = 0] = `hasFacet`,
      e
  }({})
}
)), Bd, Vd = t(( () => {
  Bd = class e {
      static #e = this.tokenRegex = /(\:([\w\-+]+)\:(?:\:skin-tone-[1-6]\:)?)(?![0-9])/;
      static #t = this.minNameLength = 1;
      static #n = this.maxNameLength = 256;
      static #r = this.nameValidation = /^[a-z0-9-_]+$/;
      static isEmojiCode(e) {
          return e.startsWith(`:`) && e.endsWith(`:`) && e.length > 2
      }
      static toEmojiCode(t) {
          return e.isEmojiCode(t) ? t : `:${t}:`
      }
      static toEmojiName(t) {
          return e.isEmojiCode(t) ? t.slice(1, t.length - 1) : t
      }
      static replaceEmojiStrings(t, n) {
          return t.replace(new RegExp(e.tokenRegex.source,`gi`), (t, r, i) => {
              let a = e.toEmojiName(i)
                , o = n(a);
              return !o && a.includes(`skin-tone-`) ? `` : o ?? r
          }
          )
      }
      static #i = this.emojiColorCache = new Map
  }
}
)), Hd, Ud = t(( () => {
  Hd = function(e) {
      return e.dev = `dev`,
      e.internal = `internal`,
      e.partial = `partial`,
      e.full = `full`,
      e
  }({})
}
)), Wd, Gd, Kd = t(( () => {
  zn(),
  Wd = function(e) {
      return e.backlog = `backlog`,
      e.planned = `planned`,
      e.started = `started`,
      e.paused = `paused`,
      e.completed = `completed`,
      e.canceled = `canceled`,
      e
  }({}),
  (function(e) {
      e.statusOrdering = Object.freeze({
          [Wd.backlog]: 0,
          [Wd.planned]: 1,
          [Wd.started]: 2,
          [Wd.completed]: 3,
          [Wd.canceled]: 4,
          [Wd.paused]: 10
      }),
      e.statusListOrdering = Object.freeze({
          [Wd.started]: 0,
          [Wd.planned]: 1,
          [Wd.backlog]: 2,
          [Wd.paused]: 3,
          [Wd.completed]: 4,
          [Wd.canceled]: 5
      }),
      e.pausable = [Wd.planned, Wd.started],
      e.all = Object.values(Wd).filter(e => typeof e == `string`),
      e.allNotDone = Object.values(Wd).filter(e => typeof e == `string` && ![Wd.completed, Wd.canceled].includes(e)),
      e.allExceptPaused = Object.values(Wd).filter(e => typeof e == `string` && e !== Wd.paused),
      e.labelForProjectState = e => {
          switch (e) {
          case Wd.backlog:
              return `Backlog`;
          case Wd.planned:
              return `Planned`;
          case Wd.started:
              return `In Progress`;
          case Wd.paused:
              return `Paused`;
          case Wd.completed:
              return `Completed`;
          case Wd.canceled:
              return `Canceled`;
          default:
              return y(e),
              e
          }
      }
  }
  )(Gd ||= {})
}
)), qd, Jd, Yd, Xd = t(( () => {
  Kd(),
  qd = class e {
      static #e = this.maxNameLength = 25;
      static #t = this.maxDescriptionLength = 255;
      static getStatusOrder(e) {
          return Gd.statusOrdering[e]
      }
      static isStateBefore(e, t) {
          let n = Gd.statusOrdering[e.type]
            , r = Gd.statusOrdering[t.type];
          return n < r || n === r && e.position < t.position
      }
      static #n = this.defaultStatuses = [{
          type: Wd.backlog,
          name: `Backlog`,
          color: `#F2994A`
      }, {
          type: Wd.planned,
          name: `Planned`,
          color: `#D7D8DB`
      }, {
          type: Wd.started,
          name: `In Progress`,
          color: `#F2C94C`
      }, {
          type: Wd.completed,
          name: `Completed`,
          color: `#5E6AD2`
      }, {
          type: Wd.canceled,
          name: `Canceled`,
          color: `#8A8F98`
      }];
      static #r = this.pausedStatus = {
          type: Wd.planned,
          name: `Paused`,
          color: `#D7D8DB`,
          position: 2
      };
      static getDefaultStatusTypeColor(t) {
          let n = e.defaultStatuses.find(e => e.type === t);
          return n ? n.color : `#8A8F98`
      }
      static sortProjectStatusesForLayout({layout: t, groupingType: n}) {
          return (r, i) => {
              let a = r.type
                , o = i.type;
              if (a === o) {
                  let n = e.isStateBefore(r, i) ? -1 : 1;
                  return (t === `list` || t === `timeline`) && a !== Wd.completed && a !== Wd.canceled ? -n : n
              }
              return t === `board` && n === `grouping` ? Yd.indexOf(a) - Yd.indexOf(o) : Jd.indexOf(a) - Jd.indexOf(o)
          }
      }
      static #i = this.doneStateTypes = [Wd.completed, Wd.canceled]
  }
  ,
  Jd = [Wd.started, Wd.planned, Wd.backlog, Wd.paused, Wd.completed, Wd.canceled],
  Yd = [Wd.backlog, Wd.planned, Wd.started, Wd.paused, Wd.completed, Wd.canceled]
}
)), Zd, Qd, $d = t(( () => {
  cr(),
  Zd = `400.401.402.403.404.405.406.407.408.409.410.411.412.413.414.416.417.418.419.420.421.422.423.424.425.426.427.428.429.430.431.500.501.502.503.504.505.506.507.508.509.510.511.aakash.about.account.activate.add-account.admin.administrator.agent.agents.ai.ale.alert.alerts.analytic.android.anonymous.api.app.app.application.applications.apps.apps.archives.asks.auth.authentication.behind-the-craft.behindthecraft.billing.blob.blog.brand.browser-compatibility.build.building.careers.carlos.cart.case-studies.case-study.cdn.cdn-cgi.change.changelog.checkout.cli.client.comment.comments.communities.company.compare.conf.conference.configuration.confirm.connect.contact.contributing.customer.customers.dashboards.debug.desktop.desktop-preload.developers.discover.discussion.discussions.docs.documentation.download.downloads.download-mobile.dpa.drafts.dwarkesh.edit.editor.employee.employees.enterprise.enterprises.event.events.jedcal.faq.featured.features.files.fm.follow.for.forums.fund.get-started.groups.guides.harry.20vc.help.height.homepage.icons.image.images.inbox.info.initiatives.insights.integration.integrations.interfaces.introduction.invest.investor.investors.invitations.invite.invites.ios.issue.issues.jobs.join.join-slack.language.languages.launch.legal.lenny.lennys-list.linear.linear-method.log-in.login.logos.manual.media.media-kit.mediakit.meetup.meetups.mentions.message.messages.migrate.migrating.mobile.my-issues.navigation.new.news.newsroom.notice.notices.notifications.now.oauth.offer.onboarding.open.open-desktop.org.organisation.organisations.organizations.orgs.pages.partner.partners.pay.plan.planning.plans.plugin.popular.pragmatic.preferences.press.pricing.privacy.project.projects.public.quality.readme.recommend.recommendation.recommended.redeem.refresh.register.release.release-2020-12.releases.reply.report.reporting.reports.reset.resources.revert.rss.sale.saml.scim.security.settings.sign-in.sign-on.sign-up.signin.signon.signup.site.sitemap.solution.solutions.sponsor.sponsors.staff.startups.static.status.statuses.storage.subscribe.subscription.subscriptions.support.suspended.switch.customer-requests.talk.talks.tcr.team.terms.thanks.timeline.tips.topic.topics.tos.tour.trending.trends.tutorials.twist.unsubscribe.update.updates.username.users.video.view.views.web-api.website.welcome.wiki.windows.work-with-linear`.split(`.`),
  Qd = class e {
      static #e = this.minNameLength = 1;
      static #t = this.maxNameLength = 80;
      static #n = this.validUrlKeyFormat = /^[a-z0-9]+(([a-z0-9]*)\-?)*[a-z0-9]+$/;
      static #r = this.minUrlKeyLength = 3;
      static #i = this.maxUrlKeyLength = 32;
      static get disallowedUrlKeys() {
          return sr.PRODUCTION_ENV ? Zd : Zd.filter(e => e !== `linear`)
      }
      static isUrlKeyLike(t) {
          return t.length >= this.minNameLength && t.length <= this.maxNameLength && e.validUrlKeyFormat.test(t) && !e.disallowedUrlKeys.includes(t)
      }
      static #a = this.deletionCodeLength = 6
  }
}
)), ef, tf = t(( () => {
  ef = function(e) {
      return e[e.hasOrganizationIssueTemplates = 0] = `hasOrganizationIssueTemplates`,
      e[e.hasOrganizationProjectTemplates = 1] = `hasOrganizationProjectTemplates`,
      e[e.hasOrganizationDocumentTemplates = 2] = `hasOrganizationDocumentTemplates`,
      e[e.hasDashboards = 3] = `hasDashboards`,
      e[e.hasOrganizationDashboards = 4] = `hasOrganizationDashboards`,
      e
  }({})
}
)), nf, rf = t(( () => {
  nf = function(e) {
      return e.development = `development`,
      e.internal = `internal`,
      e.privateBeta = `private-beta`,
      e.beta = `beta`,
      e.preRelease = `pre-release`,
      e.public = `public`,
      e
  }({})
}
));
function af(e) {
  if (e.type !== `doc`)
      return !1;
  if (e.content.length === 1) {
      let t = e.content[0];
      return t.type === `paragraph` && (t.content == null || t.content.length === 0)
  }
  return e.content.length === 0
}
function Xne(e) {
  if (!e)
      return ``;
  let t = e => e.text ? e.text : e.content && Array.isArray(e.content) ? e.content.map(t).join(``) : ``;
  return !e.content || !Array.isArray(e.content) ? `` : e.content.map(t).join(`
`).trim()
}
var of, sf, cf, lf = t(( () => {
  hee(),
  of = dt({
      type: yt(),
      attrs: gt(yt(), Ct()).optional()
  }),
  sf = dt({
      type: yt(),
      attrs: gt(yt(), Ct()).optional(),
      content: Ct().optional(),
      marks: Dt(of).optional(),
      text: yt().optional()
  }),
  cf = dt({
      type: pt(`doc`),
      content: Dt(sf)
  })
}
)), uf, df, ff, pf, mf, hf, gf = t(( () => {
  uf = 75,
  df = 100,
  ff = 100,
  pf = 50,
  mf = 3e3,
  hf = {
      title: `Enter issue title`,
      text: `Enter text`,
      textArea: `Enter text`,
      select: `Select an option`,
      date: `Select a date`,
      fileUpload: `Upload file`,
      customer: `Find a customer`,
      labelGroup: `Select a label`,
      priority: `Select a priority`,
      dueDate: `Select a due date`
  }
}
)), _f, vf, yf, bf, xf, Sf, Cf, wf, Tf, Ef, Df, Of, kf, Af, jf, Mf, Nf, Pf, Ff, If, Lf, Rf, zf, Bf, Vf, Hf, Uf, Wf, Gf, Kf, qf, Jf, Yf = t(( () => {
  hee(),
  _f = e(_(), 1),
  nt(),
  vf = e(Gt(), 1),
  zn(),
  Kd(),
  lf(),
  gf(),
  yf = function(e) {
      return e.issue = `issue`,
      e.document = `document`,
      e.project = `project`,
      e.recurringIssue = `recurringIssue`,
      e
  }({}),
  bf = class {
      static get allTypes() {
          return [yf.issue, yf.document, yf.project, yf.recurringIssue]
      }
      static #e = this.validIntegrationTypes = new Set([yf.issue]);
      static nameForType(e) {
          switch (e) {
          case yf.issue:
              return `Issue`;
          case yf.document:
              return `Document`;
          case yf.project:
              return `Project`;
          case yf.recurringIssue:
              return `Recurring Issue`;
          default:
              return y(e),
              ``
          }
      }
      static representativeNameForType(e) {
          switch (e) {
          case yf.issue:
          case yf.document:
          case yf.project:
              return `template`;
          case yf.recurringIssue:
              return `recurring issue`;
          default:
              return y(e),
              ``
          }
      }
  }
  ,
  xf = e => e.type === Cf.LabelGroup,
  Sf = e => xf(e) ? e.groupId : void 0,
  Cf = function(e) {
      return e.Title = `title`,
      e.Customers = `customers`,
      e.LabelGroup = `labelGroup`,
      e.Priority = `priority`,
      e.DueDate = `dueDate`,
      e
  }({}),
  wf = function(e) {
      return e.Text = `text`,
      e.Textarea = `textarea`,
      e.Select = `select`,
      e.Checkboxes = `checkboxes`,
      e.Date = `date`,
      e.FileUpload = `fileUpload`,
      e
  }({}),
  Tf = function(e) {
      return e.TextBlock = `textBlock`,
      e
  }({}),
  Ef = class {
      static #e = this.propertyFields = [Cf.Title, Cf.Customers, Cf.LabelGroup, Cf.Priority, Cf.DueDate];
      static #t = this.inputFields = [wf.Text, wf.Textarea, wf.Select, wf.Date, wf.FileUpload, wf.Checkboxes];
      static #n = this.displayFields = [Tf.TextBlock];
      static isFieldProperty(e) {
          return Object.values(Cf).includes(e)
      }
      static isFieldInput(e) {
          return Object.values(wf).includes(e)
      }
      static isFieldDisplay(e) {
          return Object.values(Tf).includes(e)
      }
      static actionId(e, t) {
          return [e, t.id].join(`-`)
      }
      static isFormTemplate(e) {
          return (e.formFields ?? []).length > 0
      }
      static getFormFields(e) {
          return (0,
          _f.default)(e.formFields ?? [], `sortOrder`)
      }
      static labelForType(e) {
          switch (e) {
          case Cf.Title:
              return `Title`;
          case Cf.Customers:
              return `Customer`;
          case Cf.LabelGroup:
              return `Label group`;
          case Cf.Priority:
              return `Priority`;
          case Cf.DueDate:
              return `Due date`;
          case wf.Text:
              return `Text`;
          case wf.Textarea:
              return `Long text`;
          case wf.Select:
              return `Dropdown`;
          case wf.Checkboxes:
              return `Checkboxes`;
          case wf.Date:
              return `Date`;
          case wf.FileUpload:
              return `Upload file`;
          case Tf.TextBlock:
              return `Instructions`;
          default:
              return y(e),
              ``
          }
      }
      static labelForField(e) {
          return e.label?.trim() || this.labelForType(e.type)
      }
  }
  ,
  Cf.DueDate,
  Cf.Customers,
  wf.Text,
  wf.Textarea,
  wf.Checkboxes,
  wf.Date,
  wf.FileUpload,
  Df = dt({
      id: yt(),
      type: mt([vt(Cf), vt(wf), vt(Tf)]),
      required: bt(),
      label: yt().trim().min(1, `Field label is required`),
      descriptionData: cf.optional(),
      description: yt().optional(),
      sortOrder: Tt().optional(),
      placeholder: yt().max(150, `Placeholder must be 150 characters or less`).optional()
  }),
  Of = e => Array.isArray(e) ? e.filter(e => e.trim() !== ``) : e,
  kf = e => new Set(e).size === e.length,
  Af = e => e.every(e => e.length <= 75),
  jf = Df.extend({
      type: pt(wf.Text)
  }),
  Mf = Df.extend({
      type: pt(wf.Textarea)
  }),
  Nf = Df.extend({
      type: pt(wf.Date)
  }),
  Pf = Df.extend({
      type: pt(wf.FileUpload)
  }),
  Ff = Df.extend({
      type: pt(wf.Select),
      options: wt(Of, Dt(yt()).min(1, `At least one option is required`).max(100, `No more than 100 options are allowed`).refine(kf, {
          message: `All options must be unique`
      }).refine(Af, {
          message: `All options must be 75 characters or fewer`
      })),
      defaultValue: yt().optional()
  }),
  If = Df.extend({
      type: pt(wf.Checkboxes),
      options: wt(Of, Dt(yt()).min(1, `At least one option is required`).max(10, `No more than 10 options are allowed`).refine(kf, {
          message: `All options must be unique`
      }).refine(Af, {
          message: `All options must be 75 characters or fewer`
      }))
  }),
  Lf = Df.extend({
      type: pt(Tf.TextBlock),
      label: pt(``),
      contentData: cf.refine(e => !af(e), {
          message: `Content is required`
      })
  }),
  Rf = Df.extend({
      type: pt(Cf.Title)
  }),
  zf = Df.extend({
      type: pt(Cf.Customers)
  }),
  Bf = Df.extend({
      type: pt(Cf.LabelGroup),
      groupId: yt()
  }),
  Vf = Df.extend({
      type: pt(Cf.Priority)
  }),
  Hf = Df.extend({
      type: pt(Cf.DueDate)
  }),
  Uf = mt([Rf, zf, Bf, Vf, Hf, jf, Mf, Ff, If, Nf, Pf, Lf]),
  Wf = Dt(Uf),
  Gf = dt({
      title: yt().optional(),
      descriptionData: cf.optional(),
      labelIds: Dt(yt()).optional(),
      priority: Tt().optional(),
      stateId: yt().optional(),
      assigneeId: yt().optional(),
      delegateId: yt().optional(),
      projectId: yt().optional(),
      projectMilestoneId: yt().optional(),
      projectMilestoneIndex: Tt().optional(),
      teamId: yt().optional(),
      lastAppliedTemplateId: yt().optional(),
      estimate: Tt().optional(),
      formFields: Dt(Df).optional()
  }).extend({
      children: fee( () => Dt(Gf).optional())
  }),
  dt({
      icon: yt().optional(),
      color: yt().optional(),
      title: yt().optional(),
      descriptionData: cf.optional(),
      projectId: yt().optional()
  }),
  dt({
      icon: yt().optional(),
      color: yt().optional(),
      title: yt().optional(),
      description: yt().optional(),
      descriptionData: Ct().optional(),
      teamIds: Dt(yt()).optional(),
      state: vt(Wd).optional(),
      statusId: yt().optional(),
      priority: Tt().optional(),
      leadId: yt().optional(),
      memberIds: Dt(yt()).optional(),
      initiativeIds: Dt(yt()).optional(),
      projectMilestones: Dt(dt({
          name: yt(),
          descriptionData: Ct().optional()
      })).optional(),
      initialIssues: Dt(Gf).optional(),
      labelIds: Dt(yt()).optional()
  }),
  Kf = function(e) {
      return e.days = `days`,
      e.weeks = `weeks`,
      e.months = `months`,
      e.years = `years`,
      e
  }({}),
  qf = dt({
      startAt: yt().transform(e => e),
      type: vt(Kf),
      interval: Tt(),
      lastRecurredAt: yt().transform(e => e).optional()
  }),
  Gf.extend({
      schedule: qf.optional()
  }),
  Jf = class {
      static nextDate(e) {
          let {startAt: t, type: n, interval: r, lastRecurredAt: i} = e
            , a = new Date().midnight()
            , o = (i ?? t).toLocalDate();
          for (i && (o = this.addPeriods(o, n, r, 1)); Ne(o, a); )
              o = this.addPeriods(o, n, r, 1);
          return o
      }
      static inWords(e, t) {
          let {interval: n, type: r, lastRecurredAt: i} = e
            , {formatDate: a, tooltip: o} = t;
          if (!a)
              return `${o ? `Repeats every` : `Every`} ${n > 1 ? `${n} ` : ``}${(0,
              vf.default)(r, n)}`;
          if (n === 1 && r === Kf.days)
              return o ? `Repeats daily` : `Due daily`;
          let s = new Date().midnight()
            , c = i?.toLocalDate() ?? this.nextDate(e)
            , l = a?.(c)
            , u = ( () => {
              if (n === 1) {
                  if (r === Kf.days)
                      return `Daily`;
                  if (r === Kf.weeks)
                      return `Weekly`;
                  if (r === Kf.months)
                      return `Monthly`;
                  if (r === Kf.years)
                      return `Yearly`
              } else if (n === 2 && r === Kf.weeks)
                  return `Bi-weekly`;
              else if (n === 3 && r === Kf.months)
                  return `Quarterly`;
              return `Every ${n > 1 ? `${n} ` : ``}${r}`
          }
          )();
          return `${o ? `Repeats ${u.toLocaleLowerCase()}` : u}, ${$e(c, s) < 7 ? `due ${l}` : `next due on ${l}`}`
      }
      static alignsWith(e, t) {
          let {startAt: n, type: r, interval: i} = e
            , a = n.toLocalDate()
            , o = Ne(t, a) ? a : t.toTimelessDate().toLocalDate()
            , s = Ne(t, a) ? t.toTimelessDate().toLocalDate() : a;
          for (; !et(s, o) && Ne(s, o); )
              s = this.addPeriods(s, r, i, 1);
          return et(s, o)
      }
      static addPeriods(e, t, n, r) {
          let i = n * (r > 0 ? 1 : -1)
            , a = Math.abs(r)
            , o = e;
          for (; a !== 0; ) {
              switch (t) {
              case Kf.days:
                  o = ze(o, i);
                  break;
              case Kf.weeks:
                  o = Ye(o, i);
                  break;
              case Kf.months:
                  o = Re(o, i);
                  break;
              case Kf.years:
                  o = ut(o, i);
                  break;
              default:
                  y(t)
              }
              a--
          }
          return o
      }
  }
}
)), Xf, Zf, Qf, $f, ep, tp, np, rp, ip, ap = t(( () => {
  Xf = e(g(), 1),
  Zf = e(nn(), 1),
  Qf = e(l(), 1),
  zn(),
  Lo(),
  Sl(),
  $f = function(e) {
      return e.desktop = `desktop`,
      e.mobile = `mobile`,
      e.email = `email`,
      e.slack = `slack`,
      e
  }({}),
  $f.desktop,
  $f.mobile,
  Po.desktop,
  $f.desktop,
  Po.web,
  $f.desktop,
  Po.mobile,
  $f.mobile,
  ep = class {
      static #e = this.getNotificationCategoryPreferenceWithoutFallback = (e, t, n) => n[e]?.[t];
      static #t = this.getNotificationCategoryPreference = (e, t, n) => {
          if (e === D.system)
              return !0;
          let r = this.getNotificationCategoryPreferenceWithoutFallback(e, t, n);
          return r === void 0 ? tp(e, t) : r
      }
      ;
      static #n = this.setNotificationCategoryPreference = (e, t, n, r) => {
          if (e === D.system)
              return;
          let i = (0,
          Zf.default)(r);
          if (i) {
              let r = i[e];
              r === void 0 ? i[e] = {
                  [t]: n
              } : r[t] = n
          } else
              i = {
                  [e]: {
                      [t]: n
                  }
              };
          return (0,
          Qf.default)(i, D.system)
      }
      ;
      static #r = this.getNotificationChannelPreference = (e, t) => {
          let n = t[e];
          return n === void 0 ? np(e) : n
      }
      ;
      static unsubscribeAllCategoryPreferencesForChannel(e, t) {
          let n = {
              ...e
          }
            , r = Object.keys(e);
          for (let e = 0; e < r.length; e++) {
              let i = r[e];
              i !== D.system && (0,
              Xf.default)(n, `${i}.${t}`, !1)
          }
          return n
      }
  }
  ,
  tp = (e, t) => {
      switch (e) {
      case D.assignments:
      case D.statusChanges:
      case D.commentsAndReplies:
      case D.mentions:
      case D.subscriptions:
      case D.documentChanges:
      case D.postsAndUpdates:
      case D.reminders:
      case D.reviews:
      case D.appsAndIntegrations:
      case D.system:
      case D.triage:
      case D.customers:
      case D.feed:
          return !0;
      case D.reactions:
          return t !== $f.desktop;
      default:
          throw y(e)
      }
  }
  ,
  np = e => {
      switch (e) {
      case $f.mobile:
      case $f.email:
          return !0;
      case $f.desktop:
      case $f.slack:
          return !1;
      default:
          throw y(e)
      }
  }
  ,
  rp = function(e) {
      return e.daily = `daily`,
      e.weekly = `weekly`,
      e.never = `never`,
      e
  }({}),
  ip = {
      [rp.daily]: `Daily`,
      [rp.weekly]: `Weekly`,
      [rp.never]: `Never`
  }
}
)), op, sp, cp, lp, up = t(( () => {
  op = function(e) {
      return e.sla = `sla`,
      e.custom = `custom`,
      e.viewSubscription = `viewSubscription`,
      e.triage = `triage`,
      e
  }({}),
  sp = function(e) {
      return e.entityCreated = `entityCreated`,
      e.entityUpdated = `entityUpdated`,
      e.entityCreatedOrUpdated = `entityCreatedOrUpdated`,
      e.entityRemoved = `entityRemoved`,
      e.entityUnarchived = `entityUnarchived`,
      e
  }({}),
  cp = function(e) {
      return e.issue = `Issue`,
      e.project = `Project`,
      e
  }({}),
  lp = class e {
      static #e = this.maxNameLength = 64;
      static #t = this.maxGroupNameLength = 64;
      static #n = this.maxDescriptionLength = 255;
      static #r = this.maxConditionCount = 8;
      static #i = this.maxActivityCount = 8;
      static #a = this.allowedIssueFilterKeysInSlaCondition = [`team`, `state`, `assignee`, `creator`, `priority`, `labels`, `project`, `sourceMetadata`, `lastAppliedTemplate`, `needs`, `customerCount`, `customerImportantCount`];
      static #o = this.disabledBlocksNameInSlaCondition = [`Project priority`];
      static #s = this.allowedIssueFilterKeysInCondition = `team.state.assignee.delegate.creator.priority.labels.project.subscribers.slaStatus.cycle.parent.searchableContent.attachments.relations.children.addedToCyclePeriod.hasBlockedByRelations.hasBlockingRelations.hasRelatedRelations.hasDuplicateRelations.suggestions.hasSuggestedRelatedIssues.hasSuggestedSimilarIssues.hasSuggestedAssignees.hasSuggestedProjects.hasSuggestedLabels.estimate.sourceMetadata.lastAppliedTemplate.dueDate.updatedAt.createdAt.startedAt.completedAt.triagedAt.needs.customerCount.customerImportantCount`.split(`.`);
      static getAllowedKeysForWorkflowType(t) {
          switch (t) {
          case op.sla:
              return new Set(e.allowedIssueFilterKeysInSlaCondition);
          default:
              return new Set(e.allowedIssueFilterKeysInCondition)
          }
      }
  }
}
));
function dp(e, t, n) {
  return Math.max(t, Math.min(n, e))
}
var fp = t(( () => {}
)), pp, mp, hp, gp = t(( () => {
  vd(),
  Od(),
  du(),
  pp = function(e) {
      return e.agentGuidanceRole = `agentGuidanceRole`,
      e.personalApiKeysRole = `personalApiKeysRole`,
      e.apiSettingsRole = `apiSettingsRole`,
      e.invitationsRole = `invitationsRole`,
      e.teamCreationRole = `teamCreationRole`,
      e.labelManagementRole = `labelManagementRole`,
      e.templateManagementRole = `templateManagementRole`,
      e.importRole = `importRole`,
      e
  }({}),
  mp = {
      [pp.agentGuidanceRole]: {
          permission: Cd.agentGuidance,
          default: su.user,
          minimumRole: su.user
      },
      [pp.personalApiKeysRole]: {
          permission: Cd.apiKeyCreation,
          default: su.user,
          minimumRole: su.user
      },
      [pp.invitationsRole]: {
          permission: Cd.invitations,
          default: su.admin,
          minimumRole: su.user,
          planFeature: gd.restrictInvites
      },
      [pp.teamCreationRole]: {
          permission: Cd.teamCreation,
          default: su.user,
          minimumRole: su.app,
          planFeature: gd.restrictTeamCreation
      },
      [pp.labelManagementRole]: {
          permission: Cd.labelManagement,
          default: su.user,
          minimumRole: su.app,
          planFeature: gd.restrictLabelManagement
      },
      [pp.apiSettingsRole]: {
          permission: Cd.api,
          default: su.admin,
          minimumRole: su.admin
      },
      [pp.templateManagementRole]: {
          permission: Cd.templateManagement,
          default: su.user,
          minimumRole: su.app,
          planFeature: gd.restrictTemplateManagement
      },
      [pp.importRole]: {
          permission: Cd.import,
          default: su.admin,
          minimumRole: su.admin
      }
  },
  hp = class {
      static getValue(e, t, n={}) {
          let r = mp[t]
            , i = e.securitySettings?.[t] ?? r.default;
          return i === su.user && r.minimumRole === su.app && !n.hideAppRole ? su.app : i === su.owner && n.hideOwnerRole ? su.admin : uu.rolesEqualToOrHigherThanRole(r.minimumRole).includes(i) ? i : r.minimumRole
      }
      static getConfig(e) {
          return mp[e]
      }
      static replaceOwnersWithAdmins(e) {
          return Object.fromEntries(Object.entries(e).map( ([e,t]) => [e, t === su.owner ? su.admin : t]))
      }
  }
}
));
function _p() {
  return os()
}
var vp = t(( () => {
  ss()
}
));
function Zne(e) {
  e.core.ruler.after(`inline`, `image_dimensions`, e => {
      function t(e) {
          return e.map(e => {
              if (e.type === `image`) {
                  let t = e.attrGet(`title`)?.match(/^=(\d+)x(\d+)?$/);
                  if (t) {
                      let[,n,r] = t;
                      return e.attrSet(`width`, n),
                      e.attrSet(`height`, r),
                      e.attrSet(`title`, ``),
                      e
                  }
              } else
                  e.children &&= t(e.children);
              return e
          }
          )
      }
      return e.tokens = t(e.tokens),
      !1
  }
  )
}
var Qne = t(( () => {}
));
function $ne(e) {
  switch (e) {
  case 9:
  case 32:
      return !0;
  default:
  }
  return !1
}
function yp(e, t) {
  let n = e.bMarks[t] + e.blkIndent
    , r = e.eMarks[t];
  return e.src.substr(n, r - n)
}
function bp(e) {
  let t = [], n = e.length, r = 0, i, a = 0, o = 0, s = !1, c = 0;
  for (i = e.charCodeAt(r); r < n; )
      i === 96 ? s ? (s = !1,
      c = r) : a % 2 == 0 && (s = !0,
      c = r) : i === 124 && a % 2 == 0 && !s && (t.push(e.substring(o, r)),
      o = r + 1),
      i === 92 ? a++ : a = 0,
      r++,
      r === n && s && (s = !1,
      r = c + 1),
      i = e.charCodeAt(r);
  return t.push(e.substring(o)),
  t
}
function ere(e, t, n, r) {
  let i;
  try {
      e.md.block._tokenize = e.md.block.tokenize,
      e.md.block.tokenize = (...t) => {
          if (i && (0,
          xp.default)(t, i))
              throw Error(`Infinite loop detected`);
          return i = t,
          e.md.block._tokenize(...t)
      }
      ,
      e.md.block.tokenize(e, t, n, r)
  } finally {
      e.md.block.tokenize = e.md.block._tokenize
  }
}
function tre(e, t, n, r) {
  let i, a, o, s, c, l, u, d, f, p;
  if (t + 2 > n || (c = t + 1,
  e.sCount[c] < e.blkIndent) || e.sCount[c] - e.blkIndent >= 4 || (o = e.bMarks[c] + e.tShift[c],
  o >= e.eMarks[c]) || (i = e.src.charCodeAt(o++),
  i !== 124 && i !== 45 && i !== 58))
      return !1;
  for (; o < e.eMarks[c]; ) {
      if (i = e.src.charCodeAt(o),
      i !== 124 && i !== 45 && i !== 58 && !$ne(i))
          return !1;
      o++
  }
  a = yp(e, t + 1),
  l = a.split(`|`);
  let m = [];
  for (s = 0; s < l.length; s++) {
      if (d = l[s].trim(),
      !d) {
          if (s === 0 || s === l.length - 1)
              continue;
          return !1
      }
      if (!/^:?-+:?$/.test(d))
          return !1;
      d.charCodeAt(d.length - 1) === 58 ? m.push(d.charCodeAt(0) === 58 ? `center` : `right`) : d.charCodeAt(0) === 58 ? m.push(`left`) : m.push(``)
  }
  if (a = yp(e, t).trim(),
  a.indexOf(`|`) === -1 || e.sCount[t] - e.blkIndent >= 4)
      return !1;
  let h = a;
  a.startsWith(`|`) && (h = h.substring(1)),
  h.endsWith(`|`) && (h = h.substring(0, h.length - 1)),
  l = bp(h);
  let g = l.length;
  if (g > m.length)
      return !1;
  if (r)
      return !0;
  for (u = e.push(`table_open`, `table`, 1),
  u.map = f = [t, 0],
  u = e.push(`tr_open`, `tr`, 1),
  u.map = [t, t + 1],
  s = 0; s < l.length; s++)
      u = e.push(`th_open`, `th`, 1),
      u.map = [t, t + 1],
      m[s] && (u.attrs = [[`style`, `text-align:` + m[s]]]),
      u = e.push(`paragraph_open`, `p`, 1),
      u = e.push(`inline`, ``, 0),
      u.content = l[s].trim(),
      u.map = [t, t + 1],
      u.children = [],
      u = e.push(`paragraph_close`, `p`, -1),
      u = e.push(`th_close`, `th`, -1);
  u = e.push(`tr_close`, `tr`, -1),
  u.map = p = [t + 2, 0];
  let _ = !1
    , ee = 0;
  for (c = t + 2; c < n && !(e.sCount[c] < e.blkIndent || (a = yp(e, c).trim(),
  a.indexOf(`|`) === -1) || e.sCount[c] - e.blkIndent >= 4); c++) {
      let t = a;
      a.startsWith(`|`) && (t = t.substring(1)),
      t.endsWith(`|`) && (t = t.substring(0, t.length - 1)),
      l = bp(t),
      _ || (u = e.push(`tr_open`, `tr`, 1));
      let n = _ ? ee : g;
      for (let t = 0, r = a.startsWith(`|`) ? 1 : 0; t < n; t++) {
          _ || (u = e.push(`td_open`, `td`, 1)),
          _ = !1,
          m[t] && (u.attrs = [[`style`, `text-align:` + m[t]]]);
          let n = l[t]?.[0] === ` ` || /^(\d+\.|\*|-)$/.test(l[t]?.trim()) ? 1 : 0;
          e.bMarks[c] += r + n,
          r = (l[t] || ``).length + (n ? 0 : 1),
          e.eMarks[c] = e.bMarks[c] + r - 1;
          let i = e.lineMax;
          e.lineMax = 1;
          try {
              ere(e, c, c + 1)
          } catch {
              break
          } finally {
              e.lineMax = i
          }
          let a = yp(e, c + 1).trim();
          if (a.indexOf(`|`) > 0 && l.length === t + 1 && !/^[-:|][-:|\s]*$/.test(a)) {
              let e = (a.match(/\|/g) || []).length
                , n = a.indexOf(`|`)
                , r = a.substring(0, n).trim()
                , i = /^[*\-+]\s/.test(r) || n === a.length - 1;
              if (!(e >= Math.floor(g / 2) && !i && r.length >= 2)) {
                  _ = !0,
                  ee = g - t;
                  break
              }
          }
          u = e.push(`td_close`, `td`, -1)
      }
      _ || (ee = 0,
      u = e.push(`tr_close`, `tr`, -1))
  }
  return u = e.push(`table_close`, `table`, -1),
  f[1] = p[1] = c,
  e.line = c,
  !0
}
var xp, Sp, nre = t(( () => {
  xp = e(ne(), 1),
  Sp = e => {
      e.block.ruler.before(`paragraph`, `table`, tre, {
          alt: [`paragraph`, `reference`]
      })
  }
}
));
function Cp(e, t) {
  let n = /`+/g, r, i = 0;
  if (e.isText)
      for (; r = n.exec(e.text); )
          i = Math.max(i, r[0].length);
  let a = i > 0 && t > 0 ? " `" : "`";
  for (let e = 0; e < i; e++)
      a += "`";
  return i > 0 && t < 0 && (a += ` `),
  a
}
var wp, Tp, Ep, Dp, Op, kp, Ap, jp, Mp, Np, Pp, Fp = t(( () => {
  el(),
  wp = {
      blockquote(e, t) {
          e.wrapBlock(`> `, null, t, () => e.renderContent(t))
      },
      code_block(e, t) {
          e.write("```" + (t.attrs.language || ``) + `
`),
          e.text(t.textContent, !1),
          e.ensureNewLine(),
          e.write("```"),
          e.closeBlock(t)
      },
      diagram(e, t) {
          e.write("```" + (t.attrs.language || `mermaid`) + `
`),
          e.text(t.textContent, !1),
          e.ensureNewLine(),
          e.write("```"),
          e.closeBlock(t)
      },
      heading(e, t, n, r) {
          jp(e, t, n, r),
          e.closeBlock(t)
      },
      collapsible_section(e, t) {
          e.write(`+++ `),
          e.renderContent(t),
          e.write(`+++`),
          e.closeBlock(t)
      },
      collapsible_heading(e, t) {
          e.renderContent(t),
          e.closeBlock(t)
      },
      horizontal_rule(e, t) {
          e.write(t.attrs.markup || `---`),
          e.closeBlock(t)
      },
      bullet_list(e, t) {
          Tp(e, t)
      },
      ordered_list(e, t) {
          Ep(e, t)
      },
      list_item(e, t) {
          let n = t.firstChild;
          n && ![`image`, `video`, `audio`, `paragraph`].includes(n.type.name) && n.type.isBlock && e.write(`
`),
          e.renderContent(t)
      },
      todo_list(e, t) {
          Dp(e, t)
      },
      todo_item(e, t) {
          e.write((t.attrs.done ? `[X]` : `[ ]`) + ` `);
          let n = t.firstChild;
          n && ![`image`, `video`, `audio`, `paragraph`].includes(n.type.name) && n.type.isBlock && e.write(`
`),
          e.renderContent(t),
          e.closeBlock(t)
      },
      paragraph(e, t) {
          e.renderInline(t),
          e.closeBlock(t)
      },
      image(e, t, n, r) {
          Op(e, t, n, r),
          e.closeBlock(t)
      },
      image_group(e, t) {
          t.forEach( (n, r) => {
              Op(e, n, t, r)
          }
          )
      },
      video(e, t, n, r) {
          kp(e, t, n, r),
          e.closeBlock(t)
      },
      audio(e, t, n, r) {
          kp(e, t, n, r),
          e.closeBlock(t)
      },
      file(e, t, n, r) {
          Ap(e, t, n, r),
          e.closeBlock(t)
      },
      hard_break(e, t, n, r=0) {
          let i = r > 0 ? n.child(r - 1) : null
            , a = n.child(r)
            , o = r + 1 < n.childCount ? n.child(r + 1) : null
            , s = [`strong`, `em`, `strike`]
            , c = (e, t) => !!e?.marks?.some(e => e.type.name === t)
            , l = s.filter(e => c(i, e) && c(o, e))
            , u = s.filter(e => !c(i, e) && c(a, e) && c(o, e))
            , d = e.options.hardBreakDelimiter ?? `
`
            , f = {
              strong: {
                  open: `**`,
                  close: `**`
              },
              em: {
                  open: `*`,
                  close: `*`
              },
              strike: {
                  open: `~~`,
                  close: `~~`
              }
          };
          if (l.length > 0) {
              let t = l.slice().reverse().map(e => f[e].close).join(``)
                , n = l.map(e => f[e].open).join(``);
              e.write(t + d + n);
              return
          }
          if (u.length > 0) {
              let t = u.map(e => f[e].open).join(``);
              e.write(d + t);
              return
          }
          e.write(d)
      },
      text(e, t) {
          e.text(t.text || ``)
      },
      table(e, t) {
          e.renderContent(t),
          e.closeBlock(t)
      },
      table_row(e, t) {
          e.write(`|`),
          e.renderContent(t),
          e.ensureNewLine(),
          t.content.firstChild && t.content.firstChild.type.name === `table_header` && (e.write(`|`),
          Array.from({
              length: t.content.childCount
          }).forEach( () => {
              e.write(` -- |`)
          }
          ),
          e.ensureNewLine())
      },
      table_cell: (...e) => Np(...e),
      table_header: (...e) => Np(...e),
      embed: (e, t, n, r) => {
          (t.attrs.href || t.attrs.src) && (e.ensureNewLine(),
          Mp(e, t, n, r),
          e.closeBlock(t))
      }
      ,
      iframe: (e, t) => {
          let n = t.attrs.src;
          n && (e.ensureNewLine(),
          e.write(`[` + e.esc(n) + `](` + e.esc(n) + `)`),
          e.closeBlock(t))
      }
      ,
      figma: (e, t) => {
          e.ensureNewLine();
          let n = t.attrs.nodeName ? `${t.attrs.nodeName} - ${t.attrs.title}` : t.attrs.title;
          e.write(`[${e.esc(n ?? ``)} (Figma)](${e.esc(t.attrs.href ?? ``)})`),
          e.closeBlock(t)
      }
      ,
      suggestion_userMentions: (e, t) => e.text(`@${t.attrs.label}`),
      issueMention: (e, t) => e.text(`[${t.attrs.label}](${t.attrs.href})`, !1),
      documentMention: (e, t) => e.text(`[${t.attrs.label}](${t.attrs.href})`, !1),
      entityMention: (e, t) => e.text(`[${t.attrs.label}](${t.attrs.href})`, !1),
      entityEmbed: (e, t) => e.text(`[${t.attrs.label}](${t.attrs.href})`, !1),
      emoji: (e, t) => e.text(t.attrs.label || t.attrs.name),
      date: (e, t) => e.text($c.format(t.attrs.date), !1),
      unsupported_block_node: e => e.text(``),
      unsupported_inline_node: e => e.text(``),
      pending_file: (e, t) => e.text(`[${t.attrs.fileName}]`, !1)
  },
  Tp = (e, t) => {
      e.renderList(t, `  `, () => (t.attrs.bullet || `*`) + ` `)
  }
  ,
  Ep = (e, t) => {
      let n = t.attrs.order || 1
        , r = String(n + t.childCount - 1).length
        , i = e.repeat(` `, r + 2);
      e.renderList(t, i, t => {
          let i = String(n + t);
          return e.repeat(` `, r - i.length) + i + `. `
      }
      )
  }
  ,
  Dp = (e, t) => {
      e.renderList(t, `  `, () => (t.attrs.bullet || `-`) + ` `)
  }
  ,
  Op = (e, t) => {
      let n = t.attrs.src;
      if (!n)
          return;
      n = n.includes(`%`) ? n : encodeURI(t.attrs.src);
      let r = t.attrs.displayWidth ? ` "=${t.attrs.displayWidth}x"` : t.attrs.width ? ` "=${t.attrs.width}x${t.attrs.height ?? ``}"` : ``;
      e.write(`![${e.esc(t.attrs.alt || t.attrs.title || ``)}](${e.esc(n)}${e.options.includeImageDimensions ? e.esc(r) : ``})`)
  }
  ,
  kp = (e, t) => {
      let n = t.attrs.src;
      if (typeof n != `string` || n.length === 0)
          return;
      let r = t.attrs.title ? e.esc(t.attrs.title) : e.esc(n).split(`/`).pop();
      e.write(`[${r}](${e.esc(encodeURI(n))})`)
  }
  ,
  Ap = (e, t) => {
      let n = t.attrs.href;
      typeof n != `string` || n.length === 0 || e.write(`[${e.esc(t.attrs.name)}](${e.esc(encodeURI(n))})`)
  }
  ,
  jp = (e, t) => {
      e.write(e.repeat(`#`, t.attrs.level) + ` `),
      e.renderInline(t)
  }
  ,
  Mp = (e, t) => {
      let n = t.attrs.href || t.attrs.src
        , r = t.attrs.title ? e.esc(t.attrs.title) : e.esc(n).split(`/`).pop();
      e.write(`[${r}](${e.esc(encodeURI(n))})`)
  }
  ,
  Np = (e, t) => {
      e.text(` `),
      t.content.forEach( (n, r) => {
          switch (n.type.name) {
          case `image`:
              Op(e, n, t, r);
              break;
          case `audio`:
          case `video`:
              kp(e, n, t, r);
              break;
          case `file`:
              Ap(e, n, t, r);
              break;
          case `heading`:
              jp(e, n, t, r);
              break;
          case `embed`:
              Mp(e, n, t, r);
              break;
          case `bullet_list`:
              Tp(e, n);
              break;
          case `ordered_list`:
              Ep(e, n);
              break;
          case `todo_list`:
              Dp(e, n);
              break;
          default:
              e.renderInline(n)
          }
      }
      ),
      e.write(` |`)
  }
  ,
  Pp = {
      em: {
          open(e, t, n, r) {
              return n.child(r).type.name === `hard_break` ? `` : `*`
          },
          close(e, t, n, r) {
              return n.child(r - 1).type.name === `hard_break` ? `` : `*`
          },
          mixable: !0,
          expelEnclosingWhitespace: !0
      },
      inlineComment: {
          open: ``,
          close: ``,
          mixable: !0,
          expelEnclosingWhitespace: !0
      },
      strong: {
          open(e, t, n, r) {
              return n.child(r).type.name === `hard_break` ? `` : `**`
          },
          close(e, t, n, r) {
              return n.child(r - 1).type.name === `hard_break` ? `` : `**`
          },
          mixable: !0,
          expelEnclosingWhitespace: !0
      },
      link: {
          open: `[`,
          close(e, t) {
              return `](` + e.esc(t.attrs.href ?? ``) + (t.attrs.title ? ` ` + e.quote(t.attrs.title) : ``) + `)`
          }
      },
      strike: {
          open(e, t, n, r) {
              return n.child(r).type.name === `hard_break` ? `` : `~~`
          },
          close(e, t, n, r) {
              return n.child(r - 1).type.name === `hard_break` ? `` : `~~`
          },
          mixable: !0,
          expelEnclosingWhitespace: !0
      },
      code: {
          open(e, t, n, r) {
              return Cp(n.child(r), -1)
          },
          close(e, t, n, r) {
              return Cp(n.child(r - 1), 1)
          },
          escape: !1
      },
      underline: {
          open: ``,
          close: ``,
          mixable: !0,
          expelEnclosingWhitespace: !0
      },
      placeholder: {
          open: `<`,
          close: `>`,
          mixable: !0,
          expelEnclosingWhitespace: !0
      },
      citation: {
          open: ``,
          close: ``,
          mixable: !0,
          expelEnclosingWhitespace: !0,
          escape: !1
      },
      attribution: {
          open: ``,
          close: ``,
          mixable: !0,
          expelEnclosingWhitespace: !0,
          escape: !1
      }
  }
}
));
function rre(e) {
  e.core.ruler.after(`inline`, `block_image`, e => {
      if (e.inlineMode)
          return !1;
      let t = e.tokens;
      for (let n = 0; n < t.length; n++) {
          let r = t[n];
          if (r.type !== `inline` || !r.children?.length || !(n > 0 && t[n - 1].type === `paragraph_open` && t[n + 1]?.type === `paragraph_close`))
              continue;
          let i = ire(e, r);
          if (i.length === 0 || i.length === 1 && i[0][0].type !== `image`)
              continue;
          let a = []
            , o = 0;
          for (let t of i)
              if (t.length === 1 && t[0].type === `image`) {
                  let n = r.content.indexOf(`![`, o)
                    , i = 0
                    , s = n;
                  for (let e = n; e < r.content.length; e++)
                      if (r.content[e] === `(`)
                          i++;
                      else if (r.content[e] === `)` && (i--,
                      i === 0)) {
                          s = e + 1;
                          break
                      }
                  let c = new e.Token(`inline`,``,0);
                  c.children = t,
                  c.content = r.content.slice(n, s),
                  a.push(c),
                  o = s
              } else {
                  let n = r.content.indexOf(`![`, o);
                  for (; n > 0 && r.content[n - 1] === `\\`; )
                      n = r.content.indexOf(`![`, n + 1);
                  n === -1 && (n = void 0);
                  let i = new e.Token(`paragraph_open`,`p`,1)
                    , s = new e.Token(`inline`,``,0);
                  if (s.children = t,
                  s.content = r.content.slice(o, n).trim(),
                  s.children[0]?.type === `text` && (s.children[0].content = s.children[0].content.trimStart()),
                  s.children.at(-1)?.type === `text` && (s.children.at(-1).content = s.children[s.children.length - 1].content.trimEnd()),
                  s.content === `` || s.children.every(e => e.type.endsWith(`_open`) || e.type.endsWith(`_close`)))
                      continue;
                  let c = new e.Token(`paragraph_close`,`p`,-1);
                  a.push(i, s, c),
                  o = s.content.length + o
              }
          t.splice(n - 1, 3, ...a),
          n += a.length - 3
      }
      return !1
  }
  )
}
function ire(e, t) {
  let n = []
    , r = []
    , i = [];
  for (let a of t.children ?? [])
      if (a.type === `image`) {
          if (r.length) {
              for (let t = i.length - 1; t >= 0; t--) {
                  let n = i[t]
                    , a = new e.Token(n.type.replace(`_open`, `_close`),n.tag,-1);
                  r.push(a)
              }
              n.push(r),
              r = [];
              for (let t of i) {
                  let n = new e.Token(t.type,t.tag,1);
                  n.attrs = [...t.attrs ?? []],
                  r.push(n)
              }
          }
          n.push([a])
      } else
          a.type.endsWith(`_open`) ? i.push(a) : a.type.endsWith(`_close`) && i.pop(),
          r.push(a);
  return r.length && n.push(r),
  n
}
var are = t(( () => {}
));
function ore(e) {
  return e.content.match(Rp)
}
function sre(e) {
  return e.type === `inline`
}
function Ip(e) {
  return e?.type === `bullet_list_open` || e?.type === `todo_list_open`
}
function Lp(e) {
  return e?.type === `bullet_list_close` || e?.type === `todo_list_close`
}
function cre(e, t) {
  return e.slice(0, t).filter(e => Ip(e)).length > e.slice(0, t).filter(e => Lp(e)).length
}
function lre(e) {
  return e.type === `paragraph_open`
}
function ure(e, t) {
  return t > 0 && sre(e[t]) && lre(e[t - 1]) && ore(e[t])
}
function dre(e) {
  e.core.ruler.after(`inline`, `todo_lists`, e => {
      let t = e.tokens
        , n = !1
        , r = [];
      for (let e = t.length - 1; e >= 0; e--) {
          Lp(t[e]) ? n = !0 : Ip(t[e]) && !cre(t, e) && (n = !1);
          let i = ure(t, e);
          if (i && n) {
              let n = i[1].toLowerCase() === `x`;
              t[e - 3].type === `bullet_list_open` && (t[e - 3].type = `todo_list_open`),
              t[e + 3].type === `bullet_list_close` && (t[e + 3].type = `todo_list_close`);
              let r = t[e].children;
              if (r) {
                  let n = r[0].content.match(Rp);
                  if (n) {
                      let i = n[2] ?? ``;
                      t[e].content = i,
                      r[0].content = i
                  }
              }
              t[e - 2].type = `todo_item_open`,
              n === !0 && (t[e - 2].attrs = [[`checked`, `true`]]);
              let a = e;
              for (; t[a].type !== `list_item_close`; )
                  a++;
              t[a].type = `todo_item_close`
          }
          e + 3 < t.length && t[e + 3].type === `todo_list_close` && r.push(t[e + 3]),
          t[e].type === `todo_list_open` && r.pop(),
          t[e].type === `bullet_list_open` && r.length > 0 && (t[e].type = `todo_list_open`)
      }
      return !1
  }
  )
}
var Rp, fre = t(( () => {
  Rp = /^\s*\[(X|\s|_|-)\](?:\s|$)(.*)?/is
}
));
function pre(e) {
  e.core.ruler.after(`inline`, `userMention`, e => {
      let t = /@$/;
      e.tokens.forEach(e => {
          if (e.type !== `inline`)
              return;
          let {children: n} = e;
          n && (n.forEach( (e, r) => {
              if (e.type !== `text` || !t.test(e.content) || r + 3 > n.length)
                  return;
              let[i,a,o] = n.slice(r + 1, r + 4);
              if (i.type !== `link_open` || (a.type === `link_close` && (o = a,
              a = void 0),
              o?.type !== `link_close`))
                  return;
              let s = i.attrGet(`href`);
              !s || !Ka(s) || (e.content = e.content.slice(0, -1),
              i.type = `user_mention`,
              i.attrSet(`id`, s),
              a ? (a.content.trim() && i.attrSet(`label`, a.content),
              n.splice(r + 2, 2)) : n.splice(r + 2, 1))
          }
          ),
          e.children = n)
      }
      )
  }
  )
}
var mre = t(( () => {
  qa()
}
));
function zp(e, t) {
  let n = !1
    , r = e.skipChars(t, Bp);
  e.src.charCodeAt(r) === Vp && (r++,
  n = !0);
  let i = r - t
    , a = String.fromCharCode(Bp).repeat(Math.max(i - 1, 0)) + (n ? `>` : `+`);
  return {
      pos: r,
      isOpen: n,
      markerCount: i,
      marker: a
  }
}
function hre(e, t, n, r) {
  let i = !1
    , a = e.bMarks[t] + e.tShift[t]
    , o = e.eMarks[t]
    , {pos: s, isOpen: c, markerCount: l, marker: u} = zp(e, a)
    , d = s;
  if (l < 3)
      return !1;
  let f = e.src.slice(d, o).trim();
  if (f.endsWith(u))
      return !1;
  if (r)
      return !0;
  let p = t
    , m = !0;
  for (; p++,
  !(p >= n || (a = e.bMarks[p] + e.tShift[p],
  o = e.eMarks[p],
  a < o && e.sCount[p] < e.blkIndent)); ) {
      if (e.src.charCodeAt(a) !== Bp) {
          m &&= gre(e, a, o);
          continue
      }
      if (e.sCount[p] - e.blkIndent >= 4)
          continue;
      let t = zp(e, a);
      if (d = t.pos,
      t.marker === u && (d = e.skipSpaces(d),
      !(d < o))) {
          i = !0;
          break
      }
  }
  if (m)
      return !1;
  let h = e.parentType
    , g = e.lineMax;
  e.parentType = `reference`,
  e.lineMax = p;
  let _ = e.push(`collapsible_open`, `details`, 1);
  _.block = !0,
  _.info = f,
  _.markup = u,
  _.map = [t, p],
  c && _.attrSet(`open`, `true`),
  _ = e.push(`collapsible_summary_open`, `summary`, 1),
  _.block = !0;
  let ee = f.trim();
  if (ee)
      if (/^#{1,6}\s/.test(ee)) {
          let n = e.parentType;
          e.parentType = `paragraph`,
          e.bMarks[t] += u.length + 1,
          e.md.block.tokenize(e, t, t + 1),
          e.parentType = n
      } else {
          let t = e.push(`paragraph_open`, `p`, 1);
          t.block = !1;
          let n = e.push(`inline`, ``, 0);
          n.content = ee,
          n.children = [];
          let r = e.push(`paragraph_close`, `p`, -1);
          r.block = !1
      }
  return _ = e.push(`collapsible_summary_close`, `summary`, -1),
  _.block = !0,
  e.md.block.tokenize(e, t + 1, p),
  _ = e.push(`collapsible_close`, `details`, -1),
  _.markup = e.src.slice(a, d),
  _.block = !0,
  e.parentType = h,
  e.lineMax = g,
  e.line = p + (i ? 1 : 0),
  !0
}
function gre(e, t, n) {
  for (; t < n; t++)
      if (!e.md.utils.isWhiteSpace(e.src.charCodeAt(t)))
          return !1;
  return !0
}
function _re(e) {
  e.block.ruler.before(`fence`, `collapsible`, hre, {
      alt: [`paragraph`, `reference`, `blockquote`, `list`]
  })
}
var Bp, Vp, vre = t(( () => {
  Bp = 43,
  Vp = 62
}
));
function yre(e, t, n, r) {
  let i = e.bMarks[t] + e.tShift[t]
    , a = e.eMarks[t];
  if (i + 3 > a)
      return !1;
  let o = e.src.charCodeAt(i);
  if (o !== 96)
      return !1;
  let s = i;
  i = e.skipChars(i, o);
  let c = i - s;
  if (c < 3)
      return !1;
  let l = e.src.slice(s, i)
    , u = e.src.slice(i, a).trim();
  if (!u.startsWith(`mermaid`))
      return !1;
  if (r)
      return !0;
  let d = t
    , f = !1;
  for (; d++,
  !(d >= n || (i = s = e.bMarks[d] + e.tShift[d],
  a = e.eMarks[d],
  i < a && e.sCount[d] < e.blkIndent)); )
      if (e.src.charCodeAt(i) === o && !(e.sCount[d] - e.blkIndent >= 4) && (i = e.skipChars(i, o),
      !(i - s < c) && (i = e.skipSpaces(i),
      !(i < a)))) {
          f = !0;
          break
      }
  let p = e.parentType
    , m = e.lineMax;
  e.parentType = `reference`,
  e.lineMax = d;
  let h = e.push(`diagram_open`, `diagram`, 1);
  h.info = u,
  h.markup = l,
  h.block = !0,
  h.map = [t, d + (f ? 1 : 0)];
  let g = e.getLines(t + 1, d, e.tShift[t], !0);
  if (g.trim()) {
      let t = e.push(`text`, ``, 0);
      t.content = g.replace(/\n$/, ``)
  }
  return h = e.push(`diagram_close`, `diagram`, -1),
  h.block = !0,
  e.parentType = p,
  e.lineMax = m,
  e.line = d + (f ? 1 : 0),
  !0
}
function bre(e) {
  e.block.ruler.before(`fence`, `diagram`, yre, {
      alt: [`paragraph`, `reference`, `blockquote`, `list`]
  })
}
var xre = t(( () => {}
));
function Sre(e, t) {
  return Object.keys(t).reduce( (n, r) => {
      let i = t[r]
        , a = i.block || i.node
        , o = i.mark;
      return (a && e.nodes[a] || o && e.marks[o]) && (n[r] = i),
      n
  }
  , {})
}
var Hp, Up, Wp, Gp = t(( () => {
  pn(),
  Gee(),
  Uee(),
  ul(),
  vp(),
  ml(),
  Qne(),
  nre(),
  Fp(),
  are(),
  fre(),
  mre(),
  vre(),
  xre(),
  Hp = class e {
      static imageRegex = /!\[(?<alt>[^\][]*?)]\((?<filename>[^\][]*?)(?="|\))"?(?<title>[^\]["]+)?"?\)/g;
      static parseToProsemirrorData(e, t) {
          return this.instance(t).parse(e)?.toJSON()
      }
      static parseToProsemirrorNode(e, t) {
          return this.instance(t).parse(e) ?? void 0
      }
      static serialize(e, t) {
          let n = e instanceof an ? e : this.instance().schema.nodeFromJSON(e);
          return this.instance().serialize(n, t)
      }
      static nodeFromJSON(e) {
          return this.instance().schema.nodeFromJSON(e)
      }
      static serializeLeafNode(e) {
          let t = e.type, n, r = ll[t];
          if (t === `hard_break`)
              return `
`;
          if (t === `list_item`)
              n = `bullet_list`;
          else if (`group`in r && r.group?.includes(`block`))
              n = `doc`;
          else if (`group`in r && r.group?.includes(`inline`))
              n = `paragraph`;
          else
              for (let[e,r] of Object.entries(ll))
                  if (`content`in r && r.content?.includes(t)) {
                      n = e;
                      break
                  }
          if (!n)
              throw Error(`Unknown or doc type for serializeLeafNode: ${e.type}`);
          let i = {
              content: [e],
              type: n
          }
            , a = this.instance().schema.nodeFromJSON(n === `doc` ? i : {
              content: [i],
              type: `doc`
          });
          return this.instance().serialize(a)
      }
      serialize(e, t) {
          return new Wee(this.nodes,this.marks).serialize(e, {
              includeImageDimensions: t?.includeImageDimensions ?? !1,
              hardBreakDelimiter: t?.hardBreakDelimiter,
              tightLists: !0
          })
      }
      parse(e) {
          return this.markdownParser.parse(e)
      }
      static instances = new WeakMap;
      markdownParser;
      nodes;
      marks;
      constructor(e) {
          this.schema = e;
          let t = Hee(`commonmark`, this.tokenizerOptions()).use(dre).use(Zne).use(pre);
          t.normalizeLinkText = e => e,
          t.block.ruler.enableOnly([]),
          t.inline.ruler.enableOnly([`entity`, `escape`, `text`]);
          let n = {
              tokenizer: t,
              nodes: wp,
              marks: Pp
          };
          this.nodes = n.nodes,
          this.marks = n.marks,
          [`nodes`, `marks`].forEach(e => {
              for (let t in Up[e])
                  this.schema[e][t] && n.tokenizer.enable(Up[e][t])
          }
          ),
          this.schema.nodes.table && n.tokenizer.use(Sp),
          this.schema.nodes.image && n.tokenizer.use(rre),
          this.schema.nodes.collapsible_section && n.tokenizer.use(_re),
          this.schema.nodes.diagram && n.tokenizer.use(bre),
          this.injectTokenizerPlugins(n.tokenizer),
          this.markdownParser = new Kee(this.schema,n.tokenizer,Sre(e, Wp))
      }
      tokenizerOptions() {
          return {
              html: !1,
              linkify: !0
          }
      }
      injectTokenizerPlugins(e) {}
      static instance(t=dl) {
          return this.instances.has(t) || this.instances.set(t, new e(t)),
          this.instances.get(t)
      }
  }
  ,
  Up = {
      nodes: {
          blockquote: `blockquote`,
          paragraph: `paragraph`,
          horizontal_rule: `hr`,
          heading: [`heading`, `lheading`],
          code_block: [`code`, `fence`],
          diagram: [`code`, `fence`],
          list_item: `list`,
          image: `image`
      },
      marks: {
          em: `emphasis`,
          inlineComment: `text`,
          strong: `text`,
          link: [`link`, `autolink`, `reference`, `linkify`],
          strike: `strikethrough`,
          code: `backticks`
      }
  },
  Wp = {
      blockquote: {
          block: `blockquote`
      },
      paragraph: {
          block: `paragraph`
      },
      em: {
          mark: `em`
      },
      strong: {
          mark: `strong`
      },
      link: {
          mark: `link`,
          getAttrs: e => ({
              href: e.attrGet(`href`)
          })
      },
      hr: {
          node: `horizontal_rule`
      },
      heading: {
          block: `heading`,
          getAttrs: e => ({
              level: +e.tag.slice(1),
              id: _p()
          })
      },
      image: {
          node: `image`,
          getAttrs: e => {
              let t = e.attrGet(`displayWidth`)
                , n = e.attrGet(`width`)
                , r = e.attrGet(`height`)
                , i = e.children?.[0];
              return {
                  src: e.attrGet(`src`),
                  displayWidth: t ? +t : null,
                  width: n ? +n : null,
                  height: r ? +r : null,
                  title: e.attrGet(`title`) || null,
                  alt: i?.content || null
              }
          }
      },
      collapsible: {
          block: `collapsible_section`,
          getAttrs: () => ({
              id: _p()
          })
      },
      collapsible_summary: {
          block: `collapsible_heading`
      },
      softbreak: {
          node: `hard_break`
      },
      hardbreak: {
          node: `hard_break`
      },
      code_block: {
          block: `code_block`,
          getAttrs: e => ({
              language: e.info || null,
              id: _p()
          })
      },
      todo_list: {
          block: `todo_list`
      },
      todo_item: {
          block: `todo_item`,
          getAttrs: e => ({
              done: e.attrGet(`checked`) === `true`
          })
      },
      list_item: {
          block: `list_item`
      },
      bullet_list: {
          block: `bullet_list`
      },
      ordered_list: {
          block: `ordered_list`,
          getAttrs: e => ({
              order: +(e.attrGet(`start`) || 1)
          })
      },
      code_inline: {
          mark: `code`
      },
      fence: {
          block: `code_block`,
          getAttrs: e => ({
              language: e.info || null,
              id: _p()
          })
      },
      diagram: {
          block: `diagram`,
          getAttrs: e => ({
              language: e.info || `mermaid`,
              id: _p()
          })
      },
      table: {
          block: `table`
      },
      tr: {
          block: `table_row`
      },
      th: {
          block: `table_header`
      },
      td: {
          block: `table_cell`
      },
      s: {
          mark: `strike`
      },
      user_mention: {
          node: `suggestion_userMentions`,
          getAttrs: e => ({
              id: e.attrGet(`id`),
              label: e.attrGet(`label`)
          })
      }
  }
}
)), Cre = n(( (e, t) => {
  (function() {
      var e = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`
        , n = {
          rotl: function(e, t) {
              return e << t | e >>> 32 - t
          },
          rotr: function(e, t) {
              return e << 32 - t | e >>> t
          },
          endian: function(e) {
              if (e.constructor == Number)
                  return n.rotl(e, 8) & 16711935 | n.rotl(e, 24) & 4278255360;
              for (var t = 0; t < e.length; t++)
                  e[t] = n.endian(e[t]);
              return e
          },
          randomBytes: function(e) {
              for (var t = []; e > 0; e--)
                  t.push(Math.floor(Math.random() * 256));
              return t
          },
          bytesToWords: function(e) {
              for (var t = [], n = 0, r = 0; n < e.length; n++,
              r += 8)
                  t[r >>> 5] |= e[n] << 24 - r % 32;
              return t
          },
          wordsToBytes: function(e) {
              for (var t = [], n = 0; n < e.length * 32; n += 8)
                  t.push(e[n >>> 5] >>> 24 - n % 32 & 255);
              return t
          },
          bytesToHex: function(e) {
              for (var t = [], n = 0; n < e.length; n++)
                  t.push((e[n] >>> 4).toString(16)),
                  t.push((e[n] & 15).toString(16));
              return t.join(``)
          },
          hexToBytes: function(e) {
              for (var t = [], n = 0; n < e.length; n += 2)
                  t.push(parseInt(e.substr(n, 2), 16));
              return t
          },
          bytesToBase64: function(t) {
              for (var n = [], r = 0; r < t.length; r += 3)
                  for (var i = t[r] << 16 | t[r + 1] << 8 | t[r + 2], a = 0; a < 4; a++)
                      r * 8 + a * 6 <= t.length * 8 ? n.push(e.charAt(i >>> 6 * (3 - a) & 63)) : n.push(`=`);
              return n.join(``)
          },
          base64ToBytes: function(t) {
              t = t.replace(/[^A-Z0-9+\/]/gi, ``);
              for (var n = [], r = 0, i = 0; r < t.length; i = ++r % 4)
                  i != 0 && n.push((e.indexOf(t.charAt(r - 1)) & 2 ** (-2 * i + 8) - 1) << i * 2 | e.indexOf(t.charAt(r)) >>> 6 - i * 2);
              return n
          }
      };
      t.exports = n
  }
  )()
}
)), Kp = n(( (e, t) => {
  var n = {
      utf8: {
          stringToBytes: function(e) {
              return n.bin.stringToBytes(unescape(encodeURIComponent(e)))
          },
          bytesToString: function(e) {
              return decodeURIComponent(escape(n.bin.bytesToString(e)))
          }
      },
      bin: {
          stringToBytes: function(e) {
              for (var t = [], n = 0; n < e.length; n++)
                  t.push(e.charCodeAt(n) & 255);
              return t
          },
          bytesToString: function(e) {
              for (var t = [], n = 0; n < e.length; n++)
                  t.push(String.fromCharCode(e[n]));
              return t.join(``)
          }
      }
  };
  t.exports = n
}
)), wre = n(( (e, t) => {
  t.exports = function(e) {
      return e != null && (n(e) || r(e) || !!e._isBuffer)
  }
  ;
  function n(e) {
      return !!e.constructor && typeof e.constructor.isBuffer == `function` && e.constructor.isBuffer(e)
  }
  function r(e) {
      return typeof e.readFloatLE == `function` && typeof e.slice == `function` && n(e.slice(0, 0))
  }
}
)), qp = n(( (e, t) => {
  (function() {
      var e = Cre()
        , n = Kp().utf8
        , r = wre()
        , i = Kp().bin
        , a = function(t, o) {
          t.constructor == String ? t = o && o.encoding === `binary` ? i.stringToBytes(t) : n.stringToBytes(t) : r(t) ? t = Array.prototype.slice.call(t, 0) : Array.isArray(t) || (t = t.toString());
          for (var s = e.bytesToWords(t), c = t.length * 8, l = 1732584193, u = -271733879, d = -1732584194, f = 271733878, p = 0; p < s.length; p++)
              s[p] = (s[p] << 8 | s[p] >>> 24) & 16711935 | (s[p] << 24 | s[p] >>> 8) & 4278255360;
          s[c >>> 5] |= 128 << c % 32,
          s[(c + 64 >>> 9 << 4) + 14] = c;
          for (var m = a._ff, h = a._gg, g = a._hh, _ = a._ii, p = 0; p < s.length; p += 16) {
              var ee = l
                , te = u
                , ne = d
                , re = f;
              l = m(l, u, d, f, s[p + 0], 7, -680876936),
              f = m(f, l, u, d, s[p + 1], 12, -389564586),
              d = m(d, f, l, u, s[p + 2], 17, 606105819),
              u = m(u, d, f, l, s[p + 3], 22, -1044525330),
              l = m(l, u, d, f, s[p + 4], 7, -176418897),
              f = m(f, l, u, d, s[p + 5], 12, 1200080426),
              d = m(d, f, l, u, s[p + 6], 17, -1473231341),
              u = m(u, d, f, l, s[p + 7], 22, -45705983),
              l = m(l, u, d, f, s[p + 8], 7, 1770035416),
              f = m(f, l, u, d, s[p + 9], 12, -1958414417),
              d = m(d, f, l, u, s[p + 10], 17, -42063),
              u = m(u, d, f, l, s[p + 11], 22, -1990404162),
              l = m(l, u, d, f, s[p + 12], 7, 1804603682),
              f = m(f, l, u, d, s[p + 13], 12, -40341101),
              d = m(d, f, l, u, s[p + 14], 17, -1502002290),
              u = m(u, d, f, l, s[p + 15], 22, 1236535329),
              l = h(l, u, d, f, s[p + 1], 5, -165796510),
              f = h(f, l, u, d, s[p + 6], 9, -1069501632),
              d = h(d, f, l, u, s[p + 11], 14, 643717713),
              u = h(u, d, f, l, s[p + 0], 20, -373897302),
              l = h(l, u, d, f, s[p + 5], 5, -701558691),
              f = h(f, l, u, d, s[p + 10], 9, 38016083),
              d = h(d, f, l, u, s[p + 15], 14, -660478335),
              u = h(u, d, f, l, s[p + 4], 20, -405537848),
              l = h(l, u, d, f, s[p + 9], 5, 568446438),
              f = h(f, l, u, d, s[p + 14], 9, -1019803690),
              d = h(d, f, l, u, s[p + 3], 14, -187363961),
              u = h(u, d, f, l, s[p + 8], 20, 1163531501),
              l = h(l, u, d, f, s[p + 13], 5, -1444681467),
              f = h(f, l, u, d, s[p + 2], 9, -51403784),
              d = h(d, f, l, u, s[p + 7], 14, 1735328473),
              u = h(u, d, f, l, s[p + 12], 20, -1926607734),
              l = g(l, u, d, f, s[p + 5], 4, -378558),
              f = g(f, l, u, d, s[p + 8], 11, -2022574463),
              d = g(d, f, l, u, s[p + 11], 16, 1839030562),
              u = g(u, d, f, l, s[p + 14], 23, -35309556),
              l = g(l, u, d, f, s[p + 1], 4, -1530992060),
              f = g(f, l, u, d, s[p + 4], 11, 1272893353),
              d = g(d, f, l, u, s[p + 7], 16, -155497632),
              u = g(u, d, f, l, s[p + 10], 23, -1094730640),
              l = g(l, u, d, f, s[p + 13], 4, 681279174),
              f = g(f, l, u, d, s[p + 0], 11, -358537222),
              d = g(d, f, l, u, s[p + 3], 16, -722521979),
              u = g(u, d, f, l, s[p + 6], 23, 76029189),
              l = g(l, u, d, f, s[p + 9], 4, -640364487),
              f = g(f, l, u, d, s[p + 12], 11, -421815835),
              d = g(d, f, l, u, s[p + 15], 16, 530742520),
              u = g(u, d, f, l, s[p + 2], 23, -995338651),
              l = _(l, u, d, f, s[p + 0], 6, -198630844),
              f = _(f, l, u, d, s[p + 7], 10, 1126891415),
              d = _(d, f, l, u, s[p + 14], 15, -1416354905),
              u = _(u, d, f, l, s[p + 5], 21, -57434055),
              l = _(l, u, d, f, s[p + 12], 6, 1700485571),
              f = _(f, l, u, d, s[p + 3], 10, -1894986606),
              d = _(d, f, l, u, s[p + 10], 15, -1051523),
              u = _(u, d, f, l, s[p + 1], 21, -2054922799),
              l = _(l, u, d, f, s[p + 8], 6, 1873313359),
              f = _(f, l, u, d, s[p + 15], 10, -30611744),
              d = _(d, f, l, u, s[p + 6], 15, -1560198380),
              u = _(u, d, f, l, s[p + 13], 21, 1309151649),
              l = _(l, u, d, f, s[p + 4], 6, -145523070),
              f = _(f, l, u, d, s[p + 11], 10, -1120210379),
              d = _(d, f, l, u, s[p + 2], 15, 718787259),
              u = _(u, d, f, l, s[p + 9], 21, -343485551),
              l = l + ee >>> 0,
              u = u + te >>> 0,
              d = d + ne >>> 0,
              f = f + re >>> 0
          }
          return e.endian([l, u, d, f])
      };
      a._ff = function(e, t, n, r, i, a, o) {
          var s = e + (t & n | ~t & r) + (i >>> 0) + o;
          return (s << a | s >>> 32 - a) + t
      }
      ,
      a._gg = function(e, t, n, r, i, a, o) {
          var s = e + (t & r | n & ~r) + (i >>> 0) + o;
          return (s << a | s >>> 32 - a) + t
      }
      ,
      a._hh = function(e, t, n, r, i, a, o) {
          var s = e + (t ^ n ^ r) + (i >>> 0) + o;
          return (s << a | s >>> 32 - a) + t
      }
      ,
      a._ii = function(e, t, n, r, i, a, o) {
          var s = e + (n ^ (t | ~r)) + (i >>> 0) + o;
          return (s << a | s >>> 32 - a) + t
      }
      ,
      a._blocksize = 16,
      a._digestsize = 16,
      t.exports = function(t, n) {
          if (t == null)
              throw Error(`Illegal argument ` + t);
          var r = e.wordsToBytes(a(t, n));
          return n && n.asBytes ? r : n && n.asString ? i.bytesToString(r) : e.bytesToHex(r)
      }
  }
  )()
}
)), Jp, Yp, Xp = t(( () => {
  Jp = class e extends Promise {
      constructor(e) {
          if (typeof e == `function`) {
              let t, n;
              super( (e, r) => {
                  t = e,
                  n = r
              }
              ),
              e(e => {
                  this.__result__ = {
                      resolved: e,
                      success: !0
                  },
                  t(e)
              }
              , e => {
                  this.__result__ = {
                      rejected: e,
                      success: !1
                  },
                  n(e)
              }
              )
          } else
              super(t => {
                  t(e)
              }
              ),
              this.__result__ = {
                  resolved: e,
                  success: !0
              }
      }
      get value() {
          return this.__result__?.resolved
      }
      get error() {
          return this.__result__?.rejected
      }
      get isPending() {
          return this.__result__ === void 0
      }
      static create(t) {
          return new e(t)
      }
      static allResolved(t) {
          let n = !0;
          for (let e of t) {
              if (e.error)
                  return e;
              e.isPending && (n = !1)
          }
          return n ? Yp : new e( (e, n) => {
              Promise.all(t).then( () => {
                  e()
              }
              ).catch(e => {
                  n(e)
              }
              )
          }
          )
      }
  }
  ,
  Yp = Jp.resolve()
}
)), Zp, Qp = t(( () => {
  pi(),
  Xp(),
  Zp = class e {
      static trace(t, n, r) {
          return n && r ? e.shouldTrack(t) ? e.execute(n, this, r, []) : r() : (n, r, i) => {
              if (e.shouldTrack(t)) {
                  let t = i.value;
                  i.value = function(...i) {
                      let a = `${this.constructorName || n.constructor?.constructorName || ``}.${r}`;
                      return e.execute(a, this, t, i)
                  }
              }
              return i
          }
      }
      static createSpanFromStart(t, n) {
          e.shouldTrack(t) && performance.measure(n)
      }
      static addArguments(...e) {
          this.currentSpanName && this.currentSpanName(t => `${t} [${e.map(e => JSON.stringify(e)).join(`, `)}]`)
      }
      static cancelSpan() {
          this.currentSpanName?.( () => void 0),
          this.currentSpanName = void 0
      }
      static disable() {
          this.disabled = !0
      }
      static #e = this.disabled = !1;
      static #t = this.callCount = 0;
      static execute(t, n, r, i) {
          if (e.disabled)
              return r.apply(n, i);
          let a = t;
          this.currentSpanName = e => {
              a = e(a)
          }
          ;
          let o = e.callCount++
            , s = `start_${o}`
            , c = `end_${o}`;
          performance.mark(s);
          let l = r.apply(n, i)
            , u = performance.now()
            , d = e => {
              try {
                  if (a === void 0)
                      return;
                  let t = e ? u : performance.now();
                  performance.mark(c, {
                      startTime: t
                  }),
                  performance.measure(a, s, c),
                  performance.clearMarks(s),
                  performance.clearMarks(c),
                  this.currentSpanName = void 0
              } catch {}
          }
          ;
          if (l instanceof Jp && !l.isPending)
              d(!0);
          else if (l instanceof Promise) {
              let e = !0;
              l.then( () => {
                  d(e)
              }
              ).catch( () => {
                  d(e)
              }
              ),
              Promise.resolve().then( () => {
                  e = !1
              }
              )
          } else
              d(!1);
          return l
      }
      static shouldTrack(t) {
          return e.categories ||= new Set(di.getValue(di.tracingCategories, ``).split(`,`)),
          e.disabled === !1 && (e.categories.has(t) || e.categories.has(`all`))
      }
  }
}
)), $p, em, tm, nm = t(( () => {
  $p = e(qp(), 1),
  zt(),
  em = class e {
      static get schemaHash() {
          return e._schemaHash
      }
      static getModelNames(e) {
          return e ? Object.keys(this.modelLookup).filter(t => this.modelLookup[t].loadStrategy === e) : Object.keys(this.modelLookup)
      }
      static getModelNamesByLoadStrategy(e, t) {
          return Object.keys(this.modelLookup).filter(n => this.modelLookup[n].loadStrategy >= e && this.modelLookup[n].loadStrategy <= t)
      }
      static getModelClasses(e) {
          return e ? Object.values(this.modelLookup).filter(t => t.loadStrategy === e) : Object.values(this.modelLookup)
      }
      static getModelClass(e) {
          return this.modelLookup[e]
      }
      static registerModel(t, n, r) {
          this.modelLookup[t] = n,
          n.prototype.modelName = t,
          n.name !== t && (this.modelPropertyLookup[t] = this.modelPropertyLookup[n.name],
          delete this.modelPropertyLookup[n.name],
          this.modelActionLookup[t] = this.modelActionLookup[n.name],
          delete this.modelActionLookup[n.name],
          this.modelDataPropertyLookup[t] = this.modelDataPropertyLookup[n.name],
          delete this.modelDataPropertyLookup[n.name],
          this.modelReferencedPropertyLookup[t] = this.modelReferencedPropertyLookup[n.name],
          delete this.modelReferencedPropertyLookup[n.name],
          this.modelLazyCollectionKeys[t] = this.modelLazyCollectionKeys[n.name],
          delete this.modelLazyCollectionKeys[n.name],
          this.modelLazyReferenceKeys[t] = this.modelLazyReferenceKeys[n.name],
          delete this.modelLazyReferenceKeys[n.name],
          this.modelCascadeHydrationKeys[t] = this.modelCascadeHydrationKeys[n.name],
          delete this.modelCascadeHydrationKeys[n.name]),
          this.modelPropertyHashLookup[t] = r,
          e._schemaHash = (0,
          $p.default)(e._schemaHash + r)
      }
      static registerProperty(e, t, n) {
          let r = this.modelPropertyLookup[e];
          if (r ? r[t] = n : (this.modelPropertyLookup[e] = {
              id: {
                  type: tm.property,
                  persistence: `createOnly`
              }
          },
          this.modelPropertyLookup[e][t] = n),
          n.referencedProperty || n.type === tm.reference || n.type === tm.referenceArray) {
              let r = this.modelReferencedPropertyLookup[e];
              r ? r[t] = n : (this.modelReferencedPropertyLookup[e] = {},
              this.modelReferencedPropertyLookup[e][t] = n)
          }
          if (n.lazy)
              if (n.type === tm.referenceCollection) {
                  let n = this.modelLazyCollectionKeys[e];
                  n ? n.push(t) : this.modelLazyCollectionKeys[e] = [t]
              } else {
                  let n = this.modelLazyReferenceKeys[e];
                  n ? n.push(t) : this.modelLazyReferenceKeys[e] = [t]
              }
          if (n.cascadeHydration) {
              let n = this.modelCascadeHydrationKeys[e];
              n ? n.push(t) : this.modelCascadeHydrationKeys[e] = [t]
          }
      }
      static registerAction(e, t) {
          let n = this.modelActionLookup[e];
          n ? n.push(t) : this.modelActionLookup[e] = [t]
      }
      static propertiesOfModel(e) {
          return this.modelPropertyLookup[e] || {}
      }
      static dataPropertiesOfModel(e) {
          if (!this.modelDataPropertyLookup[e])
              for (let t in this.modelDataPropertyLookup[e] = {},
              this.modelPropertyLookup[e]) {
                  let n = this.modelPropertyLookup[e][t];
                  (n.type === void 0 || n.type === tm.property || n.type === tm.ephemeralProperty || n.type === tm.reference || n.type === tm.referenceArray) && (this.modelDataPropertyLookup[e][t] = n)
              }
          return this.modelDataPropertyLookup[e]
      }
      static referencedPropertiesOfModel(e) {
          return this.modelReferencedPropertyLookup[e] || {}
      }
      static lazyCollectionKeysOfModel(e) {
          return this.modelLazyCollectionKeys[e] || []
      }
      static lazyReferenceKeysOfModel(e) {
          return this.modelLazyReferenceKeys[e] || []
      }
      static cascadeHydrationKeysOfModel(e) {
          return this.modelCascadeHydrationKeys[e] || []
      }
      static propertyHashOfModel(e) {
          return this.modelPropertyHashLookup[e] || ``
      }
      static actionAnnotationsForModel(e) {
          let t = {};
          for (let n of this.modelActionLookup[e] || [])
              t[n] = Ft;
          return t
      }
      static dependenciesOfModel(e) {
          if (!this.allModelDependenciesCache) {
              let e = {};
              for (let t of this.getModelNames()) {
                  let n = this.getModelClass(t);
                  if (!n)
                      continue;
                  let r = this.propertiesOfModel(t);
                  for (let[t,i] of Object.entries(r)) {
                      if (i.type !== tm.reference && i.type !== tm.referenceArray)
                          continue;
                      let r = i.referencedClassResolver?.();
                      if (!r)
                          continue;
                      let a = i.onDelete ?? (i.referenceNullable || i.type === tm.referenceArray ? `SET NULL` : `CASCADE`)
                        , o = i.onArchive ?? a;
                      if (a === `NO ACTION` && o === `NO ACTION`)
                          continue;
                      let s = {
                          model: n,
                          property: t,
                          propertyInfo: i,
                          backReference: i.referencedProperty,
                          deleteType: a,
                          archiveType: o,
                          isOptional: i.referenceOptional ?? !1
                      }
                        , c = r.modelName;
                      e[c] || (e[c] = []),
                      e[c].push(s)
                  }
              }
              this.allModelDependenciesCache = Object.freeze(e)
          }
          return this.allModelDependenciesCache[e] || []
      }
      static referencedModelClass(t, n) {
          let r = e.propertiesOfModel(t)[n]?.referencedClassResolver;
          if (r)
              return r();
          let i = `${t}.${n}`;
          this.reverseDependenciesCache ||= {};
          let a = this.reverseDependenciesCache[i];
          return a === void 0 && (a = e.dependenciesOfModel(t)?.find(e => e.backReference === n),
          this.reverseDependenciesCache[i] = a ?? null),
          a?.model
      }
      static dependencyOrder() {
          if (!this.dependencyOrderCache) {
              let t = e.getModelClasses()
                , n = new Map
                , r = (t, i) => e.dependenciesOfModel(t.modelName).map(e => {
                  if (i.includes(e.model.modelName))
                      return;
                  if (n.has(e.model.modelName))
                      return n.get(e.model.modelName);
                  let t = {
                      modelName: e.model.modelName,
                      path: i,
                      children: r(e.model, [...i, e.model.modelName])
                  };
                  return n.set(t.modelName, t),
                  t
              }
              ).concrete()
                , i = t.filter(n => !t.some(t => t !== n && e.dependenciesOfModel(t.modelName).some(e => e.model === n)));
              for (let e of i) {
                  let t = {
                      modelName: e.modelName,
                      path: [],
                      children: []
                  };
                  n.set(t.modelName, t),
                  t.children = r(e, [t.modelName])
              }
              let a = {
                  roots: [...n.values()].filter(e => e.path.length === 0)
              }
                , o = (e, t) => e.children.length === t.children.length ? e.modelName.localeCompare(t.modelName) : t.children.length - e.children.length
                , s = []
                , c = a.roots;
              for (c.sort(o); c.length; ) {
                  for (let e of c)
                      s.includes(e.modelName) || s.push(e.modelName);
                  c = c.flatMap(e => e.children),
                  c.sort(o)
              }
              this.dependencyOrderCache = Object.freeze(s)
          }
          return this.dependencyOrderCache
      }
      static hasUniqueAssociativeReferenceToModelType(e, t) {
          let n = this.referencedPropertiesOfModel(e);
          return Object.values(n).filter(e => e.referencedClassResolver?.() === t && e.referencedProperty !== void 0).length === 1
      }
      static #e = this._schemaHash = ``;
      static #t = this.modelLookup = {};
      static #n = this.modelPropertyLookup = {};
      static #r = this.modelActionLookup = {};
      static #i = this.modelDataPropertyLookup = {};
      static #a = this.modelReferencedPropertyLookup = {};
      static #o = this.modelLazyReferenceKeys = {};
      static #s = this.modelLazyCollectionKeys = {};
      static #c = this.modelCascadeHydrationKeys = {};
      static #l = this.modelPropertyHashLookup = {}
  }
  ,
  tm = function(e) {
      return e[e.property = 0] = `property`,
      e[e.ephemeralProperty = 1] = `ephemeralProperty`,
      e[e.reference = 2] = `reference`,
      e[e.referencedModel = 3] = `referencedModel`,
      e[e.referenceCollection = 4] = `referenceCollection`,
      e[e.backReference = 5] = `backReference`,
      e[e.referenceArray = 6] = `referenceArray`,
      e
  }({})
}
)), rm, im, am, om = t(( () => {
  rm = function(e) {
      return e[e.instant = 1] = `instant`,
      e[e.placeholder = 2] = `placeholder`,
      e[e.lazy = 3] = `lazy`,
      e[e.partial = 4] = `partial`,
      e[e.explicitlyRequested = 5] = `explicitlyRequested`,
      e[e.local = 6] = `local`,
      e
  }({}),
  im = function(e) {
      return e[e.full = 1] = `full`,
      e[e.regular = 2] = `regular`,
      e
  }({}),
  am = function(e) {
      return e[e.noPreload = 1] = `noPreload`,
      e[e.firstPriority = 2] = `firstPriority`,
      e[e.secondPriority = 3] = `secondPriority`,
      e
  }({})
}
)), sm, cm = t(( () => {
  sm = class {
      static #e = this.FULLY_LOADED_INDEX_NAME = `#fullyLoaded#`;
      static constructPartialIndexValue(e, t, n) {
          return n ? t.toString() : `${e}-${t}`
      }
  }
}
)), lm, um = t(( () => {
  lm = class e {
      static #e = this.identifier = Symbol(`LazyIdentifier`);
      static isLazy(t) {
          return typeof t == `object` && !!t && e.identifier in t
      }
  }
}
)), dm, fm, pm = t(( () => {
  dm = class extends Error {
      constructor(e, t) {
          super(`Hydrating a model of type ${e.modelName} failed due to network error`),
          this.modelClass = e,
          this.modelName = e.modelName,
          this.underlyingError = t
      }
  }
  ,
  fm = class extends Error {
      constructor(e, t, n) {
          super(n.message),
          this.modelClass = e,
          this.indexKey = t,
          this.underlyingError = n
      }
  }
}
)), mm, hm = t(( () => {
  mm = class {
      static #e = this.accessCount = 0;
      static registerAccess() {
          this.accessCount += 1
      }
      static reset() {
          this.accessCount = 0
      }
  }
}
));
function M(e, t, n, r) {
  var i = arguments.length, a = i < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, n) : r, o;
  if (typeof Reflect == `object` && typeof Reflect.decorate == `function`)
      a = Reflect.decorate(e, t, n, r);
  else
      for (var s = e.length - 1; s >= 0; s--)
          (o = e[s]) && (a = (i < 3 ? o(a) : i > 3 ? o(t, n, a) : o(t, n)) || a);
  return i > 3 && a && Object.defineProperty(t, n, a),
  a
}
var N = t(( () => {}
)), gm, _m, vm, ym, bm, xm, Sm = t(( () => {
  zt(),
  um(),
  Xp(),
  ws(),
  F(),
  nm(),
  Tm(),
  pm(),
  hm(),
  N(),
  _m = class e {
      constructor() {
          this[gm] = !0,
          this._value = void 0,
          this.observable = !1
      }
      static #e = gm = lm.identifier;
      static unwrap(t) {
          return t instanceof e ? t.value : t
      }
      isResolved() {
          return !!(this.hydrationPromise && !this.hydrationPromise.error && !this.hydrationPromise.isPending && !this.isHydrationPromiseLocalOnly)
      }
      get value() {
          if (this.startObservation(),
          this._value)
              return this._value.observePropertyChanges(),
              this._value;
          this.resolve()
      }
      set value(e) {
          Mt( () => {
              this._value = e,
              e ? this.hydrationPromise = new Jp(e) : this.hydrationPromise = void 0
          }
          )
      }
      get unsafeValue() {
          return this.startObservation(),
          this._value
      }
      then(e, t) {
          return this.resolve().then(e, t)
      }
      static isLazy(t) {
          return t instanceof e
      }
      startObservation() {
          this.observable || (this.observable = !0,
          At(this))
      }
      invalidateRejectedWhenRequested() {
          this._invalidateRejectedWhenRequestedSubscribed ||= (qh.store.onInvalidateRejectedHydrations.subscribeOnce( () => this.invalidateRejectedHydrationPromises()),
          !0)
      }
      invalidateRejectedHydrationPromises() {
          this.hydrationPromise?.error && (this.hydrationPromise = void 0,
          this.isHydrationPromiseLocalOnly = !1),
          this._invalidateRejectedWhenRequestedSubscribed = !1
      }
  }
  ,
  M([Vt], _m.prototype, `_value`, void 0),
  vm = class extends _m {
      static wrap(e) {
          return new bm(e)
      }
      constructor(e, t) {
          super(),
          this.referencedClass = t,
          this.id = e
      }
      get id() {
          return this.startObservation(),
          this._id
      }
      set id(e) {
          Mt( () => {
              this._id = e,
              this._value = qh.store.findById(this.referencedClass, e),
              this._value ? this.hydrationPromise = new Jp(this._value) : this.hydrationPromise = void 0
          }
          )
      }
      get value() {
          let e = super.value ?? qh.store.findById(this.referencedClass, this._id);
          return qh.store.developerOptions?.nonHydratedLazyReferenceValueDebug && !this.isResolved() && (mm.registerAccess(),
          w.info(`Hydration: Accessing non hydrated lazy reference value`, {
              modelName: this.referencedClass.modelName,
              id: this._id,
              stack: Error().stack
          })),
          e
      }
      set value(e) {
          super.value = e,
          e && (this._id = e.id)
      }
      resolve(e) {
          return this.startObservation(),
          this._value,
          this.isHydrationPromiseLocalOnly && e?.onlyIfLocallyAvailable !== !0 && (this.hydrationPromise = void 0),
          this.hydrationPromise ? this.hydrationPromise : (this.isHydrationPromiseLocalOnly = e?.onlyIfLocallyAvailable === !0,
          this.hydrationPromise = new Jp(async (t, n) => {
              await qh.store.hydrateModel(this.referencedClass, this._id, e).then(Ft(e => {
                  e && (this.isHydrationPromiseLocalOnly = !1,
                  e.observePropertyChanges()),
                  this._value = e,
                  t(e)
              }
              )).catch(async e => {
                  w.error(`Hydration of model from disk or network failed`, e, {
                      modelClass: this.referencedClass.name,
                      id: this._id
                  }),
                  this.invalidateRejectedWhenRequested(),
                  n(new dm(this.referencedClass,e))
              }
              )
          }
          ),
          this.hydrationPromise.catch(e => {
              w.info(`Error while hydrating lazy reference`, {
                  modelName: this.referencedClass.modelName,
                  id: this._id,
                  error: e
              })
          }
          ),
          this.hydrationPromise)
      }
      get logMetadata() {
          return {
              type: `LazyReference`,
              modelName: this.referencedClass.modelName,
              modelId: this._id
          }
      }
  }
  ,
  M([Vt], vm.prototype, `_id`, void 0),
  ym = class extends _m {
      static wrap(e) {
          return new xm(e)
      }
      constructor(e, t, n) {
          super(),
          this.model = e,
          this.referencedKey = t,
          this.options = n
      }
      get value() {
          let e = super.value;
          return qh.store.developerOptions?.nonHydratedLazyReferenceValueDebug && !this.isResolved() && (mm.registerAccess(),
          w.info(`Hydration: Accessing non hydrated lazy back reference value`, {
              modelName: this.model.modelName,
              referencedKey: this.referencedKey
          })),
          e
      }
      set value(e) {
          super.value = e
      }
      resolve(e) {
          if (this.startObservation(),
          this._value,
          this.options?.canSkipHydration?.(this.model) && (this.isHydrationPromiseLocalOnly = !1,
          this.hydrationPromise = new Jp(this._value)),
          this.isHydrationPromiseLocalOnly && e?.onlyIfLocallyAvailable !== !0 && (this.hydrationPromise = void 0),
          this.hydrationPromise)
              return this.hydrationPromise;
          let t = em.dependenciesOfModel(this.model.modelName).find(e => e.backReference === this.referencedKey);
          if (!t)
              throw Error(`No dependencies on ${this.model.modelName}.${this.referencedKey}. Can't use LazyBackReference`);
          let n = wm.resolveCoveringPartialIndexes(t.model, t.property, this.model)
            , r = this.model.id
            , i = e || this.options ? {
              ...e,
              ...this.options
          } : void 0;
          return this.isHydrationPromiseLocalOnly = i?.onlyIfLocallyAvailable === !0,
          this.hydrationPromise = new Jp(async (e, a) => {
              let o;
              try {
                  let e = await qh.store.hydrateModels(t.model, {
                      key: t.property,
                      value: r,
                      coveringPartialIndexes: n
                  }, i);
                  e === !1 ? o = void 0 : e === !0 ? (this.isHydrationPromiseLocalOnly = !1,
                  o = this._value) : (this.isHydrationPromiseLocalOnly = !1,
                  o = Array.isArray(e) ? e[0] : void 0)
              } catch (e) {
                  return w.error(`Hydration of model from disk or network failed`, e, {
                      modelClass: t.model.modelName,
                      key: t.property,
                      keyValue: r
                  }),
                  this.invalidateRejectedWhenRequested(),
                  a(new dm(t.model,e))
              }
              Mt( () => {
                  this._value = o,
                  o?.observePropertyChanges()
              }
              ),
              e(o)
          }
          ),
          this.hydrationPromise.catch(e => {
              w.info(`Error while hydrating lazy back reference`, {
                  modelName: t.model.modelName,
                  key: t.property,
                  value: r,
                  error: e
              })
          }
          ),
          this.hydrationPromise
      }
      get logMetadata() {
          let e = em.dependenciesOfModel(this.model.modelName).find(e => e.backReference === this.referencedKey);
          return {
              type: `LazyBackReference`,
              modelName: this.model.modelName,
              modelId: this.model.id,
              dependencyModelName: e?.model.modelName,
              dependencyProperty: e?.property
          }
      }
  }
  ,
  bm = class extends vm {
      constructor(e) {
          super(e.id, e.constructor),
          this.hydrationPromise = new Jp(e),
          this._value = e
      }
      resolve() {
          return this.hydrationPromise
      }
  }
  ,
  xm = class extends ym {
      constructor(e) {
          super(e, `unused`),
          this.hydrationPromise = new Jp(e),
          this._value = e
      }
      resolve() {
          return this.hydrationPromise
      }
  }
}
)), Cm, wm, Tm = t(( () => {
  cm(),
  Xn(),
  ws(),
  F(),
  nm(),
  Sm(),
  Cm = 2,
  wm = class {
      static createPartialIndex(e, t) {
          if (`path`in e && t)
              return {
                  value: sm.constructPartialIndexValue(e.path, t, e.canFlatten),
                  isSyncGroupRoot: e.isSyncGroupRoot
              };
          let n = e;
          if (`id`in n)
              return {
                  value: n.id,
                  isSyncGroupRoot: n.modelClass.syncGroupRoot
              };
          if (`indexedKey`in n) {
              let e = this.partialIndexInfoForModel(n.modelClass.modelName);
              for (let t of e)
                  if (t.path === n.indexedKey)
                      return {
                          value: sm.constructPartialIndexValue(n.indexedKey, n.keyValue, t.canFlatten),
                          isSyncGroupRoot: t.isSyncGroupRoot
                      };
              if (n.indexedKey.split(`.`).length > 1) {
                  let e = `Partial index key "${n.indexedKey}" not found for model "${n.modelClass.modelName}". This is usually caused by a missing "trait: useForPartialIndex" on one of the decorators in the reference path. This should be fixed as this can cause data inconsistency problems over time.

-> Make sure that each of the properties in the key path ${n.modelClass.modelName}.${n.indexedKey} is marked with "trait: useForPartialIndex"

`;
                  Jn.IS_DEVELOPMENT_ENV ? w.error(e) : w.warning(e)
              }
              return {
                  value: `${n.indexedKey}-${n.keyValue}`,
                  isSyncGroupRoot: !1
              }
          } else if (`syncGroup`in n)
              return {
                  value: n.syncGroup,
                  isSyncGroupRoot: !0
              };
          else
              return {
                  value: sm.FULLY_LOADED_INDEX_NAME,
                  isSyncGroupRoot: !1
              }
      }
      static resolveCoveringPartialIndexes(e, t, n) {
          let r = em.referencedPropertiesOfModel(e.modelName)[t];
          if (r && r.trait === `sameAsSelfPartial`) {
              let t = []
                , r = em.referencedPropertiesOfModel(e.modelName);
              for (let i in r) {
                  if (r[i].trait === `sameAsSelfPartial`)
                      continue;
                  let a = _m.unwrap(n[this.transformIdKey(i)]);
                  a instanceof qh && (t = t.concat(this.resolveCoveringPartialIndexes(e, i, a)))
              }
              return t
          } else
              return this.processResolveCoveringPartialIndexes(e, t, n)
      }
      static resolveSyncGroupsForModel(e) {
          let t = new Set
            , n = this.partialIndexInfoForModel(e.modelName, {
              findSyncGroupRoots: !0
          });
          for (let r of n) {
              if (!r.isSyncGroupRoot)
                  continue;
              let n = r.path.split(`.`)
                , i = e;
              for (let e of n) {
                  if (Array.isArray(i) || !(i instanceof qh))
                      break;
                  i = _m.unwrap(i[e])
              }
              if (typeof i == `string`)
                  t.add(i);
              else if (Array.isArray(i))
                  for (let e of i)
                      t.add(e)
          }
          return Array.from(t)
      }
      static transientPartialIndexedKeysOfModel(e) {
          if (!this.transientPartialIndexedKeys[e]) {
              let t = this.partialIndexInfoForModel(e).filter(e => e.path.split(`.`).length <= Cm - 1).map(e => e.path);
              if (t.length === 0)
                  this.transientPartialIndexedKeys[e] = [];
              else {
                  let n = em.dependenciesOfModel(e).filter(e => e.model.isPartiallyLoaded && e.propertyInfo.trait === `useForPartialIndex`);
                  n.length === 0 ? this.transientPartialIndexedKeys[e] = [] : this.transientPartialIndexedKeys[e] = n.flatMap(e => t.map(t => {
                      let n = `${this.transformIdKey(e.property)}.${t}`
                        , r = this.partialIndexInfoForModel(e.model.modelName).find(e => e.path === n);
                      if (r)
                          return {
                              dependency: e,
                              indexedKey: t,
                              partialIndexInfo: r
                          }
                  }
                  ).concrete())
              }
          }
          return this.transientPartialIndexedKeys[e]
      }
      static partialIndexInfoForModel(e, t={}) {
          let {onlyReferencingModelType: n, findSyncGroupRoots: r=!1} = t
            , i = `${e}_${n}_${r}}`;
          if (!this.partialIndexInfoCache[i]) {
              let a;
              a = this.processPartialIndexInfoForModel(e, 0, t),
              n && (a = a.filter(e => e.referencedModelName === n)),
              r && (a = a.filter(e => e.isSyncGroupRoot)),
              this.partialIndexInfoCache[i] = a
          }
          return this.partialIndexInfoCache[i]
      }
      static #e = this.partialIndexInfoCache = {};
      static #t = this.transientPartialIndexedKeys = {};
      static processPartialIndexInfoForModel(e, t=0, n, r=new Set) {
          let {findSyncGroupRoots: i=!1} = n;
          if (!em.getModelClass(e))
              return [];
          let a = new Set(r)
            , o = em.referencedPropertiesOfModel(e)
            , s = [];
          for (let r of Object.keys(o)) {
              let c = o[r];
              if (c.referencedProperty && c.referencedClassResolver) {
                  let o = c.referencedClassResolver();
                  if (c.trait === `sameAsSelfPartial` || t > 0 && c.trait !== `useForPartialIndex` && i !== !0)
                      continue;
                  let l = o.syncGroupRoot;
                  if (s.push({
                      path: r,
                      referencedModelName: o.modelName,
                      canFlatten: l,
                      isSyncGroupRoot: o.syncGroupRoot
                  }),
                  (i || t < Cm - 1) && c.trait === `useForPartialIndex` && !a.has(`${e}.${r}`)) {
                      a.add(`${e}.${r}`);
                      for (let e of this.processPartialIndexInfoForModel(o.modelName, t + 1, n, a))
                          em.getModelClass(e.referencedModelName) && s.push({
                              path: this.transformIdKey(r) + `.` + e.path,
                              referencedModelName: e.referencedModelName,
                              canFlatten: e.canFlatten,
                              isSyncGroupRoot: e.isSyncGroupRoot
                          })
                  }
              }
          }
          let c = new Set
            , l = new Set;
          for (let e of s)
              e.canFlatten && (c.has(e.referencedModelName) ? l.add(e.referencedModelName) : c.add(e.referencedModelName));
          for (let e of s)
              l.has(e.referencedModelName) && (e.canFlatten = !1);
          return s
      }
      static processResolveCoveringPartialIndexes(e, t, n) {
          let r = this.partialIndexInfoForModel(e.modelName)
            , i = [];
          for (let e of r) {
              let r = e.path
                , a = r.split(`.`)
                , o = n
                , s = a.shift();
              if (!(s !== t && s !== this.transformIdKey(t))) {
                  if (a.length === 0) {
                      i.push({
                          value: sm.constructPartialIndexValue(s, o.id, e.canFlatten),
                          isSyncGroupRoot: e.isSyncGroupRoot
                      });
                      continue
                  }
                  for (let t of a) {
                      let n = o[t];
                      if (_m.isLazy(n) && (n = _m.unwrap(n)),
                      n instanceof qh)
                          o = n;
                      else if (typeof n == `string`) {
                          i.push({
                              value: sm.constructPartialIndexValue(r, n, e.canFlatten),
                              isSyncGroupRoot: e.isSyncGroupRoot
                          });
                          break
                      } else if (Array.isArray(n)) {
                          for (let t of n)
                              typeof t == `string` && i.push({
                                  value: sm.constructPartialIndexValue(r, t, e.canFlatten),
                                  isSyncGroupRoot: e.isSyncGroupRoot
                              });
                          break
                      } else
                          break
                  }
              }
          }
          return i
      }
      static transformIdKey(e) {
          return e.replace(/Id(s?)$/, `$1`)
      }
  }
}
)), Em, Tre = t(( () => {
  ws(),
  F(),
  nm(),
  Tm(),
  es(),
  Em = class {
      constructor(e, t) {
          this.modelClass = e,
          this.options = t,
          this.path = []
      }
      viaRelation(e) {
          return this.path.push(e),
          this
      }
      async for(e) {
          try {
              await this.withIdInternal(e)
          } catch (t) {
              Wo(t) || (Go(t) ? w.warning(`Network error while preloading model ${this.modelClass.modelName}`, {
                  modelName: this.modelClass.modelName,
                  numberOfIds: Array.isArray(e) ? e.length : 1,
                  error: t
              }) : w.error(`Error while preloading model ${this.modelClass.modelName}`, t, {
                  modelName: this.modelClass.modelName,
                  numberOfIds: Array.isArray(e) ? e.length : 1
              }))
          }
      }
      async withId(e) {
          try {
              await this.withIdInternal(e)
          } catch (t) {
              Wo(t) || (Go(t) ? w.warning(`Network error while preloading model ${this.modelClass.modelName}`, {
                  modelName: this.modelClass.modelName,
                  numberOfIds: Array.isArray(e) ? e.length : 1,
                  error: t
              }) : w.error(`Error while preloading model ${this.modelClass.modelName}`, t, {
                  modelName: this.modelClass.modelName,
                  numberOfIds: Array.isArray(e) ? e.length : 1
              }))
          }
      }
      async withIdInternal(e) {
          let t = qh.store
            , n = Array.isArray(e) ? e : [e];
          if (this.path.length === 0) {
              await Promise.all(n.map(e => t.syncClient.hydrateModel(this.modelClass, this.getId(e))));
              return
          }
          let r = this.modelClass
            , i = [];
          for (let e = 0; e < this.path.length; e++) {
              let t = this.path[e]
                , n = em.propertiesOfModel(r.modelName)[t];
              e !== this.path.length - 1 && n?.referencedClassResolver ? (r = n.referencedClassResolver(),
              i.push(t)) : n.type === tm.referenceCollection ? i.push(t.replace(/s$/, `Ids`)) : i.push(t + `Id`)
          }
          let a = i.join(`.`)
            , o = n.map(e => {
              let t = typeof e == `string` ? [wm.createPartialIndex({
                  modelClass: this.modelClass,
                  indexedKey: a,
                  keyValue: this.getId(e)
              })] : wm.resolveCoveringPartialIndexes(this.modelClass, a, e);
              return t.length === 0 && t.push(wm.createPartialIndex({
                  modelClass: this.modelClass,
                  indexedKey: a,
                  keyValue: this.getId(e)
              })),
              {
                  value: e,
                  coveringPartialIndexes: t
              }
          }
          )
            , s = new Set(await t.syncClient.removeLoadedPartialIndexes(this.modelClass.modelName, o.flatMap(e => e.coveringPartialIndexes)));
          if (s.size === 0)
              return;
          let c = o.filter( ({coveringPartialIndexes: e}) => e.every(e => s.has(e.value))).map( ({value: e, coveringPartialIndexes: n}) => t.batchModelLoader.addRequest({
              modelClass: this.modelClass,
              indexedKey: a,
              keyValue: this.getId(e),
              coveringPartialIndexes: n,
              skipCreatingModelsInMemory: this.options?.skipAddingToMemory
          }));
          await Promise.all(c)
      }
      getId(e) {
          return typeof e == `string` ? e : e.id
      }
  }
}
)), Dm, Om = t(( () => {
  Dm = class e {
      static #e = this.identifier = Symbol(`CollectionIdentifier`);
      static isCollection(t) {
          return typeof t == `object` && !!t && e.identifier in t
      }
  }
}
)), km, Am = t(( () => {
  km = class {
      filterElements(e) {
          return this.isFiltering ? e.filter(e => this.filterElement(e)) : e
      }
      filterNotElements(e) {
          return this.isFiltering ? e.filter(e => !this.filterElement(e)) : []
      }
  }
}
));
function jm(e, t) {
  return e === t ? 0 : e == null ? t == null ? 0 : 1 : t == null ? -1 : typeof e == `string` ? Mm.compare(e, t) : e - t
}
var P, Mm, Nm = t(( () => {
  zt(),
  P = class {
      constructor(e, t=`asc`) {
          this.observable = !1,
          this.reset(e, t),
          Mm ||= new Intl.Collator(void 0,{
              numeric: !0
          })
      }
      and(e, t=`asc`) {
          return this.fields.push(e),
          this.directions.push(t),
          this
      }
      reset(e, t=`asc`) {
          return this.fields = [e],
          this.directions = [t],
          this
      }
      orderElements(e) {
          return this.observable || (this.observable = !0,
          At(this, {
              and: Ft,
              reset: Ft,
              fields: Vt,
              directions: Vt
          })),
          this._orderElements(e)
      }
      compareElements(e, t) {
          let n = this.directions;
          for (let r = 0, i = this.fields.length; r < i; ++r) {
              let i = this.fields[r]
                , a = jm(this.getFieldValue(e, i), this.getFieldValue(t, i));
              if (a !== 0)
                  return (n[r] === `desc` ? -1 : 1) * a
          }
          return 0
      }
      getFieldValue(e, t) {
          return typeof t == `function` ? t(e) : e[t]
      }
      getFieldValues(e) {
          return this.fields.map(t => this.getFieldValue(e, t))
      }
      _orderElements(e) {
          let t = this.directions
            , n = e.length;
          function r(e, n) {
              let r = e.fields
                , i = n.fields;
              for (let e = 0, n = r.length; e < n; ++e) {
                  let n = jm(r[e], i[e]);
                  if (n !== 0)
                      return (t[e] === `desc` ? -1 : 1) * n
              }
              return e.index - n.index
          }
          let i = Array(n);
          for (let t = 0; t < n; ++t) {
              let n = e[t];
              i[t] = {
                  index: t,
                  value: n,
                  fields: this.getFieldValues(n)
              }
          }
          return i.sort(r),
          i.map(e => e.value)
      }
  }
}
)), Pm, Ere = t(( () => {
  um(),
  Vm(),
  Pm = class {
      constructor(e, t, n) {
          this.map = new Map;
          let r = new Map;
          for (let n of e.elements) {
              let e = n[t];
              lm.isLazy(e) && (e = e.value);
              let i = r.get(e);
              i ? i.push(n) : r.set(e, [n])
          }
          for (let[n,i] of r)
              this.map.set(n, {
                  group: i[0][t],
                  collection: Bm.of(e.modelClass, i)
              });
          this.groups = Array.from(this.map.values()),
          n && (this.groups = n.orderElements(this.groups))
      }
      getCollectionOfGroup(e) {
          return lm.isLazy(e) && (e = e.value),
          this.map.get(e)?.collection
      }
  }
}
)), Fm, Im = t(( () => {
  zt(),
  Fm = class e {
      static #e = this.enabled = !1;
      static enable() {
          e.enabled || (e.enabled = !0,
          e.data = Vt([]))
      }
      static disable() {
          e.enabled = !1,
          e.data = Vt([])
      }
      static #t = this.record = Ft(t => {
          e.enabled && e.data.push({
              ...t,
              date: new Date
          })
      }
      );
      constructor() {
          throw Error(`Do not instantiate`)
      }
  }
  ,
  Fm.enable()
}
)), Lm, Rm, zm = t(( () => {
  zt(),
  Om(),
  F(),
  Xp(),
  ws(),
  Am(),
  Nm(),
  Ere(),
  Im(),
  hm(),
  Rm = class e {
      get constructorName() {
          return `ReadonlyCollection<${this.modelClass.modelName}>`
      }
      get elements() {
          this.makeObservable();
          let e = this.rawElements
            , t = this.order;
          return t && (e = t.orderElements(e)),
          e
      }
      get transientlyHydratedElements() {
          let e = []
            , t = [];
          for (let n of this.elements)
              n.isHydrated() ? e.push(n) : t.push(n.hydrate());
          return t.length && (Jp.allResolved(t).then(this.afterHydrate).catch( () => {}
          ),
          qh.store.developerOptions?.nonHydratedCollectionHydratedElementsDebug && !this.hydrationElementsPromise && (mm.registerAccess(),
          w.info(`Hydration: Accessing hydrated elements before triggering elements hydration`))),
          e
      }
      orderBy(t, n=`asc`) {
          let r = t instanceof P ? t : new P(t,n);
          return new e(this.modelClass,this,{
              order: r
          })
      }
      filter(t) {
          return t === void 0 ? this : new e(this.modelClass,this,{
              filters: Array.isArray(t) ? t : [t]
          })
      }
      filterNot(t) {
          return t === void 0 ? this : new e(this.modelClass,this,{
              filters: Array.isArray(t) ? t : [t],
              inverseFilter: !0
          })
      }
      get first() {
          return this.length > 0 ? this.elements[0] : void 0
      }
      get last() {
          return this.length > 0 ? this.elements[this.elements.length - 1] : void 0
      }
      get length() {
          return this.rawElements.length
      }
      get hydratedLength() {
          return this.transientlyHydratedElements.length
      }
      get order() {
          return this.options?.order ? this.options.order : this.parentCollection?.order
      }
      indexOf(e) {
          return this.elements.indexOf(e)
      }
      indexOfId(e) {
          let t = this.elements;
          for (let n = 0, r = t.length; n < r; ++n)
              if (t[n].id === e)
                  return n;
          return -1
      }
      contains(e) {
          return this.rawElements.indexOf(e) !== -1
      }
      findById(e) {
          for (let t of this.rawElements)
              if (t.id === e)
                  return t
      }
      slice(e, t) {
          return this.elements.slice(e, t)
      }
      map(e) {
          return this.elements.map(e)
      }
      flatMap(e) {
          return this.elements.flatMap(e)
      }
      reduce(e, t) {
          return this.elements.reduce(e, t)
      }
      forEach(e) {
          let t = this.elements.concat();
          for (let n = 0, r = t.length; n < r; ++n)
              e(t[n], n, t)
      }
      find(e) {
          return this.elements.find(e)
      }
      findLast(e) {
          for (let t = this.elements.length - 1; t >= 0; t--)
              if (e(this.elements[t], t, this.elements))
                  return this.elements[t]
      }
      some(e) {
          return this.rawElements.some(e)
      }
      every(e) {
          return this.rawElements.every(e)
      }
      findIndex(e) {
          return this.elements.findIndex(e)
      }
      split(e) {
          let t = []
            , n = []
            , r = this.elements;
          for (let i = 0, a = r.length; i < a; ++i) {
              let a = r[i];
              e(a, i, r) ? t.push(a) : n.push(a)
          }
          return [t, n]
      }
      groupBy(e, t) {
          return new Pm(this,e,t)
      }
      [(Lm = Dm.identifier,
      Symbol.iterator)]() {
          let e = 0
            , t = this.elements;
          return {
              next: () => ({
                  value: t[e++],
                  done: e > t.length
              })
          }
      }
      transientlyHydrateElements(e) {
          let t = this.elements.map(e => e.id).join(`,`);
          return this.hydrationElementsPromise && this.hydrationElementsPromiseHash !== t && (this.hydrationElementsPromiseHash = void 0,
          this.hydrationElementsPromise = void 0),
          this.hydrationElementsPromise ? this.hydrationElementsPromise : (Fm.enabled && Fm.record({
              type: `hydrateElements`,
              options: e,
              modelName: this.elements[0]?.modelName
          }),
          this.hydrationElementsPromiseHash = t,
          this.hydrationElementsPromise = new Jp( (t, n) => {
              if (this.elements.length === 0)
                  return t([]);
              let r = [];
              for (let t of this.elements)
                  t.isHydrated() || r.push(t.hydrate(e));
              r.length ? Jp.allResolved(r).then( () => {
                  t(this.transientlyHydratedElements)
              }
              ).catch(e => {
                  this.invalidateRejectedWhenRequested(),
                  n(e)
              }
              ) : t(this.transientlyHydratedElements)
          }
          ),
          this.hydrationElementsPromise)
      }
      get rawElements() {
          this.makeObservable();
          let e = this.parentCollection?.rawElements || this.rootRawElements;
          if (!e)
              return [];
          if (this.options?.filters)
              for (let t of this.options.filters)
                  e = this.options?.inverseFilter ? t instanceof km ? t.filterNotElements(e) : e.filter( (e, n, r) => !t(e, n, r)) : t instanceof km ? t.filterElements(e) : e.filter(t);
          else
              e = e.slice(0);
          return e
      }
      constructor(t, n, r) {
          this[Lm] = !0,
          this.observed = !1,
          this.modelClass = t,
          n instanceof e ? this.parentCollection = n : n ? this._rootRawElements = n.concrete() : this._rootRawElements = [],
          this.options = r
      }
      get rootRawElements() {
          return this._rootRawElements
      }
      afterHydrate() {}
      invalidateRejectedWhenRequested() {
          this.invalidateRejectedWhenRequestedSubscribed ||= (qh.store.onInvalidateRejectedHydrations.subscribeOnce( () => this.invalidateRejectedHydrationPromises()),
          !0)
      }
      invalidateRejectedHydrationPromises() {
          this.hydrationElementsPromise?.error && (this.hydrationElementsPromiseHash = void 0,
          this.hydrationElementsPromise = void 0),
          this.invalidateRejectedWhenRequestedSubscribed = !1
      }
      makeObservable() {
          this.observed ||= (At(this, {
              elements: Bt,
              rawElements: Bt
          }),
          !0)
      }
  }
}
)), Bm, Vm = t(( () => {
  zt(),
  zm(),
  F(),
  Es(),
  Bm = class e extends Rm {
      get constructorName() {
          return `Collection<${this.modelClass.modelName}>`
      }
      get lastAccessedAt() {
          return this._lastAccessedAt ? new Date(this._lastAccessedAt) : void 0
      }
      static of(e, t, n) {
          return new Rm(e,t,n)
      }
      static mutableOf(t, n=[], r) {
          return new e(t,n,r)
      }
      get length() {
          return this.makeObservable(),
          super.length
      }
      get elements() {
          return this._lastAccessedAt = Date.now(),
          this.internalElements
      }
      get rawElements() {
          return this._lastAccessedAt = Date.now(),
          this.internalRawElements
      }
      get onChange() {
          return this._onChange
      }
      constructor(e, t=[], n) {
          super(e, t, n),
          this.idLookup = {},
          this.elementIds = [],
          this._onChange = new Ts,
          this.elementsObserved = !1,
          this.options = n;
          for (let e = 0, t = this.rootRawElements.length; e < t; ++e) {
              let t = this.rootRawElements[e];
              t !== void 0 && (this.idLookup[t.id] = t,
              this.elementIds.push(t.id))
          }
      }
      findById(e) {
          this.forceObservation();
          let t = this.idLookup[e];
          return t && t.observePropertyChanges(),
          t
      }
      add(e) {
          this.makeObservable(),
          this.elementsObserved && e.observePropertyChanges();
          let t = this.idLookup[e.id];
          if (t === void 0 || t !== e) {
              let n = this._onChange.observerCount > 0 ? this.elementIds.slice(0) : void 0
                , r = t ? this.rootRawElements.indexOf(t) : -1;
              r === -1 ? (this._rootRawElements.push(e),
              this.idLookup[e.id] = e,
              this.elementIds.push(e.id)) : (this._rootRawElements[r] = e,
              this.idLookup[e.id] = e,
              this.elementIds[r] = e.id),
              n !== void 0 && this._onChange.fire([n, this.elementIds])
          }
      }
      remove(e) {
          this.makeObservable();
          let t = this.rootRawElements.indexOf(e);
          if (t !== -1) {
              let n = this._onChange.observerCount > 0 ? this.elementIds.slice(0) : void 0;
              return this._rootRawElements.splice(t, 1),
              this.elementIds.splice(t, 1),
              delete this.idLookup[e.id],
              n !== void 0 && this._onChange.fire([n, this.elementIds]),
              !0
          }
          return !1
      }
      clear() {
          let e = this.elementIds;
          this._rootRawElements = [],
          this.elementIds = [],
          this.idLookup = {},
          this._onChange.fire([e, this.elementIds])
      }
      concat(t) {
          return new e(this.modelClass,this.elements.concat(Array.isArray(t) ? t : t.elements),this.options)
      }
      setElementIds(e) {
          let t = this.elementIds
            , n = []
            , r = []
            , i = {}
            , a = qh.store.syncClient;
          for (let t = 0, o = e.length; t < o; ++t) {
              let o = e[t]
                , s = a.findById(this.modelClass, o);
              s && (n.push(o),
              r.push(s),
              i[o] = s,
              this.elementsObserved && s.observePropertyChanges())
          }
          this.elementIds = n,
          this._rootRawElements = r,
          this.idLookup = i,
          this._onChange.fire([t, n])
      }
      getElementIds() {
          return this.forceObservation(),
          this.elementIds
      }
      contains(e) {
          return this.forceObservation(),
          this.idLookup[e.id] !== void 0
      }
      indexOfId(e) {
          this.forceObservation();
          let t = this.idLookup[e];
          return t ? this.indexOf(t) : -1
      }
      updateOnSyncGroupChanges() {
          let e = qh.store.syncClient;
          e.onSyncGroupsChanged.subscribe( () => {
              Mt( () => {
                  this._rootRawElements = this.elementIds.map(t => e.findById(this.modelClass, t)).concrete()
              }
              )
          }
          )
      }
      get internalElements() {
          return this.makeObservable(),
          this.makeElementsObservable(),
          super.elements
      }
      get internalRawElements() {
          return this.makeObservable(),
          this.makeElementsObservable(),
          super.rawElements
      }
      get rootRawElements() {
          return this._rootRawElements || []
      }
      afterHydrate() {
          this.forceObserverUpdates()
      }
      forceObserverUpdates() {
          Mt( () => {
              this._rootRawElements = this.rootRawElements.slice(0)
          }
          )
      }
      makeObservable() {
          this.observed ||= (At(this, {
              add: Ft,
              remove: Ft,
              clear: Ft,
              setElementIds: Ft,
              _rootRawElements: Vt.shallow,
              internalElements: Bt,
              internalRawElements: Bt
          }),
          !0)
      }
      makeElementsObservable() {
          if (!this.elementsObserved) {
              for (let e of this.rootRawElements)
                  e.observePropertyChanges();
              this.elementsObserved = !0
          }
      }
      forceObservation() {
          this.makeObservable(),
          this._rootRawElements.length
      }
  }
}
)), Hm, Dre = t(( () => {
  Nm(),
  zm(),
  Hm = class e extends Rm {
      get constructorName() {
          return `LazyReadonlyCollection<${this.modelClass.modelName}>`
      }
      isHydrated(e) {
          return this.parentCollection.isHydrated(e)
      }
      hydrate(e) {
          return this.parentCollection.hydrate(e)
      }
      orderBy(t, n=`asc`) {
          let r = t instanceof P ? t : new P(t,n);
          return new e(this.modelClass,this,{
              order: r
          })
      }
      filter(t) {
          return t === void 0 ? this : new e(this.modelClass,this,{
              filters: Array.isArray(t) ? t : [t]
          })
      }
      filterNot(t) {
          return t === void 0 ? this : new e(this.modelClass,this,{
              filters: Array.isArray(t) ? t : [t],
              inverseFilter: !0
          })
      }
      transientlyHydrateElements(e) {
          return this.parentCollection.transientlyHydrateElements(e)
      }
      constructor(e, t, n) {
          super(e, t, n)
      }
  }
}
)), Um, Wm = t(( () => {
  zt(),
  Xp(),
  ws(),
  Vm(),
  Qp(),
  F(),
  om(),
  Tm(),
  pm(),
  Im(),
  ai(),
  Dre(),
  Nm(),
  hm(),
  N(),
  Um = class e extends Bm {
      static isLazyCollection(t) {
          return t instanceof e
      }
      get constructorName() {
          return `LazyCollection<${this.modelClass.modelName}>`
      }
      get rawElements() {
          if (!this.isHydrated() && (this.hydrate(this.hydrateLocallyOnly ? {
              onlyIfLocallyAvailable: !0
          } : void 0),
          qh.store.developerOptions?.nonHydratedLazyCollectionElementsDebug)) {
              mm.registerAccess();
              let e = Error();
              w.info(`Hydration: Accessing elements of non hydrated lazy collection`, {
                  parent: this.parent.modelName,
                  index: this.index,
                  modelName: this.modelClass.modelName,
                  stack: e.stack
              })
          }
          let e = super.rawElements;
          return this.finalizationRegistry && (this.accessCount === void 0 ? this.accessCount = 1 : this.accessCount++,
          this.finalizationRegistry.register(e)),
          e
      }
      get localElements() {
          this.hydrateLocallyOnly = !0;
          let e = this.elements;
          return this.hydrateLocallyOnly = !1,
          e
      }
      get existingElements() {
          return super.elements
      }
      get length() {
          return this.isHydrated() || this.hydrate(),
          super.length
      }
      get localLength() {
          return this.isHydrated() || this.hydrate({
              onlyIfLocallyAvailable: !0
          }),
          super.length
      }
      get currentLength() {
          return super.rawElements.length
      }
      orderBy(e, t=`asc`) {
          let n = e instanceof P ? e : new P(e,t);
          return new Hm(this.modelClass,this,{
              order: n
          })
      }
      filter(e) {
          return new Hm(this.modelClass,this,{
              filters: e ? Array.isArray(e) ? e : [e] : []
          })
      }
      filterNot(e) {
          return new Hm(this.modelClass,this,{
              filters: e ? Array.isArray(e) ? e : [e] : [],
              inverseFilter: !0
          })
      }
      get isBeingAccessed() {
          if (this.finalizationRegistry)
              return (this.accessCount ?? 0) > 0
      }
      get logMetadata() {
          return {
              type: `LazyCollection`,
              modelName: this.modelClass.modelName,
              modelId: this.parent.id,
              dependencyModelName: this.parent.modelName,
              dependencyProperty: this.index?.toString()
          }
      }
      constructor(e, t, n, r) {
          super(e, [], r),
          this.parent = t,
          this.index = n,
          this.lazyOptions = r,
          e.loadStrategy === rm.instant && (this.isHydrationPromiseLocalOnly = !1,
          this.hydrationPromise = new Jp(this)),
          r?.observeAccess && typeof FinalizationRegistry < `u` && (this.finalizationRegistry = new FinalizationRegistry( () => {
              this.accessCount && this.accessCount--
          }
          ))
      }
      isHydrated(e) {
          return this.hydrationPromise && !this.hydrationPromise.error && !this.hydrationPromise.isPending ? e?.onlyCheckLocally || !this.isHydrationPromiseLocalOnly : !1
      }
      canSkipAttachingModels() {
          return this.hydrationPromise === void 0 && this.lazyOptions?.canSkipHydration === void 0 && this.lazyOptions?.canSkipNetworkHydration === void 0 && this.modelClass.store.isBootstrapped
      }
      hydrationFailed() {
          return !!this.hydrationPromise?.error
      }
      async isLocallyAvailable() {
          return this.isHydrated() ? !0 : qh.store.syncClient.hasModelsForPartialIndexes(this.modelClass.modelName, this.getCoveringPartialIndexes())
      }
      hydrate(e) {
          if (this.hydrationCounter = (this.hydrationCounter ?? 0) + 1,
          this.hydrationPromise && (!this.isHydrationPromiseLocalOnly || e?.onlyIfLocallyAvailable))
              return Zp.cancelSpan(),
              this.hydrationPromise;
          if (this.lazyOptions?.canSkipHydration?.() === !0 || this.modelClass.loadStrategy === rm.local)
              return Zp.cancelSpan(),
              this.hydrationPromise = new Jp(this),
              this.hydrationPromise;
          if (qh.store.isPreBootstrapRendering)
              return Zp.cancelSpan(),
              _ee( () => qh.store.isBootstrapped, () => {
                  this.hydrationPromise = void 0,
                  this.hydrate()
              }
              ),
              w.verbose( () => ({
                  message: `Pre-bootstrap: Postponing hydration of lazy collection while bootstrapping`,
                  metaData: {
                      modelName: this.modelClass.modelName,
                      stack: Error().stack
                  }
              })),
              this.hydrationPromise = new Jp(this),
              this.hydrationPromise;
          this.isHydrationPromiseLocalOnly = this.index ? !!e?.onlyIfLocallyAvailable && !qh.store.localStoreReady(this.modelClass) : !1;
          let t = {
              onlyIfLocallyAvailable: this.isHydrationPromiseLocalOnly,
              customNetworkHydration: this.lazyOptions?.customNetworkHydration,
              canSkipNetworkHydration: this.lazyOptions?.canSkipNetworkHydration
          };
          Fm.enabled && Fm.record({
              type: `collection`,
              modelName: this.modelClass.modelName,
              index: this.index,
              parentId: this.parent.id,
              parentModelName: this.parent.modelName,
              options: e
          });
          let n = new Jp(async (e, r) => {
              try {
                  if (this.index) {
                      let e = this.getCoveringPartialIndexes()
                        , r = await qh.store.hydrateModels(this.modelClass, {
                          key: this.index,
                          value: this.parent.id,
                          coveringPartialIndexes: e
                      }, t);
                      n === this.hydrationPromise && r !== !1 && (this.isHydrationPromiseLocalOnly = !1)
                  } else
                      await qh.store.hydrateLocalModelsByIds(this.modelClass, this.elementIds),
                      this.updateRawModels();
                  e(this)
              } catch (e) {
                  e instanceof fm ? w.error(`Partial index likely missing.

An index on "${e.indexKey}" is likely missing from the model ${e.modelClass.modelName}.
To fix it add "indexed: true" to the decorator options.

After adding a new index you can refresh the local database and try again in development. For production you need to bump "DatabaseInfo.indexVersion".
`, e) : w.error(`Hydration failed`, e, {
                      modelClass: this.modelClass.modelName,
                      key: this.index,
                      keyValue: this.parent.id
                  }),
                  this.invalidateRejectedWhenRequested(),
                  r(new dm(this.modelClass,e))
              }
          }
          );
          return n.catch(e => {
              w.info(`Error while hydrating collection`, {
                  modelName: this.modelClass.modelName,
                  parent: this.parent.modelName,
                  index: this.index,
                  error: e
              })
          }
          ),
          this.hydrationPromise = n,
          n
      }
      async deHydrate() {
          let e = Date.now()
            , t = 0;
          if (!this.isHydrated() || this.isBeingAccessed !== !1)
              return 0;
          let n = this.elements;
          this.isHydrationPromiseLocalOnly = void 0,
          this.hydrationPromise = void 0,
          this.clear();
          let r = this.hydrationCounter;
          for (let i of n) {
              let n = i.inHydratedCollections();
              if (!i.isHydrated() && n.length === 0 && (i.store.syncClient.deleteModel(i),
              t++),
              Date.now() > e + 5) {
                  if (await ri(0),
                  r !== this.hydrationCounter)
                      return t;
                  e = Date.now()
              }
          }
          return t
      }
      setElementIds(e) {
          this.isHydrationPromiseLocalOnly = void 0,
          this.hydrationPromise = void 0;
          let t = this.elementIds.concat();
          this.elementIds = e.concat(),
          this.updateRawModels(),
          this._onChange.fire([t, this.elementIds.concat()])
      }
      transientlyHydrateElements(e) {
          return this.isHydrated() ? super.transientlyHydrateElements(e) : new Jp(async (t, n) => {
              try {
                  await this.hydrate(e),
                  t(await super.transientlyHydrateElements(e))
              } catch (e) {
                  n(e)
              }
          }
          )
      }
      forceSetHydrated() {
          this.hydrationPromise = new Jp(this)
      }
      invalidateRejectedHydrationPromises() {
          this.hydrationPromise?.error && (this.hydrationPromise = void 0,
          this.isHydrationPromiseLocalOnly = !1),
          super.invalidateRejectedHydrationPromises()
      }
      updateRawModels() {
          Mt( () => {
              let e = qh.store.syncClient
                , t = this.elementIds.map(t => e.findById(this.modelClass, t)).concrete();
              this._rootRawElements = t,
              this.idLookup = {};
              for (let e of t)
                  this.idLookup[e.id] = e,
                  this.elementsObserved && e.observePropertyChanges()
          }
          )
      }
      getCoveringPartialIndexes() {
          return this.index ? wm.resolveCoveringPartialIndexes(this.modelClass, this.index, this.parent) : []
      }
  }
  ,
  M([Zp.trace(`hydration`)], Um.prototype, `hydrate`, null)
}
)), Gm, Km, qm, Jm, Ym, Xm, Zm, Qm, $m, eh, th, nh, rh, ih, ah, oh, sh, ch, lh, uh, dh, fh, ph, mh, hh, gh, _h, vh, yh, bh, xh, Sh, Ch, wh, Th, Eh, Dh, Oh, Ore = t(( () => {
  Gm = `3.7.7`,
  Km = Gm,
  qm = typeof Buffer == `function`,
  Jm = typeof TextDecoder == `function` ? new TextDecoder : void 0,
  Ym = typeof TextEncoder == `function` ? new TextEncoder : void 0,
  Xm = Array.prototype.slice.call(`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=`),
  Zm = (e => {
      let t = {};
      return e.forEach( (e, n) => t[e] = n),
      t
  }
  )(Xm),
  Qm = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/,
  $m = String.fromCharCode.bind(String),
  eh = typeof Uint8Array.from == `function` ? Uint8Array.from.bind(Uint8Array) : e => new Uint8Array(Array.prototype.slice.call(e, 0)),
  th = e => e.replace(/=/g, ``).replace(/[+\/]/g, e => e == `+` ? `-` : `_`),
  nh = e => e.replace(/[^A-Za-z0-9\+\/]/g, ``),
  rh = e => {
      let t, n, r, i, a = ``, o = e.length % 3;
      for (let o = 0; o < e.length; ) {
          if ((n = e.charCodeAt(o++)) > 255 || (r = e.charCodeAt(o++)) > 255 || (i = e.charCodeAt(o++)) > 255)
              throw TypeError(`invalid character found`);
          t = n << 16 | r << 8 | i,
          a += Xm[t >> 18 & 63] + Xm[t >> 12 & 63] + Xm[t >> 6 & 63] + Xm[t & 63]
      }
      return o ? a.slice(0, o - 3) + `===`.substring(o) : a
  }
  ,
  ih = typeof btoa == `function` ? e => btoa(e) : qm ? e => Buffer.from(e, `binary`).toString(`base64`) : rh,
  ah = qm ? e => Buffer.from(e).toString(`base64`) : e => {
      let t = 4096
        , n = [];
      for (let r = 0, i = e.length; r < i; r += t)
          n.push($m.apply(null, e.subarray(r, r + t)));
      return ih(n.join(``))
  }
  ,
  oh = (e, t=!1) => t ? th(ah(e)) : ah(e),
  sh = e => {
      if (e.length < 2) {
          var t = e.charCodeAt(0);
          return t < 128 ? e : t < 2048 ? $m(192 | t >>> 6) + $m(128 | t & 63) : $m(224 | t >>> 12 & 15) + $m(128 | t >>> 6 & 63) + $m(128 | t & 63)
      } else {
          var t = 65536 + (e.charCodeAt(0) - 55296) * 1024 + (e.charCodeAt(1) - 56320);
          return $m(240 | t >>> 18 & 7) + $m(128 | t >>> 12 & 63) + $m(128 | t >>> 6 & 63) + $m(128 | t & 63)
      }
  }
  ,
  ch = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g,
  lh = e => e.replace(ch, sh),
  uh = qm ? e => Buffer.from(e, `utf8`).toString(`base64`) : Ym ? e => ah(Ym.encode(e)) : e => ih(lh(e)),
  dh = (e, t=!1) => t ? th(uh(e)) : uh(e),
  fh = e => dh(e, !0),
  ph = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g,
  mh = e => {
      switch (e.length) {
      case 4:
          var t = ((7 & e.charCodeAt(0)) << 18 | (63 & e.charCodeAt(1)) << 12 | (63 & e.charCodeAt(2)) << 6 | 63 & e.charCodeAt(3)) - 65536;
          return $m((t >>> 10) + 55296) + $m((t & 1023) + 56320);
      case 3:
          return $m((15 & e.charCodeAt(0)) << 12 | (63 & e.charCodeAt(1)) << 6 | 63 & e.charCodeAt(2));
      default:
          return $m((31 & e.charCodeAt(0)) << 6 | 63 & e.charCodeAt(1))
      }
  }
  ,
  hh = e => e.replace(ph, mh),
  gh = e => {
      if (e = e.replace(/\s+/g, ``),
      !Qm.test(e))
          throw TypeError(`malformed base64.`);
      e += `==`.slice(2 - (e.length & 3));
      let t, n = ``, r, i;
      for (let a = 0; a < e.length; )
          t = Zm[e.charAt(a++)] << 18 | Zm[e.charAt(a++)] << 12 | (r = Zm[e.charAt(a++)]) << 6 | (i = Zm[e.charAt(a++)]),
          n += r === 64 ? $m(t >> 16 & 255) : i === 64 ? $m(t >> 16 & 255, t >> 8 & 255) : $m(t >> 16 & 255, t >> 8 & 255, t & 255);
      return n
  }
  ,
  _h = typeof atob == `function` ? e => atob(nh(e)) : qm ? e => Buffer.from(e, `base64`).toString(`binary`) : gh,
  vh = qm ? e => eh(Buffer.from(e, `base64`)) : e => eh(_h(e).split(``).map(e => e.charCodeAt(0))),
  yh = e => vh(xh(e)),
  bh = qm ? e => Buffer.from(e, `base64`).toString(`utf8`) : Jm ? e => Jm.decode(vh(e)) : e => hh(_h(e)),
  xh = e => nh(e.replace(/[-_]/g, e => e == `-` ? `+` : `/`)),
  Sh = e => bh(xh(e)),
  Ch = e => {
      if (typeof e != `string`)
          return !1;
      let t = e.replace(/\s+/g, ``).replace(/={0,2}$/, ``);
      return !/[^\s0-9a-zA-Z\+/]/.test(t) || !/[^\s0-9a-zA-Z\-_]/.test(t)
  }
  ,
  wh = e => ({
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
  }),
  Th = function() {
      let e = (e, t) => Object.defineProperty(String.prototype, e, wh(t));
      e(`fromBase64`, function() {
          return Sh(this)
      }),
      e(`toBase64`, function(e) {
          return dh(this, e)
      }),
      e(`toBase64URI`, function() {
          return dh(this, !0)
      }),
      e(`toBase64URL`, function() {
          return dh(this, !0)
      }),
      e(`toUint8Array`, function() {
          return yh(this)
      })
  }
  ,
  Eh = function() {
      let e = (e, t) => Object.defineProperty(Uint8Array.prototype, e, wh(t));
      e(`toBase64`, function(e) {
          return oh(this, e)
      }),
      e(`toBase64URI`, function() {
          return oh(this, !0)
      }),
      e(`toBase64URL`, function() {
          return oh(this, !0)
      })
  }
  ,
  Dh = () => {
      Th(),
      Eh()
  }
  ,
  Oh = {
      version: Gm,
      VERSION: Km,
      atob: _h,
      atobPolyfill: gh,
      btoa: ih,
      btoaPolyfill: rh,
      fromBase64: Sh,
      toBase64: dh,
      encode: dh,
      encodeURI: fh,
      encodeURL: fh,
      utob: lh,
      btou: hh,
      decode: Sh,
      isValid: Ch,
      fromUint8Array: oh,
      toUint8Array: yh,
      extendString: Th,
      extendUint8Array: Eh,
      extendBuiltins: Dh
  }
}
));
function kh(e) {
  return {
      serialize: t => JSON.stringify(t, (t, n) => {
          if (e[t]) {
              let {nullable: r, serializer: i} = e[t];
              if (n == null) {
                  if (r === !0)
                      return n;
                  throw Error(`Value for key ${t} is null or undefined`)
              }
              return i === Ah && typeof n == `string` ? n : i.serialize(n)
          }
          return n
      }
      ),
      deserialize: t => {
          let n = t => {
              for (let[n,r] of Object.entries(e)) {
                  let {nullable: e, serializer: i} = r
                    , a = t[n];
                  if (a == null) {
                      if (e === !0)
                          continue;
                      throw Error(`Value for key ${n} is null or undefined`)
                  }
                  t[n] = i.deserialize(a)
              }
          }
          ;
          return t = typeof t == `string` ? JSON.parse(t) : Array.isArray(t) ? t.map(e => ({
              ...e
          })) : {
              ...t
          },
          Array.isArray(t) ? t.forEach(n) : n(t),
          t
      }
  }
}
var Ah, jh, Mh, Nh, Ph, Fh, Ih = t(( () => {
  Ore(),
  ws(),
  Ah = {
      serialize: e => {
          try {
              return e.toISOString()
          } catch (t) {
              throw w.error(`Error serializing date in DateTimeSerializer`, t, {
                  value: e,
                  typeofValue: typeof e
              }),
              t
          }
      }
      ,
      deserialize: e => e instanceof Date ? e : new Date(e)
  },
  jh = {
      serialize: e => e.substring(0, 10),
      deserialize: e => e instanceof Date ? e.toTimelessDate() : e.substring(0, 10)
  },
  Mh = {
      serialize: e => JSON.stringify(e),
      deserialize: e => typeof e == `string` ? JSON.parse(e) : e
  },
  Nh = {
      serialize: e => JSON.stringify(e),
      deserialize: e => JSON.parse(e)
  },
  Ph = {
      serialize: e => Oh.fromUint8Array(e),
      deserialize: e => Oh.toUint8Array(e)
  },
  Fh = {
      serialize: e => JSON.stringify(e).replace(/"([^"]+)":/g, `$1:`),
      deserialize: e => {
          if (typeof e == `string`) {
              let t = e.replace(/([{,])(\s*)([A-Za-z0-9_\-]+?)\s*:/g, `$1"$3":`);
              return JSON.parse(t)
          }
          return e
      }
      ,
      dontQuote: !0
  }
}
));
function Lh(e) {
  let t = zh(e);
  return t.shift() + Bh(t).join(``)
}
function Rh(e) {
  return Bh(zh(e)).join(``)
}
function zh(e) {
  return kre(e.replace(/[^a-z0-9]+/gi, ` `).replace(/([A-Z0-9]+)([A-Z][a-z])/g, `$1 $2`).replace(/([a-z0-9])([A-Z])/g, `$1 $2`).toLowerCase()).split(/\s+/)
}
function kre(e) {
  return e.replace(/^\s+|\s+$/g, ``)
}
function Bh(e) {
  let t = [];
  for (let n = 0; n < e.length; n++)
      t.push(e[n].charAt(0).toUpperCase() + e[n].substr(1));
  return t
}
var Vh = t(( () => {}
)), Hh, Uh, Wh = t(( () => {
  Hh = e(qee(), 1),
  Uh = class {
      static structuredClone(e) {
          return typeof structuredClone == `function` ? structuredClone(e) : e === void 0 ? e : JSON.parse(JSON.stringify(e))
      }
      static stableHash(e) {
          return (0,
          Hh.default)(e, {
              encoding: `hex`,
              respectType: !1,
              unorderedObjects: !0,
              unorderedArrays: !1
          })
      }
  }
}
));
function Gh(e) {
  qh.applyObservability = !1;
  let t = Mt(e);
  return qh.applyObservability = !0,
  t
}
var Kh, qh, Jh, Yh, Xh, F = t(( () => {
  Kh = e(Ht(), 1),
  zt(),
  ss(),
  zn(),
  ed(),
  ws(),
  Qp(),
  nm(),
  om(),
  Tre(),
  Vm(),
  Wm(),
  Xp(),
  pm(),
  Sm(),
  Ih(),
  Es(),
  Vh(),
  Im(),
  Wh(),
  N(),
  qh = class Model {
      static #e = this.applyObservability = !0;
      static #t = this.syncGroupRoot = !1;
      get constructorName() {
          return this.modelName || `Model`
      }
      get supportsUndoCreatedAtArguments() {
          return !1
      }
      static get isFullyLoaded() {
          switch (this.loadStrategy) {
          case rm.instant:
          case rm.placeholder:
          case rm.lazy:
              return !0;
          case rm.partial:
          case rm.explicitlyRequested:
          case rm.local:
              return !1;
          default:
              throw y(this.loadStrategy)
          }
      }
      static get isPartiallyLoaded() {
          switch (this.loadStrategy) {
          case rm.instant:
          case rm.placeholder:
          case rm.lazy:
          case rm.explicitlyRequested:
          case rm.local:
              return !1;
          case rm.partial:
              return !0;
          default:
              throw y(this.loadStrategy)
          }
      }
      static #n = this.loadStrategy = rm.instant;
      static #r = this.partialLoadMode = im.regular;
      static #i = this.partialPreloadForTeam = am.noPreload;
      static #a = this.hydrateAfterStartupConfig = void 0;
      static get modelName() {
          return this.prototype.modelName
      }
      get isArchived() {
          return this.archivedAt !== void 0
      }
      get isArchivedNonObservable() {
          let e = this.__data?.archivedAt;
          return e ? Pt(e) ? e.get() !== void 0 : e !== void 0 : !1
      }
      get onSave() {
          return this._onSave ||= new Ts,
          this._onSave
      }
      get onUpdateFromData() {
          return this._onUpdateFromData ||= new Ts,
          this._onUpdateFromData
      }
      get onUpdate() {
          return this._onUpdate ||= new Ts,
          this._onUpdate
      }
      get clonedFromModel() {
          return this._clonedFromModel
      }
      get isClone() {
          return this._clonedFromModel !== void 0
      }
      get modelClass() {
          return this.constructor
      }
      get mutationResultName() {
          return this.modelName[0].toLowerCase() + this.modelName.substring(1)
      }
      get properties() {
          return em.propertiesOfModel(this.modelName)
      }
      get dataProperties() {
          return em.dataPropertiesOfModel(this.modelName)
      }
      get applyingNetworkChanges() {
          return this.ignoreUpdates
      }
      get naturalIdentity() {}
      constructor(t=!0) {
          if (this.permanentlyDeleted = !1,
          this.dependenciesRequireLoading = !1,
          this.modifiedProperties = {},
          this.observingPropertyChanges = !1,
          this.ignoreUpdates = !1,
          this.hydratedRelationsPromises = new Map,
          this._ephemeralSubscribeCount = 0,
          !e.store)
              throw Error(`Model.store not registered when instantiating Model.`);
          if (this.store = e.store,
          t) {
              let e = Date.now();
              this.__data = {
                  createdAt: e,
                  updatedAt: e,
                  hydrated: !0
              },
              this.id = os();
              for (let e of em.lazyCollectionKeysOfModel(this.modelName)) {
                  let t = this.getKeyValue(e);
                  Um.isLazyCollection(t) && t.forceSetHydrated()
              }
          }
      }
      beforeSave(e) {}
      prepareForAdd() {}
      get isSingletonModel() {
          return !1
      }
      save(e=!1, t) {
          if (!this.store.isBootstrapped)
              throw w.warning(`Saving ${this.modelName} while bootstrapping`, {
                  modelId: this.id
              }),
              Error(`Saving ${this.modelName} while bootstrapping`);
          return Mt( () => {
              let n = this.store.save(this, e, t);
              return this.isInTransaction() || (this._clonedFromModel = void 0),
              this._onSave?.fire(),
              n
          }
          )
      }
      createMutation(e, t={}) {
          let n = `${this.modelName}CreateInput`
            , r = {}
            , i = Object.keys(this.properties).filter(e => {
              let t = this.properties[e];
              return t.persistence === `createOnly` || t.persistence === `createAndUpdate`
          }
          );
          for (let e of i) {
              let t = this.serializedValue(e, this.getKeyValue(e))
                , n = this.properties[e].optimizer;
              n?.optimizeCreate && t && (t = n.optimizeCreate(t));
              let i = this.graphQLSerializedVariableValue(e, t, !1);
              i !== void 0 && (r[e] = i)
          }
          let a = ``;
          t && Object.keys(t).length > 0 && (a = `, ` + Object.keys(t).map(e => `${e}:${JSON.stringify(t[e])}`).join(`, `));
          let o = `${Lh(this.modelName)}Create`
            , s = 1
            , c = `${o}Input`;
          for (; e.has(c); )
              c = `${o}Input_${++s}`;
          let l = `${o}(input: $${c}${a}) { lastSyncId }`;
          return this.observePropertyChanges(),
          {
              mutationText: l,
              variables: {
                  [c]: r
              },
              variableTypes: {
                  [c]: n
              }
          }
      }
      get changedProperties() {
          return Object.keys(this.modifiedProperties)
      }
      updateMutation(e, t, n={}) {
          let r = `${this.modelName}UpdateInput`
            , i = {};
          for (let e in t.changes) {
              let n = this.graphQLSerializedVariableValue(e, t.changes[e].updated, !0);
              n !== void 0 && (i[e] = n)
          }
          if (Qu(i).length === 0)
              return;
          let a = this.isSingletonModel ? `` : `id: "${this.id}", `
            , o = `${Lh(this.modelName)}Update`
            , s = 1
            , c = `${o}Input`;
          for (; e.has(c); )
              c = `${o}Input_${++s}`;
          let l = ``;
          return n && Qu(n).length > 0 && (l = `, ` + Qu(n).map(e => `${e}:${JSON.stringify(n[e])}`).join(`, `)),
          {
              mutationText: `${o}(${a}input: $${c}${l}) { lastSyncId }`,
              variables: {
                  [c]: i
              },
              variableTypes: {
                  [c]: r
              }
          }
      }
      archiveMutation() {
          return `${Lh(this.modelName)}Archive(id: "${this.id}") { lastSyncId }`
      }
      unarchiveMutation() {
          return `${Lh(this.modelName)}Unarchive(id: "${this.id}") { lastSyncId }`
      }
      deleteMutation(e={}) {
          let t = `${Lh(this.modelName)}Delete`
            , n = ``;
          return e && Qu(e).length > 0 && (n = `, ` + Qu(e).map(t => `${t}:${JSON.stringify(e[t])}`).join(`, `)),
          `${t}(id: "${this.id}"${n}) { lastSyncId }`
      }
      markPropertyChanged(e, t) {
          let n = this.properties[e];
          if ((n.persistence === `updateOnly` || n.persistence === `createAndUpdate`) && !(e in this.modifiedProperties) && !this.ignoreUpdates) {
              let n = this.serializedValue(e, t ?? void 0);
              n !== this.serializedValue(e, this.getKeyValue(e)) && (this.modifiedProperties[e] = n)
          }
      }
      changeSnapshot() {
          let e = {};
          for (let t in this.modifiedProperties) {
              let n = this.properties[t], r, i = this.serializedValue(t, this.getKeyValue(t));
              n.optimizer && this.modifiedProperties[t] && i && (r = i,
              i = n.optimizer.optimizeUpdate(this.modifiedProperties[t], i)),
              e[t] = {
                  original: this.modifiedProperties[t],
                  updatedFrom: this.modifiedProperties[t],
                  updated: i,
                  unoptimizedUpdated: r
              }
          }
          return this.clearSnapshot(),
          {
              changes: e
          }
      }
      clearSnapshot() {
          this.modifiedProperties = {}
      }
      clone(e) {
          let t = em.getModelClass(this.modelName);
          if (!t)
              throw Error(`Could not find class for model ${this.modelName}`);
          let n = new t(!0);
          return n.merge(this),
          n.markAsClonedFrom(this),
          e && (n.id = os()),
          n
      }
      serialize(e) {
          let t = {}
            , n = this.properties
            , r = Object.keys(n);
          e && (`onlyForCreate`in e && e.onlyForCreate && (r = r.filter(e => n[e].persistence === `createOnly` || n[e].persistence === `createAndUpdate`)),
          `onlyForUpdate`in e && e?.onlyForUpdate && (r = r.filter(e => n[e].persistence === `updateOnly` || n[e].persistence === `createAndUpdate`)));
          for (let e of r) {
              let n = this.serializedValue(e, this.getKeyValue(e));
              n !== null && (t[e] = n)
          }
          return t
      }
      merge(e, t) {
          Mt( () => {
              let n = t?.onlyKeys ?? Object.keys(this.properties);
              for (let t of n) {
                  let n = this.properties[t];
                  if (n.type === tm.referenceCollection || n.type === tm.referencedModel || n.type === tm.backReference)
                      continue;
                  let r = e.serializedValue(t, e[t]);
                  this.setSerializedValue(t, r === null ? void 0 : r, n)
              }
              this.setHydrated(e.hydrated)
          }
          )
      }
      differences(e) {
          return Object.keys(this.properties).filter(t => !(0,
          Kh.default)(this.serializedValue(t, this.getKeyValue(t)), e.serializedValue(t, e[t])))
      }
      updateFromData(e, t) {
          if (!this.__data) {
              this.updateFromInitialData(e, t);
              return
          }
          this.ignoreUpdates = !0;
          let n = em.propertiesOfModel(this.modelName);
          for (let t in e)
              this.setSerializedValue(t, e[t], n[t]);
          if (t?.dataContainsAllProperties === !0) {
              let t = this.dataProperties;
              for (let n in t)
                  if (!(n in e)) {
                      let e = t[n];
                      e.type !== tm.ephemeralProperty && this.setSerializedValue(n, void 0, e)
                  }
          }
          this._onUpdateFromData?.fire(e),
          this.ignoreUpdates = !1
      }
      updateFromInitialData(e, t) {
          this.id = e.id || os(),
          this.__data = t?.dontCloneData ? e : Uh.structuredClone(e)
      }
      didUpdate() {
          this._onUpdate?.fire(this)
      }
      attachToReferencedProperties() {
          this.updateReferencedModels(!0)
      }
      detachFromReferencedProperties() {
          this.updateReferencedModels(!1)
      }
      serializedValue(e, t) {
          let n = this.properties[e];
          return !n || n.type === tm.referenceCollection || n.type === tm.referencedModel || n.type === tm.backReference ? null : t !== void 0 && n.serializer !== void 0 ? n.serializer.serialize(t) : Array.isArray(t) ? [].concat(t) : t === void 0 ? null : t
      }
      setSerializedValue(e, t, n) {
          if (!n)
              return;
          let r = t === null ? void 0 : t;
          n.type === tm.reference || n.type === tm.backReference ? this.setKeyValue(e, r) : (r !== void 0 && n.serializer !== void 0 && (r = n.serializer.deserialize(r)),
          (0,
          Kh.default)(this.getKeyValue(e), r) || this.setKeyValue(e, r))
      }
      references(e) {
          for (let t in this.properties)
              if (_m.unwrap(this.getKeyValue(t)) === e)
                  return !0;
          return !1
      }
      independentOf(e) {
          if (this.modelName === e.modelName) {
              if (this.id === e.id)
                  return !1;
              let t = this.naturalIdentity
                , n = e.naturalIdentity;
              if (t !== void 0 && n !== void 0 && (0,
              Kh.default)(t, n))
                  return !1
          }
          return !(this.references(e) || e.references(this))
      }
      get persisted() {
          let e = this.store ? this.store.findById(this.modelClass, this.id, {
              excludeTemporaryModels: !0
          }) !== void 0 : !1;
          return e || this.createdAt,
          e
      }
      get persistedOnBackend() {
          return this.persisted && this.store.transactionsForModel(this).filter(e => e.type === `create`).length === 0
      }
      get filterValue() {
          return this.id
      }
      get filterMatchValue() {
          return this.id
      }
      updateRelation(e, t, n=!0) {
          let r = this.isArchivedNonObservable
            , i = e.isArchivedNonObservable;
          if (n && !r && i || !n && r && i || this.isInDifferentLocalTransaction(e))
              return;
          let a = this.properties[t];
          if (!a) {
              w.error(`Updating relation on a non-existing property`, void 0, {
                  property: t,
                  modelName: this.modelName,
                  relatedModelName: e.modelName
              });
              return
          }
          if (a.type === tm.referenceCollection) {
              let i = this[t];
              if (!i)
                  return;
              if (n) {
                  if (i instanceof Um && i.canSkipAttachingModels() && !r)
                      return;
                  i.add(e)
              } else
                  i.remove(e)
          } else if (n)
              this[t] = e;
          else {
              if (a.referenceNullable === !1)
                  return;
              a.lazy === !0 ? (this[t + `Id`] === e.id || this[t + `_l`]?.value === e) && (this[t] = void 0) : this[t + `Id`] === e.id && (this[t] = void 0)
          }
      }
      referencedPropertyChanged(e, t, n, r) {
          if (this.observingPropertyChanges)
              if (Array.isArray(r) && Array.isArray(n)) {
                  for (let i of n)
                      r.includes(i) || this.updateReferencedModel(e, i, t, !1);
                  for (let i of r)
                      n.includes(i) || this.updateReferencedModel(e, i, t, !0)
              } else
                  n !== r && (this.updateReferencedModel(e, n, t, !1),
                  this.updateReferencedModel(e, r, t, !0))
      }
      observePropertyChanges() {
          this.observingPropertyChanges ||= !0
      }
      hydrate(t, n) {
          if (Zp.addArguments(this.id),
          this.hydrationPromise && (!this.isHydrationPromiseLocalOnly || t?.onlyIfLocallyAvailable))
              return Zp.cancelSpan(),
              this.hydrationPromise;
          if (!this.persisted || this.hydrated)
              return this.setHydrated(),
              this.isHydrationPromiseLocalOnly = !1,
              this.hydrationPromise = new Jp(this),
              this.hydrationPromise;
          n = (n ?? []).concat(this.id);
          let r = t?.skipCascadeHydration ? [] : em.cascadeHydrationKeysOfModel(this.modelName)
            , i = []
            , a = !1
            , o = em.propertiesOfModel(this.modelName);
          for (let e of em.lazyCollectionKeysOfModel(this.modelName)) {
              let n = this.getKeyValue(e);
              if (Um.isLazyCollection(n) && !n.isHydrated()) {
                  let e = n.hydrate(t);
                  i.push(e),
                  n.modelClass.isPartiallyLoaded && (a = !0)
              }
          }
          for (let s of em.lazyReferenceKeysOfModel(this.modelName)) {
              let c = o[s]
                , l = this.getKeyValue(s);
              if (_m.isLazy(l))
                  if (l.isResolved())
                      l.value instanceof e && !l.value.isHydrated() && r.includes(s) && !n.includes(l.value.id) && i.push(l.value.hydrate(t, n));
                  else {
                      let e = l.resolve(t);
                      r.includes(s) && (e = e.then(e => {
                          if (!(e === void 0 || e.isHydrated() || n.includes(e.id)))
                              return e.hydrate(t, n)
                      }
                      )),
                      i.push(e),
                      c.referencedClassResolver?.().isPartiallyLoaded ? a = !0 : c.referencedClassResolver || (a = !0)
                  }
          }
          let s = this.hydrateExtra();
          if (s && i.push(s.hydrate()),
          r)
              for (let a of r) {
                  let r = this.getKeyValue(a);
                  if (r instanceof e && r.isHydrated() === !1 && !n.includes(r.id)) {
                      let e = r.hydrate(t, n);
                      i.push(e)
                  } else if (r instanceof Bm) {
                      let e = r.transientlyHydrateElements();
                      e.isPending && i.push(e)
                  }
              }
          return i.length ? (this.isHydrationPromiseLocalOnly = a && t?.onlyIfLocallyAvailable,
          this.hydrationPromise = new Jp( (e, n) => {
              Promise.all(i).then( () => {
                  this.setHydrated(!a || !t?.onlyIfLocallyAvailable),
                  e(this)
              }
              ).catch(async e => {
                  this.invalidateRejectedWhenRequested(),
                  n(new dm(this.modelClass,e))
              }
              )
          }
          ),
          this.hydrationPromise.catch(e => {
              w.info(`Error while hydrating model`, {
                  modelName: this.modelClass.modelName,
                  id: this.id,
                  error: e
              })
          }
          )) : (this.setHydrated(),
          this.isHydrationPromiseLocalOnly = !1,
          this.hydrationPromise = new Jp(this)),
          Fm.enabled && Fm.record({
              type: `model`,
              modelName: this.modelClass.modelName,
              id: this.id,
              options: t
          }),
          this.hydrationPromise
      }
      hydrateRelations(e, t) {
          let n = [...e].sort().join(`-`)
            , r = this.hydratedRelationsPromises.get(n);
          if (r)
              return r;
          let i = new Jp(async (r, i) => {
              if (!this.isHydrated())
                  try {
                      await this.hydrate(t)
                  } catch (e) {
                      return i(e)
                  }
              if (e.length === 0)
                  return r(this);
              let a = [];
              for (let n of e) {
                  let e = this.getKeyValue(n);
                  _m.isLazy(e) && e.value && !e.value.isHydrated() && a.push(e.value.hydrate(t))
              }
              if (a.length)
                  try {
                      await Promise.all(a)
                  } catch (e) {
                      return this.invalidateRejectedWhenRequested(n),
                      i(new dm(this.modelClass,e))
                  }
              r(this)
          }
          );
          return this.hydratedRelationsPromises.set(n, i),
          i
      }
      prefetch(t) {
          this.hydrate(t === `localOnly` ? {
              onlyIfLocallyAvailable: !0
          } : void 0).then( () => {
              let n = em.cascadeHydrationKeysOfModel(this.modelName);
              for (let r of n) {
                  let n = this.getKeyValue(r);
                  n instanceof e && n.prefetch(t)
              }
          }
          )
      }
      isHydrated() {
          if (this.hydrated)
              return !0;
          for (let e of em.lazyCollectionKeysOfModel(this.modelName)) {
              let t = this.getKeyValue(e);
              if (Um.isLazyCollection(t) && !t.isHydrated())
                  return !1
          }
          for (let t of em.lazyReferenceKeysOfModel(this.modelName)) {
              if (em.propertiesOfModel(this.modelName)[t].referencedClassResolver === void 0) {
                  let e = this.getKeyValue(t + `_l`);
                  if (e && !e.isResolved())
                      return !1
              }
              let n = t + `Id`;
              if (this.getKeyValue(n)) {
                  let r = em.referencedModelClass(this.modelName, t);
                  if (r && !e.store.findById(r, this.getKeyValue(n)))
                      return !1
              }
          }
          let t = this.hydrateExtra();
          return !(t && !t.isHydrated())
      }
      hydrationFailed() {
          return !!this.hydrationPromise?.error
      }
      static getAllInitialHydratedModelData(e) {}
      static preloadFor(e, t) {
          return new Em(this,t).viaRelation(e)
      }
      static preloadWithId(e) {
          return new Em(this).withId(e)
      }
      get shouldSetUpdatedAt() {
          let e = this.skipUpdatedAtKeys
            , t = Object.keys(this.modifiedProperties);
          return t.length === 0 ? !1 : e === void 0 || t.some(t => !e.has(t))
      }
      isInstanceOf(e) {
          return this instanceof e
      }
      propertyChanged(e, t, n) {
          let r = this.properties[e];
          if (r) {
              if (r.type === tm.ephemeralProperty) {
                  if (r.ephemeralType === `map`)
                      return;
                  let t = this.serializedValue(e, n);
                  this.ignoreUpdates || (this.ephemeralUpdates ? this.ephemeralUpdates[e] = t : (this.ephemeralUpdates = {
                      [e]: t
                  },
                  window.setTimeout( () => {
                      this.store.sendEphemeralPrimitive(this, this.ephemeralUpdates || {}),
                      this.ephemeralUpdates = void 0
                  }
                  , 5)))
              } else
                  this.markPropertyChanged(e, t);
              if (r.referencedProperty) {
                  let i = r.referencedClassResolver?.() ?? em.referencedModelClass(this.modelName, e);
                  i && this.referencedPropertyChanged(i.modelName, r.referencedProperty, t, n)
              }
          }
      }
      includeInLocalTransactionVia() {
          return []
      }
      static #o = this.collectionsIncludedInLocalTransaction = [];
      static #s = this.collectionsExcludedFromLocalTransaction = [];
      inHydratedCollections() {
          let t = em.referencedPropertiesOfModel(this.modelName)
            , n = [];
          for (let r in t) {
              let i = t[r]
                , a = em.referencedModelClass(this.modelName, r);
              if (a) {
                  let t = this.getKeyValue(r)
                    , o = t instanceof e ? t.id : t;
                  if (!o || !i.referencedProperty)
                      continue;
                  for (let e of Array.isArray(o) ? o : [o]) {
                      let t = this.store.findById(a, e);
                      if (t) {
                          let e = t.getKeyValue(i.referencedProperty);
                          e && e instanceof Um && e.isHydrated() && n.push(e)
                      }
                  }
              }
          }
          return n
      }
      ephemeralSubscribe() {
          if (this.ephemeralSubscribed) {
              this._ephemeralSubscribeCount++;
              return
          }
          this.resetEphemeralProperties(),
          this.store.sendEphemeralSubscribe(this),
          this._ephemeralSubscribeCount++
      }
      ephemeralUnsubscribe() {
          if (this._ephemeralSubscribeCount--,
          this._ephemeralSubscribeCount < 0) {
              w.warning(`Model.ephemeralUnsubscribe was called more times than ephemeralSubscribe`, {
                  modelName: this.modelClass.modelName,
                  id: this.id
              });
              return
          }
          this.ephemeralSubscribed || (this.store.sendEphemeralUnsubscribe(this),
          this.resetEphemeralProperties())
      }
      get ephemeralSubscribed() {
          return this._ephemeralSubscribeCount > 0
      }
      static createEmpty() {
          return new this
      }
      graphQLSerializedVariableValue(e, t, n) {
          let r = this.properties[e];
          if (!(t === null && !n)) {
              if (r.enum)
                  if (typeof t == `string` || typeof t == `number`) {
                      for (let e of Qu(r.enum))
                          if (r.enum[e] === t)
                              return e;
                      return t
                  } else if (t === null)
                      return null;
                  else
                      return;
              return r.serializer === Fh && typeof t == `string` ? Fh.deserialize(t) : t
          }
      }
      setHydrated(e=!0) {
          this.hydrated && !e && (this.hydrationPromise = void 0,
          this.isHydrationPromiseLocalOnly = void 0),
          this.hydrated = e
      }
      hydrateExtra() {}
      getKeyValue(e) {
          return this[e]
      }
      setKeyValue(e, t) {
          this[e] = t
      }
      updateReferencedModels(e) {
          let t = em.referencedPropertiesOfModel(this.modelName);
          for (let n in t) {
              let r = t[n];
              if (!r.referencedProperty)
                  continue;
              let i = this.__data?.[n];
              if (Pt(i) && (i = i.get()),
              i) {
                  typeof i == `string` && (i = [i]);
                  for (let t of i) {
                      let i = r.referencedClassResolver?.() ?? em.referencedModelClass(this.modelName, n);
                      i?.loadStrategy === rm.placeholder && this.store.syncClient.findById(i, t),
                      i && this.updateReferencedModel(i.modelName, t, r.referencedProperty, e)
                  }
              }
          }
      }
      updateReferencedModel(e, t, n, r) {
          let i = this.store.syncClient.getInMemoryModel(e, t);
          i ? i.updateRelation(this, n, r) : r && this.store.delayedRelationManager.addDelayedRelation(this, e, t)
      }
      isInDifferentLocalTransaction(e) {
          if (!this.store.hasLocalTransactions)
              return !1;
          let t = !this.isClone && this.persisted
            , n = !e.isClone && e.persisted;
          if (t && n)
              return !1;
          let r = this.store.localTransactionsForModel(this)
            , i = this.store.localTransactionsForModel(e)
            , a = r.some(e => i.includes(e))
            , o = !!r.length && !!i.length
            , s = !r.length && !!i.length;
          return !a && o || s
      }
      markAsClonedFrom(e) {
          this._clonedFromModel = e
      }
      isInTransaction() {
          return this.store.modelIsInTransaction(this)
      }
      invalidateRejectedWhenRequested(e) {
          e && (this._invalidateRejectedWhenRequestedKeys ||= new Set,
          this._invalidateRejectedWhenRequestedKeys.add(e)),
          this._invalidateRejectedWhenRequestedSubscribed ||= (this.store.onInvalidateRejectedHydrations.subscribeOnce( () => this.invalidateRejectedHydrationPromises()),
          !0)
      }
      invalidateRejectedHydrationPromises() {
          if (this.hydrationPromise?.error && (this.hydrationPromise = void 0,
          this.isHydrationPromiseLocalOnly = !1),
          this._invalidateRejectedWhenRequestedKeys) {
              for (let e of this._invalidateRejectedWhenRequestedKeys.keys())
                  this.hydratedRelationsPromises.delete(e);
              this._invalidateRejectedWhenRequestedKeys = void 0
          }
          this._invalidateRejectedWhenRequestedSubscribed = !1
      }
      resetEphemeralProperties() {
          for (let e in this.properties) {
              let t = this.properties[e];
              if (t.type === tm.ephemeralProperty) {
                  let n = e;
                  t.ephemeralType === `map` ? this[n].clear() : t.ephemeralType === `primitive` && (this[n] = void 0)
              }
          }
      }
  }
  ,
  M([Zp.trace(`hydration`)], qh.prototype, `hydrate`, null),
  Jh = class extends qh {
      archive() {
          return this.archivedAt = new Date,
          this.store.archive(this)
      }
      unarchive() {
          return this.store.unarchive(this)
      }
  }
  ,
  Yh = class extends Jh {
      delete(e) {
          return Mt( () => (this._onDelete?.fire(this),
          this.store.delete(this, e)))
      }
      get onDelete() {
          return this._onDelete ||= new Ts,
          this._onDelete
      }
  }
  ,
  Xh = class extends Jh {
      trash() {
          return Mt( () => this.store.trash(this))
      }
  }
}
)), Zh, Qh, $h, eg, tg, ng = t(( () => {
  if (yn(),
  Zh = e(qp(), 1),
  to(),
  Yr(),
  Xn(),
  ws(),
  ni(),
  Qh = {
      models: {
          ApiKey: 1,
          Comment: 1,
          Document: 1,
          DocumentContent: 2,
          EmailIntakeAddress: 2,
          FeatureFlag: 1,
          FeatureFlagRolloutStage: 1,
          Favorite: 2,
          GitAutomationState: 1,
          GitAutomationTargetBranch: 1,
          IntegrationTemplate: 1,
          InitiativeUpdate: 1,
          InitiativeToProject: 1,
          Issue: 5,
          IssueHistory: 2,
          IssueImport: 4,
          IssueLabel: 3,
          IssueRelation: 1,
          Notification: 2,
          NotificationSubscription: 1,
          Project: 1,
          PullRequestDiff: 3,
          Post: 1,
          PullRequestComment: 1,
          PushSubscription: 1,
          RoadmapToProject: 1,
          Subscription: 1,
          Team: 9,
          TeamMembership: 8,
          Template: 3,
          TimeSchedule: 1,
          User: 1,
          Webhook: 3,
          WorkflowCronJobDefinition: 1,
          WorkflowState: 2
      },
      indexVersion: 30,
      partialObjectStoreSchemaVersion: 1,
      syncActionStoreVersion: 1
  },
  $h = `linear_databases`,
  eg = class e {
      static #e = this.constructorName = `DatabaseManager`;
      static #t = this.deletingDatabase = !1;
      static async databaseInfo(t) {
          let {userId: n, modelSchemaHash: r, minVersion: i} = t
            , a = i
            , o = (await e.databases()).filter(e => e.userId === n && e.version > a).orderBy([`version`], [`desc`]);
          o.length > 0 && (a = o[0].version);
          let s = await this.userVersion(n)
            , c = `linear_` + (0,
          Zh.default)(`${n}_fake_token__${a}${s ? `_${s}` : ``}`)
            , l = (0,
          Zh.default)(`
    ${r}_${Qh.indexVersion}_${Qh.partialObjectStoreSchemaVersion}_${Qh.syncActionStoreVersion}`)
            , u = (await this.databases()).find(e => e.name === c)
            , d = u && Number(u?.schemaVersion) || 1;
          return u && u.schemaHash !== l && d++,
          {
              name: c,
              createdAt: Date.now(),
              userId: n,
              schemaHash: l,
              schemaVersion: d,
              version: a,
              userVersion: s
          }
      }
      static async registerDatabase(t) {
          return await (await e.database()).transaction(`databases`, `readwrite`).store.put(t)
      }
      static async unregisterDatabase(t) {
          let n = await e.database();
          w.network(`Unregistering database ${t}`, {
              name: t
          });
          let r = n.transaction(`databases`, `readwrite`);
          r.store.delete(t).catch( () => {}
          ),
          await r.done.catch( () => {}
          )
      }
      static async deleteDatabaseForUserId(t) {
          let n = await this.databases();
          for (let r of n.filter(e => e.userId === t))
              await e.deleteDatabase(r.name)
      }
      static async deleteOutdatedDemoDatabases() {
          let t = (await this.databases()).filter(e => e.userId === Jn.DEMO_USER_ID).filter(e => e.createdAt < Date.now() - b.DAY);
          for (let n of t)
              await e.deleteDatabase(n.name)
      }
      static async deleteDatabase(t) {
          w.network(`Deleting database`, {
              database: t
          }),
          this.deletingDatabase = !0;
          let n = await e.database()
            , r = await n.transaction(`databases`, `readonly`).store.get(t).catch( () => {}
          );
          if (r) {
              let e = n.transaction(`databases`, `readwrite`);
              e.store.put({
                  ...r,
                  deleting: !0
              }).catch( () => {}
              ),
              await e.done.catch( () => {}
              )
          }
          return new Promise(async e => {
              try {
                  await Yee(t, {
                      blocked: () => {
                          w.info(`Database deletion blocked`, {
                              name: t
                          }),
                          this.deletingDatabase = !1,
                          e()
                      }
                  }),
                  await this.unregisterDatabase(t)
              } catch (e) {
                  w.error(`Error deleting database`, e)
              }
              this.deletingDatabase = !1,
              e()
          }
          )
      }
      static async deleteAllDatabases() {
          this.deletingDatabase = !0;
          let t = await e.databases();
          if (t.length > 0 && w.network(`Deleting ${t.length} databases`, {
              dbs: t
          }),
          await Promise.all(t.map(t => e.deleteDatabase(t.name))),
          typeof indexedDB.databases == `function`)
              for (let t of await indexedDB.databases())
                  t.name && await e.deleteDatabase(t.name);
          this.deletingDatabase = !1
      }
      static async cleanOutdatedDatabases(t, n, r) {
          let i = await e.outdatedDatabases(t, n, r);
          i.length > 0 && w.network(`Cleaning up ${i.length} stale databases`, {
              dbs: i
          }),
          i.map(t => e.deleteDatabase(t.name))
      }
      static async incrementUserVersion(t) {
          let n = (await this.userVersion(t) || 1) + 1;
          w.info(`Incrementing user version to ${n}`),
          await (await e.database()).put(`userVersion`, {
              userId: t,
              version: n
          })
      }
      static async database() {
          return e.databaseInstance ||= await Qa.executeWithRetries({
              maxRetries: 2,
              backoff: 0,
              beforeRetry: async () => {
                  w.info(`Retrying opening database after error. Deleting existing database.`),
                  await Yee($h).catch(e => {
                      w.info(`Failed to delete database after error`, {
                          error: e
                      })
                  }
                  )
              }
          }, async () => await Jee($h, 2, {
              upgrade: e => {
                  w.network(`Initializing Database Manager database`),
                  e.objectStoreNames.contains(`databases`) || e.createObjectStore(`databases`, {
                      keyPath: `name`
                  }),
                  e.objectStoreNames.contains(`userVersion`) || e.createObjectStore(`userVersion`, {
                      keyPath: `userId`
                  })
              }
              ,
              blocking: () => {
                  w.info(`DatabaseManager database is blocking.`),
                  e.databaseInstance?.close(),
                  e.databaseInstance = void 0
              }
              ,
              blocked: () => {
                  w.info(`DatabaseManager database is blocked.`)
              }
              ,
              terminated: () => {
                  w.info(`DatabaseManager database is terminated.`),
                  e.databaseInstance = void 0
              }
          })),
          e.databaseInstance
      }
      static async databases() {
          return (await e.database()).transaction(`databases`).store.getAll()
      }
      static async outdatedDatabases(t, n, r) {
          return (await e.databases()).filter(e => e.userId === t && (e.version !== n || (e.userVersion || 0) !== (r || 0))).orderBy([`createdAt`], [`desc`])
      }
      static async userVersion(t) {
          return (await (await e.database()).transaction(`userVersion`).store.get(t))?.version
      }
  }
  ,
  tg = ei.get(`databaseVersionOverrides`, {
      logError: !1
  }),
  tg && tg.models)
      for (let e in tg.models)
          Qh.models[e] = tg.models[e]
}
)), rg, Are = t(( () => {
  zt(),
  Yr(),
  ws(),
  Ih(),
  rg = class {
      constructor(e, t) {
          this.model = e,
          this.property = t,
          this.map = Vt.map(),
          At(this, {
              set: Ft,
              delete: Ft,
              clear: Ft
          })
      }
      get(e) {
          return this.warnIfNotSubscribed(`get`),
          this.map.get(e)
      }
      has(e) {
          return this.warnIfNotSubscribed(`has`),
          this.map.has(e)
      }
      set(e, t, n=!1) {
          if (this.map.get(e) !== t && (this.warnIfNotSubscribed(`set`),
          this.map.set(e, t),
          !n)) {
              let n = this.model.properties[e]?.serializer ?? Nh;
              this.model.store.sendEphemeralMap(this.model, this.property, {
                  updates: {
                      [e]: n.serialize(t)
                  }
              })
          }
      }
      delete(e, t=!1) {
          this.map.has(e) && (this.warnIfNotSubscribed(`delete`),
          this.map.delete(e),
          t || this.model.store.sendEphemeralMap(this.model, this.property, {
              removeKeys: [e]
          }))
      }
      keys() {
          return this.warnIfNotSubscribed(`keys`),
          this.map.keys()
      }
      entries() {
          return this.warnIfNotSubscribed(`entries`),
          this.map.entries()
      }
      [Symbol.iterator]() {
          return this.warnIfNotSubscribed(Symbol.iterator),
          this.map[Symbol.iterator]()
      }
      toKeysAsDependency() {
          return [...this.map.keys()].sort().join(`,`)
      }
      toObject() {
          return this.warnIfNotSubscribed(`toObject`),
          Object.fromEntries(this.entries())
      }
      clear() {
          this.warnIfSubscribed(`clear`),
          this.map.clear()
      }
      canLogWarning() {
          return this.lastLoggedWarning ? new Date().getTime() - this.lastLoggedWarning.getTime() > b.SECOND * 10 : !0
      }
      warnIfNotSubscribed(e) {
          !this.model.ephemeralSubscribed && this.canLogWarning() && (w.warning(`Called EphemeralMap.${String(e)} while not subscribed`, {
              model: {
                  name: this.model.modelName,
                  id: this.model.id
              },
              property: this.property
          }),
          this.lastLoggedWarning = new Date)
      }
      warnIfSubscribed(e) {
          this.model.ephemeralSubscribed && this.canLogWarning() && (w.warning(`Called EphemeralMap.${String(e)} while still subscribed`, {
              model: {
                  name: this.model.modelName,
                  id: this.model.id
              },
              property: this.property
          }),
          this.lastLoggedWarning = new Date)
      }
  }
}
));
function I(e, t) {
  em.registerAction(e.constructor.name, t)
}
function L(e, t, n) {
  return t ? ig(e, t, n) : (t, n, r) => ig(t, n, r, e)
}
function ig(e, t, n, r) {
  let i = `${t}_c`
    , a = n.get;
  n.get = function() {
      return this[i] ? a.call(this) : (this[i] = !0,
      r?.keepAlive ? At(this, {
          [t]: Bt({
              keepAlive: !0
          })
      }) : At(this, {
          [t]: Bt
      }),
      this[t])
  }
}
function ag(e) {
  return (t, n) => {
      yg(t, n, e?.shallowObservation !== !0)
  }
}
function R(e={}) {
  return (t, n) => {
      yg(t, n, e.serializer !== void 0 && e.shallowObservation !== !0, void 0, e?.serializer, e?.setter, e?.default);
      let r = e.persistence === void 0 ? `createAndUpdate` : e.persistence
        , i = {
          type: tm.property,
          persistence: r
      };
      if (e.serializer && (i.serializer = e.serializer),
      e.optimizer && (i.optimizer = e.optimizer),
      e.enum && (i.enum = e.enum),
      e.indexed && (i.indexed = e.indexed),
      e.multiEntry && (i.multiEntry = e.multiEntry),
      e.shallowObservation && (i.shallowObservation = e.shallowObservation),
      e.isVirtual && (i.isVirtual = e.isVirtual,
      e.indexed || e.multiEntry))
          throw Error(`Virtual properties cannot be indexed`);
      em.registerProperty(t.constructor.name, n, i)
  }
}
function jre(e={}) {
  return (t, n) => {
      yg(t, n, e.serializer !== void 0 && e.shallowObservation !== !0, void 0, e.serializer, e.setter);
      let r = {
          type: tm.ephemeralProperty,
          persistence: `none`,
          ephemeralType: `primitive`
      };
      e.serializer && (r.serializer = e.serializer),
      e.optimizer && (r.optimizer = e.optimizer),
      e.enum && (r.enum = e.enum),
      em.registerProperty(t.constructor.name, n, r)
  }
}
function Mre(e={}) {
  return (t, n) => {
      vg(t, n, function() {
          return new rg(this,n)
      });
      let r = {
          type: tm.ephemeralProperty,
          persistence: `none`,
          ephemeralType: `map`
      };
      e.serializer && (r.serializer = e.serializer),
      em.registerProperty(t.constructor.name, n, r)
  }
}
function Nre(e) {
  return function(t, n) {
      let r = Object.getOwnPropertyDescriptor(t, n)?.get;
      r != null && Object.defineProperty(t, n, {
          get() {
              return e(this) ? r.call(this) : void 0
          }
      })
  }
}
function og(e, t) {
  return (n, r) => {
      em.registerProperty(n.constructor.name, r, {
          type: tm.referenceCollection,
          persistence: `createAndUpdate`
      }),
      vg(n, r, function() {
          return new (t?.Collection ?? Bm)(e(),[],t)
      })
  }
}
function z(e, t) {
  return (n, r) => {
      em.registerProperty(n.constructor.name, r, {
          type: tm.referenceCollection,
          persistence: `createAndUpdate`,
          lazy: !0
      }),
      vg(n, r, function() {
          let {canSkipHydration: n, canSkipNetworkHydration: r, customNetworkHydration: i, ...a} = t ?? {};
          return new Um(e(),this,t?.index,{
              canSkipHydration: n ? () => n(this) : void 0,
              canSkipNetworkHydration: r ? () => r(this) : void 0,
              customNetworkHydration: i ? () => i(this) : void 0,
              ...a
          })
      })
  }
}
function B(e, t, n) {
  return (r, i) => {
      gg(r, i, n, t, e)
  }
}
function sg(e, t, n) {
  return (r, i) => {
      _g(r, i, n, t, e)
  }
}
function cg(e, t) {
  return (n, r) => {
      gg(n, r, t, void 0, e)
  }
}
function lg(e, t) {
  return (n, r) => {
      _g(n, r, t, void 0, e)
  }
}
function ug(e, t, n) {
  return (r, i) => {
      typeof e == `function` ? gg(r, i, n, t, e) : gg(r, i, {
          persistence: `none`,
          nullable: !0,
          ...e
      })
  }
}
function dg(e, t, n) {
  return (r, i) => {
      typeof e == `function` ? _g(r, i, n, t, e) : _g(r, i, {
          persistence: `none`,
          nullable: !0,
          ...e
      })
  }
}
function fg(e, t, n) {
  return (r, i) => {
      em.registerProperty(r.constructor.name, i, {
          type: tm.referenceCollection,
          persistence: `none`
      }),
      hg(r, i, e, t, n ?? {}, function() {
          return new Bm(e(),[],{
              order: n?.order
          })
      })
  }
}
function pg(e, t, n) {
  return (r, i) => {
      em.registerProperty(r.constructor.name, i, {
          type: tm.referenceCollection,
          persistence: `none`,
          lazy: !0
      }),
      hg(r, i, e, t, n ?? {}, function() {
          let {canSkipHydration: t, canSkipNetworkHydration: r, customNetworkHydration: i, ...a} = n ?? {};
          return new Um(e(),this,void 0,{
              canSkipHydration: t ? () => t(this) : void 0,
              canSkipNetworkHydration: r ? () => r(this) : void 0,
              customNetworkHydration: i ? () => i(this) : void 0,
              ...a
          })
      })
  }
}
function mg(e) {
  return t => {
      let n = t.prototype;
      R({
          serializer: Ah,
          persistence: `none`
      })(n, `createdAt`),
      R({
          serializer: Ah,
          persistence: `none`
      })(n, `updatedAt`),
      R({
          serializer: Ah,
          persistence: `none`
      })(n, `archivedAt`),
      ag()(n, `permanentlyDeleted`),
      I(n, `setHydrated`),
      yg(t.prototype, `hydrated`, !1),
      At(n, em.actionAnnotationsForModel(e)),
      n.modelName = e;
      let r = `${e}_43_${Qh.models[e]}`;
      if (em.getModelClass(e))
          return;
      t.loadStrategy === rm.partial && (r += `_partial`);
      let i = em.propertiesOfModel(t.name);
      for (let t of Object.keys(i)) {
          let n = Cg[`${e}_${Qh.models[e] || 0}_${t}`] ? `1` : `0`;
          r += `_` + t + `_` + n
      }
      r = (0,
      bg.default)(r),
      em.registerModel(e, t, r)
  }
}
function hg(e, t, n, r, i, a) {
  let o = Sg(t) + `Ids`
    , s = t + `_l`
    , c = function(e) {
      this.__data?.[o] && e.setElementIds(this.__data?.[o]),
      i?.updateOnSyncGroupChange && e.updateOnSyncGroupChanges(),
      e.onChange.subscribe(e => {
          let t = e[1].slice(0);
          this.__data ||= {},
          this.__data[o] = t;
          let i = e[0].slice(0);
          this.markPropertyChanged(o, i),
          r && this.referencedPropertyChanged(n().modelName, r, i, e[1].slice(0))
      }
      )
  };
  Object.defineProperty(e, t, {
      get: function() {
          return this[s] || (this[s] = a.call(this),
          c.call(this, this[s])),
          this[s]
      },
      set: function(e) {
          this[s] = e,
          c.call(this, e)
      },
      enumerable: !0,
      configurable: !0
  }),
  Object.defineProperty(e, o, {
      get: function() {
          return this[s] ? this[s].getElementIds() : this.__data?.[o] ?? []
      },
      set: function(e) {
          this[t].setElementIds(e || [])
      },
      enumerable: !1
  });
  let l = {
      type: tm.referenceArray,
      persistence: i?.persistence ?? `createAndUpdate`,
      referencedClassResolver: n
  };
  r && (l.referencedProperty = r),
  i?.indexed && (l.indexed = !0,
  l.multiEntry = !0),
  i?.onDelete && (l.onDelete = i.onDelete === `REMOVE` ? `SET NULL` : i.onDelete === `REMOVE AND CASCADE WHEN EMPTY` ? `CASCADE` : i.onDelete === `NO ACTION` ? `NO ACTION` : Ln(i.onDelete)),
  i?.trait && (l.trait = i.trait),
  em.registerProperty(e.constructor.name, o, l)
}
function gg(e, t, n, r, i) {
  let a = t + `Id`
    , o = n.nullable
    , s = n.nullable ? !0 : n.optional;
  Object.defineProperty(e, t, {
      get: function() {
          let e = this[a]
            , n = i?.();
          if (n ||= em.referencedModelClass(this.modelName, t),
          !n) {
              w.warning(`Reference property is non owning side but no referenced class found`, {
                  modelName: this.modelName,
                  modelId: this.id,
                  referencedProperty: t
              });
              return
          }
          if (!e) {
              s || w.debug(`Reference property is non optional but identifier not set`, {
                  modelName: this.modelName,
                  modelId: this.id,
                  idKey: a,
                  referencedModelName: n.modelName
              });
              return
          }
          let r = this.store
            , o = r.findById(n, e);
          return o || (r.isPreBootstrapRendering ? (r.syncProgress,
          r.pageDataPreloader.shouldLogPreloadError(this, `${this.modelName}.${t}`) && w.warning(`Pre-bootstrap: PreloadSync missing data ${this.modelName}.${t}`, {
              referencingModelId: this.id,
              referencingModelName: this.modelName,
              referencedModelName: n.modelName,
              referencedIdentifier: e
          })) : s || w.debug(`Reference property is non optional but no model found`, {
              modelName: this.modelName,
              modelId: this.id,
              idKey: a,
              referencedModelName: n.modelName,
              referencedModelId: e,
              isBootstrapped: r.isBootstrapped
          }),
          r.delayedRelationManager.addDelayedObserver(n.modelName, e)),
          o
      },
      set: function(e) {
          this[a] = e ? typeof e == `string` ? e : e.id : void 0
      },
      enumerable: !0,
      configurable: !0
  });
  let c = {
      type: tm.referencedModel,
      persistence: `none`,
      referenceOptional: s,
      referenceNullable: o
  };
  i && (c.referencedClassResolver = i),
  n?.cascadeHydration && (c.cascadeHydration = n.cascadeHydration),
  em.registerProperty(e.constructor.name, t, c),
  yg(e, a, !1);
  let l = {
      type: i ? tm.reference : tm.backReference,
      referenceOptional: s,
      referenceNullable: o,
      persistence: n !== void 0 && n.persistence !== void 0 ? n.persistence : `createAndUpdate`
  };
  i && (l.referencedClassResolver = i),
  r && (l.referencedProperty = r),
  n?.indexed && (l.indexed = n.indexed),
  n?.onDelete && (l.onDelete = n.onDelete),
  n?.onArchive && (l.onArchive = n.onArchive),
  n?.trait && (l.trait = n.trait),
  em.registerProperty(e.constructor.name, a, l)
}
function _g(e, t, n, r, i) {
  let a = t + `Id`
    , o = `${t}_l`
    , s = n.nullable
    , c = n.nullable ? !0 : n.optional;
  function l(s) {
      if (i) {
          let e = s[a];
          if (!e)
              return;
          s[o] || (s[o] = new vm(e,i()))
      } else
          e[r],
          s[o] || (s[o] = new ym(s,t,n));
      return s[o]
  }
  Object.defineProperty(e, t, {
      get: function() {
          return l(this)
      },
      set: function(e) {
          if (e instanceof vm || e instanceof ym)
              if (e.isResolved()) {
                  this[a] = e.value?.id;
                  let t = l(this);
                  t ? t.value = e.value : w.warning(`Lazy reference set with no value`, {
                      id: this.id,
                      modelName: this.modelName,
                      hasValue: !!e.value,
                      hasId: !!e?.value?.id,
                      stack: Error().stack
                  })
              } else
                  e instanceof ym || (this[a] = e.id),
                  this[o] = e;
          else if (e) {
              let t = l(this);
              t ? t.value = e : w.warning(`Lazy reference set with no id`, {
                  id: this.id,
                  modelName: this.modelName,
                  hasId: !!e.id,
                  stack: Error().stack
              })
          } else {
              let e = this[o];
              this[a] = void 0,
              this[o] = void 0,
              e && (e.value = void 0)
          }
      },
      enumerable: !0,
      configurable: !0
  });
  let u = {
      type: tm.referencedModel,
      persistence: `none`,
      referenceOptional: c,
      referenceNullable: s,
      lazy: !0
  };
  i && (u.referencedClassResolver = i),
  n?.cascadeHydration && (u.cascadeHydration = n.cascadeHydration),
  em.registerProperty(e.constructor.name, t, u),
  yg(e, a, !1, o);
  let d = {
      type: i ? tm.reference : tm.backReference,
      referenceOptional: c,
      referenceNullable: s,
      persistence: i ? n !== void 0 && n.persistence !== void 0 ? n.persistence : `createAndUpdate` : `none`
  };
  i && (d.referencedClassResolver = i),
  r && (d.referencedProperty = r),
  n?.indexed && (d.indexed = n.indexed),
  n?.onDelete && (d.onDelete = n.onDelete),
  n?.onArchive && (d.onArchive = n.onArchive),
  n?.trait && (d.trait = n.trait),
  em.registerProperty(e.constructor.name, a, d)
}
function vg(e, t, n) {
  let r = t + `_l`;
  Object.defineProperty(e, t, {
      get: function() {
          return r in this || (this[r] = n.apply(this)),
          this[r]
      },
      set: function(e) {
          this[r] = e
      },
      enumerable: !0,
      configurable: !0
  })
}
function yg(e, t, n, r, i, a, o) {
  let s = t + `_d`;
  Object.defineProperty(e, t, {
      get: function() {
          this.__data ||= {};
          let e = this.__data[t];
          return e === void 0 && o !== void 0 && (e = typeof o == `function` ? o() : Uh.structuredClone(o),
          this[t] = e),
          Pt(e) ? e.get() : qh.applyObservability ? (i && e !== void 0 && this.__data[s] !== !0 && (e = i.deserialize(e)),
          e = Vt.box(e, {
              deep: n
          }),
          this.__data[t] = e,
          e.get()) : i && e && this.__data[s] !== !0 ? i.deserialize(e) : e
      },
      set: function(e) {
          this.__data ||= {};
          let n = this.__data[t]
            , o = this.__data[s] === !0;
          if (this.__data[s] = !0,
          Pt(n)) {
              let i = n.get();
              r && i !== e && delete this[r],
              a ? a.set(n, e) : n.set(e),
              this.observingPropertyChanges && this.propertyChanged(t, i, e)
          } else {
              this.__data[t] = e;
              let a = i && n !== void 0 && !o ? i.deserialize(n) : n;
              r && a !== e && delete this[r],
              this.observingPropertyChanges && this.propertyChanged(t, a, e)
          }
      },
      enumerable: !0,
      configurable: !0
  })
}
var bg, xg, Sg, Cg, V = t(( () => {
  bg = e(qp(), 1),
  zt(),
  xg = e(Gt(), 1),
  zn(),
  F(),
  nm(),
  Vm(),
  Ih(),
  ng(),
  Wm(),
  Wh(),
  Are(),
  ws(),
  Sm(),
  om(),
  {singular: Sg} = xg.default,
  Cg = {
      Comment_1_issueId: !0,
      IssueHistory_1_issueId: !0,
      Issue_0_teamId: !0
  }
}
)), wg, Tg, Eg = t(( () => {
  V(),
  F(),
  om(),
  GU(),
  kg(),
  Sm(),
  N(),
  Tg = class extends Yh {
      static #e = wg = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static create({aiPrompt: e, user: t}) {
          let n = wg.createEmpty();
          return n.user = vm.wrap(t),
          n.aiPrompt = vm.wrap(e),
          n.save(!0),
          n
      }
  }
  ,
  M([sg( () => J, `aiPromptSubscriptions`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], Tg.prototype, `user`, void 0),
  M([sg( () => Og, `aiPromptSubscriptions`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], Tg.prototype, `aiPrompt`, void 0),
  Tg = wg = M([mg(`AiPromptSubscription`)], Tg)
}
)), Dg, Og, kg = t(( () => {
  Gp(),
  ml(),
  V(),
  F(),
  om(),
  GU(),
  iU(),
  Eg(),
  N(),
  Og = class extends Yh {
      static #e = Dg = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static create({body: e=``, color: t, context: n=[], targets: r=[], icon: i, owner: a, creator: o, shared: s=!1, title: c=``}) {
          let l = Dg.createEmpty();
          return l.title = c,
          l.owner = a ?? o,
          l.creator = o,
          l.icon = i,
          l.color = t,
          l.body = e,
          l.shared = s,
          l.context = n,
          l.targets = r,
          l
      }
      getBodyData(e) {
          return Hp.parseToProsemirrorData(this.body, e) ?? pl()
      }
      get numUsersSubscribed() {
          return this.aiPromptSubscriptions.length
      }
  }
  ,
  M([B( () => q, `aiPrompts`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], Og.prototype, `organization`, void 0),
  M([cg( () => J, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], Og.prototype, `owner`, void 0),
  M([cg( () => J, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], Og.prototype, `creator`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0,
      indexed: !0
  })], Og.prototype, `lastUpdatedBy`, void 0),
  M([R({
      default: !1
  })], Og.prototype, `shared`, void 0),
  M([R({
      default: ``
  })], Og.prototype, `body`, void 0),
  M([R({
      default: ``
  })], Og.prototype, `title`, void 0),
  M([R()], Og.prototype, `icon`, void 0),
  M([R()], Og.prototype, `color`, void 0),
  M([R({
      persistence: `none`,
      default: ``,
      indexed: !0
  })], Og.prototype, `slugId`, void 0),
  M([R({
      default: []
  })], Og.prototype, `context`, void 0),
  M([R({
      default: []
  })], Og.prototype, `targets`, void 0),
  M([z( () => Tg, {
      index: `aiPromptId`
  })], Og.prototype, `aiPromptSubscriptions`, void 0),
  M([L], Og.prototype, `numUsersSubscribed`, null),
  Og = Dg = M([mg(`AiPrompt`)], Og)
}
));
function Pre(e, t) {
  if (e in Mg)
      return Mg[e][t]
}
function Fre(e) {
  return e in Mg ? Object.entries(Mg[e]) : []
}
var Ag, jg, Mg, Ng = t(( () => {
  $r(),
  Ag = function(e) {
      return e.productIntelligence = `productIntelligence`,
      e.internalResearch = `internalResearch`,
      e.projectUpdates = `projectUpdates`,
      e.initiativeUpdates = `initiativeUpdates`,
      e.agentGuidance = `agentGuidance`,
      e.triageAgent = `triageAgent`,
      e.codeIntelligence = `codeIntelligence`,
      e.aiConversation = `aiConversation`,
      e.slackIssueIntake = `slackIssueIntake`,
      e.intercomIssueIntake = `intercomIssueIntake`,
      e.gongIssueIntake = `gongIssueIntake`,
      e.zendeskIssueIntake = `zendeskIssueIntake`,
      e
  }({}),
  jg = function(e) {
      return e.created = `created`,
      e.inProgress = `inProgress`,
      e.finished = `finished`,
      e.failed = `failed`,
      e.canceled = `canceled`,
      e
  }({}),
  Mg = {
      productIntelligence: {
          gpt51: {
              title: `GPT-5.1`,
              feature: Xr.productIntelligenceGpt51
          }
      },
      internalResearch: {}
  }
}
));
function Pg(e, t) {
  let[n,r] = Ire(e.path, e.caseSensitive, e.end)
    , i = t.match(n);
  if (!i)
      return null;
  let a = i[0]
    , o = a.replace(/(.)\/+$/, `$1`)
    , s = i.slice(1);
  return {
      params: r.reduce( (e, {paramName: t, isOptional: n}, r) => {
          if (t === `*`) {
              let e = s[r] || ``;
              o = a.slice(0, a.length - e.length).replace(/(.)\/+$/, `$1`)
          }
          let i = s[r];
          return n && !i ? e[t] = void 0 : e[t] = (i || ``).replace(/%2F/g, `/`),
          e
      }
      , {}),
      pathname: a,
      pathnameBase: o,
      pattern: e
  }
}
function Ire(e, t=!1, n=!0) {
  let r = []
    , i = `^` + e.replace(/\/*\*?$/, ``).replace(/^\/*/, `/`).replace(/[\\.*+^${}|()[\]]/g, `\\$&`).replace(/\/:([\w-]+)(\?)?/g, (e, t, n) => (r.push({
      paramName: t,
      isOptional: n != null
  }),
  n ? `/?([^\\/]+)?` : `/([^\\/]+)`));
  return e.endsWith(`*`) ? (r.push({
      paramName: `*`
  }),
  i += e === `*` || e === `/*` ? `(.*)$` : `(?:\\/(.+)|\\/*)$`) : n ? i += `\\/*$` : e !== `` && e !== `/` && (i += `(?:(?=\\/|$))`),
  [new RegExp(i,t ? void 0 : `i`), r]
}
var Fg = t(( () => {}
));
function Ig(e, t) {
  let n = e;
  if (t && e.startsWith(t)) {
      let {pathname: t} = new URL(e);
      n = t
  }
  for (let e of zg) {
      let t = Pg({
          path: e,
          end: !1
      }, n);
      if (t)
          return [e, t.params]
  }
  return [Bg, {}]
}
function Lg(e) {
  if (Ka(e))
      return e;
  {
      let t = e.split(`-`);
      return t[t.length - 1]
  }
}
var Rg, zg, Bg, Vg = t(( () => {
  Fg(),
  qa(),
  Rg = function(e) {
      return e.allProjectsFacet = `/:orgKey/projects/view/:customViewId`,
      e.allProjectsTeamFacet = `/:orgKey/team/:teamKey/projects/view/:customViewId`,
      e.customer = `/:orgKey/customer/:customerId`,
      e.customView = `/:orgKey/view/:customViewId`,
      e.cycle = `/:orgKey/team/:teamKey/cycle/:cycleIdentifier`,
      e.dashboard = `/:orgKey/dashboard/:dashboardId`,
      e.dashboardWidget = `/:orgKey/dashboard/:dashboardId/widget/:widgetId`,
      e.document = `/:orgKey/document/:documentId`,
      e.issueLabel = `/:orgKey/issue-label/:labelName`,
      e.teamIssueLabel = `/:orgKey/team/:teamKey/issue-label/:labelName`,
      e.initiative = `/:orgKey/initiative/:initiativeId/:tab?`,
      e.initiativeFacet = `/:orgKey/initiative/:initiativeId/view/:customViewId`,
      e.initiatives = `/:orgKey/initiatives/:viewType?`,
      e.initiativeUpdate = `/:orgKey/initiative/:initiativeId/update/:initiativeUpdateId`,
      e.issue = `/:orgKey/issue/:issueId/:slug?`,
      e.project = `/:orgKey/project/:projectId/:viewType?`,
      e.projectFacet = `/:orgKey/project/:projectId/view/:customViewId`,
      e.projectUpdate = `/:orgKey/project/:projectId/update/:projectUpdateId`,
      e.review = `/:orgKey/review/:reviewId`,
      e.team = `/:orgKey/team/:teamKey/:viewType`,
      e.teamIssuesFacet = `/:orgKey/team/:teamKey/view/:customViewId`,
      e.teamProjects = `/:orgKey/team/:teamKey/projects/:viewType?`,
      e.user = `/:orgKey/profiles/:displayName`,
      e.teamUpdate = `/:orgKey/team/:teamKey/update/:postId`,
      e.post = `/:orgKey/update/:postId`,
      e.pulseFacet = `/:orgKey/pulse/view/:customViewId`,
      e.integrationsSettings = `/:orgKey/settings/integrations/:integrationSlug?`,
      e
  }({}),
  zg = [Rg.teamIssuesFacet, Rg.allProjectsTeamFacet, Rg.allProjectsFacet, Rg.initiativeFacet, Rg.projectFacet, Rg.customView, Rg.dashboardWidget, Rg.dashboard, Rg.teamIssueLabel, Rg.issueLabel, Rg.issue, Rg.projectUpdate, Rg.project, Rg.document, Rg.initiativeUpdate, Rg.initiative, Rg.initiatives, Rg.cycle, Rg.teamProjects, Rg.teamUpdate, Rg.team, Rg.customer, Rg.review, Rg.user, Rg.post, Rg.pulseFacet, Rg.integrationsSettings],
  Bg = `NO_MATCHING_ROUTE`
}
)), Hg, Ug, Wg, Gg, Kg, qg, Jg, Yg, Xg, Zg, Qg, $g, e_, t_, n_, r_, i_, a_, o_, s_, c_, l_, u_, d_, f_, p_, m_, h_, g_, Lre, Rre, __, v_, y_, zre, Bre, b_, Vre, x_, Hre, Ure, Wre, S_, C_, w_, Gre, Kre, qre, Jre, T_, Yre, E_, D_, Xre, Zre, O_, k_, A_, j_, M_, N_, P_, Qre, $re, eie, tie, nie, rie, iie, F_, aie, I_, oie, sie, cie, lie, L_ = t(( () => {
  nt(),
  zn(),
  Xs(),
  Mu(),
  Hg = /^([a-z0-9+.-]+):(?:\/\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()+,;=]|%[0-9A-F]{2})*)(?::(\d*))?(\/(?:[a-z0-9-._~!$&'()*+,;=:@\/]|%[0-9A-F]{2})*)?|(\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@\/]|%[0-9A-F]{2})*)?)(?:\?((?:[a-z0-9-._~!$&'()*+,;=:\/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:\/?@]|%[0-9A-F]{2})*))?$/i,
  Ug = (e, t) => `${t}${e}`,
  Wg = `https://linear.app/join-slack`,
  Gg = `https://linear.app/download`,
  Kg = `https://desktop.linear.app`,
  qg = `https://linearstatus.com`,
  Jg = `https://constellation.linear.app/api/statuspage`,
  Yg = `1645587184`,
  `${Yg}`,
  Xg = e => {
      let t = e.handler ? `/auth/${e.handler}-${e.service}/${e.email}/${e.token}${e.clientAuthCode ? `/` + e.clientAuthCode : ``}` : `/auth/${e.service}/${e.email}/${e.token}${e.clientAuthCode ? `/` + e.clientAuthCode : ``}`;
      return e.state ? `${t}?state=${e.state}` : e.csrfToken ? `${t}?csrfToken=${e.csrfToken}` : t
  }
  ,
  Zg = e => `https://auth.linear.app/sso${e ? `/${e}` : ``}`,
  Qg = e => `/auth/sso/${e}/metadata.xml`,
  $g = (e, t) => `/auth/sso/${e}${t ? `/` + t : ``}`,
  e_ = e => `/auth/sso/${e}/acs`,
  t_ = e => `/auth/scim/${e}`,
  n_ = () => `/add-account`,
  r_ = () => `/signup`,
  i_ = () => `/join`,
  a_ = e => `/invite/${e}/accept`,
  o_ = (e, t) => `/${e}/settings${t ? `/` + t : ``}`,
  s_ = (e, t) => `${e}/settings/import-export/migration-assistant${t ? `/` + t : ``}`,
  c_ = (e, t, n) => {
      let {urlKey: r} = t;
      switch (e) {
      case T.airbyte:
          return o_(r, `integrations/airbyte`);
      case T.discord:
          return o_(r, `integrations/airbyte`);
      case T.figma:
      case T.figmaPlugin:
          return o_(r, `integrations/figma`);
      case T.front:
          return o_(r, `integrations/front`);
      case T.github:
      case T.githubCommit:
      case T.githubPersonal:
      case T.githubCodeAccessPersonal:
          return o_(r, `integrations/github`);
      case T.githubEnterpriseServer:
          return o_(r, `integrations/github-enterprise-server`);
      case T.githubImport:
          return s_(r);
      case T.gitlab:
          return o_(r, `integrations/gitlab`);
      case T.googleCalendarPersonal:
          return o_(r, `account/profile`);
      case T.googleSheets:
          return o_(r, `integrations/google-sheets`);
      case T.intercom:
          return o_(r, `integrations/intercom`);
      case T.jira:
      case T.jiraPersonal:
          return o_(r, `integrations/jira`);
      case T.launchDarkly:
      case T.launchDarklyPersonal:
          return o_(r, `integrations/launch-darkly`);
      case T.loom:
          return o_(r, `integrations`);
      case T.notion:
          return o_(r, `integrations/notion`);
      case T.opsgenie:
          return o_(r, `integrations/opsgenie-triage`);
      case T.pagerDuty:
          return o_(r, `integrations/pagerduty-triage`);
      case T.salesforce:
          return o_(r, `integrations/salesforce`);
      case T.slackAsks:
          return o_(r, `asks${n?.integrationId ? `/${n.integrationId}` : ``}`);
      case T.slack:
      case T.slackOrgProjectUpdatesPost:
      case T.slackOrgInitiativeUpdatesPost:
      case T.slackPersonal:
      case T.slackPost:
      case T.slackProjectPost:
      case T.slackProjectUpdatesPost:
      case T.slackCustomViewNotifications:
      case T.slackInitiativePost:
          return o_(r, `integrations/slack`);
      case T.sentry:
          return o_(r, `integrations/sentry`);
      case T.zendesk:
          return o_(r, `integrations/zendesk`);
      case T.email:
          return o_(r);
      case T.gong:
          return o_(r, `integrations/gong`);
      case Bs.zapier:
          return o_(r, `integrations/zapier`);
      case T.mcpServer:
          return o_(r, `ai`);
      case T.mcpServerPersonal:
          return o_(r, `account/connections`);
      default:
          throw new Rn(e)
      }
  }
  ,
  l_ = e => {
      let {urlKey: t} = e;
      return o_(t, `asks/email-intake/new`)
  }
  ,
  u_ = (e, t) => {
      let {urlKey: n} = e;
      return o_(n, `asks/email-intake/${t}`)
  }
  ,
  d_ = (e, t) => {
      let {urlKey: n} = e;
      return o_(n, `asks/email-intake/${t}/edit`)
  }
  ,
  f_ = `applicationApproval`,
  p_ = e => `${f_}-${e.split(`-`)[0]}`,
  m_ = `comment-`,
  h_ = `update-`,
  g_ = e => `${m_}${e.split(`-`)[0]}`,
  Lre = `agent-session-`,
  Rre = `agentSession-`,
  __ = e => `${Lre}${e.split(`-`)[0]}`,
  v_ = `project-update-`,
  y_ = `initiative-update-`,
  zre = `projectUpdate-`,
  Bre = `initiativeUpdate-`,
  b_ = e => `${v_}${e.projectUpdateId.split(`-`)[0]}`,
  Vre = e => `${b_({
      projectUpdateId: e.projectUpdateId
  })}&${g_(e.commentId)}`,
  x_ = e => `${y_}${e.initiativeUpdateSlugId}`,
  Hre = e => `${x_({
      initiativeUpdateSlugId: e.initiativeUpdateSlugId
  })}&${g_(e.commentId)}`,
  Ure = ({historyEntryId: e}) => `${h_}${e}`,
  Wre = (e, t) => `${ju(t)}-${e.split(`-`)[0]}`,
  S_ = `customerRequest-`,
  C_ = e => `${S_}${e.split(`-`)[0]}`,
  w_ = ({baseUrl: e, customerNeedId: t}) => `${e}#${C_(t)}`,
  Gre = ({organizationUrlKey: e, customerName: t, customerSlugId: n, customerNeedId: r, notificationId: i}) => w_({
      baseUrl: I_(e, t, n, {
          notificationId: i
      }),
      customerNeedId: r
  }),
  Kre = ({organizationUrlKey: e, customerNeedId: t, teamKey: n, issueNumber: r, isTeamPrivate: i, title: a, notificationId: o}) => w_({
      baseUrl: j_({
          organizationUrlKey: e,
          teamKey: n,
          issueNumber: r,
          isTeamPrivate: i,
          title: a,
          notificationId: o
      }),
      customerNeedId: t
  }),
  qre = ({organizationUrlKey: e, projectName: t, projectSlugId: n, customerNeedId: r, notificationId: i}) => w_({
      baseUrl: oie(e, t, n, {
          notificationId: i
      }),
      customerNeedId: r
  }),
  Jre = ({organizationUrlKey: e, commentId: t, teamKey: n, issueNumber: r, isTeamPrivate: i, title: a, notificationId: o}) => T_({
      baseUrl: j_({
          organizationUrlKey: e,
          teamKey: n,
          issueNumber: r,
          isTeamPrivate: i,
          title: a,
          notificationId: o
      }),
      commentId: t
  }),
  T_ = ({baseUrl: e, commentId: t}) => `${e}#${g_(t)}`,
  Yre = ({organizationUrlKey: e, agentSessionId: t, teamKey: n, issueNumber: r, isTeamPrivate: i, title: a, notificationId: o}) => E_({
      baseUrl: j_({
          organizationUrlKey: e,
          teamKey: n,
          issueNumber: r,
          isTeamPrivate: i,
          title: a,
          notificationId: o
      }),
      agentSessionId: t
  }),
  E_ = ({baseUrl: e, agentSessionId: t}) => `${e}#${__(t)}`,
  D_ = e => {
      let {organizationUrlKey: t, projectUpdateId: n, projectName: r, projectSlugId: i, notificationId: a} = e
        , o = `${M_({
          organizationUrlKey: t,
          projectName: r,
          projectSlugId: i
      })}`
        , s = b_({
          projectUpdateId: n
      });
      return a ? o += `/notification/${a}#${s}` : o += `/updates#${s}`,
      o
  }
  ,
  Xre = e => {
      let {commentId: t, ...n} = e;
      return `${D_(n)}&${g_(t)}`
  }
  ,
  Zre = e => {
      let {organizationUrlKey: t, projectName: n, projectSlugId: r, notificationId: i, createdAt: a, projectUpdateSlugId: o} = e;
      return `${M_({
          organizationUrlKey: t,
          projectName: n,
          projectSlugId: r,
          notificationId: i
      })}/update/${O_(a)}-${o}`
  }
  ,
  O_ = e => Ge(e, `MM-dd-yyyy`),
  k_ = (e, t, n=`all`) => `/${e}/team/${t}/${n}`,
  A_ = (e, t, n) => k_(e, n, `cycle/${t}`),
  j_ = ({organizationUrlKey: e, teamKey: t, issueNumber: n, title: r, notificationId: i, isTeamPrivate: a}) => {
      let o = `/${e}/issue/${t}-${n}`;
      return i ? `${o}/notification/${i}` : r && !a ? `${o}/${ju(r)}` : o
  }
  ,
  M_ = e => {
      let t = `/${e.organizationUrlKey}/project/${ju(e.projectName)}-${e.projectSlugId}`;
      return e.notificationId && (t += `/notification/${e.notificationId}`),
      t
  }
  ,
  N_ = e => {
      let t = `/${e.organizationUrlKey}/initiative/${ju(e.initiativeName)}-${e.initiativeSlugId}`;
      return e.notificationId && (t += `/notification/${e.notificationId}`),
      t
  }
  ,
  P_ = e => {
      let {organizationUrlKey: t, initiativeUpdateSlugId: n, initiativeName: r, initiativeSlugId: i, notificationId: a} = e
        , o = N_({
          organizationUrlKey: t,
          initiativeName: r,
          initiativeSlugId: i
      })
        , s = x_({
          initiativeUpdateSlugId: n
      });
      return a ? o += `/notification/${a}#${s}` : o += `/updates#${s}`,
      o
  }
  ,
  Qre = e => {
      let {commentId: t, ...n} = e;
      return `${P_(n)}&${g_(t)}`
  }
  ,
  $re = e => {
      let {notificationId: t, organizationUrlKey: n, initiativeName: r, initiativeSlugId: i, createdAt: a, initiativeUpdateSlugId: o} = e;
      return `${N_({
          notificationId: t,
          organizationUrlKey: n,
          initiativeName: r,
          initiativeSlugId: i
      })}/update/${O_(a)}-${o}`
  }
  ,
  eie = (e, t) => {
      let {viewType: n, customViewId: r} = t ?? {};
      return n ? `/${e}/pulse/${n}` : r ? `/${e}/pulse/view/${r}` : `/${e}/pulse`
  }
  ,
  tie = (e, t, n) => {
      let {teamKey: r, notificationId: i} = n ?? {}
        , a = r ? `/${e}/team/${r}/update/${t}` : `/${e}/update/${t}`;
      return i && (a += `/notification/${i}`),
      a
  }
  ,
  nie = e => `/${e}/diary`,
  rie = (e, t) => `/${e}/diary#${t}`,
  iie = (e, t) => `/${e}/profiles/${encodeURIComponent(t)}`,
  F_ = ({labelName: e, organizationUrlKey: t, teamKey: n}) => n ? `/${t}/team/${n}/issue-label/${encodeURIComponent(e.toLowerCase())}` : `/${t}/issue-label/${encodeURIComponent(e.toLowerCase())}`,
  aie = ({labelName: e, organizationUrlKey: t}) => `/${t}/project-label/${encodeURIComponent(e.toLowerCase())}`,
  I_ = (e, t, n, r) => {
      let i = `/${e}/customer/${ju(t)}-${n}`;
      return r?.notificationId && (i += `/notification/${r.notificationId}`),
      i
  }
  ,
  oie = (e, t, n, r={}) => `${M_({
      organizationUrlKey: e,
      projectName: t,
      projectSlugId: n,
      notificationId: r.notificationId
  })}/requests`,
  sie = e => e.split(`-`)[0],
  cie = (e, t) => `/${e}/inbox/notification/${sie(t)}`,
  lie = class e {
      static #e = this.BASE64_SEARCH_PARAMS = [`filter`, `insights`, `insightsFilter`, `drill`];
      static encodeObject(t) {
          return e.encodeBase64SearchParam(JSON.stringify(t, (e, t) => typeof t == `string` ? encodeURIComponent(t) : t))
      }
      static decodeObject(t, n) {
          try {
              return JSON.parse(e.decodeBase64SearchParam(t), (e, t) => typeof t == `string` ? decodeURIComponent(t) : t)
          } catch (e) {
              n(`Failed to decode search param`, e, {
                  param: t
              });
              return
          }
      }
      static encodeBase64SearchParam(e) {
          return btoa(e).replace(/[+/]/g, e => e === `+` ? `-` : `_`).replace(/[=]{1,2}$/, ``)
      }
      static decodeBase64SearchParam(e) {
          let t = e.replace(/[_-]/g, e => e === `-` ? `+` : `/`)
            , n = t.length % 4;
          return atob(n === 0 ? t : t.padEnd(t.length + (4 - n), `=`))
      }
  }
}
)), R_, z_ = t(( () => {
  R_ = class {
      static isLinearAssetURL(e) {
          return /uploads\.linear\./.test(e)
      }
      static isSecureImgProxyURL(e) {
          return /secure\-img\-proxy(\-dev)?\.linear(\-app)?\./.test(e)
      }
      static isProjectUpdateURL(e) {
          return e.includes(`#projectUpdate`)
      }
      static isProjectMilestoneURL(e) {
          return e.includes(`#milestone`)
      }
      static isInitiativeUpdateURL(e) {
          return e.includes(`#initiativeUpdate`)
      }
      static isCustomerRequestURL(e) {
          return e.includes(`#customerRequest`)
      }
      static getCommentMentionId(e) {
          if (e.includes(`comment-`))
              try {
                  return new URL(e).hash.substring(1).split(`&`).find(e => e.startsWith(`comment-`))
              } catch {
                  return
              }
      }
      static getProjectMilestoneId(e) {
          let t = `milestone-`;
          if (e.includes(t))
              try {
                  return new URL(e).hash.substring(1).split(`&`).find(e => e.startsWith(t))?.substring(10)
              } catch {
                  return
              }
      }
      static getCustomerRequestHash(e) {
          if (e.includes(`customerRequest-`))
              try {
                  return new URL(e).hash.substring(1)
              } catch {
                  return
              }
      }
  }
}
)), B_, V_, H_ = t(( () => {
  B_ = e => {
      let t = [];
      return e.forEach(e => {
          let {content: n, ...r} = e;
          t.push(r),
          n && B_(n).forEach(e => t.push(e))
      }
      ),
      t
  }
  ,
  V_ = e => e.content ? B_(e.content) : []
}
)), U_, W_ = t(( () => {
  Vg(),
  L_(),
  z_(),
  H_(),
  U_ = class e {
      static findReferencedModels(e) {
          return V_(e).flatMap(e => {
              if (e.type === `entityMention` || e.type === `issueMention`) {
                  let t = this.getModelMetadataByAttributes(e.attrs ?? {});
                  if (e.attrs?.id && t)
                      return [{
                          id: e.attrs.id,
                          metadata: t
                      }]
              }
              return []
          }
          )
      }
      static getModelMetadataByUrl(e) {
          if (!e)
              return;
          let t;
          if (typeof e == `string`)
              try {
                  t = new URL(e)
              } catch {
                  return
              }
          else
              t = e;
          let n = t.pathname, r = t.hash, [i,a] = Ig(n), o, s;
          switch (i) {
          case Rg.issue:
              o = `issue`,
              s = a.issueId;
              break;
          case Rg.teamIssueLabel:
          case Rg.issueLabel:
              o = `label`,
              s = a.labelName;
              break;
          case Rg.projectUpdate:
              r = b_({
                  projectUpdateId: a.projectUpdateId.split(`-`).pop() ?? ``
              }),
              o = `projectUpdate`,
              s = a.projectId;
              break;
          case Rg.project:
              r && R_.isProjectUpdateURL(r) ? (o = `projectUpdate`,
              s = a.projectId) : t.searchParams.has(`projectMilestoneId`) || R_.isProjectMilestoneURL(t.toString()) ? (o = `projectMilestone`,
              s = t.searchParams.get(`projectMilestoneId`) ?? R_.getProjectMilestoneId(t.toString())) : (o = `project`,
              s = a.projectId);
              break;
          case Rg.document:
              o = `document`,
              s = a.documentId;
              break;
          case Rg.dashboard:
          case Rg.dashboardWidget:
              o = `dashboard`,
              s = a.dashboardId;
              break;
          case Rg.initiativeUpdate:
              r = x_({
                  initiativeUpdateSlugId: a.initiativeUpdateId.split(`-`).pop() ?? ``
              }),
              o = `initiativeUpdate`,
              s = a.initiativeId;
              break;
          case Rg.initiative:
              o = r && R_.isInitiativeUpdateURL(r) ? `initiativeUpdate` : `initiative`,
              s = a.initiativeId;
              break;
          case Rg.projectFacet:
          case Rg.customView:
          case Rg.allProjectsFacet:
          case Rg.initiativeFacet:
          case Rg.teamIssuesFacet:
              o = `customView`,
              s = a.customViewId;
              break;
          case Rg.customer:
              o = `customer`,
              s = a.customerId;
              break;
          case Rg.review:
              o = `pullRequest`,
              s = a.reviewId;
              break;
          case Rg.cycle:
              o = `cycle`,
              s = a.cycleIdentifier;
              break;
          case Rg.team:
              o = `team`,
              s = a.teamKey;
              break;
          case Rg.teamUpdate:
          case Rg.post:
              o = `post`,
              s = a.postId;
              break;
          case Rg.integrationsSettings:
              o = `integration`,
              s = a.integrationSlug ?? ``;
              break;
          default:
              return
          }
          return {
              type: o,
              identifier: s,
              orgKey: a.orgKey,
              hash: r
          }
      }
      static getModelMetadataByAttributes(t) {
          if (!(!(`href`in t) || typeof t.href != `string`))
              return e.getModelMetadataByUrl(t.href)
      }
  }
}
)), G_, uie = t(( () => {
  G_ = function() {
      function e(e) {
          this.groups = [],
          this.each = !1,
          this.context = void 0,
          this.type = e.type,
          this.name = e.name,
          this.target = e.target,
          this.propertyName = e.propertyName,
          this.constraints = e?.constraints,
          this.constraintCls = e.constraintCls,
          this.validationTypeOptions = e.validationTypeOptions,
          e.validationOptions && (this.message = e.validationOptions.message,
          this.groups = e.validationOptions.groups,
          this.always = e.validationOptions.always,
          this.each = e.validationOptions.each,
          this.context = e.validationOptions.context)
      }
      return e
  }()
}
)), K_, die = t(( () => {
  uie(),
  K_ = function() {
      function e() {}
      return e.prototype.transform = function(e) {
          var t = [];
          return Object.keys(e.properties).forEach(function(n) {
              e.properties[n].forEach(function(r) {
                  var i = {
                      message: r.message,
                      groups: r.groups,
                      always: r.always,
                      each: r.each
                  }
                    , a = {
                      type: r.type,
                      name: r.name,
                      target: e.name,
                      propertyName: n,
                      constraints: r.constraints,
                      validationTypeOptions: r.options,
                      validationOptions: i
                  };
                  t.push(new G_(a))
              })
          }),
          t
      }
      ,
      e
  }()
}
));
function fie(e) {
  return e instanceof Map ? Array.from(e.values()) : Array.isArray(e) ? e : Array.from(e)
}
var pie = t(( () => {}
));
function mie() {
  if (typeof globalThis < `u`)
      return globalThis;
  if (typeof global < `u`)
      return global;
  if (typeof window < `u`)
      return window;
  if (typeof self < `u`)
      return self
}
var hie = t(( () => {}
));
function q_(e) {
  return typeof e == `object` && !!e && typeof e.then == `function`
}
var gie = t(( () => {}
))
, J_ = t(( () => {
  pie(),
  hie(),
  gie()
}
));
function _ie() {
  var e = mie();
  return e.classValidatorMetadataStorage ||= new Q_,
  e.classValidatorMetadataStorage
}
var Y_, X_, Z_, Q_, $_ = t(( () => {
  die(),
  J_(),
  Y_ = function(e) {
      var t = typeof Symbol == `function` && Symbol.iterator
        , n = t && e[t]
        , r = 0;
      if (n)
          return n.call(e);
      if (e && typeof e.length == `number`)
          return {
              next: function() {
                  return e && r >= e.length && (e = void 0),
                  {
                      value: e && e[r++],
                      done: !e
                  }
              }
          };
      throw TypeError(t ? `Object is not iterable.` : `Symbol.iterator is not defined.`)
  }
  ,
  X_ = function(e, t) {
      var n = typeof Symbol == `function` && e[Symbol.iterator];
      if (!n)
          return e;
      var r = n.call(e), i, a = [], o;
      try {
          for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; )
              a.push(i.value)
      } catch (e) {
          o = {
              error: e
          }
      } finally {
          try {
              i && !i.done && (n = r.return) && n.call(r)
          } finally {
              if (o)
                  throw o.error
          }
      }
      return a
  }
  ,
  Z_ = function(e, t, n) {
      if (n || arguments.length === 2)
          for (var r = 0, i = t.length, a; r < i; r++)
              (a || !(r in t)) && (a ||= Array.prototype.slice.call(t, 0, r),
              a[r] = t[r]);
      return e.concat(a || Array.prototype.slice.call(t))
  }
  ,
  Q_ = function() {
      function e() {
          this.validationMetadatas = new Map,
          this.constraintMetadatas = new Map
      }
      return Object.defineProperty(e.prototype, `hasValidationMetaData`, {
          get: function() {
              return !!this.validationMetadatas.size
          },
          enumerable: !1,
          configurable: !0
      }),
      e.prototype.addValidationSchema = function(e) {
          var t = this;
          new K_().transform(e).forEach(function(e) {
              return t.addValidationMetadata(e)
          })
      }
      ,
      e.prototype.addValidationMetadata = function(e) {
          var t = this.validationMetadatas.get(e.target);
          t ? t.push(e) : this.validationMetadatas.set(e.target, [e])
      }
      ,
      e.prototype.addConstraintMetadata = function(e) {
          var t = this.constraintMetadatas.get(e.target);
          t ? t.push(e) : this.constraintMetadatas.set(e.target, [e])
      }
      ,
      e.prototype.groupByPropertyName = function(e) {
          var t = {};
          return e.forEach(function(e) {
              t[e.propertyName] || (t[e.propertyName] = []),
              t[e.propertyName].push(e)
          }),
          t
      }
      ,
      e.prototype.getTargetValidationMetadatas = function(e, t, n, r, i) {
          var a, o, s = function(e) {
              return e.always === void 0 ? e.groups && e.groups.length ? !1 : n : e.always
          }, c = function(e) {
              return !!(r && (!i || !i.length) && e.groups && e.groups.length)
          }, l = (this.validationMetadatas.get(e) || []).filter(function(n) {
              return n.target !== e && n.target !== t ? !1 : s(n) ? !0 : c(n) ? !1 : i && i.length > 0 ? n.groups && !!n.groups.find(function(e) {
                  return i.indexOf(e) !== -1
              }) : !0
          }), u = [];
          try {
              for (var d = Y_(this.validationMetadatas.entries()), f = d.next(); !f.done; f = d.next()) {
                  var p = X_(f.value, 2)
                    , m = p[0]
                    , h = p[1];
                  e.prototype instanceof m && u.push.apply(u, Z_([], X_(h), !1))
              }
          } catch (e) {
              a = {
                  error: e
              }
          } finally {
              try {
                  f && !f.done && (o = d.return) && o.call(d)
              } finally {
                  if (a)
                      throw a.error
              }
          }
          var g = u.filter(function(t) {
              return typeof t.target == `string` || t.target === e || t.target instanceof Function && !(e.prototype instanceof t.target) ? !1 : s(t) ? !0 : c(t) ? !1 : i && i.length > 0 ? t.groups && !!t.groups.find(function(e) {
                  return i.indexOf(e) !== -1
              }) : !0
          }).filter(function(e) {
              return !l.find(function(t) {
                  return t.propertyName === e.propertyName && t.type === e.type
              })
          });
          return l.concat(g)
      }
      ,
      e.prototype.getTargetValidatorConstraints = function(e) {
          return this.constraintMetadatas.get(e) || []
      }
      ,
      e
  }()
}
)), ev, tv = t(( () => {
  ev = function() {
      function e() {}
      return e.prototype.toString = function(e, t, n, r) {
          var i = this;
          e === void 0 && (e = !1),
          t === void 0 && (t = !1),
          n === void 0 && (n = ``),
          r === void 0 && (r = !1);
          var a = e ? `\x1B[1m` : ``
            , o = e ? `\x1B[22m` : ``
            , s = function() {
              return (r ? Object.values : Object.keys)(i.constraints ?? {}).join(`, `)
          }
            , c = function(e) {
              return ` - property ${a}${n}${e}${o} has failed the following constraints: ${a}${s()}${o}
`
          };
          if (t) {
              var l = Number.isInteger(+this.property) ? `[${this.property}]` : `${n ? `.` : ``}${this.property}`;
              return this.constraints ? c(l) : this.children ? this.children.map(function(t) {
                  return t.toString(e, !0, `${n}${l}`, r)
              }).join(``) : ``
          } else
              return `An instance of ${a}${this.target ? this.target.constructor.name : `an object`}${o} has failed the validation:
` + (this.constraints ? c(this.property) : ``) + (this.children ? this.children.map(function(t) {
                  return t.toString(e, !0, i.property, r)
              }).join(``) : ``)
      }
      ,
      e
  }()
}
)), nv, rv = t(( () => {
  nv = function() {
      function e() {}
      return e.isValid = function(e) {
          var t = this;
          return e !== `isValid` && e !== `getMessage` && Object.keys(this).map(function(e) {
              return t[e]
          }).indexOf(e) !== -1
      }
      ,
      e.CUSTOM_VALIDATION = `customValidation`,
      e.NESTED_VALIDATION = `nestedValidation`,
      e.PROMISE_VALIDATION = `promiseValidation`,
      e.CONDITIONAL_VALIDATION = `conditionalValidation`,
      e.WHITELIST = `whitelistValidation`,
      e.IS_DEFINED = `isDefined`,
      e
  }()
}
));
function vie(e) {
  return Array.isArray(e) ? e.join(`, `) : (typeof e == `symbol` && (e = e.description),
  `${e}`)
}
var iv, yie = t(( () => {
  iv = function() {
      function e() {}
      return e.replaceMessageSpecialTokens = function(e, t) {
          var n;
          return e instanceof Function ? n = e(t) : typeof e == `string` && (n = e),
          n && Array.isArray(t.constraints) && t.constraints.forEach(function(e, t) {
              n = n.replace(RegExp(`\\\$constraint${t + 1}`, `g`), vie(e))
          }),
          n && t.value !== void 0 && t.value !== null && typeof t.value == `string` && (n = n.replace(/\$value/g, t.value)),
          n &&= n.replace(/\$property/g, t.property),
          n &&= n.replace(/\$target/g, t.targetName),
          n
      }
      ,
      e
  }()
}
)), av, ov, bie = t(( () => {
  tv(),
  rv(),
  yie(),
  J_(),
  $_(),
  av = function(e, t) {
      var n = typeof Symbol == `function` && e[Symbol.iterator];
      if (!n)
          return e;
      var r = n.call(e), i, a = [], o;
      try {
          for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; )
              a.push(i.value)
      } catch (e) {
          o = {
              error: e
          }
      } finally {
          try {
              i && !i.done && (n = r.return) && n.call(r)
          } finally {
              if (o)
                  throw o.error
          }
      }
      return a
  }
  ,
  ov = function() {
      function e(e, t) {
          this.validator = e,
          this.validatorOptions = t,
          this.awaitingPromises = [],
          this.ignoreAsyncValidations = !1,
          this.metadataStorage = _ie()
      }
      return e.prototype.execute = function(e, t, n) {
          var r = this;
          !this.metadataStorage.hasValidationMetaData && this.validatorOptions?.enableDebugMessages === !0 && console.warn(`No validation metadata found. No validation will be  performed. There are multiple possible reasons:
- There may be multiple class-validator versions installed. You will need to flatten your dependencies to fix the issue.
- This validation runs before any file with validation decorator was parsed by NodeJS.`);
          var i = this.validatorOptions ? this.validatorOptions.groups : void 0
            , a = this.validatorOptions && this.validatorOptions.strictGroups || !1
            , o = this.validatorOptions && this.validatorOptions.always || !1
            , s = this.validatorOptions?.forbidUnknownValues === void 0 || this.validatorOptions.forbidUnknownValues !== !1
            , c = this.metadataStorage.getTargetValidationMetadatas(e.constructor, t, o, a, i)
            , l = this.metadataStorage.groupByPropertyName(c);
          if (this.validatorOptions && s && !c.length) {
              var u = new ev;
              (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === !0) && (u.target = e),
              u.value = void 0,
              u.property = void 0,
              u.children = [],
              u.constraints = {
                  unknownValue: `an unknown value was passed to the validate function`
              },
              n.push(u);
              return
          }
          this.validatorOptions && this.validatorOptions.whitelist && this.whitelist(e, l, n),
          Object.keys(l).forEach(function(t) {
              var i = e[t]
                , a = l[t].filter(function(e) {
                  return e.type === nv.IS_DEFINED
              })
                , o = l[t].filter(function(e) {
                  return e.type !== nv.IS_DEFINED && e.type !== nv.WHITELIST
              });
              i instanceof Promise && o.find(function(e) {
                  return e.type === nv.PROMISE_VALIDATION
              }) ? r.awaitingPromises.push(i.then(function(i) {
                  r.performValidations(e, i, t, a, o, n)
              })) : r.performValidations(e, i, t, a, o, n)
          })
      }
      ,
      e.prototype.whitelist = function(e, t, n) {
          var r = this
            , i = [];
          Object.keys(e).forEach(function(e) {
              (!t[e] || t[e].length === 0) && i.push(e)
          }),
          i.length > 0 && (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted ? i.forEach(function(t) {
              var i, a = r.generateValidationError(e, e[t], t);
              a.constraints = (i = {},
              i[nv.WHITELIST] = `property ${t} should not exist`,
              i),
              a.children = void 0,
              n.push(a)
          }) : i.forEach(function(t) {
              return delete e[t]
          }))
      }
      ,
      e.prototype.stripEmptyErrors = function(e) {
          var t = this;
          return e.filter(function(e) {
              if (e.children &&= t.stripEmptyErrors(e.children),
              Object.keys(e.constraints).length === 0) {
                  if (e.children.length === 0)
                      return !1;
                  delete e.constraints
              }
              return !0
          })
      }
      ,
      e.prototype.performValidations = function(e, t, n, r, i, a) {
          var o = i.filter(function(e) {
              return e.type === nv.CUSTOM_VALIDATION
          })
            , s = i.filter(function(e) {
              return e.type === nv.NESTED_VALIDATION
          })
            , c = i.filter(function(e) {
              return e.type === nv.CONDITIONAL_VALIDATION
          })
            , l = this.generateValidationError(e, t, n);
          a.push(l),
          this.conditionalValidations(e, t, c) && (this.customValidations(e, t, r, l),
          this.mapContexts(e, t, r, l),
          !(t === void 0 && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === !0) && (t === null && this.validatorOptions && this.validatorOptions.skipNullProperties === !0 || t == null && this.validatorOptions && this.validatorOptions.skipMissingProperties === !0 || (this.customValidations(e, t, o, l),
          this.nestedValidations(t, s, l),
          this.mapContexts(e, t, i, l),
          this.mapContexts(e, t, o, l))))
      }
      ,
      e.prototype.generateValidationError = function(e, t, n) {
          var r = new ev;
          return (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === void 0 || this.validatorOptions.validationError.target === !0) && (r.target = e),
          (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.value === void 0 || this.validatorOptions.validationError.value === !0) && (r.value = t),
          r.property = n,
          r.children = [],
          r.constraints = {},
          r
      }
      ,
      e.prototype.conditionalValidations = function(e, t, n) {
          return n.map(function(n) {
              return n.constraints[0](e, t)
          }).reduce(function(e, t) {
              return e && t
          }, !0)
      }
      ,
      e.prototype.customValidations = function(e, t, n, r) {
          var i = this;
          n.forEach(function(n) {
              i.metadataStorage.getTargetValidatorConstraints(n.constraintCls).forEach(function(a) {
                  if (!(a.async && i.ignoreAsyncValidations) && !(i.validatorOptions && i.validatorOptions.stopAtFirstError && Object.keys(r.constraints || {}).length > 0)) {
                      var o = {
                          targetName: e.constructor ? e.constructor.name : void 0,
                          property: n.propertyName,
                          object: e,
                          value: t,
                          constraints: n.constraints
                      };
                      if (!n.each || !(Array.isArray(t) || t instanceof Set || t instanceof Map)) {
                          var s = a.instance.validate(t, o);
                          if (q_(s)) {
                              var c = s.then(function(o) {
                                  if (!o) {
                                      var s = av(i.createValidationError(e, t, n, a), 2)
                                        , c = s[0]
                                        , l = s[1];
                                      r.constraints[c] = l,
                                      n.context && (r.contexts ||= {},
                                      r.contexts[c] = Object.assign(r.contexts[c] || {}, n.context))
                                  }
                              });
                              i.awaitingPromises.push(c)
                          } else if (!s) {
                              var l = av(i.createValidationError(e, t, n, a), 2)
                                , u = l[0]
                                , d = l[1];
                              r.constraints[u] = d
                          }
                          return
                      }
                      var f = fie(t).map(function(e) {
                          return a.instance.validate(e, o)
                      });
                      if (f.some(function(e) {
                          return q_(e)
                      })) {
                          var p = f.map(function(e) {
                              return q_(e) ? e : Promise.resolve(e)
                          })
                            , m = Promise.all(p).then(function(o) {
                              if (!o.every(function(e) {
                                  return e
                              })) {
                                  var s = av(i.createValidationError(e, t, n, a), 2)
                                    , c = s[0]
                                    , l = s[1];
                                  r.constraints[c] = l,
                                  n.context && (r.contexts ||= {},
                                  r.contexts[c] = Object.assign(r.contexts[c] || {}, n.context))
                              }
                          });
                          i.awaitingPromises.push(m);
                          return
                      }
                      if (!f.every(function(e) {
                          return e
                      })) {
                          var h = av(i.createValidationError(e, t, n, a), 2)
                            , u = h[0]
                            , d = h[1];
                          r.constraints[u] = d
                      }
                  }
              })
          })
      }
      ,
      e.prototype.nestedValidations = function(e, t, n) {
          var r = this;
          e !== void 0 && t.forEach(function(i) {
              if (!(i.type !== nv.NESTED_VALIDATION && i.type !== nv.PROMISE_VALIDATION) && !(r.validatorOptions && r.validatorOptions.stopAtFirstError && Object.keys(n.constraints || {}).length > 0))
                  if (Array.isArray(e) || e instanceof Set || e instanceof Map)
                      (e instanceof Set ? Array.from(e) : e).forEach(function(i, a) {
                          r.performValidations(e, i, a.toString(), [], t, n.children)
                      });
                  else if (e instanceof Object) {
                      var a = typeof i.target == `string` ? i.target : i.target.name;
                      r.execute(e, a, n.children)
                  } else {
                      var o = av(r.createValidationError(i.target, e, i), 2)
                        , s = o[0]
                        , c = o[1];
                      n.constraints[s] = c
                  }
          })
      }
      ,
      e.prototype.mapContexts = function(e, t, n, r) {
          var i = this;
          return n.forEach(function(e) {
              if (e.context) {
                  var t = void 0;
                  e.type === nv.CUSTOM_VALIDATION && (t = i.metadataStorage.getTargetValidatorConstraints(e.constraintCls)[0]);
                  var n = i.getConstraintType(e, t);
                  r.constraints[n] && (r.contexts ||= {},
                  r.contexts[n] = Object.assign(r.contexts[n] || {}, e.context))
              }
          })
      }
      ,
      e.prototype.createValidationError = function(e, t, n, r) {
          var i = e.constructor ? e.constructor.name : void 0
            , a = this.getConstraintType(n, r)
            , o = {
              targetName: i,
              property: n.propertyName,
              object: e,
              value: t,
              constraints: n.constraints
          }
            , s = n.message || ``;
          return !n.message && (!this.validatorOptions || this.validatorOptions && !this.validatorOptions.dismissDefaultMessages) && r && r.instance.defaultMessage instanceof Function && (s = r.instance.defaultMessage(o)),
          [a, iv.replaceMessageSpecialTokens(s, o)]
      }
      ,
      e.prototype.getConstraintType = function(e, t) {
          return t && t.name ? t.name : e.type
      }
      ,
      e
  }()
}
)), sv, cv, xie = t(( () => {
  bie(),
  sv = function(e, t, n, r) {
      function i(e) {
          return e instanceof n ? e : new n(function(t) {
              t(e)
          }
          )
      }
      return new (n ||= Promise)(function(n, a) {
          function o(e) {
              try {
                  c(r.next(e))
              } catch (e) {
                  a(e)
              }
          }
          function s(e) {
              try {
                  c(r.throw(e))
              } catch (e) {
                  a(e)
              }
          }
          function c(e) {
              e.done ? n(e.value) : i(e.value).then(o, s)
          }
          c((r = r.apply(e, t || [])).next())
      }
      )
  }
  ,
  cv = function(e, t) {
      var n = {
          label: 0,
          sent: function() {
              if (a[0] & 1)
                  throw a[1];
              return a[1]
          },
          trys: [],
          ops: []
      }, r, i, a, o;
      return o = {
          next: s(0),
          throw: s(1),
          return: s(2)
      },
      typeof Symbol == `function` && (o[Symbol.iterator] = function() {
          return this
      }
      ),
      o;
      function s(e) {
          return function(t) {
              return c([e, t])
          }
      }
      function c(s) {
          if (r)
              throw TypeError(`Generator is already executing.`);
          for (; o && (o = 0,
          s[0] && (n = 0)),
          n; )
              try {
                  if (r = 1,
                  i && (a = s[0] & 2 ? i.return : s[0] ? i.throw || ((a = i.return) && a.call(i),
                  0) : i.next) && !(a = a.call(i, s[1])).done)
                      return a;
                  switch (i = 0,
                  a && (s = [s[0] & 2, a.value]),
                  s[0]) {
                  case 0:
                  case 1:
                      a = s;
                      break;
                  case 4:
                      return n.label++,
                      {
                          value: s[1],
                          done: !1
                      };
                  case 5:
                      n.label++,
                      i = s[1],
                      s = [0];
                      continue;
                  case 7:
                      s = n.ops.pop(),
                      n.trys.pop();
                      continue;
                  default:
                      if ((a = n.trys,
                      !(a = a.length > 0 && a[a.length - 1])) && (s[0] === 6 || s[0] === 2)) {
                          n = 0;
                          continue
                      }
                      if (s[0] === 3 && (!a || s[1] > a[0] && s[1] < a[3])) {
                          n.label = s[1];
                          break
                      }
                      if (s[0] === 6 && n.label < a[1]) {
                          n.label = a[1],
                          a = s;
                          break
                      }
                      if (a && n.label < a[2]) {
                          n.label = a[2],
                          n.ops.push(s);
                          break
                      }
                      a[2] && n.ops.pop(),
                      n.trys.pop();
                      continue
                  }
                  s = t.call(e, n)
              } catch (e) {
                  s = [6, e],
                  i = 0
              } finally {
                  r = a = 0
              }
          if (s[0] & 5)
              throw s[1];
          return {
              value: s[0] ? s[1] : void 0,
              done: !0
          }
      }
  }
  ,
  function() {
      function e() {}
      return e.prototype.validate = function(e, t, n) {
          return this.coreValidate(e, t, n)
      }
      ,
      e.prototype.validateOrReject = function(e, t, n) {
          return sv(this, void 0, void 0, function() {
              var r;
              return cv(this, function(i) {
                  switch (i.label) {
                  case 0:
                      return [4, this.coreValidate(e, t, n)];
                  case 1:
                      return r = i.sent(),
                      r.length ? [2, Promise.reject(r)] : [2]
                  }
              })
          })
      }
      ,
      e.prototype.validateSync = function(e, t, n) {
          var r = typeof e == `string` ? t : e
            , i = typeof e == `string` ? n : t
            , a = typeof e == `string` ? e : void 0
            , o = new ov(this,i);
          o.ignoreAsyncValidations = !0;
          var s = [];
          return o.execute(r, a, s),
          o.stripEmptyErrors(s)
      }
      ,
      e.prototype.coreValidate = function(e, t, n) {
          var r = typeof e == `string` ? t : e
            , i = typeof e == `string` ? n : t
            , a = typeof e == `string` ? e : void 0
            , o = new ov(this,i)
            , s = [];
          return o.execute(r, a, s),
          Promise.all(o.awaitingPromises).then(function() {
              return o.stripEmptyErrors(s)
          })
      }
      ,
      e
  }()
}
)), Sie = t(( () => {
  new (function() {
      function e() {
          this.instances = []
      }
      return e.prototype.get = function(e) {
          var t = this.instances.find(function(t) {
              return t.type === e
          });
          return t || (t = {
              type: e,
              object: new e
          },
          this.instances.push(t)),
          t.object
      }
      ,
      e
  }())
}
)), Cie = t(( () => {}
)), wie = t(( () => {}
)), Tie = t(( () => {}
));
function Eie(e) {
  return e != null
}
var Die = t(( () => {
  rv(),
  nv.IS_DEFINED
}
)), Oie = t(( () => {}
)), kie = t(( () => {}
)), Aie = t(( () => {}
)), lv, jie = t(( () => {
  lv = function() {
      return lv = Object.assign || function(e) {
          for (var t, n = 1, r = arguments.length; n < r; n++)
              for (var i in t = arguments[n],
              t)
                  Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
          return e
      }
      ,
      lv.apply(this, arguments)
  }
}
)), Mie = t(( () => {}
)), uv = n(( (e, t) => {
  Object.defineProperty(e, `__esModule`, {
      value: !0
  }),
  e.default = n;
  function n(e) {
      if (e == null)
          throw TypeError(`Expected a string but received a ${e}`);
      if (e.constructor.name !== `String`)
          throw TypeError(`Expected a string but received a ${e.constructor.name}`)
  }
  t.exports = e.default,
  t.exports.default = e.default
}
)), dv = n(( (e, t) => {
  Object.defineProperty(e, `__esModule`, {
      value: !0
  }),
  e.default = n;
  function n() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
        , t = arguments.length > 1 ? arguments[1] : void 0;
      for (var n in t)
          e[n] === void 0 && (e[n] = t[n]);
      return e
  }
  t.exports = e.default,
  t.exports.default = e.default
}
)), Nie = n(( (e, t) => {
  Object.defineProperty(e, `__esModule`, {
      value: !0
  }),
  e.default = void 0,
  e.default = function(e, t) {
      return e.indexOf(t) !== -1
  }
  ,
  t.exports = e.default,
  t.exports.default = e.default
}
)), Pie = t(( () => {}
)), Fie = t(( () => {}
)), Iie = t(( () => {}
)), Lie = t(( () => {}
)), Rie = t(( () => {}
)), zie = t(( () => {}
)), Bie = t(( () => {}
)), Vie = t(( () => {}
)), Hie = t(( () => {}
)), Uie = t(( () => {}
)), Wie = t(( () => {}
)), Gie = t(( () => {}
)), Kie = t(( () => {}
)), qie = t(( () => {}
)), Jie = t(( () => {}
)), Yie = t(( () => {}
)), Xie = t(( () => {}
)), Zie = t(( () => {}
)), Qie = t(( () => {}
)), $ie = t(( () => {}
)), eae = t(( () => {}
)), tae = t(( () => {}
)), nae = t(( () => {}
)), rae = t(( () => {}
)), iae = t(( () => {}
)), aae = t(( () => {}
)), oae = n(( (e, t) => {
  Object.defineProperty(e, `__esModule`, {
      value: !0
  }),
  e.default = r;
  function n(e) {
      return Object.prototype.toString.call(e) === `[object RegExp]`
  }
  function r(e, t) {
      for (var r = 0; r < t.length; r++) {
          var i = t[r];
          if (e === i || n(i) && i.test(e))
              return !0
      }
      return !1
  }
  t.exports = e.default,
  t.exports.default = e.default
}
)), sae = n(( (e, t) => {
  Object.defineProperty(e, `__esModule`, {
      value: !0
  }),
  e.default = o;
  var n = i(uv())
    , r = i(dv());
  function i(e) {
      return e && e.__esModule ? e : {
          default: e
      }
  }
  var a = {
      require_tld: !0,
      allow_underscores: !1,
      allow_trailing_dot: !1,
      allow_numeric_tld: !1,
      allow_wildcard: !1,
      ignore_max_length: !1
  };
  function o(e, t) {
      (0,
      n.default)(e),
      t = (0,
      r.default)(t, a),
      t.allow_trailing_dot && e[e.length - 1] === `.` && (e = e.substring(0, e.length - 1)),
      t.allow_wildcard === !0 && e.indexOf(`*.`) === 0 && (e = e.substring(2));
      var i = e.split(`.`)
        , o = i[i.length - 1];
      return t.require_tld && (i.length < 2 || !t.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(o) || /\s/.test(o)) || !t.allow_numeric_tld && /^\d+$/.test(o) ? !1 : i.every(function(e) {
          return !(e.length > 63 && !t.ignore_max_length || !/^[a-z_\u00a1-\uffff0-9-]+$/i.test(e) || /[\uff01-\uff5e]/.test(e) || /^-|-$/.test(e) || !t.allow_underscores && /_/.test(e))
      })
  }
  t.exports = e.default,
  t.exports.default = e.default
}
)), cae = n(( (e, t) => {
  Object.defineProperty(e, `__esModule`, {
      value: !0
  }),
  e.default = u;
  var n = r(uv());
  function r(e) {
      return e && e.__esModule ? e : {
          default: e
      }
  }
  function i(e) {
      "@babel/helpers - typeof";
      return i = typeof Symbol == `function` && typeof Symbol.iterator == `symbol` ? function(e) {
          return typeof e
      }
      : function(e) {
          return e && typeof Symbol == `function` && e.constructor === Symbol && e !== Symbol.prototype ? `symbol` : typeof e
      }
      ,
      i(e)
  }
  var a = `(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])`
    , o = `(${a}[.]){3}${a}`
    , s = RegExp(`^${o}\$`)
    , c = `(?:[0-9a-fA-F]{1,4})`
    , l = RegExp(`^((?:${c}:){7}(?:${c}|:)|(?:${c}:){6}(?:${o}|:${c}|:)|(?:${c}:){5}(?::${o}|(:${c}){1,2}|:)|(?:${c}:){4}(?:(:${c}){0,1}:${o}|(:${c}){1,3}|:)|(?:${c}:){3}(?:(:${c}){0,2}:${o}|(:${c}){1,4}|:)|(?:${c}:){2}(?:(:${c}){0,3}:${o}|(:${c}){1,5}|:)|(?:${c}:){1}(?:(:${c}){0,4}:${o}|(:${c}){1,6}|:)|(?::((?::${c}){0,5}:${o}|(?::${c}){1,7}|:)))(%[0-9a-zA-Z.]{1,})?\$`);
  function u(e) {
      var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0,
      n.default)(e);
      var r = (i(t) === `object` ? t.version : arguments[1]) || ``;
      return r ? r.toString() === `4` ? s.test(e) : r.toString() === `6` ? l.test(e) : !1 : u(e, {
          version: 4
      }) || u(e, {
          version: 6
      })
  }
  t.exports = e.default,
  t.exports.default = e.default
}
)), lae = t(( () => {}
)), uae = t(( () => {}
)), dae = t(( () => {}
)), fae = t(( () => {}
)), pae = t(( () => {}
)), mae = t(( () => {}
)), hae = t(( () => {}
)), gae = t(( () => {}
)), _ae = t(( () => {}
)), vae = t(( () => {}
)), yae = t(( () => {}
)), bae = t(( () => {}
)), xae = t(( () => {}
)), Sae = t(( () => {}
)), Cae = t(( () => {}
)), wae = t(( () => {}
)), Tae = t(( () => {}
)), Eae = t(( () => {}
)), Dae = t(( () => {}
)), Oae = t(( () => {}
)), kae = t(( () => {}
)), Aae = t(( () => {}
)), jae = t(( () => {}
)), Mae = n(( (e, t) => {
  Object.defineProperty(e, `__esModule`, {
      value: !0
  }),
  e.default = _;
  var n = c(uv())
    , r = c(oae())
    , i = c(Nie())
    , a = c(sae())
    , o = c(cae())
    , s = c(dv());
  function c(e) {
      return e && e.__esModule ? e : {
          default: e
      }
  }
  function l(e, t) {
      return m(e) || p(e, t) || d(e, t) || u()
  }
  function u() {
      throw TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  }
  function d(e, t) {
      if (e) {
          if (typeof e == `string`)
              return f(e, t);
          var n = {}.toString.call(e).slice(8, -1);
          return n === `Object` && e.constructor && (n = e.constructor.name),
          n === `Map` || n === `Set` ? Array.from(e) : n === `Arguments` || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? f(e, t) : void 0
      }
  }
  function f(e, t) {
      (t == null || t > e.length) && (t = e.length);
      for (var n = 0, r = Array(t); n < t; n++)
          r[n] = e[n];
      return r
  }
  function p(e, t) {
      var n = e == null ? null : typeof Symbol < `u` && e[Symbol.iterator] || e[`@@iterator`];
      if (n != null) {
          var r, i, a, o, s = [], c = !0, l = !1;
          try {
              if (a = (n = n.call(e)).next,
              t === 0) {
                  if (Object(n) !== n)
                      return;
                  c = !1
              } else
                  for (; !(c = (r = a.call(n)).done) && (s.push(r.value),
                  s.length !== t); c = !0)
                      ;
          } catch (e) {
              l = !0,
              i = e
          } finally {
              try {
                  if (!c && n.return != null && (o = n.return(),
                  Object(o) !== o))
                      return
              } finally {
                  if (l)
                      throw i
              }
          }
          return s
      }
  }
  function m(e) {
      if (Array.isArray(e))
          return e
  }
  var h = {
      protocols: [`http`, `https`, `ftp`],
      require_tld: !0,
      require_protocol: !1,
      require_host: !0,
      require_port: !1,
      require_valid_protocol: !0,
      allow_underscores: !1,
      allow_trailing_dot: !1,
      allow_protocol_relative_urls: !1,
      allow_fragments: !0,
      allow_query_components: !0,
      validate_length: !0,
      max_allowed_length: 2084
  }
    , g = /^\[([^\]]+)\](?::([0-9]+))?$/;
  function _(e, t) {
      if ((0,
      n.default)(e),
      !e || /[\s<>]/.test(e) || e.indexOf(`mailto:`) === 0 || (t = (0,
      s.default)(t, h),
      t.validate_length && e.length > t.max_allowed_length) || !t.allow_fragments && (0,
      i.default)(e, `#`) || !t.allow_query_components && ((0,
      i.default)(e, `?`) || (0,
      i.default)(e, `&`)))
          return !1;
      var c, u, d, f, p, m, _ = e.split(`#`), ee;
      e = _.shift(),
      _ = e.split(`?`),
      e = _.shift();
      var te = e.match(/^([a-z][a-z0-9+\-.]*):/i)
        , ne = !1
        , re = function(n) {
          return ne = !0,
          c = n.toLowerCase(),
          t.require_valid_protocol && t.protocols.indexOf(c) === -1 ? !1 : e.substring(te[0].length)
      };
      if (te) {
          var ie = te[1]
            , ae = e.substring(te[0].length);
          if (ae.slice(0, 2) !== `//`) {
              var oe = ae.indexOf(`/`)
                , se = oe === -1 ? ae : ae.substring(0, oe)
                , ce = se.indexOf(`@`);
              if (ce !== -1) {
                  var le = se.substring(0, ce);
                  if (/^[a-zA-Z0-9\-_.%:]*$/.test(le)) {
                      if (t.require_protocol)
                          return !1
                  } else if (e = re(ie),
                  e === !1)
                      return !1
              } else if (/^[0-9]/.test(ae)) {
                  if (t.require_protocol)
                      return !1
              } else if (e = re(ie),
              e === !1)
                  return !1
          } else if (e = re(ie),
          e === !1)
              return !1
      } else if (t.require_protocol)
          return !1;
      if (e.slice(0, 2) === `//`) {
          if (!ne && !t.allow_protocol_relative_urls)
              return !1;
          e = e.slice(2)
      }
      if (e === ``)
          return !1;
      if (_ = e.split(`/`),
      e = _.shift(),
      e === `` && !t.require_host)
          return !0;
      if (_ = e.split(`@`),
      _.length > 1) {
          if (t.disallow_auth || _[0] === `` || (u = _.shift(),
          u.indexOf(`:`) >= 0 && u.split(`:`).length > 2))
              return !1;
          var ue = l(u.split(`:`), 2)
            , de = ue[0]
            , fe = ue[1];
          if (de === `` && fe === ``)
              return !1
      }
      f = _.join(`@`),
      m = null,
      ee = null;
      var pe = f.match(g);
      if (pe ? (d = ``,
      ee = pe[1],
      m = pe[2] || null) : (_ = f.split(`:`),
      d = _.shift(),
      _.length && (m = _.join(`:`))),
      m !== null && m.length > 0) {
          if (p = parseInt(m, 10),
          !/^[0-9]+$/.test(m) || p <= 0 || p > 65535)
              return !1
      } else if (t.require_port)
          return !1;
      return t.host_whitelist ? (0,
      r.default)(d, t.host_whitelist) : d === `` && !t.require_host ? !0 : !(!(0,
      o.default)(d) && !(0,
      a.default)(d, t) && (!ee || !(0,
      o.default)(ee, 6)) || (d ||= ee,
      t.host_blacklist && (0,
      r.default)(d, t.host_blacklist)))
  }
  t.exports = e.default,
  t.exports.default = e.default
}
));
function fv(e, t) {
  return typeof e == `string` && (0,
  pv.default)(e, t)
}
var pv, Nae = t(( () => {
  pv = e(Mae())
}
)), Pae = t(( () => {}
)), Fae = t(( () => {}
)), Iae = t(( () => {}
)), Lae = t(( () => {}
)), Rae = t(( () => {}
)), zae = t(( () => {}
)), Bae = t(( () => {}
)), Vae = t(( () => {}
)), Hae = t(( () => {}
)), Uae = t(( () => {}
)), Wae = t(( () => {}
)), Gae = t(( () => {}
)), Kae = t(( () => {}
)), qae = t(( () => {}
)), Jae = t(( () => {}
)), Yae = t(( () => {}
)), Xae = t(( () => {}
)), Zae = t(( () => {}
)), Qae = t(( () => {}
)), $ae = t(( () => {}
)), eoe = t(( () => {}
)), toe = t(( () => {}
)), noe = t(( () => {}
)), roe = t(( () => {}
)), ioe = t(( () => {}
)), aoe = t(( () => {}
)), ooe = t(( () => {}
)), soe = t(( () => {}
)), coe = t(( () => {}
)), loe = t(( () => {}
)), uoe = t(( () => {}
)), doe = t(( () => {}
)), foe = t(( () => {}
)), poe = t(( () => {}
)), moe = t(( () => {}
)), hoe = t(( () => {}
)), goe = t(( () => {}
)), _oe = t(( () => {}
)), voe = t(( () => {}
)), yoe = t(( () => {}
)), boe = t(( () => {}
)), xoe = t(( () => {}
)), Soe = t(( () => {}
)), Coe = t(( () => {}
)), woe = t(( () => {}
)), Toe = t(( () => {}
)), Eoe = t(( () => {}
)), Doe = t(( () => {}
)), Ooe = t(( () => {}
)), koe = t(( () => {}
)), Aoe = t(( () => {}
)), joe = t(( () => {}
)), Moe = t(( () => {}
)), Noe = t(( () => {}
)), Poe = t(( () => {
  Cie(),
  Die(),
  Oie(),
  kie(),
  Tie(),
  Aie(),
  jie(),
  Mie(),
  Pie(),
  Fie(),
  Iie(),
  Lie(),
  Rie(),
  zie(),
  Bie(),
  Vie(),
  Hie(),
  Uie(),
  Wie(),
  Gie(),
  Kie(),
  qie(),
  Jie(),
  Yie(),
  Xie(),
  Zie(),
  Qie(),
  $ie(),
  eae(),
  tae(),
  nae(),
  rae(),
  iae(),
  aae(),
  lae(),
  uae(),
  dae(),
  fae(),
  pae(),
  mae(),
  hae(),
  _ae(),
  vae(),
  yae(),
  bae(),
  xae(),
  Sae(),
  Cae(),
  wae(),
  Tae(),
  Eae(),
  Dae(),
  Oae(),
  kae(),
  Aae(),
  jae(),
  Nae(),
  Pae(),
  Fae(),
  Iae(),
  Lae(),
  Rae(),
  zae(),
  Bae(),
  Vae(),
  Hae(),
  Uae(),
  Wae(),
  Gae(),
  Kae(),
  qae(),
  Jae(),
  Yae(),
  Xae(),
  Zae(),
  Qae(),
  $ae(),
  eoe(),
  toe(),
  noe(),
  roe(),
  ioe(),
  aoe(),
  ooe(),
  soe(),
  coe(),
  loe(),
  uoe(),
  doe(),
  foe(),
  poe(),
  moe(),
  hoe(),
  goe(),
  _oe(),
  voe(),
  yoe(),
  boe(),
  xoe(),
  Soe(),
  Coe(),
  woe(),
  Toe(),
  Eoe(),
  Doe(),
  Ooe(),
  koe(),
  Aoe(),
  joe(),
  Moe(),
  Noe()
}
)), Foe = t(( () => {}
)), Ioe = t(( () => {}
)), Loe = t(( () => {}
)), Roe = t(( () => {}
)), mv = t(( () => {
  Sie(),
  Poe(),
  gae(),
  Foe(),
  tv(),
  Ioe(),
  Loe(),
  rv(),
  xie(),
  Roe(),
  wie(),
  $_()
}
)), hv, gv = t(( () => {
  pn(),
  mv(),
  ml(),
  Gp(),
  hv = class e {
      static SKIP = Symbol();
      static async replacePattern(t, n, r={}) {
          let i = []
            , a = !1
            , {schema: o=dl, skipCode: s=!0, skipLinks: c=!1} = r
            , l = n.map(e => ({
              ...e,
              pattern: e.pattern.global ? e.pattern : new RegExp(e.pattern.source,`g`)
          }))
            , u = [];
          if (t.content.forEach(e => u.push(e)),
          u.length === 0)
              return t;
          for (let t of u) {
              let n = !1;
              if (s && (o.marks.code.isInSet(t.marks) || t.type === o.nodes.code_block)) {
                  i.push(t);
                  continue
              }
              if (o.marks.link.isInSet(t.marks) && (c === !0 || c === `urlOnly` && fv(t.text || ``))) {
                  i.push(t);
                  continue
              }
              if (!t.isText) {
                  i.push(await this.replacePattern(t, l, r));
                  continue
              }
              let {text: u=``} = t;
              for (let r of l) {
                  r.pattern.lastIndex = 0;
                  let s = r.pattern.exec(u), c;
                  for (; s && (c = await r.matchFn(s, o),
                  !c); )
                      s = r.pattern.exec(u);
                  if (!c || !s)
                      continue;
                  let l = s[0]
                    , d = s[1] ?? l
                    , f = l.indexOf(d)
                    , p = s.index + f
                    , m = p + d.length;
                  if (c === e.SKIP || c.isText && c.marks.length === 0) {
                      i.push(o.text(`${t.textBetween(0, p)}${c === e.SKIP ? `` : c.text}${t.textBetween(m, t.nodeSize)}`, t.marks)),
                      a = !0,
                      n = !0;
                      break
                  }
                  p > 0 && i.push(t.cut(0, p)),
                  i.push(c),
                  a = !0,
                  n = !0,
                  m < t.nodeSize && i.push(t.cut(m));
                  break
              }
              n || i.push(t)
          }
          let d = t.copy(on.fromArray(i));
          return a ? this.replacePattern(d, l, r) : d
      }
      static async replaceNodeWhen(e, t, n) {
          let r = []
            , i = [];
          e.content.forEach(e => i.push(e));
          for (let e of i)
              if (t(e)) {
                  let t = await n(e)
                    , i = Array.isArray(t) ? t : t ? [t] : [];
                  r.push(...i)
              } else
                  e.childCount > 0 ? r.push(await this.replaceNodeWhen(e, t, n)) : r.push(e);
          return e.copy(on.fromArray(r))
      }
      static replaceNodeWhenSync(e, t, n) {
          let r = []
            , i = [];
          e.content.forEach(e => i.push(e));
          for (let e of i)
              if (t(e)) {
                  let t = n(e)
                    , i = Array.isArray(t) ? t : t ? [t] : [];
                  r.push(...i)
              } else
                  e.childCount > 0 ? r.push(this.replaceNodeWhenSync(e, t, n)) : r.push(e);
          return e.copy(on.fromArray(r))
      }
      static getAssetsUrlsFromProsemirrorData(t) {
          let n = [];
          return t?.forEach(t => {
              let r = t.content;
              if (t.type !== `image`) {
                  (r?.length ?? !1) && n.push(...e.getAssetsUrlsFromProsemirrorData(r));
                  return
              }
              let i = t.attrs?.src;
              i && n.push(i)
          }
          ),
          n
      }
      static getMediaMetadataIdsFromProsemirrorData(t) {
          let n = [];
          return t?.forEach(t => {
              let r = t.content;
              if (t.type !== `image` && t.type !== `video` && t.type !== `audio`) {
                  (r?.length ?? !1) && n.push(...e.getMediaMetadataIdsFromProsemirrorData(r));
                  return
              }
              let i = t.attrs?.metadataId;
              i && n.push(i)
          }
          ),
          n
      }
      static removeEmptyPlaceholders(e) {
          let t = e.filter(e => !this.isPlaceholderNode(e));
          for (let e of t)
              e.content &&= this.removeEmptyPlaceholders(e.content);
          return t
      }
      static isPlaceholderNode = e => !!e && e.type === `text` && !!e.marks?.find(e => e.type === `placeholder`);
      static appendContent(e, t) {
          let n = e.content || []
            , r = t.content || [];
          if (n.length === 0)
              return {
                  type: `doc`,
                  content: r
              };
          let i = n[n.length - 1]
            , a = r[0];
          return {
              type: `doc`,
              content: [...n.slice(0, -1), ...i?.type === `paragraph` && a?.type === `paragraph` ? [{
                  type: `paragraph`,
                  content: [...i.content || [], ...a.content || []]
              }, ...r.slice(1)] : [...n.slice(-1), ...r]]
          }
      }
      static dataForClipboard(e) {
          let t = Iee.fromSchema(e.schema).serializeFragment(e.doc.content)
            , n = document.createElement(`div`);
          n.appendChild(t);
          let r = n.innerHTML;
          return {
              text: e.doc.textContent,
              html: r,
              markdown: Hp.serialize(e.doc)
          }
      }
      static flattenNestedStructures(e) {
          let t = [];
          for (let n of e)
              if ((n.type === `blockquote` || n.type === `collapsible_section` || n.type === `code_block`) && n.content) {
                  let e = this.flattenNestedStructures(n.content);
                  t.push(...e)
              } else if (n.type === `paragraph` && n.content) {
                  let e = this.flattenNestedStructures(n.content);
                  t.push(...e)
              } else if ((n.content || []).length) {
                  let e = this.flattenNestedStructures(n.content);
                  t.push(...e)
              } else
                  t.push(n);
          return t
      }
      static hasMatchingNode(e, t) {
          let n = Array.isArray(t) ? t : [t];
          return n.includes(e.type) ? !0 : e.content ? e.content.some(e => this.hasMatchingNode(e, n)) : !1
      }
  }
}
));
function _v(e) {
  if (!e)
      return;
  let t = hv.replaceNodeWhenSync(dl.nodeFromJSON(e), e => e.type.name === `entityMention` || e.type.name === `issueMention` || e.type.name === `suggestion_userMentions`, e => {
      if (e.type.name === `suggestion_userMentions`)
          return dl.text(yv(`user`, e.attrs.id, e.attrs.label));
      let t = U_.getModelMetadataByAttributes(e.attrs);
      return t ? dl.text(yv(t.type, e.attrs.id, e.attrs.label)) : dl.text(e.attrs.label)
  }
  );
  return Hp.serialize(t)
}
var vv, yv, bv = t(( () => {
  vv = e(ae(), 1),
  ml(),
  Gp(),
  W_(),
  gv(),
  yv = (e, t, n) => (e = (0,
  vv.default)(e),
  n ? `<${e} id="${t}">${n}</${e}>` : `<${e} id="${t}" />`)
}
)), xv, Sv, Cv, wv = t(( () => {
  xv = e(le(), 1),
  Sv = e(d(), 1),
  Ns(),
  (function(e) {
      e.natural = (e, t) => e.slice().sort( (e, n) => {
          let r = (0,
          Sv.default)(t) ? t(e) : e[t]
            , i = (0,
          Sv.default)(t) ? t(n) : n[t];
          if (typeof r == `string` && typeof i == `string`)
              return r.localeCompare(i, void 0, {
                  ignorePunctuation: !0
              });
          throw Error(`Cannot sort by property ` + String(t) + ` of type ` + typeof r)
      }
      ),
      e.normalizeString = e => (0,
      xv.default)(e.normalize(`NFKD`).replace(Ms(), ``))
  }
  )(Cv ||= {})
}
)), Tv, Ev = t(( () => {
  Tv = class e {
      static #e = this.colors = {
          lightGrey: {
              label: `Grey`,
              color: `#bec2c8`
          },
          darkGrey: {
              label: `Dark Grey`,
              color: `#95a2b3`
          },
          controlPrimary: {
              label: `Purple`,
              color: `#5e6ad2`
          },
          tealBase: {
              label: `Teal`,
              color: `#26b5ce`
          },
          greenBase: {
              label: `Green`,
              color: `#4cb782`
          },
          yellowBase: {
              label: `Yellow`,
              color: `#f2c94c`
          },
          orangeBase: {
              label: `Orange`,
              color: `#f2994a`
          },
          redBg: {
              label: `Pink`,
              color: `#f7c8c1`
          },
          redBase: {
              label: `Red`,
              color: `#eb5757`
          }
      };
      static #t = this.colorValues = Object.values(e.colors);
      static #n = this.colorsList = e.colorValues.map(e => e.color);
      static #r = this.defaultTeamIconColor = e.colors.lightGrey.color;
      static #i = this.defaultTeamIconBackground = e.colorsList[0]
  }
}
)), Dv, Ov, kv, Av = t(( () => {
  Dv = e(a(), 1),
  Ov = class {
      static #e = this.minLabelLength = 1;
      static #t = this.maxLabelLength = 80;
      static #n = this.maxDescriptionLength = 255;
      static #r = this.labelNamesMatch = (...e) => (0,
      Dv.default)(e.map(e => e.toLowerCase())).length === 1
  }
  ,
  kv = function(e) {
      return e.Root = `root`,
      e.Group = `group`,
      e.Child = `child`,
      e
  }({})
}
)), jv, Mv, Nv, Pv = t(( () => {
  jv = function(e) {
      return e.maxTeams = `max-teams`,
      e.maxWorkflowStatesPerTeam = `max-workflow-states-per-team`,
      e.maxProjectUpdatesPerProject = `max-project-updates-per-project`,
      e.maxProjectStatusesPerOrganization = `max-project-statuses-per-organization`,
      e.maxInitiativeUpdatesPerInitiative = `max-initiative-updates-per-initiative`,
      e.maxMilestonesPerProject = `max-milestones-per-project`,
      e.maxInitiativesPerOrganization = `max-initiatives-per-organization`,
      e.maxSubTeamsPerParentTeam = `max-sub-teams-per-parent-team`,
      e.maxCustomViewsPerProject = `max-custom-views-per-project`,
      e.maxCustomViewsPerInitiative = `max-custom-views-per-initiative`,
      e.maxCustomViewsPerTeam = `max-custom-views-per-team`,
      e.maxCustomViewsPerOrganization = `max-custom-views-per-organization`,
      e.maxPrivateCustomViewsPerUser = `max-private-custom-views-per-user`,
      e.maxEntityExternalLinksPerProject = `max-entity-external-links-per-project`,
      e.maxEntityExternalLinksPerInitiative = `max-entity-external-links-per-initiative`,
      e.maxEntityExternalLinksPerTeam = `max-entity-external-links-per-team`,
      e.maxFacetsPerProject = `max-facets-per-project`,
      e.maxFacetsPerInitiative = `max-facets-per-initiative`,
      e.maxFacetsPerTeam = `max-facets-per-team`,
      e.maxFeedFacetsPerUser = `max-feed-facets-per-user`,
      e.maxFacetsPerWorkspace = `max-facets-per-workspace`,
      e.maxResourceFoldersPerProject = `max-resource-folders-per-project`,
      e.maxResourceFoldersPerInitiative = `max-resource-folders-per-initiative`,
      e.maxResourceFoldersPerTeam = `max-resource-folders-per-team`,
      e.maxCustomersPerOrganization = `max-customers-per-organization`,
      e.maxEmailIntakeAddressesPerOrganization = `max-email-intake-addresses-per-organization`,
      e.maxSLAWorkflowsPerOrganization = `max-sla-workflows-per-organization`,
      e.maxTriageRuleWorkflowsPerOrganization = `max-triage-rule-workflows-per-organization`,
      e.maxDraftsPerUser = `max-drafts-per-user`,
      e.maxIssueDraftsPerUser = `max-issue-drafts-per-user`,
      e.maxIssuesPerTeam = `max-issues-per-team`,
      e.maxIssueTemplatesPerTeam = `max-issue-templates-per-team`,
      e.maxRecurringIssuesPerTeam = `max-recurring-issues-per-team`,
      e.maxProjectTemplatesPerTeam = `max-project-templates-per-team`,
      e.maxDocumentTemplatesPerTeam = `max-document-templates-per-team`,
      e.maxCustomerNeedsPerIssue = `max-customer-needs-per-issue`,
      e.maxCustomerNeedsPerProject = `max-customer-needs-per-project`,
      e.maxCustomerStatusesPerOrganization = `max-customer-statuses-per-organization`,
      e.maxCustomerTiersPerOrganization = `max-customer-tiers-per-organization`,
      e.maxFavoritesPerUser = `max-favorites-per-user`,
      e.maxDocumentsPerProject = `max-documents-per-project`,
      e.maxDocumentsPerInitiative = `max-documents-per-initiative`,
      e.maxDocumentsPerTeam = `max-documents-per-team`,
      e.maxDocumentsPerIssue = `max-documents-per-issue`,
      e.maxPrivateTeamMembershipsPerUser = `max-private-team-memberships-per-user`,
      e.maxPublicTeamMembershipsPerUser = `max-public-team-memberships-per-user`,
      e.maxCommentsPerUpdate = `max-comments-per-update`,
      e.maxCommentsPerPost = `max-comments-per-post`,
      e.maxCommentsPerDocumentContent = `max-comments-per-document-content`,
      e.maxCommentsPerIssue = `max-comments-per-issue`,
      e.maxCommentsPerPullRequest = `max-comments-per-pull-request`,
      e.maxProjectsPerTeam = `max-projects-per-team`,
      e.maxEmojisPerOrganization = `max-emojis-per-organization`,
      e.maxOrganizationInvitesForRestrictedDomainsPerOrganizationPerDay = `max-organization-invites-for-restricted-domains-per-organization-per-day`,
      e.maxOrganizationInvitesPerOrganizationPerDay = `max-organization-invites-per-organization-per-day`,
      e.maxOrganizationInvitesPerOrganization = `max-organization-invites-per-organization`,
      e.maxExternalUsersPerOrganization = `max-external-users-per-organization`,
      e.maxUsersPerOrganization = `max-users-per-organization`,
      e.maxTimeSchedulesPerOrganization = `max-time-schedules-per-organization`,
      e.maxExternalEntityRelationsForInitiative = `max-external-entity-relations-for-initiative`,
      e.maxExternalEntityRelationsForProject = `max-external-entity-relations-for-project`,
      e.maxExternalEntityRelationsForIssue = `max-external-entity-relations-for-issue`,
      e.maxPostsCreatedPerUser = `max-posts-created-per-user`,
      e.maxPostsCreatedPerTeam = `max-posts-created-per-team`,
      e.maxIssueLabelsPerOrganization = `max-issue-labels-per-organization`,
      e.maxIssueLabelsPerGroup = `max-issue-labels-per-label-group`,
      e.maxAttachmentsPerIssue = `max-attachments-per-issue`,
      e.maxAttachmentsPerProject = `max-attachments-per-project`,
      e.maxProjectLabelsPerOrganization = `max-project-labels-per-organization`,
      e.maxProjectLabelsPerGroup = `max-project-labels-per-label-group`,
      e.maxSubInitiativeNesting = `max-sub-initiative-nesting`,
      e.maxIdentityProviders = `max-identity-providers`,
      e.maxActiveBatchOperationsPerUser = `max-active-batch-operations-per-user`,
      e.maxIssuesPerBatchOperation = `max-issues-per-batch-operation`,
      e
  }({}),
  Mv = {
      [jv.maxTeams]: {
          limit: 1e3,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} teams.`
      },
      [jv.maxWorkflowStatesPerTeam]: {
          limit: 50,
          userReadableErrorMessage: `Your team workspace can have a maximum of {limit} issue statuses.`
      },
      [jv.maxProjectUpdatesPerProject]: {
          limit: 1e3,
          userReadableErrorMessage: `Your project can have a maximum of {limit} updates.`
      },
      [jv.maxProjectStatusesPerOrganization]: {
          limit: 500,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} project statuses.`
      },
      [jv.maxInitiativeUpdatesPerInitiative]: {
          limit: 1e3,
          userReadableErrorMessage: `Your initiative can have a maximum of {limit} updates.`
      },
      [jv.maxMilestonesPerProject]: {
          limit: 200,
          userReadableErrorMessage: `Your project can have a maximum of {limit} milestones.`
      },
      [jv.maxInitiativesPerOrganization]: {
          limit: 1e3,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} initiatives.`
      },
      [jv.maxSubTeamsPerParentTeam]: {
          limit: 20,
          userReadableErrorMessage: `A parent team can have a maximum of {limit} sub-teams.`
      },
      [jv.maxCustomViewsPerOrganization]: {
          limit: 2500,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} views.`
      },
      [jv.maxPrivateCustomViewsPerUser]: {
          limit: 300,
          userReadableErrorMessage: `You can have a maximum of {limit} private views.`
      },
      [jv.maxCustomViewsPerProject]: {
          limit: 1e3,
          userReadableErrorMessage: `Your project can have a maximum of {limit} views.`
      },
      [jv.maxCustomViewsPerTeam]: {
          limit: 1e3,
          userReadableErrorMessage: `Your team can have a maximum of {limit} views.`
      },
      [jv.maxCustomViewsPerInitiative]: {
          limit: 1e3,
          userReadableErrorMessage: `Your initiative can have a maximum of {limit} views.`
      },
      [jv.maxProjectTemplatesPerTeam]: {
          limit: 500,
          userReadableErrorMessage: `You can have a maximum of {limit} project templates per team or at the workspace level.`
      },
      [jv.maxDocumentTemplatesPerTeam]: {
          limit: 500,
          userReadableErrorMessage: `You can have a maximum of {limit} document templates per team or at the workspace level.`
      },
      [jv.maxIssueTemplatesPerTeam]: {
          limit: 500,
          userReadableErrorMessage: `You can have a maximum of {limit} issue templates per team or at the workspace level.`
      },
      [jv.maxRecurringIssuesPerTeam]: {
          limit: 200,
          userReadableErrorMessage: `Your team can have a maximum of {limit} recurring issues.`
      },
      [jv.maxEntityExternalLinksPerProject]: {
          limit: 1e3,
          userReadableErrorMessage: `Your project can have a maximum of {limit} entity external links.`
      },
      [jv.maxEntityExternalLinksPerInitiative]: {
          limit: 1e3,
          userReadableErrorMessage: `Your initiative can have a maximum of {limit} entity external links.`
      },
      [jv.maxEntityExternalLinksPerTeam]: {
          limit: 1e3,
          userReadableErrorMessage: `Your team can have a maximum of {limit} entity external links.`
      },
      [jv.maxFeedFacetsPerUser]: {
          limit: 100,
          userReadableErrorMessage: `You can have a maximum of {limit} Pulse feed facets.`
      },
      [jv.maxFacetsPerProject]: {
          limit: 1e3,
          userReadableErrorMessage: `Your project can have a maximum of {limit} views.`
      },
      [jv.maxFacetsPerInitiative]: {
          limit: 1e3,
          userReadableErrorMessage: `Your initiative can have a maximum of {limit} views.`
      },
      [jv.maxFacetsPerTeam]: {
          limit: 1e3,
          userReadableErrorMessage: `Your team can have a maximum of {limit} views.`
      },
      [jv.maxFacetsPerWorkspace]: {
          limit: 1e3,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} workspace-level views.`
      },
      [jv.maxResourceFoldersPerProject]: {
          limit: 1e3,
          userReadableErrorMessage: `Your project can have a maximum of {limit} resource folders.`
      },
      [jv.maxResourceFoldersPerInitiative]: {
          limit: 1e3,
          userReadableErrorMessage: `Your initiative can have a maximum of {limit} resource folders.`
      },
      [jv.maxResourceFoldersPerTeam]: {
          limit: 1e3,
          userReadableErrorMessage: `Your team can have a maximum of {limit} resource folders.`
      },
      [jv.maxCustomersPerOrganization]: {
          limit: 1e5,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} customers.`
      },
      [jv.maxEmailIntakeAddressesPerOrganization]: {
          limit: 1e3,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} email intake addresses.`
      },
      [jv.maxSLAWorkflowsPerOrganization]: {
          limit: 1e3,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} SLA rules.`
      },
      [jv.maxTriageRuleWorkflowsPerOrganization]: {
          limit: 1e3,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} Triage rules.`
      },
      [jv.maxDraftsPerUser]: {
          limit: 2e3,
          userReadableErrorMessage: `You can have a maximum of {limit} drafts.`
      },
      [jv.maxIssueDraftsPerUser]: {
          limit: 2e3,
          userReadableErrorMessage: `You can have a maximum of {limit} issue drafts.`
      },
      [jv.maxIssuesPerTeam]: {
          limit: 6e4,
          userReadableErrorMessage: `Your team can have a maximum of {limit} issues.`
      },
      [jv.maxCustomerNeedsPerIssue]: {
          limit: 1e3,
          userReadableErrorMessage: `An issue can have a maximum of {limit} customer needs.`
      },
      [jv.maxCustomerNeedsPerProject]: {
          limit: 5e3,
          userReadableErrorMessage: `A project can have a maximum of {limit} customer needs.`
      },
      [jv.maxCustomerStatusesPerOrganization]: {
          limit: 50,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} customer statuses.`
      },
      [jv.maxCustomerTiersPerOrganization]: {
          limit: 50,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} customer tiers.`
      },
      [jv.maxFavoritesPerUser]: {
          limit: 2e3,
          userReadableErrorMessage: `You can have a maximum of {limit} favorites.`
      },
      [jv.maxDocumentsPerProject]: {
          limit: 1e3,
          userReadableErrorMessage: `Your project can have a maximum of {limit} documents.`
      },
      [jv.maxDocumentsPerInitiative]: {
          limit: 1e3,
          userReadableErrorMessage: `Your initiative can have a maximum of {limit} documents.`
      },
      [jv.maxDocumentsPerTeam]: {
          limit: 1e3,
          userReadableErrorMessage: `Your team can have a maximum of {limit} documents.`
      },
      [jv.maxDocumentsPerIssue]: {
          limit: 1e3,
          userReadableErrorMessage: `Your issue can have a maximum of {limit} documents.`
      },
      [jv.maxPrivateTeamMembershipsPerUser]: {
          limit: 150,
          userReadableErrorMessage: `You can be a member of a maximum of {limit} private teams.`
      },
      [jv.maxPublicTeamMembershipsPerUser]: {
          limit: 500,
          userReadableErrorMessage: `You can be a member of a maximum of {limit} public teams.`
      },
      [jv.maxCommentsPerUpdate]: {
          limit: 2e3,
          userReadableErrorMessage: `An update can have a maximum of {limit} comments.`
      },
      [jv.maxCommentsPerPost]: {
          limit: 2e3,
          userReadableErrorMessage: `A post can have a maximum of {limit} comments.`
      },
      [jv.maxCommentsPerDocumentContent]: {
          limit: 2e3,
          userReadableErrorMessage: `A document content can have a maximum of {limit} comments.`
      },
      [jv.maxCommentsPerIssue]: {
          limit: 2e3,
          userReadableErrorMessage: `An issue can have a maximum of {limit} comments.`
      },
      [jv.maxCommentsPerPullRequest]: {
          limit: 2e3,
          userReadableErrorMessage: `A pull request can have a maximum of {limit} comments.`
      },
      [jv.maxProjectsPerTeam]: {
          limit: 5e3,
          userReadableErrorMessage: `Your teams can have a maximum of {limit} projects.`
      },
      [jv.maxEmojisPerOrganization]: {
          limit: 1e5,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} emojis.`
      },
      [jv.maxOrganizationInvitesForRestrictedDomainsPerOrganizationPerDay]: {
          limit: 100,
          userReadableErrorMessage: `You workspace can only have a maximum of {limit} pending invites to restricted email domains per day.`
      },
      [jv.maxOrganizationInvitesPerOrganizationPerDay]: {
          limit: 1e3,
          userReadableErrorMessage: `You workspace can only have a maximum of {limit} pending invites per day.`
      },
      [jv.maxOrganizationInvitesPerOrganization]: {
          limit: 2500,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} pending invites.`
      },
      [jv.maxExternalUsersPerOrganization]: {
          limit: 1e5,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} external users.`
      },
      [jv.maxUsersPerOrganization]: {
          limit: 2e4,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} users.`
      },
      [jv.maxTimeSchedulesPerOrganization]: {
          limit: 2e3,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} time schedules.`
      },
      [jv.maxExternalEntityRelationsForInitiative]: {
          limit: 400,
          userReadableErrorMessage: `An initiative can have a maximum of {limit} external entity relations.`
      },
      [jv.maxExternalEntityRelationsForProject]: {
          limit: 400,
          userReadableErrorMessage: `A project can have a maximum of {limit} external entity relations.`
      },
      [jv.maxExternalEntityRelationsForIssue]: {
          limit: 400,
          userReadableErrorMessage: `An issue can have a maximum of {limit} external entity relations.`
      },
      [jv.maxPostsCreatedPerUser]: {
          limit: 1e3,
          userReadableErrorMessage: `A user can have a maximum of {limit} updates.`
      },
      [jv.maxPostsCreatedPerTeam]: {
          limit: 1e3,
          userReadableErrorMessage: `Your team can create a maximum of {limit} updates.`
      },
      [jv.maxIssueLabelsPerOrganization]: {
          limit: 2e4,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} issue labels.`
      },
      [jv.maxIssueLabelsPerGroup]: {
          limit: 250,
          userReadableErrorMessage: `A label group can have a maximum of {limit} child labels.`
      },
      [jv.maxAttachmentsPerIssue]: {
          limit: 500,
          userReadableErrorMessage: `An issue can have a maximum of {limit} attachments.`
      },
      [jv.maxAttachmentsPerProject]: {
          limit: 2e3,
          userReadableErrorMessage: `A project can have a maximum of {limit} attachments.`
      },
      [jv.maxProjectLabelsPerOrganization]: {
          limit: 2e4,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} project labels.`
      },
      [jv.maxProjectLabelsPerGroup]: {
          limit: 250,
          userReadableErrorMessage: `A label group can have a maximum of {limit} child labels.`
      },
      [jv.maxSubInitiativeNesting]: {
          limit: 5,
          userReadableErrorMessage: `An initiative can have a maximum of {limit} levels of sub-initiatives.`
      },
      [jv.maxIdentityProviders]: {
          limit: 5,
          userReadableErrorMessage: `Your workspace can have a maximum of {limit} identity providers.`
      },
      [jv.maxActiveBatchOperationsPerUser]: {
          limit: 5,
          userReadableErrorMessage: `You can have a maximum of {limit} active bulk operations.`
      },
      [jv.maxIssuesPerBatchOperation]: {
          limit: 300,
          userReadableErrorMessage: `A bulk operation can have a maximum of {limit} issues.`
      }
  },
  Nv = class {
      static getLimit(e, t) {
          let n = Mv[t];
          return e.quotaOverrides?.[t] === void 0 ? n.limit : e.quotaOverrides[t]
      }
      static atLimit(e, t, n) {
          return n >= this.getLimit(e, t)
      }
      static getErrorMessage(e, t, n) {
          let r = this.getLimit(e, t)
            , i = n === `api` ? `${r}` : `<strong>${r}</strong>`
            , a = Mv[t].userReadableErrorMessage.replace(`{limit}`, i);
          return n === `api` ? `${a} This quota is enforced to keep the workspace performant. If you would want to increase the limit, please send a request to support@linear.app.` : `${a}<br/>This quota is enforced to keep the workspace performant.<br/>If you would want to increase the limit, please send a request to <strong>support@linear.app</strong>.`
      }
  }
}
)), Fv, Iv = t(( () => {
  Fv = function(e) {
      return e.labels = `labels`,
      e.assignee = `assignee`,
      e.delegate = `delegate`,
      e.state = `state`,
      e.team = `team`,
      e.priority = `priority`,
      e.project = `project`,
      e
  }({})
}
)), Lv, Rv, zv, Bv = t(( () => {
  Lv = function(e) {
      return e.created = `created`,
      e.inProgress = `inProgress`,
      e.finished = `finished`,
      e
  }({}),
  Rv = function(e) {
      return e.IssueSuggestions = `IssueSuggestions`,
      e.LabelMove = `LabelMove`,
      e.LabelMerge = `LabelMerge`,
      e
  }({}),
  zv = function(e) {
      return e.issueSuggestionsParameters = `issueSuggestionsParameters`,
      e.labelMoveParameters = `labelMoveParameters`,
      e.labelMergeParameters = `labelMergeParameters`,
      e
  }({})
}
)), Vv, Hv = t(( () => {
  Vv = function(e) {
      return e.allIssues = `allIssues`,
      e.activeIssues = `activeIssues`,
      e.activeCycle = `activeCycle`,
      e.upcomingCycle = `upcomingCycle`,
      e.backlog = `backlog`,
      e.triage = `triage`,
      e.cycles = `cycles`,
      e.views = `views`,
      e.projects = `projects`,
      e
  }({})
}
)), Uv, Wv = t(( () => {
  Xs(),
  (function(e) {
      e.SLACK_BOT_ID = `USLACKBOT`;
      let t = e.SLACK_DM_CHANNEL_NAME = `directmessage`;
      e.SLACK_PRIVATE_CHANNEL_NAME = `privategroup`;
      let n = e.AttachmentLinkIntegrations = [T.discord, T.front, T.intercom, T.zendesk, T.slack, T.slackAsks, T.github, T.gitlab, T.jira, T.salesforce];
      e.isAttachmentLinkIntegration = e => n.includes(e),
      e.findIntegrationMatches = (e, t, d) => {
          let p = t || n, m;
          for (let t of p)
              switch (t) {
              case T.slack:
              case T.slackAsks:
                  let n = r.parseMessageUrl(e);
                  n && (m = {
                      match: n,
                      integrationType: t
                  });
                  break;
              case T.discord:
                  let p = o.parseMessageUrl(e);
                  p && (m = {
                      match: p,
                      integrationType: t
                  });
                  break;
              case T.front:
                  let h = s.parseTicketUrl(e);
                  h && (m = {
                      match: h,
                      integrationType: t
                  });
                  break;
              case T.intercom:
                  let g = c.parseConversationUrl(e);
                  g && (m = {
                      match: g,
                      integrationType: t
                  });
                  break;
              case T.zendesk:
                  let _ = i.parseTicketUrl(e);
                  _ && (m = {
                      match: _,
                      integrationType: t
                  });
                  break;
              case T.github:
                  let ee = l.parsePullRequestUrl(e, {
                      strict: !0
                  });
                  ee && (m = {
                      match: ee,
                      type: `pr`,
                      integrationType: t
                  });
                  let te = l.parseIssueUrl(e, {
                      strict: !0
                  });
                  te && (m = {
                      match: te,
                      type: `issue`,
                      integrationType: t
                  });
                  break;
              case T.gitlab:
                  let ne = u.parseMergeRequestUrl(e, d?.gitlab);
                  ne && (m = {
                      match: ne,
                      integrationType: t
                  });
                  break;
              case T.jira:
                  let re = f.parseIssueUrl(e);
                  re && (m = {
                      match: re,
                      integrationType: t
                  });
                  break;
              case T.salesforce:
                  let ie = a.parseCaseUrl(e);
                  ie && (m = {
                      match: ie,
                      integrationType: t
                  });
                  break;
              default:
                  break
              }
          return m
      }
      ;
      let r;
      (function(e) {
          e.channelNameToDisplay = e => n(e) ? `#${e}` : e === t ? `Direct message` : `Private channel`;
          let n = e.isPublicChannel = e => e !== `directmessage` && e !== `privategroup`;
          e.getChannelUrlFromMetadata = ({slackChannelId: e, slackTeamId: t}) => {
              if (!(!e || !t))
                  return `https://app.slack.com/client/${t}/${e}`
          }
          ;
          let r = e.slackMessageUrlRegexp = /^(?<baseChannelUrl>(?:(https|http):\/\/)?[-\w\d]+\.slack\.com\/[\w]+\/(?<channel>[-\w\d]+)\/)(?<latest>[-\w\d]+)[?]?(thread_ts=(?<ts>[\d.]+))?[&]?(cid=(?<cid>[\d\w]+))?$/i;
          function i(e) {
              let t = r.exec(e);
              if (!t)
                  return;
              let n = t.groups?.baseChannelUrl;
              if (!n)
                  return;
              let i = t.groups?.channel;
              if (!i)
                  return;
              let a = t.groups?.latest.slice(1);
              if (a)
                  return {
                      baseChannelUrl: n,
                      channel: i,
                      latest: `${a.substring(0, a.length - 6)}.${a.substring(a.length - 6)}`,
                      ts: t.groups?.ts
                  }
          }
          e.parseMessageUrl = i
      }
      )(r ||= e.Slack ||= {});
      let i;
      (function(e) {
          let t = e.subdomainRegexp = RegExp(`^(?:https\\:\\/\\/)?([\\w\\-\\_]+).zendesk.com`, `i`)
            , n = e.ticketUrlRegexp = RegExp(`(?:\\/agent)?\\/tickets\\/(\\d+)|\\/tickets\\/(\\d+)`, `i`);
          function r(e) {
              let n = t.exec(e);
              if (n)
                  return n[1]
          }
          e.parseSubdomain = r;
          function i(e) {
              let t = n.exec(e);
              if (t)
                  return t[1]
          }
          e.parseTicketUrl = i
      }
      )(i ||= e.Zendesk ||= {});
      let a;
      (function(e) {
          let t = e.subdomainRegexp = RegExp(`^(?:https\\:\\/\\/)?([\\w\\-\\_\\.]+)\\.(?:my\\.salesforce\\.com|lightning\\.force\\.com|my\\.salesforce-setup\\.com)`, `i`);
          function n(e) {
              let n = t.exec(e);
              if (n)
                  return n[1]
          }
          e.parseSubdomain = n;
          let r = e.caseUrlRegexp = RegExp(`^(?:https\\:\\/\\/)?[\\w\\-\\_\\.]+\\.(?:my\\.salesforce\\.com|lightning\\.force\\.com)\\/lightning\\/r\\/Case\\/([a-zA-Z0-9]+.)\\/.+`, `i`);
          function i(e) {
              let t = r.exec(e);
              if (t)
                  return t[1]
          }
          e.parseCaseUrl = i
      }
      )(a ||= e.Salesforce ||= {});
      let o;
      (function(e) {
          let t = e.messageRegexp = /^(?:https:\/\/)?(?:[a-z\d]+\.)?discord(?:app)?\.com\/channels\/\d+\/(\d+)\/(\d+)$/i;
          function n(e) {
              let n = t.exec(e);
              if (n)
                  return [n[1], n[2]]
          }
          e.parseMessageUrl = n
      }
      )(o ||= e.Discord ||= {});
      let s;
      (function(e) {
          let t = e.ticketUrlRegexp = /^(?:https:\/\/)?app\.frontapp\.com\/open\/(msg_\w+|cnv_\w+)(\?.*)?$/i;
          function n(e) {
              let n = t.exec(e);
              if (n)
                  return n[1]
          }
          e.parseTicketUrl = n
      }
      )(s ||= e.Front ||= {});
      let c;
      (function(e) {
          let t = e.conversationUrlRegexp = /^(?:https:\/\/)?app(\.au|\.eu)?\.intercom\.com\/a\/(?:inbox|apps)\/.*\/conversations{0,1}\/(\d+)(?:[?#]part_id=)?(.*)?$/i;
          function n(e) {
              let n = t.exec(e);
              if (n)
                  return {
                      conversationId: n[2],
                      partId: n[3]
                  }
          }
          e.parseConversationUrl = n
      }
      )(c ||= e.Intercom ||= {});
      let l;
      (function(e) {
          let t = `github.com`
            , n = e.pullRequestUrlRegexp = (e=t) => RegExp(`^https://${e}/([^/]+)/([^/]+)/pull/(\\d+)/?`)
            , r = e.issueUrlRegexp = (e=t) => RegExp(`^https://${e}/([^/]+)/([^/]+)/issues/(\\d+)/?`);
          e.getGithubFullUrlName = e => Uv.GitHub.getGithubFullUrlMetadata(e)?.name,
          e.getGithubFullUrlMetadata = e => {
              let t = Uv.GitHub.parsePullRequestUrl(e);
              if (t?.number !== void 0)
                  return {
                      name: `${t.owner}/${t.repo}#${t.number}`,
                      type: `pull_request`
                  };
              let n = Uv.GitHub.parseIssueUrl(e);
              if (n?.number !== void 0)
                  return {
                      name: `${n.owner}/${n.repo}#${n.number}`,
                      type: `issue`
                  };
              let r = Uv.GitHub.parseReleaseUrl(e);
              if (r?.tag !== void 0)
                  return {
                      name: `${r.owner}/${r.repo} ${r.tag}`,
                      type: `release`
                  };
              let i = Uv.GitHub.parseRepositoryUrl(e);
              if (i?.repo !== void 0)
                  return {
                      name: `${i.owner}/${i.repo}`,
                      type: `repository`
                  }
          }
          ;
          function i(e, r) {
              let i = e.match(n(r?.domain ?? t));
              if (!(!i || r?.strict && i[0] !== e))
                  return {
                      owner: i[1],
                      repo: i[2],
                      number: Number(i[3])
                  }
          }
          e.parsePullRequestUrl = i;
          function a(e, n) {
              let i = e.match(r(n?.domain ?? t));
              if (!(!i || n?.strict && i[0] !== e))
                  return {
                      owner: i[1],
                      repo: i[2],
                      number: Number(i[3])
                  }
          }
          e.parseIssueUrl = a;
          let o = e.repositoryUrlRegexp = (e=t) => RegExp(`^https://${e}/([^/]+)/([^/]+)/?`);
          function s(e, n) {
              let r = e.match(o(n?.domain ?? t));
              if (r)
                  return {
                      owner: r[1],
                      repo: r[2]
                  }
          }
          e.parseRepositoryUrl = s;
          let c = e.releaseUrlRegexp = (e=t) => RegExp(`^https://${e}/([^/]+)/([^/]+)/releases/tag/([^/]+)/?`);
          function l(e, n) {
              let r = e.match(c(n?.domain ?? t));
              if (!r || n?.strict && r[0] !== e)
                  return;
              let i = r[1]
                , a = r[2]
                , o = r[3];
              return {
                  owner: i,
                  repo: a,
                  tag: decodeURIComponent(o)
              }
          }
          e.parseReleaseUrl = l;
          function u(e, t) {
              let n = new Map
                , r = new Map
                , i = [];
              for (let a of e) {
                  let e = a.settings?.gitHub;
                  if (!e)
                      continue;
                  let o = e.repositories ?? [];
                  for (let e of o)
                      r.set(e.id, e);
                  let s = e.repositoriesMapping ?? [];
                  for (let e of s)
                      e.linearTeamId === t.teamId && e.bidirectional && (i.push(e),
                      n.set(e.id, a.id))
              }
              if (i.length === 0)
                  return;
              let a = e => {
                  let t = r.get(e.gitHubRepoId);
                  if (t)
                      return {
                          integrationId: n.get(e.id),
                          destination: {
                              mapping: e,
                              repo: t
                          }
                      }
              }
                , o = new Set(t.labels.map(e => e.name))
                , s = i.map(e => ({
                  mapping: e,
                  matchingLabels: e.gitHubLabels?.filter(e => o.has(e)) ?? [],
                  hasLabelFilters: !!e.gitHubLabels?.length
              }));
              if (!s.some(e => e.hasLabelFilters))
                  return a((s.find(e => e.mapping.default) ?? s[0]).mapping);
              let c = s.filter(e => e.matchingLabels.length > 0).sort( (e, t) => t.matchingLabels.length - e.matchingLabels.length);
              if (c.length > 0)
                  return a(c[0].mapping);
              let l = s.find(e => e.mapping.default && !e.hasLabelFilters);
              if (l)
                  return a(l.mapping)
          }
          e.findOutgoingDestination = u
      }
      )(l ||= e.GitHub ||= {});
      let u;
      (function(e) {
          e.getGitlabFullUrlName = e => {
              let t = Uv.GitLab.getGitlabFullUrlMetadata(e);
              if (t?.name)
                  return t.name
          }
          ,
          e.getGitlabFullUrlMetadata = e => {
              let t = Uv.GitLab.parseMergeRequestUrl(e);
              if (t?.number !== void 0)
                  return {
                      name: `${t.projectPathWithNamespace}!${t.number}`,
                      type: `merge_request`
                  };
              let n = Uv.GitLab.parseTagUrl(e);
              if (n?.tag !== void 0)
                  return {
                      name: `${n.projectPathWithNamespace} ${n.tag}`,
                      type: `tag`
                  }
          }
          ;
          let t = e.mergeRequestUrlRegexp = e => RegExp(`^${e || `https://gitlab.com`}\/((?:[^\/]+\/)+)-\/merge_requests\/(\\d+)$\/?`, `i`);
          function n(e) {
              let t = e.split(`/`);
              return {
                  owner: t[0],
                  repo: t.slice(1).join(`/`)
              }
          }
          e.parseProjectPathName = n;
          function r(e, n) {
              let r = e.match(t(n));
              if (r)
                  return {
                      projectPathWithNamespace: r[1].replace(/\/$/, ``),
                      number: Number(r[2])
                  }
          }
          e.parseMergeRequestUrl = r;
          let i = e.tagUrlRegexp = e => RegExp(`^${e || `https://gitlab.com`}\/((?:[^\/]+\/)+)-\/tags\/([^\/]+)$\/?`, `i`);
          function a(e, t) {
              let n = e.match(i(t));
              if (!n)
                  return;
              let r = n[1].replace(/\/$/, ``)
                , a = n[2];
              return {
                  projectPathWithNamespace: r,
                  tag: decodeURIComponent(a)
              }
          }
          e.parseTagUrl = a
      }
      )(u ||= e.GitLab ||= {});
      let d;
      (function(e) {
          e.ALL_PUBLIC_CHANNELS_ID = `ALL_PUBLIC_CHANNELS_ID`,
          e.APP_HOME_ID = `APP_HOME_ID`,
          e.GENERAL_ASK_TEMPLATE_ID = `GENERAL_ASK_TEMPLATE_ID`,
          e.generateGeneralAskTemplateIdForTeamId = e => `${Uv.Asks.GENERAL_ASK_TEMPLATE_ID}${e}`
      }
      )(d ||= e.Asks ||= {});
      let f;
      (function(e) {
          let t = e.issueUrlRegexp = /(?!^https:\/\/.+atlassian.net\/wiki\/.*?$)^(https:\/\/.+atlassian.net.+\/)?([A-Z][A-Z0-9_]{1,}-[0-9]+)(.*)/;
          e.broadIssueUrlRegexp = /^(https:\/\/.+\/)?([A-Z][A-Z0-9_]{1,}-[0-9]+)(.*)/;
          function n(e) {
              let n = e.match(t);
              if (n)
                  return n[2]
          }
          e.parseIssueUrl = n
      }
      )(f ||= e.jira ||= {})
  }
  )(Uv ||= {})
}
)), Gv, Kv = t(( () => {
  Av(),
  Gv = class extends Ov {
      static #e = this.reservedLabels = [`assignee`, `cycle`, `effort`, `estimate`, `hours`, `priority`, `project`, `state`, `status`]
  }
}
)), qv, Jv = t(( () => {
  qv = function(e) {
      return e.workspace = `workspace`,
      e.teamHierarchy = `teamHierarchy`,
      e.team = `team`,
      e.none = `none`,
      e
  }({})
}
));
function Yv(e) {
  return Array.isArray(e)
}
var Xv = t(( () => {}
)), H, Zv = t(( () => {
  Xv(),
  H = function(e) {
      return e.adminAccess = `ad619acc-aaaa-4d84-ad23-61ddca8319a0`,
      e.privateTeamSettingsAccess = `a7f3e2d1-aaaa-4c8b-9a7f-3e2d1c8b9a7f`,
      e.fullMemberAccess = `cda201a7-aaaa-45c5-888b-3ce8b747d26b`,
      e.publicTeamsAccess = `b0b41c7e-aaaa-4c7d-a93d-cd9565da4358`,
      e.everyone = `e7e6104e-aaaa-42bc-9b8b-b91fcdd9946b`,
      e.customerEntityAccess = `cb3afc47-aaaa-4adb-b1ef-85c7a5751e33`,
      e.initiativeEntityAccess = `f7463355-aaaa-4ee0-89c3-40cd9f02f4e4`,
      e
  }({}),
  (function(e) {
      let t = Object.values(H).filter(e => typeof e == `string`);
      function n() {
          return t
      }
      e.all = n;
      function r(e) {
          return t.includes(e)
      }
      e.isConstant = r;
      function i(e) {
          return e === H.publicTeamsAccess
      }
      e.isPublicTeamsAccess = i;
      function a(e, t) {
          return e === t
      }
      e.equals = a;
      function o(e, t) {
          return Yv(e) ? e.includes(t) : e.has(t)
      }
      e.includes = o
  }
  )(H ||= {})
}
)), Qv, $v = t(( () => {
  Qv = class {
      static #e = this.minNameLength = 2;
      static #t = this.maxNameLength = 48;
      static #n = this.minKeyLength = 1;
      static #r = this.maxKeyLength = 7;
      static #i = this.validAutoClosePeriodValues = [1, 3, 6, 9, 12];
      static #a = this.defaultAutoClosePeriod = 6;
      static #o = this.validAutoArchivePeriodValues = [1, 3, 6, 9, 12];
      static #s = this.defaultAutoArchivePeriod = 3;
      static #c = this.AlphaNumericRegex = RegExp(`^[a-zA-Z0-9]+$`, `g`);
      static #l = this.maxNestingDepth = 1
  }
}
)), ey, ty = t(( () => {
  ey = function(e) {
      return e[e.hasIssueTemplates = 0] = `hasIssueTemplates`,
      e[e.hasProjectTemplates = 1] = `hasProjectTemplates`,
      e[e.hasDocumentTemplates = 2] = `hasDocumentTemplates`,
      e[e.hasRecurringIssueTemplates = 3] = `hasRecurringIssueTemplates`,
      e[e.hasDashboards = 4] = `hasDashboards`,
      e
  }({})
}
)), ny, ry, iy = t(( () => {
  ny = function(e) {
      return e.Project = `Project`,
      e.Initiative = `Initiative`,
      e.TeamPage = `TeamPage`,
      e.WorkspacePage = `WorkspacePage`,
      e.Feed = `Feed`,
      e.Unknown = `Unknown`,
      e
  }({}),
  ry = function(e) {
      return e.projects = `projects`,
      e.teamIssues = `teamIssues`,
      e.feed = `feed`,
      e
  }({})
}
)), ay, oy, sy = t(( () => {
  ay = function(e) {
      return e[e.info = 0] = `info`,
      e[e.success = 1] = `success`,
      e[e.warning = 2] = `warning`,
      e[e.error = 3] = `error`,
      e[e.tip = 4] = `tip`,
      e
  }({}),
  oy = class e {
      constructor(t, n, r, i) {
          if (!e.implementation)
              throw Error(`Toast implementation not registered. Call Toast.register() first.`);
          this.instance = new e.implementation(t,n,r,i)
      }
      show() {
          return this.instance.show()
      }
      static register(t) {
          e.implementation = t
      }
  }
}
)), cy, ly = t(( () => {
  Pv(),
  sy(),
  cy = class {
      static validateQuotaOrToast(e, t, n) {
          if (Nv.atLimit(e, t, n)) {
              let n = Nv.getErrorMessage(e, t, `client`);
              return new oy(ay.error,`Quota exceeded`,n).show(),
              !1
          }
          return !0
      }
      static getLimit(e, t) {
          return Nv.getLimit(e, t)
      }
      static atLimit(e, t, n) {
          return Nv.atLimit(e, t, n)
      }
  }
}
)), uy, zoe = t(( () => {
  uy = function(e) {
      return e[e.hasCustomerNeed = 0] = `hasCustomerNeed`,
      e
  }({})
}
)), dy, fy = t(( () => {
  dy = function(e) {
      return e[e.hasCustomerNeeds = 0] = `hasCustomerNeeds`,
      e[e.hasExternalEntityRelations = 1] = `hasExternalEntityRelations`,
      e[e.hasChildren = 2] = `hasChildren`,
      e[e.hasCreatedIssues = 3] = `hasCreatedIssues`,
      e[e.hasAgentSession = 4] = `hasAgentSession`,
      e[e.hasAiPromptProgresses = 5] = `hasAiPromptProgresses`,
      e[e.hasSpawnedAgentSessions = 6] = `hasSpawnedAgentSessions`,
      e
  }({})
}
)), py, my, hy = t(( () => {
  py = function(e) {
      return e[e.Linear = 0] = `Linear`,
      e[e.Slack = 1] = `Slack`,
      e
  }({}),
  my = function(e) {
      return e.cycle = `cycle`,
      e.default = `default`,
      e.labelGroupConflict = `labelGroupConflict`,
      e
  }({})
}
));
function gy(e) {
  if (e.isText)
      return e.textContent;
  {
      let t = [];
      return e.content.forEach(e => {
          t.push(e.textContent)
      }
      ),
      t.join(`
`)
  }
}
function Boe(e) {
  let t = [];
  for (let n of e.content) {
      if (n.type === `paragraph` && n.content?.length === 1) {
          let e = n.content[0];
          if (e.type === `text` && typeof e.text == `string` && e.marks === void 0) {
              t.push(e.text);
              continue
          }
      }
      return
  }
  return t
}
var _y = t(( () => {}
));
function vy(e, t={}) {
  let {text: n, tokens: r} = Voe(e, t.preserveCodeMarks)
    , i = n;
  return t.preserveCodeMarks && (i = i.replace(by.codeBlocks, "`$1`")),
  i = i.replace(by.escapedChars, `$1`).replace(by.blockquotesAndHeaders, ``).replace(by.lists, ``).replace(by.linksAndImages, `$1`).replace(by.bold, `$1`).replace(by.italic, `$1`).replace(by.strikethrough, `$1`).replace(by.newlines, ` `).replace(by.spaces, ` `).replace(by.codeBlocks, `$1`),
  i = Hoe(i, r, t.preserveCodeMarks),
  i = i.trim(),
  t.truncateLength ? (0,
  yy.default)(i, {
      length: t.truncateLength,
      omission: ``
  }) : i
}
function Voe(e, t=!1) {
  let n = {}
    , r = 1
    , i = e.replace(/`([^`\n]+)`/g, (e, i) => {
      let a = `$$CODEMARK${r++}`;
      return n[a] = i,
      t ? `\`${a}\`` : a
  }
  );
  return i = i.replace(by.codeBlocks, (e, i) => {
      let a = `$$CODEMARK${r++}`;
      return n[a] = i,
      t ? `\`\`\`\n${a}\n\`\`\`` : a
  }
  ),
  {
      text: i,
      tokens: n
  }
}
function Hoe(e, t, n=!1) {
  return e.replace(/\$\$CODEMARK\d+/g, e => t[e] ? n ? t[e].replace(/\n+/g, ` `).trim() : t[e] : e)
}
var yy, by, xy = t(( () => {
  yy = e(_e(), 1),
  by = {
      escapedChars: /\\([\\`*_{}[\]()<>#+=.!|\-])/g,
      blockquotesAndHeaders: /^(?:>|#+)\s+/gm,
      lists: /^(?:[-*+]\s+\[[ x]\]\s+|[-*+]\s+|\d+\.\s+)/gm,
      linksAndImages: /!?\[([^\]]+)\]\([^\)]+\)/g,
      bold: /\*\*(.+?)\*\*/g,
      italic: /[_*](.+?)[_*]/g,
      strikethrough: /~~(.+?)~~/g,
      newlines: /(?:\r\n|\r|\n)/g,
      spaces: /\s+/g,
      codeBlocks: /```[^\n]*\n([\s\S]*?)\n```/g
  }
}
)), Sy = t(( () => {
  Gp(),
  Fp()
}
)), Cy, wy = t(( () => {
  Cy = (e, t, n) => {
      let r = e => e.map(e => t(e) ? n(e) : `content`in e && Array.isArray(e.content) ? {
          ...e,
          content: r(e.content)
      } : e);
      return {
          ...e,
          content: r(e.content)
      }
  }
}
)), Ty, Ey, Dy, Oy = t(( () => {
  xy(),
  Sy(),
  wy(),
  Ty = (e, t) => {
      let n = Ey(e);
      return n = Cy(n, e => e.type === `suggestion_userMentions`, e => {
          let n = e.attrs
            , r = n?.id
            , i = n?.label;
          return r && i ? {
              ...e,
              attrs: {
                  ...e.attrs,
                  label: t.getDisplayUserLabel(r, i)
              }
          } : e
      }
      ),
      Dy(n, {
          truncateLength: t.truncateLength
      })
  }
  ,
  Ey = (e, t=3) => {
      let n = []
        , r = e.content.filter(e => ![`horizontal_rule`, `image_group`, `hard_break`, `iframe`, `unsupported_block_node`, `unsupported_inline_node`].includes(e.type)).slice(0, t)
        , i = r.findIndex(e => e.type !== `blockquote`);
      return (i > 0 ? r.slice(i) : r).forEach(e => {
          if (e.type === `collapsible_section`) {
              let t = Array.isArray(e.content) ? e.content.find(e => e.type === `collapsible_heading`) : void 0;
              t && Array.isArray(t.content) && n.push(...t.content)
          } else if (e.type === `table` || e.type === `video` || e.type === `audio` || e.type === `file` || e.type === `image` || e.type === `figma` || e.type === `embed`) {
              let t = e.attrs?.alt ?? e.attrs?.name ?? e.attrs?.title
                , r = typeof t == `string` ? t : void 0;
              n.push({
                  type: `paragraph`,
                  content: [{
                      type: `text`,
                      text: r ? `[${e.type}: ${r}]` : `[${e.type}]`
                  }]
              })
          } else
              n.push(e)
      }
      ),
      {
          ...e,
          content: n
      }
  }
  ,
  Dy = (e, t) => vy(Hp.serialize(e), {
      preserveCodeMarks: !0,
      ...t
  })
}
)), ky, Ay, jy, My, Ny, Py = t(( () => {
  ky = `80ch`,
  Ay = [`graphite-app`, `chatgpt-codex-connector[bot]`, `chatgpt-codex-connector`, `github-advanced-security`, `gitar-bot`],
  jy = {
      "graphite-app": `Graphite`,
      "chatgpt-codex-connector[bot]": `ChatGPT Codex`,
      "chatgpt-codex-connector": `ChatGPT Codex`,
      "github-advanced-security": `GitHub Advanced Security`,
      "gitar-bot": `Gitar`
  },
  My = {
      "graphite-app": `graphite`,
      "chatgpt-codex-connector[bot]": `codex`,
      "chatgpt-codex-connector": `codex`,
      "github-advanced-security": `github`,
      "gitar-bot": `gitar`
  },
  Ny = (e, t) => t ? jy[e] || e : My[e] || e
}
)), Fy, Iy = t(( () => {
  pu(),
  iU(),
  V(),
  F(),
  om(),
  Py(),
  N(),
  Fy = class extends qh {
      static #e = this.loadStrategy = rm.lazy;
      get effectiveDisplayName() {
          return Ny(this.name, !1) || this.displayName || this.name
      }
      get effectiveFullName() {
          return Ny(this.name, !0) || this.name
      }
      get initials() {
          return fu(this.name)
      }
      get firstName() {
          return this.name.split(` `).shift() || this.name
      }
  }
  ,
  M([R({
      default: ``
  })], Fy.prototype, `name`, void 0),
  M([R({
      default: ``
  })], Fy.prototype, `displayName`, void 0),
  M([L], Fy.prototype, `effectiveDisplayName`, null),
  M([L], Fy.prototype, `effectiveFullName`, null),
  M([R({
      default: ``
  })], Fy.prototype, `email`, void 0),
  M([R()], Fy.prototype, `avatarUrl`, void 0),
  M([B( () => q, `externalUsers`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], Fy.prototype, `organization`, void 0),
  M([R()], Fy.prototype, `atlassianAccountId`, void 0),
  M([R()], Fy.prototype, `gitHubUserId`, void 0),
  Fy = M([mg(`ExternalUser`)], Fy)
}
)), Ly, Ry = t(( () => {
  Iy(),
  GU(),
  Ly = class {
      static #e = this.getUsername = (e, t) => t instanceof J && t.isAgentAppUser ? t.name : t instanceof Fy ? e.showFullUserNames ? t.effectiveFullName : t.effectiveDisplayName : e.showFullUserNames ? t.name : t.displayName || t.name;
      static #t = this.getUserAltName = (e, t) => t instanceof J && t.isAgentAppUser ? t.displayName : t instanceof Fy ? e.showFullUserNames ? t.effectiveDisplayName : t.effectiveFullName : e.showFullUserNames ? t.displayName : t.name
  }
}
));
function zy(e) {
  if (e.type !== `doc`)
      return !1;
  if (e.content.length === 1) {
      let t = e.content[0];
      return t.type === `paragraph` && (t.content == null || t.content.length === 0)
  }
  return e.content.length === 0
}
function By(e) {
  if (e.type !== `doc`)
      return e;
  let t = [...e.content];
  return Vy(t),
  t.filter(e => e.type === `paragraph` && e.content && e.content.length > 0).forEach(e => Vy(e.content)),
  {
      ...e,
      content: t
  }
}
function Vy(e) {
  for (; e.length > 0 && Hy(e[0]); )
      e.shift();
  for (; e.length > 0 && Hy(e[e.length - 1]); )
      e.pop()
}
function Hy(e) {
  return e.type === `hard_break` ? !0 : e.type === `paragraph` ? !e.content || !Array.isArray(e.content) || e.content.length === 0 ? !0 : e.content.every(e => e.type === `hard_break` || e.type === `text` && e.text !== void 0 && /^\s*$/.test(e.text)) : !1
}
var Uy = t(( () => {}
)), Wy, Gy = t(( () => {
  Wy = class e {
      static get location() {
          return e.getLocation ? e.getLocation() : {
              pathname: `/`,
              search: ``,
              hash: ``,
              state: ``,
              key: ``
          }
      }
      static register(t) {
          e.getLocation = t
      }
  }
}
)), Ky, qy, Jy, Yy, Xy, Zy, Qy, $y = t(( () => {
  Xs(),
  Ky = class {
      static #e = this.maxNameLength = 25;
      static #t = this.maxDescriptionLength = 255;
      static getDefaultStatusColor() {
          return `#95A2B3`
      }
      static #n = this.defaultStatuses = [{
          name: `Active`,
          color: `#5E6AD2`,
          position: 0
      }, {
          name: `Prospect`,
          color: `#4CB782`,
          position: 1
      }, {
          name: `Churned`,
          color: `#EB5757`,
          position: 2
      }, {
          name: `Lost`,
          color: `#F2994A`,
          position: 3
      }]
  }
  ,
  qy = class {
      static #e = this.maxNameLength = 25;
      static #t = this.maxDescriptionLength = 255;
      static getDefaultTierColor() {
          return `#8A8F98`
      }
  }
  ,
  T.intercom,
  T.salesforce,
  Jy = [T.intercom, T.zendesk, T.front, T.salesforce],
  Yy = [T.salesforce, T.front, T.zendesk],
  Xy = (e, t={
      withSuffix: !0
  }) => {
      switch (e.revenueDisplay) {
      case `monthly`:
          return `Monthly` + (t.withSuffix ? ` revenue` : ``);
      case `annual`:
      default:
          return `Annual` + (t.withSuffix ? ` revenue` : ``)
      }
  }
  ,
  Zy = e => {
      switch (e.revenueDisplay) {
      case `monthly`:
          return `/mo`;
      case `annual`:
      default:
          return `/yr`
      }
  }
  ,
  Qy = (e, t) => {
      if (!t)
          return t;
      switch (e.revenueDisplay) {
      case `monthly`:
          return t * 12;
      case `annual`:
      default:
          return t
      }
  }
}
)), eb, Uoe = t(( () => {
  eb = function(e) {
      return e[e.hasArchivedCustomerNeeds = 0] = `hasArchivedCustomerNeeds`,
      e
  }({})
}
)), tb, nb = t(( () => {
  tb = function(e) {
      return e.stringType = `string`,
      e.numberType = `number`,
      e.booleanType = `boolean`,
      e.dateType = `date`,
      e
  }({})
}
)), rb, ib, ab = t(( () => {
  Xs(),
  (function(e) {
      function t(e) {
          if (!n(e))
              throw Error(`Templates are not supported for the ${e} integration`);
          switch (e) {
          case T.slackAsks:
              return Number.MAX_VALUE;
          default:
              return 10
          }
      }
      e.maxNumTemplatesPerIntegration = t;
      let n = e.isTemplateEnabledIntegration = e => Object.values(ib).includes(e);
      e.isPrivateTemplateEnabledIntegration = e => [T.slackAsks].includes(e),
      e.isWorkspaceTemplatesEnabledIntegration = e => [T.intercom, T.slack, T.zendesk, T.salesforce].includes(e)
  }
  )(rb ||= {}),
  ib = function(e) {
      return e[e.asks = T.slackAsks] = `asks`,
      e[e.intercom = T.intercom] = `intercom`,
      e[e.slack = T.slack] = `slack`,
      e[e.zendesk = T.zendesk] = `zendesk`,
      e[e.salesforce = T.salesforce] = `salesforce`,
      e
  }({})
}
)), ob, sb, cb, lb, ub, db, fb, pb, mb, hb, gb, _b, vb = t(( () => {
  ob = `____null____`,
  sb = `____any____`,
  cb = `__isMe__`,
  lb = `__isInvited__`,
  ub = `__isSuspended__`,
  db = `__isAppUser__`,
  fb = `__activeCycle__`,
  pb = `__inCooldown__`,
  mb = `__nextCycle__`,
  hb = `__previousCycle__`,
  gb = `__pastCycles__`,
  _b = `__futureCycles__`
}
)), yb, bb, xb, Sb, Cb, Woe = t(( () => {
  yb = class {
      static dbEntryToIssuesProgressHistoryEntry(e) {
          return {
              createdAt: new Date(e[this.propertyNameIndexMap.createdAt]),
              date: e[this.propertyNameIndexMap.date],
              scopeCount: e[this.propertyNameIndexMap.scopeCount],
              triageIssueCount: e[this.propertyNameIndexMap.triageIssueCount],
              backlogIssueCount: e[this.propertyNameIndexMap.backlogIssueCount],
              unstartedIssueCount: e[this.propertyNameIndexMap.unstartedIssueCount],
              startedIssueCount: e[this.propertyNameIndexMap.startedIssueCount],
              completedIssueCount: e[this.propertyNameIndexMap.completedIssueCount],
              cancelledIssueCount: e[this.propertyNameIndexMap.cancelledIssueCount],
              scopeEstimate: e[this.propertyNameIndexMap.scopeEstimate],
              triageEstimate: e[this.propertyNameIndexMap.triageEstimate],
              backlogEstimate: e[this.propertyNameIndexMap.backlogEstimate],
              unstartedEstimate: e[this.propertyNameIndexMap.unstartedEstimate],
              startedEstimate: e[this.propertyNameIndexMap.startedEstimate],
              completedEstimate: e[this.propertyNameIndexMap.completedEstimate],
              cancelledEstimate: e[this.propertyNameIndexMap.cancelledEstimate],
              completedEstimateToday: e[this.propertyNameIndexMap.completedEstimateToday],
              completedIssueCountToday: e[this.propertyNameIndexMap.completedIssueCountToday],
              addedEstimateToday: e[this.propertyNameIndexMap.addedEstimateToday],
              addedIssueCountToday: e[this.propertyNameIndexMap.addedIssueCountToday]
          }
      }
      static issuesProgressHistoryEntryToDBEntry(e) {
          let t = Array(Object.values(this.propertyNameIndexMap).length);
          return t[0] = this.VERSION,
          t[this.propertyNameIndexMap.createdAt] = e.createdAt,
          t[this.propertyNameIndexMap.date] = e.date,
          t[this.propertyNameIndexMap.scopeCount] = e.scopeCount || 0,
          t[this.propertyNameIndexMap.triageIssueCount] = e.triageIssueCount || 0,
          t[this.propertyNameIndexMap.backlogIssueCount] = e.backlogIssueCount || 0,
          t[this.propertyNameIndexMap.unstartedIssueCount] = e.unstartedIssueCount || 0,
          t[this.propertyNameIndexMap.startedIssueCount] = e.startedIssueCount || 0,
          t[this.propertyNameIndexMap.completedIssueCount] = e.completedIssueCount || 0,
          t[this.propertyNameIndexMap.cancelledIssueCount] = e.cancelledIssueCount || 0,
          t[this.propertyNameIndexMap.scopeEstimate] = e.scopeEstimate || 0,
          t[this.propertyNameIndexMap.triageEstimate] = e.triageEstimate || 0,
          t[this.propertyNameIndexMap.backlogEstimate] = e.backlogEstimate || 0,
          t[this.propertyNameIndexMap.unstartedEstimate] = e.unstartedEstimate || 0,
          t[this.propertyNameIndexMap.startedEstimate] = e.startedEstimate || 0,
          t[this.propertyNameIndexMap.completedEstimate] = e.completedEstimate || 0,
          t[this.propertyNameIndexMap.cancelledEstimate] = e.cancelledEstimate || 0,
          t[this.propertyNameIndexMap.completedEstimateToday] = e.completedEstimateToday || 0,
          t[this.propertyNameIndexMap.completedIssueCountToday] = e.completedIssueCountToday || 0,
          t[this.propertyNameIndexMap.addedEstimateToday] = e.addedEstimateToday || 0,
          t[this.propertyNameIndexMap.addedIssueCountToday] = e.addedIssueCountToday || 0,
          t
      }
      static #e = this.VERSION = 1;
      static #t = this.propertyNameIndexMap = {
          version: 0,
          createdAt: 1,
          date: 2,
          scopeCount: 3,
          triageIssueCount: 4,
          backlogIssueCount: 5,
          unstartedIssueCount: 6,
          startedIssueCount: 7,
          completedIssueCount: 8,
          cancelledIssueCount: 9,
          scopeEstimate: 10,
          triageEstimate: 11,
          backlogEstimate: 12,
          unstartedEstimate: 13,
          startedEstimate: 14,
          completedEstimate: 15,
          cancelledEstimate: 16,
          completedEstimateToday: 17,
          completedIssueCountToday: 18,
          addedEstimateToday: 19,
          addedIssueCountToday: 20
      }
  }
  ,
  bb = class {
      static serialize(e) {
          return xb(e[0]).fromDBEntry(e)
      }
      static deserialize(e) {
          return xb(Sb).toDBEntry(e)
      }
  }
  ,
  xb = e => Cb[e ?? Sb],
  Sb = yb.VERSION,
  Cb = {
      1: {
          fromDBEntry: e => yb.dbEntryToIssuesProgressHistoryEntry(e),
          toDBEntry: e => yb.issuesProgressHistoryEntryToDBEntry(e)
      }
  }
}
));
function Goe({anchorType: e, relatedAnchorType: t}) {
  switch (e) {
  case Tb.start:
      switch (t) {
      case Tb.start:
          return Eb.startsWith;
      case Tb.end:
      case Tb.milestone:
          return Eb.blockedBy;
      default:
          y(t);
          return
      }
  case Tb.end:
  case Tb.milestone:
      switch (t) {
      case Tb.start:
      case Tb.milestone:
          return Eb.blocking;
      case Tb.end:
          return Eb.endsWith;
      default:
          y(t);
          return
      }
  default:
      y(e);
      return
  }
}
function Koe({anchorType: e, relatedAnchorType: t}) {
  switch (t) {
  case Tb.start:
  case Tb.milestone:
      switch (e) {
      case Tb.start:
          return Eb.startsWith;
      case Tb.end:
      case Tb.milestone:
          return Eb.blockedBy;
      default:
          y(e);
          return
      }
  case Tb.end:
      switch (e) {
      case Tb.start:
      case Tb.milestone:
          return Eb.blocking;
      case Tb.end:
          return Eb.endsWith;
      default:
          y(e);
          return
      }
  default:
      y(t);
      return
  }
}
var wb, Tb, Eb, Db = t(( () => {
  zn(),
  wb = function(e) {
      return e.dependency = `dependency`,
      e
  }({}),
  Tb = function(e) {
      return e.start = `start`,
      e.end = `end`,
      e.milestone = `milestone`,
      e
  }({}),
  Eb = function(e) {
      return e.blocking = `Blocking`,
      e.blockedBy = `Blocked by`,
      e.startsWith = `Starts with`,
      e.endsWith = `Ends with`,
      e
  }({})
}
)), Ob, kb = t(( () => {
  Ob = function(e) {
      return e[e.hasCustomerNeeds = 0] = `hasCustomerNeeds`,
      e[e.hasDocuments = 1] = `hasDocuments`,
      e[e.hasEntityExternalLinks = 2] = `hasEntityExternalLinks`,
      e[e.hasFacets = 3] = `hasFacets`,
      e[e.hasRelations = 4] = `hasRelations`,
      e[e.hasReverseRelations = 5] = `hasReverseRelations`,
      e[e.hasProjectMilestones = 6] = `hasProjectMilestones`,
      e[e.hasExternalEntityRelations = 7] = `hasExternalEntityRelations`,
      e
  }({})
}
)), Ab, jb = t(( () => {
  Ab = function(e) {
      return e.daily = `daily`,
      e.weekly = `weekly`,
      e
  }({})
}
)), Mb, Nb, Pb, Fb, Ib, Lb, Rb = t(( () => {
  zn(),
  Mb = 48,
  Nb = 84,
  Pb = ({lastUpdateTimestamp: e, workingDays: t}) => {
      let n = Mb;
      if (e) {
          let r = new Date(e)
            , i = t[t.length - 1];
          r.getDay() === i && (n = Nb)
      }
      return n
  }
  ,
  Fb = function(e) {
      return e.onTrack = `onTrack`,
      e.atRisk = `atRisk`,
      e.offTrack = `offTrack`,
      e
  }({}),
  Ib = function(e) {
      return e.outdated = `outdated`,
      e.noUpdate = `noUpdate`,
      e
  }({}),
  Lb = class {
      static #e = this.all = Object.values(Fb).filter(e => typeof e == `string`);
      static #t = this.allWithAged = [...Object.values(Fb), ...Object.values(Ib)].filter(e => typeof e == `string`);
      static #n = this.healthOrdering = Object.freeze({
          [Fb.offTrack]: 0,
          [Fb.atRisk]: 1,
          [Fb.onTrack]: 2,
          [Ib.outdated]: 3,
          [Ib.noUpdate]: 4
      });
      static emojiForUpdateHealth(e) {
          switch (e) {
          case Fb.onTrack:
              return ``;
          case Fb.atRisk:
              return ``;
          case Fb.offTrack:
              return ``;
          default:
              throw y(e)
          }
      }
      static labelForUpdateAgedHealth(e) {
          switch (e) {
          case Fb.onTrack:
              return `On track`;
          case Fb.atRisk:
              return `At risk`;
          case Fb.offTrack:
              return `Off track`;
          case Ib.outdated:
              return `Update missing`;
          case Ib.noUpdate:
              return `No update expected`;
          default:
              throw y(e)
          }
      }
      static labelForUpdateHealth(e) {
          switch (e) {
          case Fb.onTrack:
              return `On track`;
          case Fb.atRisk:
              return `At risk`;
          case Fb.offTrack:
              return `Off track`;
          case void 0:
              return `No updates`;
          default:
              throw y(e)
          }
      }
  }
}
)), zb, Bb, Vb, Hb = t(( () => {
  nt(),
  Rb(),
  jb(),
  zb = 1,
  Bb = 7 * zb,
  Vb = class e {
      static healthIsOutdated({healthAgeInDays: e, updateReminderFrequency: t, frequencyResolution: n, orgReminderFrequency: r, isActive: i}) {
          if (!e)
              return !1;
          let a = r || 8
            , o = i ? t ?? a : t || a
            , s = (n ?? Ab.weekly) === Ab.weekly ? o * Bb + zb * 3 : o + zb;
          return o > 0 ? e >= s : !1
      }
      static healthIsSlightlyOutdated({healthAgeInDays: t, updateReminderFrequency: n, frequencyResolution: r, orgReminderFrequency: i, isActive: a}) {
          if (!t)
              return !1;
          let o = i || 8
            , s = a ? n ?? o : n || o
            , c = r ?? Ab.weekly;
          if (c === Ab.daily && s === 1)
              return e.healthIsOutdated({
                  healthAgeInDays: t,
                  updateReminderFrequency: n,
                  frequencyResolution: r,
                  orgReminderFrequency: i,
                  isActive: a
              });
          let l = c === Ab.weekly ? s * Bb + zb : s + zb;
          return s > 0 ? t >= l : !1
      }
      static labelForUpdateAgedHealth(e) {
          return Lb.labelForUpdateAgedHealth(e)
      }
      static labelForUpdateHealth(e) {
          return Lb.labelForUpdateHealth(e)
      }
      static emojiForUpdateHealth(e) {
          return Lb.emojiForUpdateHealth(e)
      }
      static isHealth(e) {
          return Lb.all.includes(e)
      }
      static isHealthWithAge(e) {
          return Lb.allWithAged.includes(e)
      }
      static getHealthWithAge(t) {
          let {health: n, healthAgeInDays: r, isActive: i, isDone: a, updateReminderFrequency: o, frequencyResolution: s, orgReminderFrequency: c=0} = t
            , l = e.healthIsOutdated({
              healthAgeInDays: r,
              updateReminderFrequency: o,
              frequencyResolution: s,
              orgReminderFrequency: c,
              isActive: i
          });
          return n ? a && l ? Ib.noUpdate : n === Fb.offTrack ? Fb.offTrack : n === Fb.atRisk ? l ? o === 0 && c > 0 ? Ib.noUpdate : Ib.outdated : Fb.atRisk : n === Fb.onTrack ? l ? o === 0 && c > 0 ? Ib.noUpdate : i ? Ib.outdated : Ib.noUpdate : Fb.onTrack : n : i ? Ib.outdated : Ib.noUpdate
      }
      static getHealthAgeInDays(e) {
          return e.healthUpdatedAt && $e(new Date, e.healthUpdatedAt)
      }
  }
}
)), Ub, Wb, Gb = t(( () => {
  Ub = [`buzzin`, `active`, `some`, `none`],
  Wb = class {
      static getActivityType(e) {
          return e < 1 ? `none` : e < 5 ? `some` : e < 9 ? `active` : `buzzin`
      }
      static getTitle(e) {
          return e === `none` ? `No activity` : e === `some` ? `Some activity` : e === `active` ? `Active` : `Very active`
      }
  }
}
)), Kb, qb = t(( () => {
  Rl(),
  Kb = class e extends Ll {
      static #e = this.NoPriority = new e(`No priority`,0);
      static #t = this.Urgent = new e(`Urgent`,1);
      static #n = this.High = new e(`High`,2);
      static #r = this.Medium = new e(`Medium`,3);
      static #i = this.Low = new e(`Low`,4);
      static createFromPriority(t) {
          switch (t) {
          case 1:
              return e.Urgent;
          case 2:
              return e.High;
          case 3:
              return e.Medium;
          case 4:
              return e.Low;
          default:
              return e.NoPriority
          }
      }
      static createFromName(e) {
          for (let t of this.allPriorities)
              if (t.name.toLowerCase() === e.toLowerCase() || Number(e) === t.priority)
                  return t
      }
      static get allPriorities() {
          return [e.NoPriority, e.Urgent, e.High, e.Medium, e.Low]
      }
  }
}
)), Jb, Yb, Xb = t(( () => {
  rB(),
  gx(),
  V(),
  F(),
  Sm(),
  N(),
  Yb = Jb = class extends Yh {
      static create(e) {
          let t = Jb.createEmpty();
          return t.template = vm.wrap(e.template),
          t.integration = e.integration,
          t.foreignEntityId = e.foreignEntityId,
          t
      }
  }
  ,
  M([sg( () => hx, `integrationTemplates`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], Yb.prototype, `template`, void 0),
  M([B( () => nB, `integrationTemplates`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], Yb.prototype, `integration`, void 0),
  M([R()], Yb.prototype, `foreignEntityId`, void 0),
  Yb = Jb = M([mg(`IntegrationTemplate`)], Yb)
}
)), Zb, Qb = t(( () => {
  V(),
  F(),
  ex(),
  N(),
  Zb = class extends qh {
      canSendFromCustomDomain() {
          let e = this.verificationStatus === `SUCCESS`
            , t = this.dkimStatus === `SUCCESS`
            , n = this.mailFromDomainStatus === `SUCCESS`
            , r = this.verifiedOrganizationStatus;
          return e && t && n && r
      }
  }
  ,
  M([R({
      persistence: `none`,
      default: ``
  })], Zb.prototype, `domain`, void 0),
  M([R({
      persistence: `none`,
      default: ``
  })], Zb.prototype, `verificationStatus`, void 0),
  M([R({
      persistence: `none`,
      default: ``
  })], Zb.prototype, `dkimStatus`, void 0),
  M([R({
      persistence: `none`,
      default: ``
  })], Zb.prototype, `mailFromDomainStatus`, void 0),
  M([R({
      persistence: `none`,
      default: !1
  })], Zb.prototype, `verifiedOrganizationStatus`, void 0),
  M([og( () => $b)], Zb.prototype, `emailIntakeAddresses`, void 0),
  Zb = M([mg(`SesDomainIdentity`)], Zb)
}
)), $b, ex = t(( () => {
  Ru(),
  Xn(),
  iU(),
  Qb(),
  mH(),
  gx(),
  GU(),
  V(),
  F(),
  N(),
  $b = class extends Yh {
      get emailAddress() {
          return Lu.emailIntakeAddressToEmailAddress({
              address: this.address,
              template: this.template?.value,
              team: this.team?.value,
              emailIntakeHostname: Jn.EMAIL_INTAKE_HOSTNAME,
              type: this.type,
              staticSlug: this.staticSlug
          })
      }
      get domain() {
          if (this.forwardingEmailAddress)
              return Lu.parseDomain(this.forwardingEmailAddress)
      }
      get title() {
          return this.senderName || this.forwardingEmailAddress || this.emailAddress
      }
      get description() {
          let e = this.forwardingEmailAddress || this.emailAddress;
          if (this.title !== e)
              return e
      }
  }
  ,
  M([R({
      persistence: `none`,
      default: ``
  })], $b.prototype, `address`, void 0),
  M([R({
      persistence: `createOnly`,
      enum: Pu
  })], $b.prototype, `type`, void 0),
  M([R()], $b.prototype, `forwardingEmailAddress`, void 0),
  M([R()], $b.prototype, `senderName`, void 0),
  M([R({
      persistence: `updateOnly`,
      default: !0
  })], $b.prototype, `enabled`, void 0),
  M([R({
      default: !1
  })], $b.prototype, `repliesEnabled`, void 0),
  M([R({
      default: !1
  })], $b.prototype, `useUserNamesInReplies`, void 0),
  M([R({
      default: !1
  })], $b.prototype, `customerRequestsEnabled`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0
  })], $b.prototype, `creator`, void 0),
  M([B( () => Zb, `emailIntakeAddresses`, {
      persistence: `none`,
      nullable: !0
  })], $b.prototype, `sesDomainIdentity`, void 0),
  M([R()], $b.prototype, `issueCreatedAutoReply`, void 0),
  M([R({
      default: !1
  })], $b.prototype, `issueCreatedAutoReplyEnabled`, void 0),
  M([R({
      default: !1
  })], $b.prototype, `issueCompletedAutoReplyEnabled`, void 0),
  M([R()], $b.prototype, `issueCompletedAutoReply`, void 0),
  M([R({
      default: !1
  })], $b.prototype, `issueCanceledAutoReplyEnabled`, void 0),
  M([R()], $b.prototype, `issueCanceledAutoReply`, void 0),
  M([R({
      persistence: `none`
  })], $b.prototype, `staticSlug`, void 0),
  M([sg( () => K, `emailIntakeAddresses`, {
      nullable: !1,
      optional: !0,
      indexed: !0
  })], $b.prototype, `team`, void 0),
  M([sg( () => hx, `emailIntakeAddresses`, {
      nullable: !1,
      optional: !0
  })], $b.prototype, `template`, void 0),
  M([B( () => q, `emailIntakeAddresses`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], $b.prototype, `organization`, void 0),
  $b = M([mg(`EmailIntakeAddress`)], $b)
}
)), tx, nx = t(( () => {
  zm(),
  tx = class e {
      static firstSortOrder(e, t) {
          return e.length === 0 ? Math.round((-100 + Math.random() * 200) * 100) / 100 : Math.round((e.reduce( (e, n) => Math.min(e, n[t] ?? 0), Number.MAX_VALUE) - 900 - Math.random() * 200) * 100) / 100
      }
      static lastSortOrder(e, t) {
          return e.length === 0 ? Math.round((-100 + Math.random() * 200) * 100) / 100 : Math.round((e.reduce( (e, n) => Math.max(e, n[t] ?? 0), Number.MIN_VALUE) + 900 + Math.random() * 200) * 100) / 100
      }
      static calculateSortOrder(t, n, r, i) {
          if (t.length === 0)
              return -100 + Math.random() * 200;
          let a = t.map(e => e[n])
            , o = Math.min(2 ** 53 - 1, ...a)
            , s = Math.max(-(2 ** 53 - 1), ...a);
          if (r === i && a.length > r) {
              let e = a[r - 1] ?? -(2 ** 53 - 1)
                , t = a[r + 1] ?? 2 ** 53 - 1;
              return a[r] === e || a[r] === t ? Math.round((s + 900 + Math.random() * 200) * 100) / 100 : a[r]
          }
          if (r <= 0)
              return Math.round((o - 900 - Math.random() * 200) * 100) / 100;
          if (r >= a.length - (i === void 0 ? 0 : 1))
              return Math.round((s + 900 + Math.random() * 200) * 100) / 100;
          {
              let t = r + (i !== void 0 && i < r ? 1 : 0)
                , n = a[t - 1]
                , o = a[t];
              return n === o ? Math.round((s + 900 + Math.random() * 200) * 100) / 100 : e.calculateBetweenItems(n, o)
          }
      }
      static calculateMultipleSortOrders({collection: t, property: n, count: r, index: i, sourceIndex: a}) {
          let o = t instanceof Rm ? t.elements : t
            , s = e.calculateSortOrder(t, n, i, a)
            , c = a !== void 0 && i > a ? i + 1 : i
            , l = o.length > c ? o[c]?.[n] : 0
            , u = l === void 0 || t.length === 0 || i >= t.length ? 1e3 : l - s;
          return Array.from({
              length: r
          }, (e, t) => s + u * (t / r))
      }
      static calculateBetweenItems(e, t) {
          let n = t - e
            , r = e + n / (1.9 + .2 * Math.random());
          return Math.abs(n) > 100 ? Math.round(r * 100) / 100 : Math.abs(n) > 10 ? Math.round(r * 1e3) / 1e3 : Math.abs(n) > 1 ? Math.round(r * 1e4) / 1e4 : r
      }
      static calculateMultipleBetweenItems(e, t, n) {
          let r = t - e
            , i = r / (n + 1)
            , a = Math.abs(i) > 100 ? 100 : Math.abs(r) > 10 ? 1e3 : Math.abs(r) > 1 ? 1e4 : 1
            , o = [];
          for (let t = 1; t <= n; ++t) {
              let n = e + (t + (.2 * Math.random() - .1)) * i;
              a > 1 && (n = Math.round(n * a) / a),
              o.push(n)
          }
          return o
      }
      static fixTooCloseProximity(e, t) {
          let n = []
            , r = 0
            , i = e instanceof Rm ? e.elements : e;
          for (let e = 0; e < i.length; e++) {
              let a = i[e]
                , o = i[e + 1];
              if (a?.[t] !== void 0 && o?.[t] !== void 0) {
                  let i = a[t]
                    , s = o[t];
                  Math.abs(s - i) < 1e-8 ? n.length === 0 || n[r] === void 0 ? n[r] = [{
                      item: a,
                      index: e
                  }, {
                      item: o,
                      index: e + 1
                  }] : n[r].push({
                      item: o,
                      index: e + 1
                  }) : n[r] && (r += 1)
              }
          }
          let a = [];
          return n.forEach(e => {
              let n = e[e.length - 1]
                , r = n.item[t]
                , o = ((i[n.index + 1]?.[t] || r + Math.random()) - r) / (e.length + 1)
                , s = new Set(e.map( ({item: e}) => e[t]));
              e.forEach( ({item: e}, n) => {
                  let r = e[t] + o * (n + 1);
                  s.has(r) && (r -= o / 2 * (n + 1)),
                  a.push({
                      item: e,
                      newPropertyValue: r
                  })
              }
              )
          }
          ),
          a
      }
  }
}
)), rx, ix = t(( () => {
  rx = function(e) {
      return e.draft = `draft`,
      e.start = `start`,
      e.review = `review`,
      e.mergeable = `mergeable`,
      e.merge = `merge`,
      e
  }({})
}
)), ax, ox = t(( () => {
  cx(),
  mH(),
  V(),
  F(),
  om(),
  N(),
  ax = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular
  }
  ,
  M([B( () => K, `gitAutomationTargetBranches`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], ax.prototype, `team`, void 0),
  M([R({
      default: ``
  })], ax.prototype, `branchPattern`, void 0),
  M([R({
      default: !1
  })], ax.prototype, `isRegex`, void 0),
  M([z( () => sx, {
      index: `targetBranchId`
  })], ax.prototype, `automationStates`, void 0),
  ax = M([mg(`GitAutomationTargetBranch`)], ax)
}
)), sx, cx = t(( () => {
  ix(),
  ox(),
  mH(),
  dx(),
  V(),
  F(),
  om(),
  N(),
  sx = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular;
      static groupByEventsForBranch(e) {
          return e.reduce( (e, t) => {
              let {event: n} = t;
              if (e[n])
                  throw Error(`Duplicate automation state for type: ${n}`);
              return e[n] = t,
              e
          }
          , {})
      }
  }
  ,
  M([B( () => ux, `gitAutomationStates`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], sx.prototype, `state`, void 0),
  M([B( () => K, `gitAutomationStates`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], sx.prototype, `team`, void 0),
  M([sg( () => ax, `automationStates`, {
      nullable: !1,
      optional: !0,
      indexed: !0
  })], sx.prototype, `targetBranch`, void 0),
  M([R({
      default: rx.start
  })], sx.prototype, `event`, void 0),
  sx = M([mg(`GitAutomationState`)], sx)
}
)), lx, ux, dx = t(( () => {
  zn(),
  vc(),
  gc(),
  Iv(),
  Gl(),
  nx(),
  Lq(),
  mH(),
  F(),
  V(),
  Nm(),
  cx(),
  N(),
  ux = lx = class extends Jh {
      get compositeKey() {
          return lx.getCompositeKey(this)
      }
      get isTriage() {
          return this.type === E.triage
      }
      get isBacklog() {
          return this.type === E.backlog
      }
      get isActive() {
          return this.type === E.unstarted || this.type === E.started
      }
      get isUnstarted() {
          return this.type === E.unstarted
      }
      get isStarted() {
          return this.type === E.started
      }
      get isCompleted() {
          return this.type === E.completed
      }
      get isCanceled() {
          return this.type === E.canceled
      }
      get isClosed() {
          return hc.closedStateTypes.includes(this.type)
      }
      get displayCompletionPercentage() {
          switch (this.type) {
          case E.triage:
              return 1;
          case E.backlog:
          case E.unstarted:
              return 0;
          case E.started:
              let e = this.team.states.filter(e => e.type === E.started).orderBy(`position`, `asc`);
              return e.length === 1 ? .5 : e.length === 2 ? e.indexOf(this) === 0 ? .5 : .75 : 1 / (e.length + 1) * (e.indexOf(this) + 1);
          case E.completed:
          case E.canceled:
              return 1;
          default:
              throw y(this.type)
          }
      }
      get nameForView() {
          switch (this.type) {
          case E.triage:
              return `Triage`;
          case E.backlog:
              return `Backlog`;
          case E.unstarted:
              return `Active issues`;
          case E.started:
              return `Active issues`;
          case E.completed:
              return `All issues`;
          case E.canceled:
              return `All issues`;
          default:
              throw y(this.type)
          }
      }
      get filterMatchValue() {
          return this.name.toLowerCase() + this.type
      }
      sortOrderForIssueDropLocation(e, t) {
          let n = this.issues.indexOf(e)
            , r = t ? this.issues.indexOf(t) : void 0;
          return n === -1 || r === -1 ? this.firstSortOrder() : tx.calculateSortOrder(this.issues, `sortOrder`, n, r)
      }
      firstSortOrder() {
          return tx.firstSortOrder(this.issues, `sortOrder`)
      }
      lastSortOrder() {
          return tx.lastSortOrder(this.issues, `sortOrder`)
      }
      get indexWithinStateType() {
          let e = this.type
            , t = this.position;
          return this.findIndexWithPredicate(n => n.type === e && n.position < t)
      }
      get sortOrderWithinStateType() {
          return this.indexWithinStateType / this.team.states.filter(e => e.type === this.type).length
      }
      get indexInWorkflow() {
          return this.findIndexWithPredicate(e => _c.isStateBefore(e, this))
      }
      get usedByTriageRuleCount() {
          return this.associatedTriageRules.length
      }
      get associatedTriageRules() {
          return this.team.organization.triageWorkflowDefinitions.filter(e => !!(e.enabled && e.activities.find(e => e.updateIssue?.property === Fv.state && e.updateIssue?.value === this.id)))
      }
      findIndexWithPredicate(e) {
          let t = 0
            , n = this.team.states.elements;
          for (let r = 0, i = n.length; r < i; ++r)
              e(n[r]) && ++t;
          return t
      }
      static compareWorkflowIndex(e, t) {
          return e.id === t.id ? 0 : e.indexInWorkflow - t.indexInWorkflow
      }
      static getCompositeKey(e) {
          return Wl.getStateCompositeKey(e)
      }
  }
  ,
  M([R({
      default: ``
  })], ux.prototype, `name`, void 0),
  M([R()], ux.prototype, `description`, void 0),
  M([R({
      default: `#f00`
  })], ux.prototype, `color`, void 0),
  M([R({
      default: 0
  })], ux.prototype, `position`, void 0),
  M([R({
      persistence: `createOnly`,
      default: E.backlog
  })], ux.prototype, `type`, void 0),
  M([B( () => K, `states`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], ux.prototype, `team`, void 0),
  M([z( () => sx, {
      index: `stateId`
  })], ux.prototype, `gitAutomationStates`, void 0),
  M([z( () => Y, {
      index: `stateId`,
      order: new P(`sortOrder`),
      canSkipHydration: e => e.team.issues.isHydrated()
  })], ux.prototype, `issues`, void 0),
  M([B( () => ux, `inheritedBy`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], ux.prototype, `inheritedFrom`, void 0),
  M([og( () => ux)], ux.prototype, `inheritedBy`, void 0),
  M([L({
      keepAlive: !0
  })], ux.prototype, `compositeKey`, null),
  M([L], ux.prototype, `displayCompletionPercentage`, null),
  M([L], ux.prototype, `indexWithinStateType`, null),
  M([L], ux.prototype, `sortOrderWithinStateType`, null),
  M([L], ux.prototype, `indexInWorkflow`, null),
  M([L], ux.prototype, `usedByTriageRuleCount`, null),
  M([L], ux.prototype, `associatedTriageRules`, null),
  ux = lx = M([mg(`WorkflowState`)], ux)
}
)), fx, px, mx = t(( () => {
  ws(),
  nm(),
  om(),
  es(),
  ai(),
  pm(),
  fx = class e {
      static async start(t, n) {
          if (t)
              try {
                  await new e(t,n).startHydration()
              } catch (e) {
                  if (Go(e) || e instanceof dm && Go(e.underlyingError))
                      return;
                  w.warning(`Error in after startup prehydrator`, {
                      error: e
                  })
              }
      }
      constructor(e, t) {
          this.organization = e,
          this.options = t
      }
      async startHydration() {
          await ri(this.options?.delay ?? 500);
          let e = em.getModelClasses(rm.partial).concat(em.getModelClasses(rm.lazy)).filter(e => !!e.hydrateAfterStartupConfig).sortBy(e => e.hydrateAfterStartupConfig.priority);
          for (let t of e)
              await new Promise(e => {
                  window.requestIdleCallback(async () => {
                      await t.hydrateAfterStartupConfig.execute(this.organization).catch(e => {
                          Go(e) ? w.debug(`AfterStartupPrehydrator failed with network error`, {
                              modelName: t.modelName,
                              error: e
                          }) : w.error(`AfterStartupPrehydrator failed`, e, {
                              modelName: t.modelName
                          })
                      }
                      ),
                      e()
                  }
                  )
              }
              )
      }
  }
  ,
  px = function(e) {
      return e[e.critical = 0] = `critical`,
      e[e.high = 1] = `high`,
      e[e.medium = 2] = `medium`,
      e[e.low = 3] = `low`,
      e
  }({})
}
)), hx, gx = t(( () => {
  Yf(),
  iU(),
  mH(),
  GU(),
  V(),
  F(),
  Ih(),
  Nm(),
  Xb(),
  ex(),
  dx(),
  om(),
  mx(),
  Lq(),
  iz(),
  N(),
  hx = class extends Yh {
      constructor(...e) {
          super(...e),
          this.skipUpdatedAtKeys = new Set([`sortOrder`])
      }
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.full;
      get isTeamTemplate() {
          return !!this.team?.id
      }
      get isStandardIssueTemplate() {
          return this.type === yf.issue && !Ef.isFormTemplate(this.templateData)
      }
      get isFormIssueTemplate() {
          return this.type === yf.issue && Ef.isFormTemplate(this.templateData)
      }
      get state() {
          let e = this.templateData?.stateId;
          return e ? this.store.findById(ux, e) : void 0
      }
      static #n = this.hydrateAfterStartupConfig = {
          priority: px.high,
          execute: async e => {
              await e.allTemplates.hydrate()
          }
      };
      setSchedule(e) {
          this.type === yf.recurringIssue && (this.templateData = {
              ...this.templateData,
              schedule: e
          })
      }
      setFormFields(e) {
          let {formFields: t, ...n} = this.templateData;
          this.templateData = e.length ? {
              ...n,
              formFields: e
          } : n
      }
      getProjectsReferencedInTemplate() {
          return [this?.templateData.projectId, ...this?.templateData.children?.map(e => e.projectId) || []].concrete().map(e => this.store.findById(G, e)).concrete()
      }
  }
  ,
  M([R({
      default: ``
  })], hx.prototype, `name`, void 0),
  M([R()], hx.prototype, `description`, void 0),
  M([R({
      serializer: Mh,
      shallowObservation: !0,
      default: {}
  })], hx.prototype, `templateData`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !0,
      nullable: !1
  })], hx.prototype, `creator`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0
  })], hx.prototype, `lastUpdatedBy`, void 0),
  M([B( () => q, `allTemplates`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], hx.prototype, `organization`, void 0),
  M([B( () => K, `templates`, {
      nullable: !1,
      optional: !0,
      indexed: !0
  })], hx.prototype, `team`, void 0),
  M([R({
      persistence: `createOnly`,
      default: yf.issue
  })], hx.prototype, `type`, void 0),
  M([R({
      default: 0
  })], hx.prototype, `sortOrder`, void 0),
  M([og( () => Yb)], hx.prototype, `integrationTemplates`, void 0),
  M([og( () => $b, {
      order: new P(`address`)
  })], hx.prototype, `emailIntakeAddresses`, void 0),
  M([z( () => Y, {
      index: `recurringIssueTemplateId`
  })], hx.prototype, `recurringIssues`, void 0),
  M([sg( () => hx, `inheritedBy`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], hx.prototype, `inheritedFrom`, void 0),
  M([z( () => hx, {
      index: `inheritedFromId`
  })], hx.prototype, `inheritedBy`, void 0),
  M([I], hx.prototype, `setSchedule`, null),
  M([I], hx.prototype, `setFormFields`, null),
  hx = M([mg(`Template`)], hx)
}
)), _x, vx = t(( () => {
  V(),
  om(),
  F(),
  iz(),
  N(),
  _x = class extends qh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular
  }
  ,
  M([B( () => G, `history`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], _x.prototype, `project`, void 0),
  M([R({
      default: []
  })], _x.prototype, `entries`, void 0),
  _x = M([mg(`ProjectHistory`)], _x)
}
)), yx, bx = t(( () => {
  yx = class {
      static #e = this.maxTitleLength = 512;
      static #t = this.defaultDocumentTitle = `New document`
  }
}
)), xx, Sx = t(( () => {
  ite(),
  $ee(),
  Xee(),
  ml(),
  xx = class extends tte {
      get documentVersion() {
          let e = this.getMap(`meta`).get(`version`);
          return !e || Number.isNaN(e) ? 1 : e
      }
      constructor() {
          super({
              gc: !0
          })
      }
      getFlattenedState(e) {
          let t = this.documentVersion
            , n = xn(rte(dl, this));
          return e?.dontBumpVersion || n.getMap(`meta`).set(`version`, t + 1),
          bn(n)
      }
      async getFlattenedStateAsync(e) {
          let t = this.documentVersion
            , n = rte(dl, this);
          await Zee(0);
          let r = xn(n);
          return e?.dontBumpVersion || r.getMap(`meta`).set(`version`, t + 1),
          bn(r)
      }
      updateToProsemirrorData(e) {
          nte(this, this.getXmlFragment(`prosemirror`), dl.nodeFromJSON(e), new Map)
      }
      applyUpdate(e) {
          e.length > 0 && Qee(this, e)
      }
      encodeStateAsUpdate(e) {
          return bn(this, e)
      }
      encodeStateVector() {
          return ete(this)
      }
      asProsemirrorData() {
          return ate(this)
      }
  }
}
));
function Cx(e, t, n, r) {
  let i = ``
    , a = !0;
  return e.nodesBetween(t, n, (e, o) => {
      let s = r[e.type.name];
      s === void 0 ? e.isText ? (i += e.text?.slice(Math.max(t, o) - o, n - o),
      a = !1) : e.isBlock && !a && (i += `

`,
      a = !0) : (e.isBlock && !a && (i += `

`,
      a = !0),
      i += s(e))
  }
  ),
  i
}
var wx = t(( () => {}
)), Tx, qoe = t(( () => {
  Tx = function(e) {
      return e[e.hasComments = 0] = `hasComments`,
      e
  }({})
}
)), Ex, Dx = t(( () => {
  Ex = class {
      static #e = this.maxContentLength = 25e4;
      static #t = this.maxContentDataLength = 75e4;
      static #n = this.contentStateOptimizationLimit = 1e5;
      static #r = this.contentStateOptimizationThreshold = 1e3;
      static #i = this.contentStateOptimizationPercentageThreshold = .2;
      static #a = this.maxContentStateLength = 1e6;
      static maxContentStateLengthErrorMessage(e=`document`) {
          return `The ${e} is too large to save. Please reduce the size of the ${e}.`
      }
  }
}
)), Ox, kx, Ax = t(( () => {
  Ox = class {
      static #e = this.minNameLength = 2;
      static #t = this.maxNameLength = 80;
      static getStatus(e, t, n, r) {
          let i = t !== 1;
          return n && n.toLocalDate().valueOf() < Date.now() && i ? kx.overdue : e === r.find(e => e.progress < 1)?.id ? kx.next : i ? kx.unstarted : kx.done
      }
  }
  ,
  kx = function(e) {
      return e.unstarted = `unstarted`,
      e.next = `next`,
      e.overdue = `overdue`,
      e.done = `done`,
      e
  }({})
}
)), jx, Joe = t(( () => {
  jx = function(e) {
      return e[e.hasRelations = 0] = `hasRelations`,
      e[e.hasReverseRelations = 1] = `hasReverseRelations`,
      e
  }({})
}
)), Mx, Nx = t(( () => {
  zn(),
  Dl(),
  Mx = class e {
      static getNotificationGrouping(e, t) {
          switch (t) {
          case O.oauthClientApprovalCreated:
              return {
                  type: `oauth-client-approval`,
                  entityId: e.oauthClientApprovalId || e.id
              };
          case O.system:
              return {
                  type: `system`,
                  entityId: e.id
              };
          case O.issueDue:
          case O.issuePriorityUrgent:
          case O.issueReopened:
          case O.issueStatusChangedDone:
          case O.issueStatusChangedAll:
              return {
                  type: `issue`,
                  entityId: e.issueId || e.id
              };
          case O.initiativeUpdatePrompt:
          case O.initiativeUpdateCreated:
          case O.initiativeUpdateReaction:
          case O.initiativeUpdateMention:
          case O.initiativeUpdateNewComment:
          case O.initiativeUpdateCommentMention:
          case O.initiativeUpdateCommentReaction:
          case O.pullRequestReviewRequested:
          case O.pullRequestReviewRerequested:
          case O.pullRequestApproved:
          case O.pullRequestChangesRequested:
          case O.pullRequestCommented:
          case O.pullRequestChecksFailed:
          case O.pullRequestMention:
          case O.pullRequestCommentMention:
          case O.pullRequestRemovedFromMergeQueue:
          case O.projectUpdatePrompt:
          case O.projectUpdateCreated:
          case O.projectUpdateReaction:
          case O.projectUpdateMention:
          case O.projectUpdateNewComment:
          case O.projectUpdateCommentMention:
          case O.projectUpdateCommentReaction:
          case O.issueAssignedToYou:
          case O.issueUnassignedFromYou:
          case O.projectAddedAsMember:
          case O.projectAddedAsLead:
          case O.projectCommentMention:
          case O.projectNewComment:
          case O.projectCommentReaction:
          case O.projectThreadResolved:
          case O.projectMention:
          case O.projectDescriptionContentChange:
          case O.projectDeleted:
          case O.projectRestored:
          case O.initiativeAddedAsOwner:
          case O.initiativeCommentMention:
          case O.initiativeNewComment:
          case O.initiativeThreadResolved:
          case O.initiativeCommentReaction:
          case O.initiativeMention:
          case O.initiativeDescriptionContentChange:
          case O.initiativeDeleted:
          case O.initiativeRestored:
          case O.initiativeMoved:
          case O.customerAddedAsOwner:
          case O.customerNeedCreated:
          case O.customerNeedMarkedAsImportant:
          case O.customerNeedResolved:
          case O.projectMilestoneCommentMention:
          case O.projectMilestoneMention:
          case O.projectMilestoneCommentReaction:
          case O.projectMilestoneNewComment:
          case O.projectMilestoneThreadResolved:
          case O.projectMilestoneDescriptionContentChange:
          case O.documentCommentMention:
          case O.documentNewComment:
          case O.documentThreadResolved:
          case O.documentCommentReaction:
          case O.documentMention:
          case O.documentContentChange:
          case O.documentMoved:
          case O.documentDeleted:
          case O.documentRestored:
          case O.documentReminder:
          case O.documentSubscribed:
          case O.documentUnsubscribed:
          case O.issueNewComment:
          case O.issueCommentMention:
          case O.issueCommentReaction:
          case O.issueThreadResolved:
          case O.teamUpdateCommentMention:
          case O.teamUpdateNewComment:
          case O.teamUpdateCommentReaction:
          case O.teamUpdateCreated:
          case O.teamUpdateMention:
          case O.teamUpdateReaction:
          case O.feedSummaryGenerated:
          case O.triageResponsibilityIssueAddedToTriage:
          case O.issueAddedToTriage:
          case O.issueAddedToView:
          case O.issueCreated:
          case O.issueSlaBreached:
          case O.issueSlaHighRisk:
          case O.issueMention:
          case O.initiativeReminder:
          case O.projectReminder:
          case O.issueSubscribed:
          case O.issueUnsubscribed:
          case O.issueEmojiReaction:
          case O.issueBlocking:
          case O.issueUnblocked:
          case O.issueReminder:
          case O.issueSlackThreadSynced:
              throw Error(`${t} should not be handled here`);
          default:
              return y(t),
              {
                  type: `unknown`,
                  entityId: e.id
              }
          }
      }
      static getNotificationGroupingId(t, n) {
          let r = e.getNotificationGrouping(t, n);
          return `${r.type}#${r.entityId}`
      }
  }
}
)), Px, Fx = t(( () => {
  Px = class {
      getNotificationGroupingId(e) {
          let t = this.getNotificationGrouping(e);
          return `${t.type}#${t.entityId}`
      }
  }
}
)), Ix, Lx, Rx, zx, Bx, Vx, Hx = t(( () => {
  Sl(),
  Fx(),
  Ix = {
      issue: e => ({
          type: `issue`,
          entityId: e.issueId || e.id
      })
  },
  Lx = class extends Px {
      getShortLabel() {
          return `Mentioned in comment`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return Ix.issue(e)
      }
  }
  ,
  Rx = class extends Px {
      getShortLabel() {
          return `New comment`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return Ix.issue(e)
      }
  }
  ,
  zx = class extends Px {
      getShortLabel() {
          return `Resolved a thread`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return Ix.issue(e)
      }
  }
  ,
  Bx = class extends Px {
      getShortLabel() {
          return `Reacted to comment`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return Ix.issue(e)
      }
  }
  ,
  Vx = class extends Px {
      getShortLabel() {
          return `Slack thread synced`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return Ix.issue(e)
      }
  }
}
)), Ux, Wx, Gx, Kx = t(( () => {
  Sl(),
  Fx(),
  Ux = class extends Px {
      getNotificationCategory() {
          return D.assignments
      }
      getNotificationGrouping(e) {
          return {
              type: `issue`,
              entityId: e.issueId || e.id
          }
      }
  }
  ,
  Wx = class extends Ux {
      getShortLabel() {
          return `Assigned`
      }
      static getNotificationText() {
          return {
              type: `assigned`,
              labelText: `assigned the issue to you`
          }
      }
  }
  ,
  Gx = class extends Ux {
      getShortLabel() {
          return `Unassigned`
      }
      static getNotificationText(e) {
          let {actorId: t, toAssigneeId: n} = e;
          return n && t && n === t ? {
              type: `self-assign`,
              labelText: `self-assigned your issue`
          } : n ? {
              type: `reassign`,
              labelText: `re-assigned your issue to`,
              toAssigneeId: n
          } : {
              type: `unassign`,
              labelText: `unassigned your issue`
          }
      }
  }
}
)), qx, Jx, Yx, Xx, Zx = t(( () => {
  Sl(),
  Fx(),
  qx = class extends Px {
      getNotificationGrouping(e) {
          return e.customerId ? {
              type: `customer`,
              entityId: e.customerId
          } : e.issueId ? {
              type: `issue`,
              entityId: e.issueId
          } : e.projectId ? {
              type: `project`,
              entityId: e.projectId
          } : {
              type: `issue`,
              entityId: e.id
          }
      }
      getNotificationCategory() {
          return D.customers
      }
  }
  ,
  Jx = class extends qx {
      getShortLabel() {
          return `New customer request`
      }
      getNotificationGroupingId(e) {
          return e.metadata?.issueIdForGrouping && this.getNotificationGrouping(e).type === `project` ? `issue#${e.metadata.issueIdForGrouping}` : super.getNotificationGroupingId(e)
      }
  }
  ,
  Yx = class extends qx {
      getShortLabel() {
          return `A request has been marked as important`
      }
  }
  ,
  Xx = class extends qx {
      getShortLabel() {
          return `A requested issue or project is completed`
      }
  }
}
)), Qx, $x, eS, tS, nS, rS, iS, aS, oS, sS, cS, lS, uS, dS = t(( () => {
  Sl(),
  Fx(),
  Qx = {
      document: e => ({
          type: `document`,
          entityId: e.documentId || e.id
      }),
      documentThread: e => e.parentCommentId || e.commentId ? {
          type: `document-thread`,
          entityId: e.parentCommentId || e.commentId || e.id
      } : {
          type: `document`,
          entityId: e.documentId || e.id
      },
      documentChange: e => ({
          type: `document-content-change`,
          entityId: e.documentId || e.id
      }),
      documentMoved: e => ({
          type: `document-moved`,
          entityId: e.documentId || e.id
      }),
      documentReminder: e => ({
          type: `document-reminder`,
          entityId: e.documentId || e.id
      })
  },
  $x = class extends Px {
      getShortLabel() {
          return `Mentioned in comment`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return Qx.documentThread(e)
      }
  }
  ,
  eS = class extends Px {
      getShortLabel() {
          return `New comment`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return Qx.documentThread(e)
      }
  }
  ,
  tS = class extends Px {
      getShortLabel() {
          return `Resolved a thread`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return Qx.documentThread(e)
      }
  }
  ,
  nS = class extends Px {
      getShortLabel() {
          return `Reacted to comment`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return Qx.documentThread(e)
      }
  }
  ,
  rS = class extends Px {
      getShortLabel() {
          return `Mentioned in document`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return Qx.document(e)
      }
  }
  ,
  iS = class extends Px {
      getShortLabel() {
          return `Content changed`
      }
      getNotificationCategory() {
          return D.documentChanges
      }
      getNotificationGrouping(e) {
          return Qx.documentChange(e)
      }
  }
  ,
  aS = class extends Px {
      getShortLabel() {
          return `Document moved`
      }
      getNotificationCategory() {
          return D.documentChanges
      }
      getNotificationGrouping(e) {
          return Qx.documentMoved(e)
      }
  }
  ,
  oS = class extends Px {
      getShortLabel() {
          return `Document deleted`
      }
      getNotificationCategory() {
          return D.documentChanges
      }
      getNotificationGrouping(e) {
          return Qx.documentMoved(e)
      }
  }
  ,
  sS = class extends Px {
      getShortLabel() {
          return `Document restored`
      }
      getNotificationCategory() {
          return D.documentChanges
      }
      getNotificationGrouping(e) {
          return Qx.documentMoved(e)
      }
  }
  ,
  cS = class extends Px {
      getShortLabel() {
          return `Reminder`
      }
      getNotificationCategory() {
          return D.reminders
      }
      getNotificationGrouping(e) {
          return Qx.documentReminder(e)
      }
  }
  ,
  lS = class extends Px {
      getShortLabel() {
          return `Subscribed`
      }
      getNotificationCategory() {
          return D.subscriptions
      }
      getNotificationGrouping(e) {
          return Qx.documentThread(e)
      }
  }
  ,
  uS = class extends Px {
      getShortLabel() {
          return `Unsubscribed`
      }
      getNotificationCategory() {
          return D.subscriptions
      }
      getNotificationGrouping(e) {
          return Qx.documentThread(e)
      }
  }
}
)), fS, pS, mS, hS = t(( () => {
  fS = e(Gt(), 1),
  Sl(),
  ap(),
  Yr(),
  Fx(),
  pS = {
      feed: e => ({
          type: `feed`,
          entityId: e.postId || e.id
      })
  },
  mS = class extends Px {
      getNotificationCategory() {
          return D.feed
      }
      getShortLabel() {
          return `Pulse`
      }
      getNotificationGrouping(e) {
          return pS.feed(e)
      }
      static getByline(e, t, n, r) {
          let i = Object.values(r?.updates || {}).flatMap(e => e.updates).map( ({title: e}) => {
              let t = e.match(/\[(.*?)\]\(.*?\)/);
              return t ? t[1] : e
          }
          )
            , a = i.length
            , o = a - 1;
          if (a === 0)
              return (n || this.inferScheduleAtTimeOfCreate(t)) === rp.weekly ? `Pulse updates from the last week` : `Pulse updates for ${xr(e, {
                  month: `long`
              })}`;
          let s = i.find(e => e.length <= 20) || i.sort( (e, t) => e.length - t.length)[0];
          return a === 1 ? `Update from ${s}` : `${s} and ${o} other ${(0,
          fS.default)(`update`, o)}`
      }
      static getTitle(e, t) {
          return (t || this.inferScheduleAtTimeOfCreate(e)) === rp.daily ? `Daily Pulse` : t === rp.weekly ? `Weekly Pulse` : `Pulse`
      }
      static inferScheduleAtTimeOfCreate(e) {
          if (e?.toLowerCase().includes(rp.daily))
              return rp.daily;
          if (e?.toLowerCase().includes(rp.weekly))
              return rp.weekly
      }
  }
}
)), gS, _S, vS, yS, bS, xS, SS, CS, wS, TS, ES, DS, OS = t(( () => {
  ed(),
  Sl(),
  Fx(),
  gS = {
      initiativeThread: e => e.parentCommentId || e.commentId ? {
          type: `initiative-thread`,
          entityId: e.parentCommentId || e.commentId || e.id
      } : {
          type: `initiative-thread`,
          entityId: e.commentId || e.id
      },
      initiative: e => ({
          type: `initiative`,
          entityId: e.initiativeId || e.id
      }),
      initiativeDescription: e => ({
          type: `initiative-description-change`,
          entityId: e.initiativeId || e.id
      }),
      initiativeReminder: e => ({
          type: `initiative-reminder`,
          entityId: e.initiativeId || e.id
      }),
      initiativeMoved: e => ({
          type: `initiative-moved`,
          entityId: e.initiativeId || e.id
      })
  },
  _S = class extends Px {
      getShortLabel() {
          return `Added as owner of initiative`
      }
      getNotificationCategory() {
          return D.assignments
      }
      getNotificationGrouping(e) {
          return gS.initiative(e)
      }
  }
  ,
  vS = class extends Px {
      getShortLabel() {
          return `Reminder`
      }
      getNotificationCategory() {
          return D.reminders
      }
      getNotificationGrouping(e) {
          return gS.initiativeReminder(e)
      }
  }
  ,
  yS = class extends Px {
      getShortLabel() {
          return `Mentioned in comment`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return gS.initiativeThread(e)
      }
  }
  ,
  bS = class extends Px {
      getShortLabel() {
          return `New comment`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return gS.initiativeThread(e)
      }
  }
  ,
  xS = class extends Px {
      getShortLabel() {
          return `Resolved a thread`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return gS.initiativeThread(e)
      }
  }
  ,
  SS = class extends Px {
      getShortLabel() {
          return `Reacted to comment`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return gS.initiativeThread(e)
      }
  }
  ,
  CS = class extends Px {
      getShortLabel() {
          return `Mentioned in initiative`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return gS.initiative(e)
      }
  }
  ,
  wS = class extends Px {
      getShortLabel() {
          return `Content changed`
      }
      getNotificationCategory() {
          return D.documentChanges
      }
      getNotificationGrouping(e) {
          return gS.initiativeDescription(e)
      }
  }
  ,
  TS = class extends Px {
      getShortLabel() {
          return `Initiative deleted`
      }
      getNotificationCategory() {
          return D.subscriptions
      }
      getNotificationGrouping(e) {
          return gS.initiativeMoved(e)
      }
  }
  ,
  ES = class extends Px {
      static getNotificationBody(e, t) {
          let n = ``;
          return e && (e.previousParentId && e.newParentId ? n = e.previousParentName && e.newParentName ? `moved the initiative from ${e.previousParentName} to ${e.newParentName}` : `moved the initiative from one sub-initiative to another` : e.newParentId && !e.previousParentId ? n = e.newParentName ? `made initiative a sub-initiative of ${e.newParentName}` : `made initiative a sub-initiative of another initiative` : e.previousParentId && !e.newParentId && (n = e.previousParentName ? `removed initiative from ${e.previousParentName}` : `removed initiative from a sub-initiative`)),
          n ||= `moved the initiative`,
          [t, n].filter(Xu).join(` `)
      }
      getShortLabel() {
          return `Initiative moved`
      }
      getNotificationCategory() {
          return D.subscriptions
      }
      getNotificationGrouping(e) {
          return gS.initiativeMoved(e)
      }
  }
  ,
  DS = class extends Px {
      getShortLabel() {
          return `Initiative restored`
      }
      getNotificationCategory() {
          return D.subscriptions
      }
      getNotificationGrouping(e) {
          return gS.initiativeMoved(e)
      }
  }
}
)), kS, AS, jS, MS, NS, PS, FS, IS, LS = t(( () => {
  Sl(),
  Fx(),
  kS = {
      initiativeUpdate: e => ({
          type: `initiative-update`,
          entityId: e.initiativeUpdateId || e.id
      }),
      initiativeUpdatePrompt: e => ({
          type: `initiative-update-prompt`,
          entityId: e.initiativeId || e.id
      })
  },
  AS = class extends Px {
      getNotificationCategory() {
          return D.postsAndUpdates
      }
      getShortLabel() {
          return `New initiative update`
      }
      getNotificationGrouping(e) {
          return kS.initiativeUpdate(e)
      }
  }
  ,
  jS = class extends Px {
      getNotificationCategory() {
          return D.postsAndUpdates
      }
      getShortLabel() {
          return `Initiative update reminder`
      }
      getNotificationGrouping(e) {
          return kS.initiativeUpdatePrompt(e)
      }
  }
  ,
  MS = class extends Px {
      getShortLabel() {
          return `Mentioned in initiative update`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return kS.initiativeUpdate(e)
      }
  }
  ,
  NS = class extends Px {
      getShortLabel() {
          return `Reacted to initiative update`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return kS.initiativeUpdate(e)
      }
  }
  ,
  PS = class extends Px {
      getShortLabel() {
          return `New comment`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return kS.initiativeUpdate(e)
      }
  }
  ,
  FS = class extends Px {
      getShortLabel() {
          return `Mentioned in comment`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return kS.initiativeUpdate(e)
      }
  }
  ,
  IS = class extends Px {
      getShortLabel() {
          return `Reacted to comment`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return kS.initiativeUpdate(e)
      }
  }
}
)), RS, zS, BS, VS, HS, US, WS, GS = t(( () => {
  Sl(),
  Fx(),
  RS = {
      issue: e => ({
          type: `issue`,
          entityId: e.issueId || e.id
      })
  },
  zS = class extends Px {
      getShortLabel() {
          return `Added to view`
      }
      getNotificationCategory() {
          return D.subscriptions
      }
      getNotificationGrouping(e) {
          return RS.issue(e)
      }
  }
  ,
  BS = class extends Px {
      getShortLabel() {
          return `New issue`
      }
      getNotificationCategory() {
          return D.subscriptions
      }
      getNotificationGrouping(e) {
          return RS.issue(e)
      }
  }
  ,
  VS = class extends Px {
      getShortLabel() {
          return `Mentioned in issue`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return RS.issue(e)
      }
  }
  ,
  HS = class extends Px {
      getShortLabel() {
          return `Reacted to issue`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return RS.issue(e)
      }
  }
  ,
  US = class extends Px {
      getShortLabel() {
          return `Marked as blocking`
      }
      getNotificationCategory() {
          return D.statusChanges
      }
      getNotificationGrouping(e) {
          return RS.issue(e)
      }
  }
  ,
  WS = class extends Px {
      getShortLabel() {
          return `No longer blocked`
      }
      getNotificationCategory() {
          return D.statusChanges
      }
      getNotificationGrouping(e) {
          return RS.issue(e)
      }
  }
}
)), KS, qS, JS, YS = t(( () => {
  Sl(),
  Fx(),
  KS = class extends Px {
      getNotificationGrouping(e) {
          return {
              type: `issue`,
              entityId: e.issueId || e.id
          }
      }
      getNotificationCategory() {
          return D.reminders
      }
  }
  ,
  qS = class extends KS {
      getShortLabel() {
          return `High risk of breaching SLA`
      }
  }
  ,
  JS = class extends KS {
      getShortLabel() {
          return `SLA breached`
      }
  }
}
)), XS, ZS, QS, $S, eC, tC, nC, rC = t(( () => {
  Sl(),
  Fx(),
  XS = {
      projectMilestoneThread: e => e.parentCommentId || e.commentId ? {
          type: `project-milestone-thread`,
          entityId: e.parentCommentId || e.commentId || e.id
      } : {
          type: `project-milestone`,
          entityId: e.projectMilestoneId || e.id
      },
      projectMilestoneDescription: e => ({
          type: `project-description-change`,
          entityId: e.projectId || e.projectMilestoneId || e.id
      })
  },
  ZS = class extends Px {
      getShortLabel() {
          return `Mentioned in comment`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return XS.projectMilestoneThread(e)
      }
  }
  ,
  QS = class extends Px {
      getShortLabel() {
          return `New comment`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return XS.projectMilestoneThread(e)
      }
  }
  ,
  $S = class extends Px {
      getShortLabel() {
          return `Resolved a thread`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return XS.projectMilestoneThread(e)
      }
  }
  ,
  eC = class extends Px {
      getShortLabel() {
          return `Reacted to comment`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return XS.projectMilestoneThread(e)
      }
  }
  ,
  tC = class extends Px {
      getShortLabel() {
          return `Mentioned in milestone`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return XS.projectMilestoneThread(e)
      }
  }
  ,
  nC = class extends Px {
      getShortLabel() {
          return `Content changed`
      }
      getNotificationCategory() {
          return D.documentChanges
      }
      getNotificationGrouping(e) {
          return XS.projectMilestoneDescription(e)
      }
  }
}
)), iC, aC, oC, sC, cC, lC, uC, dC, fC, pC, mC, hC, gC = t(( () => {
  Sl(),
  Fx(),
  iC = {
      projectThread: e => e.parentCommentId || e.commentId ? {
          type: `project-thread`,
          entityId: e.parentCommentId || e.commentId || e.id
      } : {
          type: `project`,
          entityId: e.projectId || e.id
      },
      project: e => ({
          type: `project`,
          entityId: e.projectId || e.id
      }),
      projectDescription: e => ({
          type: `project-description-change`,
          entityId: e.projectId || e.projectMilestoneId || e.id
      }),
      projectReminder: e => ({
          type: `project-reminder`,
          entityId: e.projectId || e.id
      }),
      projectMoved: e => ({
          type: `project-moved`,
          entityId: e.projectId || e.id
      })
  },
  aC = class extends Px {
      getShortLabel() {
          return `Added as member of project`
      }
      getNotificationCategory() {
          return D.assignments
      }
      getNotificationGrouping(e) {
          return iC.project(e)
      }
  }
  ,
  oC = class extends Px {
      getShortLabel() {
          return `Reminder`
      }
      getNotificationCategory() {
          return D.reminders
      }
      getNotificationGrouping(e) {
          return iC.projectReminder(e)
      }
  }
  ,
  sC = class extends Px {
      getShortLabel() {
          return `Added as lead of project`
      }
      getNotificationCategory() {
          return D.assignments
      }
      getNotificationGrouping(e) {
          return iC.project(e)
      }
  }
  ,
  cC = class extends Px {
      getShortLabel() {
          return `Mentioned in comment`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return iC.projectThread(e)
      }
  }
  ,
  lC = class extends Px {
      getShortLabel() {
          return `New comment`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return iC.projectThread(e)
      }
  }
  ,
  uC = class extends Px {
      getShortLabel() {
          return `Resolved a thread`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return iC.projectThread(e)
      }
  }
  ,
  dC = class extends Px {
      getShortLabel() {
          return `Reacted to comment`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return iC.projectThread(e)
      }
  }
  ,
  fC = class extends Px {
      getShortLabel() {
          return `Mentioned in project`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return iC.project(e)
      }
  }
  ,
  pC = class extends Px {
      getShortLabel() {
          return `Content changed`
      }
      getNotificationCategory() {
          return D.documentChanges
      }
      getNotificationGrouping(e) {
          return iC.projectDescription(e)
      }
  }
  ,
  mC = class extends Px {
      getShortLabel() {
          return `Project deleted`
      }
      getNotificationCategory() {
          return D.subscriptions
      }
      getNotificationGrouping(e) {
          return iC.projectMoved(e)
      }
  }
  ,
  hC = class extends Px {
      getShortLabel() {
          return `Project restored`
      }
      getNotificationCategory() {
          return D.subscriptions
      }
      getNotificationGrouping(e) {
          return iC.projectMoved(e)
      }
  }
}
)), _C, vC, yC, bC, xC, SC, CC, wC, TC = t(( () => {
  Sl(),
  Fx(),
  _C = {
      projectUpdate: e => ({
          type: `project-update`,
          entityId: e.projectUpdateId || e.id
      }),
      projectUpdatePrompt: e => ({
          type: `project-update-prompt`,
          entityId: e.projectId || e.id
      })
  },
  vC = class extends Px {
      getShortLabel() {
          return `New project update`
      }
      getNotificationCategory() {
          return D.postsAndUpdates
      }
      getNotificationGrouping(e) {
          return _C.projectUpdate(e)
      }
  }
  ,
  yC = class extends Px {
      getNotificationCategory() {
          return D.postsAndUpdates
      }
      getShortLabel() {
          return `Project update reminder`
      }
      getNotificationGrouping(e) {
          return _C.projectUpdatePrompt(e)
      }
  }
  ,
  bC = class extends Px {
      getShortLabel() {
          return `Reacted to project update`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return _C.projectUpdate(e)
      }
  }
  ,
  xC = class extends Px {
      getShortLabel() {
          return `Mentioned in project update`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return _C.projectUpdate(e)
      }
  }
  ,
  SC = class extends Px {
      getShortLabel() {
          return `New comment`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return _C.projectUpdate(e)
      }
  }
  ,
  CC = class extends Px {
      getShortLabel() {
          return `Mentioned in comment`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return _C.projectUpdate(e)
      }
  }
  ,
  wC = class extends Px {
      getShortLabel() {
          return `Reacted to comment`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return _C.projectUpdate(e)
      }
  }
}
)), EC, DC = t(( () => {
  EC = function(e) {
      return e.pending = `pending`,
      e.commented = `commented`,
      e.approved = `approved`,
      e.changesRequested = `changesRequested`,
      e
  }({})
}
)), OC, kC = t(( () => {
  OC = function(e) {
      return e.pending = `pending`,
      e.failed = `failed`,
      e.success = `success`,
      e.canceled = `canceled`,
      e
  }({})
}
));
function Yoe(e, t, n, r, i={}) {
  let a = i.decisionVerb ?? (t === EC.approved ? `approved` : t === EC.changesRequested ? `requested changes` : `reviewed`);
  return t === EC.changesRequested ? n === 0 || n === 1 ? `${e} ${a}`.trim() : `${e} ${a} with ${n} code comments`.trim() : n === 0 && !r ? `${e} ${a}`.trim() : n === 0 && r || n === 1 ? `${e} ${a} with comment`.trim() : `${e} ${a} with ${n} code comments`.trim()
}
var AC, jC, MC, NC, PC, FC, IC, LC, RC, zC, BC, VC, HC = t(( () => {
  AC = e(_(), 1),
  jC = e(Gt(), 1),
  DC(),
  kC(),
  Sl(),
  Fx(),
  MC = class extends Px {
      getNotificationGrouping(e) {
          return {
              type: `pull-request`,
              entityId: e.pullRequestId || e.id
          }
      }
      getNotificationCategory() {
          return D.reviews
      }
  }
  ,
  NC = class extends MC {
      getShortLabel() {
          return `Review requested`
      }
  }
  ,
  PC = class extends MC {
      getShortLabel() {
          return `Review re-requested`
      }
  }
  ,
  FC = class extends MC {
      getShortLabel() {
          return `Changes approved`
      }
  }
  ,
  IC = class extends MC {
      getShortLabel() {
          return `Changes requested`
      }
  }
  ,
  LC = class extends MC {
      getShortLabel() {
          return `Checks failed`
      }
      static getFailedRequiredChecks(e) {
          return e.filter(e => e.status === OC.failed && e.isRequired !== !1)
      }
      static getFailedChecks(e) {
          return e.filter(e => e.status === OC.failed)
      }
      static getFailedChecksMessage(e, t={
          requiredOnly: !0
      }) {
          let n = (0,
          AC.default)((t.requiredOnly ? this.getFailedRequiredChecks(e) : this.getFailedChecks(e)).map(e => e.name), e => {
              let t = e.toLowerCase();
              return [`lint`, `test`, `tsc`, `deploy`].includes(t) ? 0 : 1
          }
          , e => e.length)
            , r = n.length;
          return r === 0 ? `Checks failed` : r === 1 ? `${n[0]} check failed` : [r >= 4 ? `${n[0]}, ${n[1]}, and ${r - 2} more checks failed` : ``, r === 3 ? `${n[0]}, ${n[1]}, and ${n[2]} checks failed` : ``, r === 2 ? `${n[0]} and ${n[1]} checks failed` : ``, `${n[0]} and ${r - 1} more ${(0,
          jC.default)(`check`, r - 1)} failed`].find(e => e.length > 0 && e.length <= 64) ?? `${r} checks failed`
      }
  }
  ,
  RC = class extends MC {
      getShortLabel() {
          return `Removed from merge queue`
      }
  }
  ,
  zC = class extends MC {
      getShortLabel() {
          return `New comment`
      }
  }
  ,
  BC = class extends MC {
      getShortLabel() {
          return `Mentioned in pull request`
      }
  }
  ,
  VC = class extends MC {
      getShortLabel() {
          return `Mentioned in comment`
      }
  }
}
)), UC, WC, GC, KC, qC, JC, YC, XC = t(( () => {
  Sl(),
  Fx(),
  UC = {
      teamUpdate: e => ({
          type: `team-update`,
          entityId: e.postId || e.id
      })
  },
  WC = class extends Px {
      getNotificationCategory() {
          return D.postsAndUpdates
      }
      getShortLabel() {
          return `New team update`
      }
      getNotificationGrouping(e) {
          return UC.teamUpdate(e)
      }
  }
  ,
  GC = class extends Px {
      getShortLabel() {
          return `Mentioned in team update`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return UC.teamUpdate(e)
      }
  }
  ,
  KC = class extends Px {
      getShortLabel() {
          return `Reacted to team update`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return UC.teamUpdate(e)
      }
  }
  ,
  qC = class extends Px {
      getShortLabel() {
          return `New comment`
      }
      getNotificationCategory() {
          return D.commentsAndReplies
      }
      getNotificationGrouping(e) {
          return UC.teamUpdate(e)
      }
  }
  ,
  JC = class extends Px {
      getShortLabel() {
          return `Mentioned in comment`
      }
      getNotificationCategory() {
          return D.mentions
      }
      getNotificationGrouping(e) {
          return UC.teamUpdate(e)
      }
  }
  ,
  YC = class extends Px {
      getShortLabel() {
          return `Reacted to comment`
      }
      getNotificationCategory() {
          return D.reactions
      }
      getNotificationGrouping(e) {
          return UC.teamUpdate(e)
      }
  }
}
)), ZC, QC = t(( () => {
  Sl(),
  Fx(),
  ZC = class extends Px {
      getShortLabel() {
          return `New triage issue`
      }
      getNotificationCategory() {
          return D.triage
      }
      getNotificationGrouping(e) {
          return {
              type: `issue`,
              entityId: e.issueId || e.id
          }
      }
  }
}
)), $C, ew, tw, nw = t(( () => {
  Sl(),
  Fx(),
  $C = {
      issue: e => ({
          type: `issue`,
          entityId: e.issueId || e.id
      })
  },
  ew = class extends Px {
      getShortLabel() {
          return `Subscribed`
      }
      getNotificationCategory() {
          return D.subscriptions
      }
      getNotificationGrouping(e) {
          return $C.issue(e)
      }
  }
  ,
  tw = class extends Px {
      getShortLabel() {
          return `Unsubscribed`
      }
      getNotificationCategory() {
          return D.subscriptions
      }
      getNotificationGrouping(e) {
          return $C.issue(e)
      }
  }
}
)), rw, iw = t(( () => {
  Sl(),
  Fx(),
  rw = class extends Px {
      getShortLabel() {
          return `Reminder`
      }
      getNotificationCategory() {
          return D.reminders
      }
      getNotificationGrouping(e) {
          return {
              type: `issue-reminder`,
              entityId: e.issueId || e.id
          }
      }
  }
}
)), aw, ow = t(( () => {
  Sl(),
  Fx(),
  aw = class extends Px {
      getNotificationGrouping(e) {
          return {
              type: `customer`,
              entityId: e.customerId || e.id
          }
      }
      getShortLabel() {
          return `Added as customer owner`
      }
      getNotificationCategory() {
          return D.assignments
      }
  }
}
)), sw, cw = t(( () => {
  Hx(),
  Kx(),
  Zx(),
  dS(),
  hS(),
  OS(),
  LS(),
  GS(),
  YS(),
  rC(),
  gC(),
  TC(),
  HC(),
  XC(),
  QC(),
  nw(),
  iw(),
  ow(),
  sw = {
      IssueSubscribedNotificationPresenter: new ew,
      IssueUnsubscribedNotificationPresenter: new tw,
      IssueReminderNotificationPresenter: new rw,
      IssueAssignedToYouNotificationPresenter: new Wx,
      IssueUnassignedFromYouNotificationPresenter: new Gx,
      IssueCommentMentionNotificationPresenter: new Lx,
      IssueCommentReactionNotificationPresenter: new Bx,
      IssueNewCommentNotificationPresenter: new Rx,
      IssueThreadResolvedNotificationPresenter: new zx,
      IssueMentionNotificationPresenter: new VS,
      IssueCreatedNotificationPresenter: new BS,
      IssueAddedToViewNotificationPresenter: new zS,
      IssueAddedToTriageNotificationPresenter: new ZC,
      TriageResponsibilityIssueAddedToTriageNotificationPresenter: new ZC,
      IssueEmojiReactionNotificationPresenter: new HS,
      IssueBlockingNotificationPresenter: new US,
      IssueUnblockedNotificationPresenter: new WS,
      IssueSlackThreadSyncedNotificationPresenter: new Vx,
      IssueSlaBreachedNotificationPresenter: new JS,
      IssueSlaHighRiskNotificationPresenter: new qS,
      ProjectUpdateCommentMentionNotificationPresenter: new CC,
      ProjectUpdateCommentReactionNotificationPresenter: new wC,
      ProjectUpdateCreatedNotificationPresenter: new vC,
      ProjectUpdateMentionPromptNotificationPresenter: new xC,
      ProjectUpdateNewCommentNotificationPresenter: new SC,
      ProjectUpdateReactionNotificationPresenter: new bC,
      ProjectUpdatePromptNotificationPresenter: new yC,
      ProjectMilestoneCommentMentionNotificationPresenter: new ZS,
      ProjectMilestoneCommentReactionNotificationPresenter: new eC,
      ProjectMilestoneDescriptionContentChangeNotificationPresenter: new nC,
      ProjectMilestoneMentionNotificationPresenter: new tC,
      ProjectMilestoneNewCommentNotificationPresenter: new QS,
      ProjectMilestoneThreadResolvedNotificationPresenter: new $S,
      ProjectAddedAsLeadNotificationPresenter: new sC,
      ProjectAddedAsMemberNotificationPresenter: new aC,
      ProjectCommentMentionNotificationPresenter: new cC,
      ProjectCommentReactionNotificationPresenter: new dC,
      ProjectDescriptionContentChangeNotificationPresenter: new pC,
      ProjectMentionNotificationPresenter: new fC,
      ProjectNewCommentNotificationPresenter: new lC,
      ProjectThreadResolvedNotificationPresenter: new uC,
      ProjectReminderNotificationPresenter: new oC,
      ProjectDeletedNotificationPresenter: new mC,
      ProjectRestoredNotificationPresenter: new hC,
      DocumentCommentMentionNotificationPresenter: new $x,
      DocumentCommentReactionNotificationPresenter: new nS,
      DocumentContentChangeNotificationPresenter: new iS,
      DocumentDeletedNotificationPresenter: new oS,
      DocumentMentionNotificationPresenter: new rS,
      DocumentMovedNotificationPresenter: new aS,
      DocumentNewCommentNotificationPresenter: new eS,
      DocumentReminderNotificationPresenter: new cS,
      DocumentRestoredNotificationPresenter: new sS,
      DocumentSubscribedNotificationPresenter: new lS,
      DocumentThreadResolvedNotificationPresenter: new tS,
      DocumentUnsubscribedNotificationPresenter: new uS,
      TeamUpdateCommentMentionNotificationPresenter: new JC,
      TeamUpdateCommentReactionNotificationPresenter: new YC,
      TeamUpdateCreatedNotificationPresenter: new WC,
      TeamUpdateMentionNotificationPresenter: new GC,
      TeamUpdateNewCommentNotificationPresenter: new qC,
      TeamUpdateReactionNotificationPresenter: new KC,
      InitiativeUpdateCommentMentionNotificationPresenter: new FS,
      InitiativeUpdateCommentReactionNotificationPresenter: new IS,
      InitiativeUpdateCreatedNotificationPresenter: new AS,
      InitiativeUpdateMentionNotificationPresenter: new MS,
      InitiativeUpdateNewCommentNotificationPresenter: new PS,
      InitiativeUpdatePromptNotificationPresenter: new jS,
      InitiativeUpdateReactionNotificationPresenter: new NS,
      InitiativeDeletedNotificationPresenter: new TS,
      InitiativeRestoredNotificationPresenter: new DS,
      InitiativeMovedNotificationPresenter: new ES,
      FeedSummaryGeneratedNotificationPresenter: new mS,
      InitiativeAddedAsOwnerNotificationPresenter: new _S,
      InitiativeCommentMentionNotificationPresenter: new yS,
      InitiativeCommentReactionNotificationPresenter: new SS,
      InitiativeDescriptionContentChangeNotificationPresenter: new wS,
      InitiativeMentionNotificationPresenter: new CS,
      InitiativeNewCommentNotificationPresenter: new bS,
      InitiativeThreadResolvedNotificationPresenter: new xS,
      InitiativeReminderNotificationPresenter: new vS,
      PullRequestApprovedNotificationPresenter: new FC,
      PullRequestChangesRequestedNotificationPresenter: new IC,
      PullRequestChecksFailedNotificationPresenter: new LC,
      PullRequestCommentedNotificationPresenter: new zC,
      PullRequestCommentMentionNotificationPresenter: new VC,
      PullRequestMentionNotificationPresenter: new BC,
      PullRequestRemovedFromMergeQueueNotificationPresenter: new RC,
      PullRequestReviewRequestedNotificationPresenter: new NC,
      PullRequestReviewRerequestedNotificationPresenter: new PC,
      CustomerNeedCreatedNotificationPresenter: new Jx,
      CustomerNeedMarkedAsImportantNotificationPresenter: new Yx,
      CustomerNeedResolvedNotificationPresenter: new Xx,
      CustomerAddedAsOwnerNotificationPresenter: new aw
  }
}
));
function lw(e) {
  if ([`docs`, `overview`, `documentation`, `activity`].includes(e))
      return {
          tab: dw.documents
      };
  if (e === `customer-requests` || e === `requests`)
      return {
          tab: dw.customers
      };
  if (Object.values(dw).includes(e))
      return {
          tab: e
      };
  if (Ka(e))
      return {
          facetId: e
      }
}
function uw(e=dw.issues) {
  switch (e) {
  case dw.customers:
      return `Customers`;
  case dw.documents:
      return `Overview`;
  case dw.issues:
      return `Issues`;
  case dw.updates:
      return `Updates`;
  default:
      throw y(e)
  }
}
function Xoe(e=dw.issues) {
  switch (e) {
  case dw.customers:
  case dw.documents:
  case dw.issues:
      return uw(e);
  case dw.updates:
      return `updates and activity`;
  default:
      throw y(e)
  }
}
function Zoe({tab: e, activeTab: t, activeFacetId: n}) {
  return t === e && n === void 0 || n === e
}
var dw, fw = t(( () => {
  qa(),
  zn(),
  dw = function(e) {
      return e.customers = `customers`,
      e.documents = `documents`,
      e.issues = `issues`,
      e.updates = `updates`,
      e
  }({})
}
));
function Qoe(e) {
  if (Object.values(pw).includes(e))
      return {
          tab: e
      };
  if (Ka(e))
      return {
          facetId: e
      }
}
function $oe(e) {
  switch (e) {
  case pw.overview:
      return `Overview`;
  case pw.projects:
      return `Projects`;
  case pw.updates:
      return `Updates`;
  default:
      throw y(e)
  }
}
function ese({tab: e, activeTab: t, activeFacetId: n}) {
  return t === e && n === void 0 || n === e
}
var pw, mw = t(( () => {
  zn(),
  qa(),
  pw = function(e) {
      return e.overview = `overview`,
      e.projects = `projects`,
      e.updates = `updates`,
      e
  }({})
}
));
function tse(e) {
  switch (e) {
  case hw.resources:
      return `Overview`;
  case hw.updates:
      return `Updates`;
  case hw.allIssues:
      return `Issues`;
  default:
      throw y(e)
  }
}
function nse({tab: e, activeTab: t, activeFacetId: n}) {
  return t === e && n === void 0 || n === e
}
var hw, gw = t(( () => {
  zn(),
  hw = function(e) {
      return e.resources = `resources`,
      e.updates = `updates`,
      e.allIssues = `all`,
      e
  }({})
}
)), _w, vw, yw, bw, xw, Sw, Cw, ww = t(( () => {
  St(),
  _w = 1e4,
  vw = 100,
  yw = function(e) {
      return e.commentThread = `commentThread`,
      e
  }({}),
  bw = function(e) {
      return e.pending = `pending`,
      e.active = `active`,
      e.complete = `complete`,
      e.awaitingInput = `awaitingInput`,
      e.error = `error`,
      e.stale = `stale`,
      e
  }({}),
  xw = function(e) {
      return e.pending = `pending`,
      e.inProgress = `inProgress`,
      e.completed = `completed`,
      e.canceled = `canceled`,
      e
  }({}),
  Sw = dt({
      content: yt().min(1, `Plan entry content cannot be empty`).max(_w, `Plan entry content cannot exceed ${_w} characters`),
      status: vt(xw, {
          errorMap: () => ({
              message: `Status must be one of: ${Object.values(xw).join(`, `)}`
          })
      })
  }).strict(),
  Cw = Dt(Sw).min(1, `Plan must contain at least one entry`).max(vw, `Plan cannot exceed ${vw} entries`),
  dt({
      entries: Cw,
      updatedAt: yt().datetime()
  }).strict()
}
)), Tw, Ew = t(( () => {
  zn(),
  Tw = function(e) {
      return e.assigned = `assigned`,
      e.created = `created`,
      e
  }({}),
  (function(e) {
      function t(e) {
          switch (e) {
          case Tw.assigned:
              return `Assigned`;
          case Tw.created:
              return `Created`;
          default:
              throw y(e)
          }
      }
      e.labelForType = t
  }
  )(Tw ||= {})
}
)), Dw, Ow = t(( () => {
  Dw = function(e) {
      return e.me = `me`,
      e.all = `all`,
      e
  }({}),
  (function(e) {
      function t(e) {
          return !!e && Object.keys(Dw).includes(e)
      }
      e.isValid = t
  }
  )(Dw ||= {})
}
)), kw, Aw = t(( () => {
  Hb(),
  Yr(),
  Xs(),
  kw = class e {
      static async exportPullRequestReviewAsMarkdown(t) {
          let n = [];
          n.push(`# ${t.title}`),
          t.descriptionMarkdown && n.push(`\n${t.descriptionMarkdown}`),
          t.linkedIssues && t.linkedIssues.length > 0 && (n.push(`
## Linked issues`),
          n.push(`
` + e.formatSubIssues(t.linkedIssues)));
          let r = t.comments ?? []
            , i = e => e.isTopLevel === !0 || e.parentId == null
            , a = r.filter(e => i(e) && e.anchor?.path);
          if (a.length > 0) {
              n.push(`
## Comments`);
              let t = a.slice().sort( (t, n) => {
                  let r = t.anchor?.path || ``
                    , i = n.anchor?.path || ``;
                  if (r !== i)
                      return r.localeCompare(i);
                  let[a] = e.parseLineRange(t.anchor?.diffHunk)
                    , [o] = e.parseLineRange(n.anchor?.diffHunk);
                  return (a ?? 0) - (o ?? 0)
              }
              ).map(t => e.formatPullRequestComment(t)).join(`

`);
              n.push(`
` + t)
          }
          return n.join(`
`)
      }
      static async exportIssueAsMarkdown(t) {
          return [`# ${t.title}`, t.descriptionMarkdown ? `\n${t.descriptionMarkdown}` : ``, t.videoSummaries ? `\n## Video summaries\n\n${t.videoSummaries}` : void 0, `
## Metadata`, `${e.formatIssueProperties(t)}`, t.customerNeeds.length > 0 ? `\n## Customer requests\n\n${e.formatCustomerNeeds(t.customerNeeds)}` : void 0, ...e.formatAttachmentSections(t.attachments), t.comments.length > 0 ? `\n## Comments\n\n${e.formatComments(t.comments)}` : void 0, t.subIssues.length > 0 ? `\n## Sub-issues\n\n${e.formatSubIssues(t.subIssues)}` : void 0].concrete().join(`
`)
      }
      static async exportProjectAsMarkdown(t) {
          return [`# ${t.name}`, t.summary ? `\n## ${t.summary}` : void 0, t.descriptionMarkdown ? `\n${t.descriptionMarkdown}` : void 0, t.projectMilestones.length > 0 ? `\n## Milestones\n${e.formatProjectMilestones(t.projectMilestones)}` : void 0, `
## Metadata`, `${e.formatProjectProperties(t)}`].concrete().join(`
`)
      }
      static async exportProjectCustomerRequestsAsMarkdown(t) {
          return [`# ${t.name}`, t.customerNeeds.length > 0 ? `\n## Customer requests\n\n${e.formatCustomerNeeds(t.customerNeeds)}` : void 0].concrete().join(`
`)
      }
      static async exportCustomerRequestsAsMarkdown(t) {
          return [`# ${t.name}`, t.customerNeeds.length > 0 ? `\n## Customer requests\n\n${e.formatCustomerNeeds(t.customerNeeds)}` : void 0].concrete().join(`
`)
      }
      static async exportInitiativeAsMarkdown(t) {
          return [`# ${t.name}`, t.descriptionMarkdown ? `\n${t.descriptionMarkdown}\n` : ``, `## Projects
`, t.projects.length > 0 ? e.formatInitiativeProjects(t.projects) : `None`].concrete().join(`
`)
      }
      static async exportUpdateAsMarkdown(t, n) {
          let {includeComments: r=!1, includeName: i=!0} = n ?? {}
            , a = `[${t.parentName.replace(/[\[\]]/g, `\\$&`)}](${t.parentUrl})`
            , o = [Vb.emojiForUpdateHealth(t.health), Vb.labelForUpdateHealth(t.health), `| ${t.userName ? `${t.userName} posted an update on` : `Posted on`} ${xr(t.createdAt)}`].concrete().join(` `)
            , s = [];
          if (i && s.push(a + `
`),
          s.push(o + `
`),
          s.push(t.bodyMarkdown),
          t.diffMarkdown && s.push(`
` + t.diffMarkdown),
          r) {
              let n = t.comments.filter(e => !e.isSyncedExternalThreadRoot);
              if (n.length > 0) {
                  let t = e.formatComments(n);
                  s.push(`
*Comments:*

` + t)
              }
          }
          return s.join(`
`)
      }
      static formatInitiativeProjects(e) {
          return e.map(e => `- ${e.name} - ${e.status}${e.summary ? `\n\n  ${e.summary}` : ``}`).join(`

`)
      }
      static formatProjectMilestones(e) {
          let t = e => e.descriptionMarkdown?.split(`
`).map(e => `  ${e}`).join(`
`) || ``;
          return e.map(e => `\n- ${e.name}${e.targetDate ? ` - Target date: ${e.targetDate.toISOString()}` : ``}${e.descriptionMarkdown ? `\n\n${t(e)}` : ``}`).join(`
`)
      }
      static formatComments(e) {
          let t = e.slice().sort( (e, t) => e.createdAt.getTime() - t.createdAt.getTime())
            , n = t.map(e => e.id);
          if (new Set(n).size !== n.length)
              throw Error(`Comment IDs are not unique`);
          let r = new Map;
          for (let e of t) {
              let t = e.parentId;
              r.has(t) || r.set(t, []),
              r.get(t).push(e)
          }
          let i = (e, n=0) => {
              let a = `  `.repeat(n)
                , {sourceMetadata: o} = e
                , s = o?.subType && o.externalSyncRoot ? Ys.getDisplayName(o.subType) : void 0
                , c = t.some(t => t.resolvingCommentId === e.id)
                , l = e.resolvedAt != null
                , u = c ? ` (thread resolution)` : l ? ` (thread resolved)` : ``
                , d = `${a}- ${e.author || (s ? `${s} integration` : `Unknown author`)}${u}:`
                , f = `  `.repeat(n + 1)
                , p = e.bodyMarkdown.split(`
`).map( (e, t) => `${t === 0 ? `` : f}${e}`.trimEnd()).join(`
`)
                , m = r.get(e.id) || [];
              return `${d}\n\n${f}${p}${m.length > 0 ? `

` + m.map(e => i(e, n + 1)).join(`

`) : ``}`
          }
          ;
          return (r.get(void 0) || []).map(e => i(e)).join(`

`)
      }
      static formatCustomerNeeds(e) {
          let t = e => e.bodyMarkdown?.split(`
`).map(e => `  ${e}`.trimEnd()).join(`
`);
          return [...e].sort( (e, t) => t.createdAt.getTime() - e.createdAt.getTime()).map(e => {
              let n = t(e) ?? void 0
                , r = e.feature ? `[${e.feature.type === `issue` ? `Issue` : `Project`}${e.feature.identifier ? ` ${e.feature.identifier}` : ``}: ${e.feature.name}](${e.feature.url})` : e.customer ? `[${e.customer.name}](${e.customer.url})` : `No customer`
                , i = e.createdAt.toLocaleDateString(void 0, {
                  month: `short`,
                  day: `numeric`,
                  year: `numeric`
              });
              return [`- ${r}${e.isImportant ? ` (important)` : ``}  ${i}`, n].concrete().join(`

`)
          }
          ).join(`

`)
      }
      static formatProjectProperties(e) {
          return [`- URL: [${e.url}](${e.url})`, `- Status: ${e.status}`, `- Lead: ${e.lead || `No lead`}`, e.members.length > 0 ? `- Members: ${e.members.join(`, `)}` : void 0, `- Start date: ${e.startDate ? e.startDate : `Not set`}`, `- Target date: ${e.targetDate ? e.targetDate : `Not set`}`].concrete().join(`
`)
      }
      static formatIssueProperties(e) {
          let {labels: t, project: n} = e;
          return [`- URL: [${e.url}](${e.url})`, `- Identifier: ${e.identifier}`, `- Status: ${e.status}`, `- Priority: ${e.priority || `No priority`}`, `- Assignee: ${e.assignee || `Unassigned`}`, t.length > 0 ? `- Labels: ${t.map(e => e.name).join(`, `)}` : void 0, n ? `- Project: [${n.name}](${n.url}). ${n.summary}` : void 0, e.projectMilestone ? `- Project milestone: ${e.projectMilestone.name}${e.projectMilestone.targetDate ? ` (target: ${e.projectMilestone.targetDate.toISOString()})` : ``}` : void 0, e.cycle ? `- Cycle: ${e.cycle.name} (#${e.cycle.number})` : void 0, e.slaBreachesAt ? `- SLA: ${e.slaBreachesAt.toISOString()}` : void 0, e.dueDate ? `- Due date: ${e.dueDate.toISOString()}` : void 0, `- Created: ${e.createdAt.toISOString()}`, `- Updated: ${e.updatedAt.toISOString()}`].concrete().join(`
`)
      }
      static formatSubIssues(e) {
          return e.map(e => `- [${e.identifier} ${e.title}](${e.url})`).join(`
`)
      }
      static formatAttachmentSections(e) {
          let t = []
            , n = []
            , r = [];
          for (let i of e) {
              let e = `[${i.title}](${i.url})${i.subtitle ? ` - ${i.subtitle}` : ``}`;
              i.source?.type === `github` || i.source?.type === `gitlab` ? n.push(`- ${e}`) : i.source?.type === `sentry` ? r.push(`- ${e}`) : t.push(`- ${e}`)
          }
          return [n.length > 0 ? `\n## Pull requests\n\n${n.join(`
`)}` : void 0, r.length > 0 ? `\n## Sentry issues\n\n${r.join(`
`)}` : void 0, t.length > 0 ? `\n## Links\n\n${t.join(`
`)}` : void 0].concrete()
      }
      static formatPullRequestComment(t) {
          let n = []
            , r = t.anchor?.path ?? `Unknown`
            , [i,a] = e.parseLineRange(t.anchor?.diffHunk)
            , o = i == null ? void 0 : a && a > 1 ? `L${i}${i + a - 1}` : `L${i}`;
          n.push(`### ${r}${o ? ` (${o})` : ``}`);
          let s = (t.author || `Unknown`).trim()
            , c = s.startsWith(`@`) ? s : `@${s}`
            , l = e.extractFirstTextLine(t.bodyMarkdown);
          n.push(`**${c}:** ${l || ``}`.trim());
          let u = e.extractCurrentLineFromDiff(t.anchor?.diffHunk);
          u && (n.push(`
Context:`),
          n.push("```ts\n// current\n" + u + "\n```"));
          let d = e.extractSuggestionFromBody(t.bodyMarkdown);
          return d && (n.push(`
Suggested:`),
          n.push("```ts\n" + d.trimEnd() + "\n```")),
          n.join(`
`)
      }
      static parseLineRange(e) {
          if (!e)
              return [void 0, void 0];
          let t = e.match(/@@[^@]*\+(\d+)(?:,(\d+))?/);
          return t ? [Number(t[1]), t[2] ? Number(t[2]) : 1] : [void 0, void 0]
      }
      static extractFirstTextLine(e) {
          if (e)
              return e.replace(/```[\s\S]*?```/g, ``).split(`
`).map(e => e.trim()).filter(e => e.length > 0)[0]
      }
      static extractCurrentLineFromDiff(e) {
          if (!e)
              return;
          let t = e.split(`
`).filter(e => !e.startsWith(`@@`))
            , n = t.find(e => e.startsWith(`-`));
          if (n)
              return n.slice(1);
          let r = t.find(e => e.startsWith(` `));
          return r ? r.slice(1) : void 0
      }
      static extractSuggestionFromBody(e) {
          if (!e)
              return;
          let t = e.match(/```suggestion\n([\s\S]*?)```/);
          if (t)
              return t[1]
      }
  }
}
));
function jw(e, t, n=1) {
  e.forEach( (e, r) => {
      let i = n + r;
      e.childCount !== 0 && jw(e.content, t, i + 1),
      t(e, i)
  }
  )
}
var Mw = t(( () => {}
));
function rse(e, t) {
  let n = [];
  return jw(e.content, (e, r) => {
      e.type === t && n.push([e, r])
  }
  ),
  n
}
var Nw = t(( () => {
  Mw()
}
)), Pw, Fw = t(( () => {
  cn(),
  Pw = (e, t, n) => e.selection.empty ? (n?.dom.blur(),
  !!n) : (t && t(e.tr.setSelection(fn.create(e.tr.doc, e.tr.selection.to))),
  !0)
}
)), ise = t(( () => {}
));
function Iw(e, t, n) {
  let r = [];
  if (!Array.isArray(e.content))
      return r;
  for (let i = 0, a = e.content.length; i < a; ++i) {
      let a = e.content[i];
      t(a) && r.push(a),
      n?.deep && r.push(...Iw(a, t, n))
  }
  return r
}
var ase = t(( () => {}
));
function Lw(e, t, n) {
  let r = null;
  return e.doc.descendants( (i, a) => {
      if (i.attrs.id === t && (!n || i.type.name === n)) {
          let t = e.doc.resolve(a + 1);
          return r = {
              node: i,
              pos: a,
              start: t.start(),
              depth: t.depth
          },
          !1
      }
      return !0
  }
  ),
  r
}
function ose(e, t) {
  return Lw(e, t, `code_block`)
}
var Rw = t(( () => {}
)), zw, sse = t(( () => {
  zw = (e, t) => {
      let n = null;
      return e.content.forEach(e => {
          if (e.type.name === t)
              return n = e,
              !1;
          e.childCount > 0 && (n = zw(e, t))
      }
      ),
      n
  }
}
));
function cse(e, t, n, r, i) {
  let a = [];
  return n.doc.nodesBetween(e, t, (e, t) => {
      a = [...a, ...e.marks.filter(e => r && e.type !== r ? !1 : i ? i(e.attrs) : !0).map(n => ({
          start: t,
          end: t + e.nodeSize,
          mark: n,
          text: e.textContent
      }))]
  }
  ),
  a
}
var Bw = t(( () => {}
)), Vw, lse = t(( () => {
  Vw = (e, t) => {
      let {from: n, to: r} = e.selection
        , i = [];
      e.doc.nodesBetween(n, r, e => {
          i = [...i, ...e.marks]
      }
      );
      let a = i.find(e => e.type.name === t.name);
      return a ? a.attrs : {}
  }
}
)), Hw, Uw = t(( () => {
  Hw = (e, t=null) => {
      if (!e || !t)
          return !1;
      let n = e.parent.childAfter(e.parentOffset);
      if (!n.node)
          return !1;
      let r = n.node.marks.find(e => e.type === t);
      if (!r)
          return !1;
      let i = e.index()
        , a = e.start() + n.offset
        , o = i + 1
        , s = a + n.node.nodeSize;
      for (; i > 0 && r.isInSet(e.parent.child(i - 1).marks); )
          --i,
          a -= e.parent.child(i).nodeSize;
      for (; o < e.parent.childCount && r.isInSet(e.parent.child(o).marks); )
          s += e.parent.child(o).nodeSize,
          o += 1;
      return {
          from: a,
          to: s
      }
  }
}
)), Ww, Gw, Kw = t(( () => {
  Ww = `hide-link-popovers`,
  Gw = e => {
      e.dispatch(e.state.tr.setMeta(Ww, !0))
  }
}
)), qw, Jw = t(( () => {
  qw = e => e.childCount <= 1 && e.content.size <= 2 && e.textContent === ``
}
)), Yw, Xw = t(( () => {
  Yw = (e, t) => {
      let {from: n, $from: r, to: i, empty: a} = e.selection;
      return a ? e.storedMarks && !!t.isInSet(e.storedMarks) || !!t.isInSet(r.marks()) : !!e.doc.rangeHasMark(n, i, t)
  }
}
)), Zw, Qw, $w = t(( () => {
  Zw = (e, t) => {
      let n = Object.keys(t);
      return n.length ? n.every(n => t[n] === e[n]) : !0
  }
  ,
  Qw = (e, t, n={}) => {
      let {from: r, to: i, empty: a} = e.selection
        , o = [];
      e.doc.nodesBetween(r, i, (e, t) => {
          if (e.isText)
              return;
          let n = Math.max(r, t)
            , a = Math.min(i, t + e.nodeSize);
          o.push({
              node: e,
              from: n,
              to: a
          })
      }
      );
      let s = i - r
        , c = o.filter(e => t ? t.name === e.node.type.name : !0).filter(e => Zw(e.node.attrs, n));
      return a ? !!c.length : c.reduce( (e, t) => e + t.to - t.from, 0) >= s
  }
}
));
function use(e) {
  let t = e.getMeta(`y-sync$`);
  return t !== void 0 && !t.isUndoRedoOperation
}
var eT = t(( () => {}
));
function dse(e) {
  return !!e.getMeta(`y-sync$`)?.isUndoRedoOperation
}
var fse = t(( () => {}
));
function pse(e) {
  return tT(e?.type)
}
function tT(e) {
  return e ? rT(e.name) : !1
}
function mse(e) {
  return e ? nT(e.type.name) : !1
}
function nT(e) {
  return [`list_item`, `todo_item`].includes(e)
}
function rT(e) {
  return [`bullet_list`, `ordered_list`, `todo_list`].includes(e)
}
function hse(e, t) {
  let n = e.doc.resolve(t);
  return !!(nT(n.node(-1)?.type.name) && n.node(-1) && n.index(n.depth - 1) === 0 && n.nodeBefore?.type.name !== `hard_break`)
}
var iT = t(( () => {}
));
function gse(e) {
  return e.type.name === `suggestion_userMentions` || e.type.name === `issueMention` || e.type.name === `entityMention` || e.type.name === `documentMention`
}
var _se = t(( () => {}
)), aT, oT = t(( () => {
  aT = (e, t) => t.isInSet(e.$anchor.marks()) || t.isInSet(e.$head.marks())
}
));
function sT(e) {
  let t = new Set;
  for (let n = e.$anchor.depth; n--; )
      t.add(e.$anchor.node(n).type);
  return t
}
var cT = t(( () => {}
));
function vse(e, t, n=!1) {
  let r;
  if (t) {
      let n = e.state.doc.resolve(t.from)
        , i = e.state.doc.resolve(t.to)
        , a = n.nodeAfter;
      r = t instanceof hn ? t : a && t.to === t.from + a.nodeSize ? new un(n) : new fn(n,i)
  } else
      r = e.state.selection;
  let {from: i, to: a} = r
    , o = sn.atStart(e.state.doc).from
    , s = sn.atEnd(e.state.doc).to;
  if (i < o && a > s && (i = o,
  a = s),
  r instanceof hn) {
      let e = r.$anchorCell.pos
        , t = r.$headCell.pos;
      i = Math.min(t, e),
      a = Math.max(t, e)
  }
  let c = e.coordsAtPos(i)
    , l = e.coordsAtPos(a, -1)
    , u = Math.min(c.top, l.top)
    , d = n ? u - e.dom.getBoundingClientRect().top : u
    , f = Math.max(c.bottom, l.bottom)
    , p = Math.min(c.left, l.left)
    , m = Math.max(c.right, l.right)
    , h = f - u
    , g = m - p;
  if (r instanceof un && r.node.type.name === `image`) {
      let e = r.node.attrs.displayWidth ?? r.node.attrs.width;
      if (e && e < g) {
          let t = g;
          g = e,
          p += (t - e) / 2,
          m -= (t - e) / 2
      }
  }
  if (r instanceof un && r.node.type.name === `collapsible_section`) {
      let t = window.getSelection();
      if (t) {
          let r = t.getRangeAt(0).getClientRects();
          if (r.length >= 1) {
              let t = r.length === 1 ? r[0] : Array.from(r).slice(1).reduce( (e, t) => ({
                  left: Math.min(e.left, t.left),
                  top: Math.min(e.top, t.top),
                  right: Math.max(e.right, t.right),
                  bottom: Math.max(e.bottom, t.bottom)
              }), {
                  left: 1 / 0,
                  top: 1 / 0,
                  right: -1 / 0,
                  bottom: -1 / 0
              });
              p = t.left,
              d = n ? t.top - e.dom.getBoundingClientRect().top : t.top,
              d -= 2.5,
              g = t.right - t.left,
              h = t.bottom - t.top
          }
      }
  }
  return new DOMRectReadOnly(p,d,g,h)
}
var yse = t(( () => {
  cn(),
  mn()
}
));
function bse(e, t) {
  let {$from: n} = e.selection
    , r = n.nodeBefore
    , i = n.depth;
  for (; i > 0 && !r; )
      r = e.doc.resolve(n.before(i)).nodeBefore,
      i--;
  return r ? t(r) : !1
}
var xse = t(( () => {}
));
function Sse(e, t) {
  let {$from: n} = e.selection
    , r = n.nodeBefore
    , i = n.depth
    , a = n.pos;
  for (; i > 0 && !r; )
      a = n.before(i),
      r = e.doc.resolve(a).nodeBefore,
      i--;
  if (!r || !t(r))
      return null;
  let o = a - r.nodeSize
    , s = e.doc.resolve(o + 1);
  return {
      node: r,
      pos: o,
      start: s.start(),
      depth: s.depth
  }
}
var lT = t(( () => {}
)), uT, Cse = t(( () => {
  iT(),
  cT(),
  uT = e => {
      if (e.selection.empty) {
          let t = sT(e.selection);
          for (let e of t)
              if (tT(e))
                  return !0
      }
      return !1
  }
}
));
function wse(e) {
  return e.replace(/~1/g, `/`).replace(/~0/g, `~`)
}
function Tse(e) {
  return e.replace(/~/g, `~0`).replace(/\//g, `~1`)
}
var dT, fT = t(( () => {
  dT = class e {
      constructor(e=[``]) {
          this.tokens = e
      }
      static fromJSON(t) {
          let n = t.split(`/`).map(wse);
          if (n[0] !== ``)
              throw Error(`Invalid JSON Pointer: ${t}`);
          return new e(n)
      }
      toString() {
          return this.tokens.map(Tse).join(`/`)
      }
      evaluate(e) {
          let t = null
            , n = ``
            , r = e;
          for (let e = 1, i = this.tokens.length; e < i; e++)
              t = r,
              n = this.tokens[e],
              !(n == `__proto__` || n == `constructor` || n == `prototype`) && (r = (t || {})[n]);
          return {
              parent: t,
              key: n,
              value: r
          }
      }
      get(e) {
          return this.evaluate(e).value
      }
      set(e, t) {
          let n = this.evaluate(e);
          n.parent && (n.parent[n.key] = t)
      }
      push(e) {
          this.tokens.push(e)
      }
      add(t) {
          return new e(this.tokens.concat(String(t)))
      }
  }
}
));
function pT(e) {
  return e === void 0 ? `undefined` : e === null ? `null` : Array.isArray(e) ? `array` : typeof e
}
function Ese(e) {
  return typeof e == `object` && !!e
}
function mT(e) {
  if (!Ese(e))
      return e;
  if (e.constructor == Array) {
      let t = e.length
        , n = Array(t);
      for (let r = 0; r < t; r++)
          n[r] = mT(e[r]);
      return n
  }
  if (e.constructor == Date)
      return new Date(+e);
  let t = {};
  for (let n in e)
      hT.call(e, n) && (t[n] = mT(e[n]));
  return t
}
var hT, gT = t(( () => {
  hT = Object.prototype.hasOwnProperty
}
));
function _T(e, t) {
  let n = {};
  for (let t in e)
      hT.call(e, t) && e[t] !== void 0 && (n[t] = 1);
  for (let e in t)
      hT.call(t, e) && t[e] !== void 0 && delete n[e];
  return Object.keys(n)
}
function Dse(e) {
  let t = e.length
    , n = {};
  for (let r = 0; r < t; r++) {
      let t = e[r];
      for (let e in t)
          hT.call(t, e) && t[e] !== void 0 && (n[e] = (n[e] || 0) + 1)
  }
  for (let e in n)
      n[e] < t && delete n[e];
  return Object.keys(n)
}
function Ose(e) {
  return e.op === `add`
}
function kse(e) {
  return e.op === `remove`
}
function Ase(e, t, n) {
  let r = e[t][n];
  if (!r)
      throw Error(`invalid memo`);
  let i = [];
  for (; r && r.prev && r.operation; ) {
      i.push(r.operation);
      let t = r.prev.split(`,`);
      r = e[Number(t[0])][Number(t[1])]
  }
  return i.reverse()
}
function jse(e, t, n, r=vT) {
  r === void 0 && (r = vT);
  let i = isNaN(e.length) || e.length <= 0 ? 0 : e.length
    , a = isNaN(t.length) || t.length <= 0 ? 0 : t.length
    , o = i
    , s = a;
  for (; o > 0 && s > 0 && (0,
  yT.default)(e[o - 1], t[s - 1]); )
      o--,
      s--;
  let c = Array(o + 1);
  for (let e = 0; e <= o; e++)
      c[e] = Array(s + 1);
  c[0][0] = {
      prev: null,
      operation: null,
      cost: 0
  };
  for (let n = 0; n <= o; n++)
      for (let r = 0; r <= s; r++) {
          let i = c[n][r];
          if (i)
              continue;
          let a = `${n},${r - 1}`
            , o = `${n - 1},${r}`
            , s = `${n - 1},${r - 1}`
            , l = {
              op: `remove`,
              index: n - 1
          }
            , u = {
              op: `add`,
              index: n - 1,
              value: t[r - 1]
          };
          if (r === 0)
              i = {
                  prev: o,
                  operation: l,
                  cost: c[n - 1][r].cost + 1
              };
          else if (n === 0)
              i = {
                  prev: a,
                  operation: u,
                  cost: c[n][r - 1].cost + 1
              };
          else if ((0,
          yT.default)(e[n - 1], t[r - 1]))
              i = c[n - 1][r - 1];
          else {
              let d = c[n - 1][r]
                , f = c[n][r - 1]
                , p = c[n - 1][r - 1]
                , m = Math.min(p.cost, f.cost, d.cost);
              i = d.cost === m ? {
                  prev: o,
                  operation: l,
                  cost: c[n - 1][r].cost + 1
              } : f.cost === m ? {
                  prev: a,
                  operation: u,
                  cost: c[n][r - 1].cost + 1
              } : {
                  prev: s,
                  operation: {
                      op: `replace`,
                      index: n - 1,
                      original: e[n - 1],
                      value: t[r - 1]
                  },
                  cost: c[n - 1][r - 1].cost + 1
              }
          }
          c[n][r] = i
      }
  let[l] = Ase(c, o, s).reduce( ([e,t], a) => {
      if (Ose(a)) {
          let r = a.index + 1 + t
            , o = r < i + t ? String(r) : `-`
            , s = {
              op: a.op,
              path: n.add(o).toString(),
              value: a.value
          };
          return [e.concat(s), t + 1]
      } else if (kse(a)) {
          let r = {
              op: a.op,
              path: n.add(String(a.index + t)).toString()
          };
          return [e.concat(r), t - 1]
      } else {
          let i = n.add(String(a.index + t))
            , o = r(a.original, a.value, i);
          return [e.concat(...o), t]
      }
  }
  , [[], 0]);
  return l
}
function Mse(e, t, n, r=vT) {
  let i = [];
  return _T(e, t).forEach(e => {
      i.push({
          op: `remove`,
          path: n.add(e).toString()
      })
  }
  ),
  _T(t, e).forEach(e => {
      i.push({
          op: `add`,
          path: n.add(e).toString(),
          value: t[e]
      })
  }
  ),
  Dse([e, t]).forEach(a => {
      i.push(...r(e[a], t[a], n.add(a)))
  }
  ),
  i
}
function vT(e, t, n, r=vT) {
  if (e === t || Number.isNaN(e) && Number.isNaN(t))
      return [];
  let i = pT(e)
    , a = pT(t);
  return i == `array` && a == `array` ? jse(e, t, n, r) : i == `object` && a == `object` ? Mse(e, t, n, r) : [{
      op: `replace`,
      path: n.toString(),
      value: t
  }]
}
var yT, bT = t(( () => {
  yT = e(ne(), 1),
  gT()
}
));
function xT(e, t, n) {
  if (Array.isArray(e))
      if (t == `-`)
          e.push(n);
      else {
          let r = parseInt(t, 10);
          e.splice(r, 0, n)
      }
  else
      e[t] = n
}
function ST(e, t) {
  if (Array.isArray(e)) {
      let n = parseInt(t, 10);
      e.splice(n, 1)
  } else
      delete e[t]
}
function Nse(e, t) {
  let n = dT.fromJSON(t.path).evaluate(e);
  return n.parent === void 0 ? new CT(t.path) : (xT(n.parent, n.key, mT(t.value)),
  null)
}
function Pse(e, t) {
  let n = dT.fromJSON(t.path).evaluate(e);
  return n.value === void 0 ? new CT(t.path) : (ST(n.parent, n.key),
  null)
}
function Fse(e, t) {
  let n = dT.fromJSON(t.path).evaluate(e);
  if (n.parent === null)
      return new CT(t.path);
  if (Array.isArray(n.parent)) {
      if (parseInt(n.key, 10) >= n.parent.length)
          return new CT(t.path)
  } else if (n.value === void 0)
      return new CT(t.path);
  return n.parent[n.key] = mT(t.value),
  null
}
function Ise(e, t) {
  let n = dT.fromJSON(t.from).evaluate(e);
  if (n.value === void 0)
      return new CT(t.from);
  let r = dT.fromJSON(t.path).evaluate(e);
  return r.parent === void 0 ? new CT(t.path) : (ST(n.parent, n.key),
  xT(r.parent, r.key, n.value),
  null)
}
function Lse(e, t) {
  let n = dT.fromJSON(t.from).evaluate(e);
  if (n.value === void 0)
      return new CT(t.from);
  let r = dT.fromJSON(t.path).evaluate(e);
  return r.parent === void 0 ? new CT(t.path) : (xT(r.parent, r.key, mT(n.value)),
  null)
}
function Rse(e, t) {
  let n = dT.fromJSON(t.path).evaluate(e);
  return vT(n.value, t.value, new dT).length ? new wT(n.value,t.value) : null
}
function zse(e, t) {
  switch (t.op) {
  case `add`:
      return Nse(e, t);
  case `remove`:
      return Pse(e, t);
  case `replace`:
      return Fse(e, t);
  case `move`:
      return Ise(e, t);
  case `copy`:
      return Lse(e, t);
  case `test`:
      return Rse(e, t);
  default:
      return new TT(t)
  }
  return new TT(t)
}
var CT, wT, TT, Bse = t(( () => {
  fT(),
  gT(),
  bT(),
  CT = class extends Error {
      constructor(e) {
          super(`Value required at path: ${e}`),
          this.path = e,
          this.name = `MissingError`
      }
  }
  ,
  wT = class extends Error {
      constructor(e, t) {
          super(`Test failed: ${e} != ${t}`),
          this.actual = e,
          this.expected = t,
          this.name = `TestError`
      }
  }
  ,
  TT = class extends Error {
      constructor(e) {
          super(`Invalid operation: ${e.op}`),
          this.operation = e,
          this.name = `InvalidOperationError`
      }
  }
}
));
function ET(e, t) {
  return t.map(t => zse(e, t))
}
function Vse(e) {
  function t(n, r, i) {
      let a = e(n, r, i);
      return Array.isArray(a) ? a : vT(n, r, i, t)
  }
  return t
}
function DT(e, t, n) {
  let r = new dT;
  return (n ? Vse(n) : vT)(e, t, r)
}
var Hse = t(( () => {
  fT(),
  Bse(),
  bT()
}
));
function OT(e, t) {
  let n = t.content.findDiffStart(e.content);
  if (n === null)
      return !1;
  let {a: r, b: i} = t.content.findDiffEnd(e.content)
    , a = n - Math.min(r, i);
  return a > 0 && (e.resolve(n - a).depth < t.resolve(r + a).depth ? n -= a : (r += a,
  i += a)),
  new rn(n,i,t.slice(n, r))
}
var kT = t(( () => {
  ln()
}
));
function Use(e) {
  if (!e.steps.length)
      return;
  let t = new dn(e.docs[0])
    , n = e.steps.slice();
  for (; n.length; ) {
      let e = n.shift();
      for (; n.length && e.merge(n[0]); ) {
          let r = n.shift();
          e = e instanceof rn && r instanceof rn ? OT(t.doc, r.apply(e.apply(t.doc).doc).doc) : e.merge(r)
      }
      t.step(e)
  }
  return t
}
var Wse = t(( () => {
  ln(),
  kT()
}
));
function AT(e) {
  let t = new dn(e);
  return t.removeMark(0, e.nodeSize - 2),
  t.doc
}
var Gse = t(( () => {
  ln()
}
));
function Kse(e, t) {
  let n = t.split(`/`);
  for (n.shift(); n.length; ) {
      if (typeof e != `object`)
          throw Error();
      let t = n.shift();
      e = e[t]
  }
  return e
}
var qse = t(( () => {}
));
function jT(e) {
  return JSON.parse(JSON.stringify(e))
}
var Jse = t(( () => {}
));
function MT(e, t, n={}) {
  return new NT(e,t,n).init()
}
var NT, Yse = t(( () => {
  ln(),
  Cn(),
  Hse(),
  kT(),
  Wse(),
  Gse(),
  qse(),
  Jse(),
  NT = class {
      fromDoc;
      toDoc;
      complexSteps;
      wordDiffs;
      simplifyDiff;
      schema;
      tr;
      currentJSON;
      finalJSON;
      ops;
      constructor(e, t, n={}) {
          let r = {
              complexSteps: !0,
              wordDiffs: !1,
              simplifyDiff: !0,
              ...n
          };
          this.fromDoc = e,
          this.toDoc = t,
          this.complexSteps = r.complexSteps,
          this.wordDiffs = r.wordDiffs,
          this.simplifyDiff = r.simplifyDiff,
          this.schema = e.type.schema,
          this.tr = new dn(e),
          this.currentJSON = {},
          this.finalJSON = {},
          this.ops = []
      }
      init() {
          return this.complexSteps ? (this.currentJSON = AT(this.fromDoc).toJSON(),
          this.finalJSON = AT(this.toDoc).toJSON(),
          this.ops = DT(this.currentJSON, this.finalJSON),
          this.recreateChangeContentSteps(),
          this.recreateChangeMarkSteps()) : (this.currentJSON = this.fromDoc.toJSON(),
          this.finalJSON = this.toDoc.toJSON(),
          this.ops = DT(this.currentJSON, this.finalJSON),
          this.recreateChangeContentSteps()),
          this.simplifyDiff && (this.tr = Use(this.tr) || this.tr),
          this.tr
      }
      recreateChangeContentSteps() {
          let e = [];
          for (; this.ops.length; ) {
              let t = this.ops.shift();
              e.push(t);
              let n, r = jT(this.currentJSON), i = t.path.split(`/`);
              for (; n == null; ) {
                  ET(r, [t]);
                  try {
                      n = this.schema.nodeFromJSON(r),
                      n.check()
                  } catch {
                      if (n = null,
                      this.ops.length > 0)
                          t = this.ops.shift(),
                          e.push(t);
                      else
                          throw Error(`No valid diff possible applying ${t.path}`)
                  }
              }
              this.complexSteps && e.length === 1 && (i.includes(`attrs`) || i.includes(`type`)) ? (this.addSetNodeMarkup(),
              e = []) : e.length === 1 && t.op === `replace` && i[i.length - 1] === `text` ? (this.addReplaceTextSteps(t, r),
              e = []) : this.addReplaceStep(n, r) && (e = [])
          }
      }
      addSetNodeMarkup() {
          let e = this.schema.nodeFromJSON(this.currentJSON)
            , t = this.schema.nodeFromJSON(this.finalJSON)
            , n = t.content.findDiffStart(e.content)
            , r = e.nodeAt(n)
            , i = t.nodeAt(n);
          if (n != null) {
              let e = r.type === i.type ? null : i.type;
              try {
                  this.tr.setNodeMarkup(n, e, i.attrs, i.marks)
              } catch (t) {
                  if (e && (t.message.includes(`Invalid content`) || t.message.includes(`NodeType.create can't construct text nodes`)))
                      this.tr.replaceWith(n, n + r.nodeSize, i);
                  else
                      throw t
              }
              return this.currentJSON = AT(this.tr.doc).toJSON(),
              this.ops = DT(this.currentJSON, this.finalJSON),
              !0
          }
          return !1
      }
      recreateChangeMarkSteps() {
          this.toDoc.descendants( (e, t) => {
              if (!e.isInline)
                  return !0;
              this.tr.doc.nodesBetween(t, t + e.nodeSize, (n, r) => {
                  if (!n.isInline)
                      return !0;
                  let i = Math.max(t, r)
                    , a = Math.min(t + e.nodeSize, r + n.nodeSize);
                  n.marks.forEach(t => {
                      t.isInSet(e.marks) || this.tr.removeMark(i, a, t)
                  }
                  ),
                  e.marks.forEach(e => {
                      e.isInSet(n.marks) || this.tr.addMark(i, a, e)
                  }
                  )
              }
              )
          }
          )
      }
      addReplaceStep(e, t) {
          let n = OT(this.schema.nodeFromJSON(this.currentJSON), e);
          if (n) {
              if (!this.tr.maybeStep(n).failed)
                  return this.currentJSON = t,
                  !0
          } else
              return !1;
          throw Error(`No valid step found.`)
      }
      addReplaceTextSteps(e, t) {
          let n = {
              ...e,
              value: `xx`
          }
            , r = {
              ...e,
              value: `yy`
          }
            , i = jT(this.currentJSON)
            , a = jT(this.currentJSON);
          ET(i, [n]),
          ET(a, [r]);
          let o = this.schema.nodeFromJSON(i)
            , s = this.schema.nodeFromJSON(a)
            , c = e.value
            , l = Kse(this.currentJSON, e.path)
            , u = this.wordDiffs ? fte(l, c) : lte(l, c)
            , d = o.content.findDiffStart(s.content)
            , f = o.resolve(d + 1).marks();
          for (; u.length; ) {
              let e = u.shift();
              if (e.added) {
                  let t = this.schema.nodeFromJSON({
                      type: `text`,
                      text: e.value
                  }).mark(f);
                  if (u.length && u[0].removed) {
                      let e = u.shift();
                      this.tr.replaceWith(d, d + e.value.length, t)
                  } else
                      this.tr.insert(d, t);
                  d += e.value.length
              } else if (e.removed)
                  if (u.length && u[0].added) {
                      let t = u.shift()
                        , n = this.schema.nodeFromJSON({
                          type: `text`,
                          text: t.value
                      }).mark(f);
                      this.tr.replaceWith(d, d + e.value.length, n),
                      d += t.value.length
                  } else
                      this.tr.delete(d, d + e.value.length);
              else
                  d += e.value.length
          }
          this.currentJSON = t
      }
  }
}
)), PT = t(( () => {
  Yse()
}
));
function FT(e, t) {
  if (e === t)
      return 0;
  let n = e.length
    , r = t.length;
  if (n === 0)
      return r;
  if (r === 0)
      return n;
  if (n > r)
      return FT(t, e);
  let i = Array(n + 1)
    , a = Array(n + 1);
  for (let e = 0; e <= n; e++)
      i[e] = e;
  for (let o = 1; o <= r; o++) {
      a[0] = o;
      let r = t.charCodeAt(o - 1);
      for (let t = 1; t <= n; t++) {
          let n = e.charCodeAt(t - 1) === r ? 0 : 1
            , o = i[t] + 1
            , s = a[t - 1] + 1
            , c = i[t - 1] + n;
          a[t] = o < s ? o < c ? o : c : s < c ? s : c
      }
      for (let e = 0; e <= n; e++)
          i[e] = a[e]
  }
  return i[n]
}
function IT(e, t=750) {
  return e = e.replace(/\s+/g, ` `).trim(),
  e.length > t ? e.substring(0, t) + `...` : e
}
var LT, RT, Xse = t(( () => {
  ote(),
  PT(),
  ml(),
  Gp(),
  LT = class e {
      static calculateDiff(t, n, r) {
          let i = dl.nodeFromJSON(n)
            , a = dl.nodeFromJSON(t);
          try {
              let t = MT(a, i, {
                  complexSteps: !1,
                  simplifyDiff: !0,
                  wordDiffs: !0
              });
              return {
                  changes: ste(cte.create(a).addSteps(i, t.mapping.maps, []).changes, i).map(e => ({
                      fromA: e.fromA,
                      toA: e.toA,
                      fromB: e.fromB,
                      toB: e.toB
                  })),
                  changesVersion: e.DIFF_FORMAT_VERSION,
                  baseDocument: a,
                  currentDocument: i
              }
          } catch (e) {
              return r?.warning(`[Editor] Error while calculating diff`, {
                  error: e
              }),
              {
                  baseDocument: a,
                  currentDocument: i,
                  changes: [],
                  changesVersion: 0
              }
          }
      }
      static isNotificationWorthy(e) {
          let {baseDocument: t, currentDocument: n, changes: r} = e;
          for (let e of r) {
              let r = t.slice(e.fromA, e.toA)
                , i = r.content.textBetween(0, r.content.size)
                , a = n.slice(e.fromB, e.toB)
                , o = a.content.textBetween(0, a.content.size);
              if (i.trim() !== `` || o.trim() !== ``)
                  return !0;
              for (let e of [r, a])
                  for (let t = 0; t < e.content.childCount; t++) {
                      let n = e.content.child(t);
                      if (RT.includes(n.type.name))
                          return !0
                  }
          }
          return !1
      }
      static getAdditionsAsMarkdown(e, t) {
          if (t.length === 0)
              return ``;
          let n = !1
            , r = [];
          for (let i of t)
              if (i.fromB < i.toB) {
                  let t = e.slice(i.fromB, i.toB);
                  if (t.content.size > 0) {
                      n = !0;
                      let e = t.content;
                      for (let t = 0; t < e.childCount; t++)
                          r.push(e.child(t))
                  }
              }
          if (!n)
              return ``;
          let i = [];
          for (let e of r) {
              let t = Hp.serialize(e);
              t.trim() && i.push(t.trim())
          }
          return i.join(`

`)
      }
      static distance(t, n) {
          try {
              let {baseDocument: r, currentDocument: i, changes: a} = e.calculateDiff(t, n);
              if (!a || a.length === 0) {
                  let e = r.textBetween(0, r.content.size, ` `, ` `).replace(/\s+/g, ` `).trim()
                    , t = i.textBetween(0, i.content.size, ` `, ` `).replace(/\s+/g, ` `).trim();
                  if (e === t)
                      return 0;
                  let n = Math.max(1, Math.max(e.length, t.length));
                  return FT(e, t) / n
              }
              let o = e => e.textBetween(0, e.content.size, ` `, ` `).replace(/\s+/g, ` `).trim().length
                , s = e => {
                  let t = 0
                    , n = e => {
                      RT.includes(e.type.name) && (t += 1);
                      for (let t = 0; t < e.childCount; t++)
                          n(e.child(t))
                  }
                  ;
                  return n(e),
                  t
              }
                , c = o(r) + s(r) * 4
                , l = o(i) + s(i) * 4
                , u = Math.max(1, Math.max(c, l))
                , d = 0;
              for (let e of a) {
                  let t = ``
                    , n = 0;
                  if (e.fromA < e.toA) {
                      let i = r.slice(e.fromA, e.toA)
                        , a = dl.node(`doc`, void 0, i.content);
                      t = a.textBetween(0, a.content.size, ` `, ` `).replace(/\s+/g, ` `).trim(),
                      n = s(a)
                  }
                  let a = ``
                    , o = 0;
                  if (e.fromB < e.toB) {
                      let t = i.slice(e.fromB, e.toB)
                        , n = dl.node(`doc`, void 0, t.content);
                      a = n.textBetween(0, n.content.size, ` `, ` `).replace(/\s+/g, ` `).trim(),
                      o = s(n)
                  }
                  let c = FT(t, a)
                    , l = (n + o) * 4;
                  d += c + l
              }
              let f = d / u;
              return Math.max(0, Math.min(1, f))
          } catch {
              try {
                  let e = dl.nodeFromJSON(t)
                    , r = dl.nodeFromJSON(n)
                    , i = e.textBetween(0, e.content.size, ` `, ` `).replace(/\s+/g, ` `).trim()
                    , a = r.textBetween(0, r.content.size, ` `, ` `).replace(/\s+/g, ` `).trim()
                    , o = Math.max(1, Math.max(i.length, a.length));
                  return FT(i, a) / o
              } catch {
                  return 1
              }
          }
      }
      static processRawChangesToText(t, n, r) {
          let i = [];
          if (!t || !n)
              return [];
          try {
              let a = dl.nodeFromJSON(t)
                , o = dl.nodeFromJSON(n);
              for (let t of r) {
                  let n = ``;
                  if (t.fromA < t.toA) {
                      let e = a.slice(t.fromA, t.toA);
                      n = e.content.textBetween(0, e.content.size, ` `, ` `)
                  }
                  let r = ``;
                  if (t.fromB < t.toB) {
                      let e = o.slice(t.fromB, t.toB);
                      r = e.content.textBetween(0, e.content.size, ` `, ` `)
                  }
                  let s = e.determineChangeType(t)
                    , c = ``;
                  s === `addition` && r.trim() ? c = `Added: "${IT(r)}"` : s === `deletion` && n.trim() ? c = `Removed: "${IT(n)}"` : s === `modification` && (r.trim() || n.trim()) && (r.trim() && n.trim() ? c = `Changed from "${IT(n)}" to "${IT(r)}"` : r.trim() ? c = `Added: "${IT(r)}"` : n.trim() && (c = `Removed: "${IT(n)}"`)),
                  c && i.push({
                      type: s,
                      description: c
                  })
              }
          } catch {
              return []
          }
          return i
      }
      static DIFF_FORMAT_VERSION = 1;
      static determineChangeType(e) {
          let t = e.fromB < e.toB
            , n = e.fromA < e.toA;
          return t && n ? `modification` : t ? `addition` : `deletion`
      }
  }
  ,
  RT = [`file`, `image`, `video`, `audio`, `embed`, `figma`, `entityMention`, `issueMention`, `entityEmbed`, `suggestion_userMentions`, `iframe`]
}
)), zT, BT, Zse = t(( () => {
  cr(),
  gv(),
  zT = [`issueMention`, `documentMention`, `entityMention`, `entityEmbed`, `suggestion_userMentions`],
  BT = class {
      static serializeWithBareUrls(e, t) {
          let n = t.type.schema;
          return hv.replaceNodeWhenSync(t, e => zT.includes(e.type.name), t => {
              if (t.type.name === `suggestion_userMentions`) {
                  let r = t.attrs.id;
                  if (typeof r == `string`) {
                      let t = `${sr.CLIENT_URL}/${e}/profiles/${r}`
                        , i = n.marks.link.create({
                          href: t
                      });
                      return n.text(t, [i])
                  }
                  return t
              }
              let r = t.attrs.href;
              return typeof r == `string` ? n.text(r) : t
          }
          )
      }
  }
}
)), VT = t(( () => {
  Nw(),
  il(),
  Fw(),
  ise(),
  _y(),
  ase(),
  Rw(),
  sse(),
  vp(),
  Bw(),
  lse(),
  Uw(),
  Kw(),
  Jw(),
  Xw(),
  $w(),
  Uy(),
  Mw(),
  eT(),
  fse(),
  iT(),
  _se(),
  oT(),
  cT(),
  yse(),
  xse(),
  Oy(),
  lT(),
  Cse(),
  gv(),
  Xse(),
  Zse()
}
)), HT, UT = t(( () => {
  HT = function(e) {
      return e.organization = `organization`,
      e.user = `user`,
      e
  }({})
}
));
function WT(e) {
  switch (e) {
  case GT.Planned:
      return `Planned`;
  case GT.Active:
      return `Active`;
  case GT.Completed:
      return `Completed`;
  default:
      throw y(e)
  }
}
function Qse(e) {
  switch (e) {
  case GT.Planned:
      return `#949698`;
  case GT.Active:
      return `#F2C94C`;
  case GT.Completed:
      return `#5E68D0`;
  default:
      throw y(e)
  }
}
var GT, KT = t(( () => {
  zn(),
  GT = function(e) {
      return e.Planned = `Planned`,
      e.Active = `Active`,
      e.Completed = `Completed`,
      e
  }({})
}
)), qT, $se = t(( () => {
  qT = function(e) {
      return e[e.hasDocuments = 0] = `hasDocuments`,
      e[e.hasFacets = 1] = `hasFacets`,
      e
  }({})
}
)), JT, YT, XT, ZT, QT, $T, eE, tE, nE, rE, iE, aE, oE, sE, cE = t(( () => {
  JT = function(e) {
      return e.issueSnapshot = `issueSnapshot`,
      e.issue = `issue`,
      e
  }({}),
  YT = function(e) {
      return e.day = `day`,
      e.week = `week`,
      e.quarter = `quarter`,
      e.month = `month`,
      e.year = `year`,
      e.thirtyMinutes = `thirtyMinutes`,
      e
  }({}),
  YT.quarter,
  YT.year,
  XT = function(e) {
      return e.count = `count`,
      e.avg = `avg`,
      e.max = `max`,
      e.min = `min`,
      e.sum = `sum`,
      e.median = `median`,
      e.p25 = `p25`,
      e.p75 = `p75`,
      e.p90 = `p90`,
      e.p95 = `p95`,
      e.p99 = `p99`,
      e
  }({}),
  XT.p25,
  XT.median,
  XT.p75,
  XT.p90,
  XT.p95,
  XT.p99,
  ZT = function(e) {
      return e.stateName = `stateName`,
      e.priority = `priority`,
      e.estimate = `estimate`,
      e.cycle = `cycle`,
      e.label = `label`,
      e.labelGroup = `labelGroup`,
      e.stateType = `stateType`,
      e.creator = `creator`,
      e.assignee = `assignee`,
      e.delegate = `delegate`,
      e.snapshotAt = `snapshotAt`,
      e.completedAt = `completedAt`,
      e.dueDate = `dueDate`,
      e.createdAt = `createdAt`,
      e.startedAt = `startedAt`,
      e.canceledAt = `canceledAt`,
      e.addedToCycleAt = `addedToCycleAt`,
      e.cyclePeriod = `cyclePeriod`,
      e.project = `project`,
      e.projectMilestone = `projectMilestone`,
      e.projectLabel = `projectLabel`,
      e.projectLabelGroup = `projectLabelGroup`,
      e.team = `team`,
      e.initiative = `initiative`,
      e.sla = `sla`,
      e.lastAppliedTemplateId = `lastAppliedTemplateId`,
      e.externalSource = `externalSource`,
      e
  }({}),
  QT = function(e) {
      return e.id = `id`,
      e.effort = `effort`,
      e
  }({}),
  $T = function(e) {
      return e.cycleTime = `cycleTime`,
      e.timeToTriage = `timeToTriage`,
      e.timeToStart = `timeToStart`,
      e.leadTime = `leadTime`,
      e.age = `age`,
      e.timeInState = `timeInState`,
      e.timeInStateType = `timeInStateType`,
      e
  }({}),
  eE = {
      ...QT,
      ...$T
  },
  tE = function(e) {
      return e.nivoBar = `nivoBar`,
      e.nivoScatterPlot = `nivoScatterPlot`,
      e
  }({}),
  nE = [`lte`, `gt`],
  rE = [ZT.label, ZT.labelGroup, ZT.projectLabel, ZT.projectLabelGroup, ZT.project, ZT.initiative, ZT.stateName, ZT.team],
  iE = [ZT.dueDate, ZT.createdAt, ZT.startedAt, ZT.completedAt, ZT.canceledAt, ZT.snapshotAt, ZT.addedToCycleAt],
  ZT.priority,
  ZT.estimate,
  ZT.cycle,
  aE = function(e) {
      return e.default = `default`,
      e.categorical = `categorical`,
      e.turboRed = `turboRed`,
      e.turboBlue = `turboBlue`,
      e.magmaLight = `magmaLight`,
      e.magmaDark = `magmaDark`,
      e
  }({}),
  oE = [`graph`, `table`, `number`],
  sE = [`linear`, `log`]
}
));
function lE(e, t, n) {
  return e + (t - e) * n
}
function uE(e, t, n) {
  return (n - e) / (t - e)
}
function ece(e) {
  return e * (2 - e)
}
var dE = t(( () => {}
)), fE, pE = t(( () => {
  dE(),
  fE = class {
      static #e = this.ZOOM_WHEEL_SENSITIVITY = 1 / 20;
      static #t = this.ZOOM_TRACKPAD_PINCH_SENSITIVITY = 4 / 20;
      static #n = this.ZOOM_STEP = 4;
      static #r = this.PRESET_ZOOM_LEVEL_DAY_WIDTHS = {
          year: 2.5,
          quarter: 5,
          month: 15,
          week: 30
      };
      static get defaultZoomLevel() {
          return this.zoomScaleForLevel(`year`)
      }
      static #i = this.ZOOM_SCALE_MIN = .5;
      static #a = this.ZOOM_SCALE_MAX = 100;
      static #o = this.DAY_WIDTH_MIN = 1;
      static #s = this.DAY_WIDTH_MAX = 60;
      static zoomScaleForLevel(e) {
          return this.dayWidthToZoomScale(this.PRESET_ZOOM_LEVEL_DAY_WIDTHS[e])
      }
      static zoomLevelForScale(e) {
          let t = this.zoomScaleToDayWidth(e);
          return Object.entries(this.PRESET_ZOOM_LEVEL_DAY_WIDTHS).reduce( (e, [n,r]) => Math.abs(r - t) < Math.abs(this.PRESET_ZOOM_LEVEL_DAY_WIDTHS[e] - t) ? n : e, `year`)
      }
      static zoomScaleToDayWidth(e) {
          return lE(this.DAY_WIDTH_MIN, this.DAY_WIDTH_MAX, uE(this.ZOOM_SCALE_MIN, this.ZOOM_SCALE_MAX, e) ** 2)
      }
      static dayWidthToZoomScale(e) {
          return lE(this.ZOOM_SCALE_MIN, this.ZOOM_SCALE_MAX, Math.sqrt(uE(this.DAY_WIDTH_MIN, this.DAY_WIDTH_MAX, e)))
      }
  }
}
)), mE, tce = t(( () => {
  pE(),
  Bu(),
  Jc(),
  UT(),
  mE = class {
      constructor(e, t, n, r, i=!1, a=!1, o=!1) {
          return this.type = e,
          this.viewType = t,
          this.preferences = n,
          this.organizationPreferences = r,
          this.isProjectArchived = i,
          this.slasEnabled = a,
          this.roadmapsEnabled = o,
          new Proxy(this,{
              get(e, t) {
                  return t in e ? e[t] : e.getPreference(t)
              }
          })
      }
      get layout() {
          return this.viewType === k.completedCycle || this.viewType === k.myIssues && this.preferences.issueGrouping === `focus` || this.viewType === k.subIssues ? `list` : this.getPreference(`layout`) ?? `list`
      }
      get issueGrouping() {
          if (this.viewType === k.archive)
              return `none`;
          let e = this.getPreference(`issueGrouping`);
          if (this.isIssuesBoard) {
              if (e === void 0 && this.viewType === k.backlog)
                  return `priority`;
              if (e === `none` || e === void 0)
                  return `workflowState`
          }
          return e ?? (this.viewType === k.myIssues ? `focus` : this.viewType === k.myIssuesActivity ? `activityDate` : this.isIssuesBoard ? `workflowState` : this.isUserIssuesView ? `none` : `workflowState`)
      }
      get showParents() {
          return this.viewType === k.subIssues ? !1 : this.getPreference(`showParents`) ?? !0
      }
      get showSubTeamIssues() {
          return this.getPreference(`showSubTeamIssues`) ?? !0
      }
      get showSubTeamProjects() {
          return this.getPreference(`showSubTeamProjects`) ?? !0
      }
      get showSubInitiativeProjects() {
          return this.getPreference(`showSubInitiativeProjects`) ?? !0
      }
      get showArchivedItems() {
          return this.getPreference(`showArchivedItems`) ?? !0
      }
      get showTriageIssues() {
          return this.viewType === k.archive || this.viewType === k.subIssues ? !0 : this.getPreference(`showTriageIssues`) ?? [k.userProfileCreatedByUser, k.myIssues, k.myIssuesCreatedByMe, k.myIssuesSubscribedTo, k.myIssuesActivity, k.userProfile, k.quickView, k.issueIdentifiers].includes(this.viewType)
      }
      get showSnoozedItems() {
          return this.getPreference(`showSnoozedItems`) ?? !1
      }
      get showCompletedIssues() {
          return this.viewType === k.completedCycle || this.isProjectArchived ? `all` : this.getPreference(`showCompletedIssues`) ?? (this.viewType === k.userProfile ? `all` : this.viewType === k.myIssues ? `day` : `all`)
      }
      get showReadItems() {
          return this.getPreference(`showReadItems`) ?? !0
      }
      get showUnreadItemsFirst() {
          return this.getPreference(`showUnreadItemsFirst`) ?? !1
      }
      get showSubIssues() {
          return this.getPreference(`showSubIssues`) ?? !0
      }
      get issueNesting() {
          return this.viewType === k.subIssues ? `showChildren` : this.getPreference(`issueNesting`) ?? `none`
      }
      get showEmptyGroups() {
          return this.getPreference(`showEmptyGroups`) ?? !1
      }
      get showEmptyGroupsBoard() {
          return this.getPreference(`showEmptyGroupsBoard`)
      }
      get showEmptyGroupsList() {
          return this.getPreference(`showEmptyGroupsList`)
      }
      get issueSubGrouping() {
          return this.issueGrouping !== `none` && this.getPreference(`issueSubGrouping`) || `none`
      }
      get fieldId() {
          return this.viewType === k.subIssues ? this.getPreference(`fieldId`) ?? !1 : this.getPreference(`fieldId`) ?? !0
      }
      get fieldStatus() {
          return this.getPreference(`fieldStatus`) ?? !0
      }
      get fieldPriority() {
          return this.viewType === k.subIssues ? this.getPreference(`fieldPriority`) ?? this.getPreference(`viewOrdering`) === `priority` : this.getPreference(`fieldPriority`) ?? !0
      }
      get fieldDateCreated() {
          return this.viewType === k.archive || this.viewType === k.subIssues ? !1 : this.getPreference(`fieldDateCreated`) ?? (this.isUserIssuesView ? this.viewType !== k.myIssuesActivity : !0)
      }
      get fieldDateUpdated() {
          return this.viewType === k.subIssues ? !1 : this.getPreference(`fieldDateUpdated`) ?? !1
      }
      get fieldDateArchived() {
          return this.viewType === k.archive ? !0 : this.getPreference(`fieldDateArchived`) ?? !1
      }
      get fieldDateMyActivity() {
          return this.getPreference(`fieldDateMyActivity`) ?? this.viewType === k.myIssuesActivity
      }
      get fieldAssignee() {
          return this.getPreference(`fieldAssignee`) ?? !0
      }
      get fieldEstimate() {
          return this.getPreference(`fieldEstimate`) ?? !0
      }
      get fieldPullRequests() {
          return this.getPreference(`fieldPullRequests`) ?? !0
      }
      get fieldPreviewLinks() {
          return this.getPreference(`fieldPreviewLinks`) ?? !0
      }
      get fieldSentryIssues() {
          return this.getPreference(`fieldSentryIssues`) ?? !0
      }
      get fieldDueDate() {
          return this.getPreference(`fieldDueDate`) ?? !0
      }
      get fieldLinkCount() {
          return this.getPreference(`fieldLinkCount`) ?? !1
      }
      get fieldCustomerCount() {
          return this.getPreference(`fieldCustomerCount`) ?? !1
      }
      get fieldCustomerRevenue() {
          return this.getPreference(`fieldCustomerRevenue`) ?? !1
      }
      get fieldSla() {
          return this.getPreference(`fieldSla`) ?? (this.viewType === k.inbox ? !1 : this.slasEnabled)
      }
      get fieldLabels() {
          return !(this.getPreference(`fieldLabels`) ?? this.viewType === k.inbox)
      }
      get fieldProject() {
          return !(this.getPreference(`fieldProject`) ?? this.viewType === k.inbox)
      }
      get fieldCycle() {
          return this.getPreference(`fieldCycle`) ?? this.viewType !== k.inbox
      }
      get viewOrdering() {
          return this.getPreference(`viewOrdering`) ?? (this.viewType === k.userProfile ? `dateUpdated` : this.viewType === k.myIssuesActivity ? `dateMyActivity` : this.isUserIssuesView ? `dateCreated` : `priority`)
      }
      get triageViewOrdering() {
          let e = this.getPreference(`triageViewOrdering`);
          return e === `dateCreated` || e === `reverseDateCreated` ? `startedTriage` : e ?? `startedTriage`
      }
      get closedIssuesOrderedByRecency() {
          return this.getPreference(`closedIssuesOrderedByRecency`) ?? !1
      }
      get searchViewOrdering() {
          return this.getPreference(`searchViewOrdering`) ?? `relevance`
      }
      get projectFieldStatus() {
          return this.getPreference(`projectFieldStatus`) ?? !0
      }
      get projectFieldActivity() {
          return this.getPreference(`projectFieldActivity`) ?? !1
      }
      get projectFieldCustomerCount() {
          return this.getPreference(`projectFieldCustomerCount`) ?? !1
      }
      get projectFieldCustomerRevenue() {
          return this.getPreference(`projectFieldCustomerRevenue`) ?? !1
      }
      get projectFieldPriority() {
          return this.getPreference(`projectFieldPriority`) ?? !0
      }
      get projectFieldLabels() {
          return this.getPreference(`projectFieldLabels`) ?? !1
      }
      get projectFieldStatusTimeline() {
          return this.getPreference(`projectFieldStatusTimeline`) ?? !0
      }
      get projectFieldLead() {
          return this.getPreference(`projectFieldLead`) ?? !0
      }
      get projectFieldLeadTimeline() {
          return this.getPreference(`projectFieldLeadTimeline`) ?? !0
      }
      get projectFieldHealth() {
          return this.getPreference(`projectFieldHealth`) ?? !0
      }
      get projectFieldHealthTimeline() {
          return this.getPreference(`projectFieldHealthTimeline`) ?? !0
      }
      get projectFieldDescription() {
          return this.getPreference(`projectFieldDescription`) ?? !0
      }
      get projectFieldDescriptionBoard() {
          return this.getPreference(`projectFieldDescriptionBoard`) ?? !0
      }
      get projectFieldMilestone() {
          return this.getPreference(`projectFieldMilestone`) ?? !0
      }
      get projectFieldMilestoneTimeline() {
          return this.getPreference(`projectFieldMilestoneTimeline`) ?? !0
      }
      get projectFieldPredictionsTimeline() {
          return this.getPreference(`projectFieldPredictionsTimeline`) ?? !0
      }
      get projectFieldRelationsTimeline() {
          return this.getPreference(`projectFieldRelationsTimeline`) ?? !0
      }
      get projectFieldStartDate() {
          return this.getPreference(`projectFieldStartDate`) ?? !1
      }
      get projectFieldTargetDate() {
          return this.getPreference(`projectFieldTargetDate`) ?? !0
      }
      get projectFieldDateCreated() {
          return this.getPreference(`projectFieldDateCreated`) ?? !1
      }
      get projectFieldDateUpdated() {
          return this.getPreference(`projectFieldDateUpdated`) ?? !1
      }
      get projectFieldDateCompleted() {
          return this.getPreference(`projectFieldDateCompleted`) ?? !1
      }
      get projectFieldMembers() {
          return this.getPreference(`projectFieldMembers`) ?? !1
      }
      get projectFieldMembersBoard() {
          return this.getPreference(`projectFieldMembersBoard`) ?? !1
      }
      get projectFieldMembersList() {
          return this.getPreference(`projectFieldMembersList`) ?? !1
      }
      get projectFieldMembersTimeline() {
          return this.getPreference(`projectFieldMembersTimeline`) ?? !1
      }
      get projectFieldRoadmaps() {
          return this.getPreference(`projectFieldRoadmaps`) ?? this.roadmapsEnabled
      }
      get projectFieldRoadmapsBoard() {
          return this.getPreference(`projectFieldRoadmapsBoard`) ?? this.roadmapsEnabled
      }
      get projectFieldRoadmapsList() {
          return this.getPreference(`projectFieldRoadmapsList`) ?? this.roadmapsEnabled
      }
      get projectFieldRoadmapsTimeline() {
          return this.getPreference(`projectFieldRoadmapsTimeline`) ?? this.roadmapsEnabled
      }
      get projectFieldTeams() {
          return this.getPreference(`projectFieldTeams`) ?? !1
      }
      get projectFieldTeamsBoard() {
          return this.getPreference(`projectFieldTeamsBoard`) ?? !1
      }
      get projectFieldTeamsList() {
          return this.getPreference(`projectFieldTeamsList`) ?? !1
      }
      get projectFieldTeamsTimeline() {
          return this.getPreference(`projectFieldTeamsTimeline`) ?? !1
      }
      get projectLayout() {
          return this.getPreference(`projectLayout`) ?? ([k.projects, k.roadmap, k.initiative].includes(this.viewType) ? `timeline` : `list`)
      }
      get projectViewOrdering() {
          return this.getPreference(`projectViewOrdering`) || (this.viewType === k.initiativeOverview ? `priority` : `sortOrder`)
      }
      get projectGrouping() {
          let e = this.getPreference(`projectGrouping`);
          return e === `milestone` ? this.isProjectsBoard ? `status` : `none` : this.isProjectsBoard && (e === `none` || e === void 0) ? `status` : e || (this.viewType === k.initiativeOverview ? `status` : `none`)
      }
      get projectGroupOrdering() {
          return this.getPreference(`projectGroupOrdering`) ?? `name`
      }
      get projectSubGrouping() {
          return this.projectGrouping !== `none` && this.getPreference(`projectSubGrouping`) || `none`
      }
      get projectLabelGroupColumns() {
          return this.projectLayout === `list` && this.getPreference(`projectLabelGroupColumns`) || []
      }
      get projectGroupingDateResolution() {
          return this.getPreference(`projectGroupingDateResolution`) ?? qc.quarter
      }
      get projectShowEmptyGroups() {
          return this.getPreference(`projectShowEmptyGroups`) ?? `all`
      }
      get projectShowEmptyGroupsList() {
          return this.getPreference(`projectShowEmptyGroupsList`) ?? `none`
      }
      get projectShowEmptyGroupsTimeline() {
          return this.getPreference(`projectShowEmptyGroupsTimeline`) ?? `none`
      }
      get projectShowEmptyGroupsBoard() {
          return this.getPreference(`projectShowEmptyGroupsBoard`) ?? `all`
      }
      get projectShowEmptySubGroups() {
          return this.getPreference(`projectShowEmptySubGroups`) ?? `all`
      }
      get projectShowEmptySubGroupsList() {
          return this.getPreference(`projectShowEmptySubGroupsList`) ?? `none`
      }
      get projectShowEmptySubGroupsTimeline() {
          return this.getPreference(`projectShowEmptySubGroupsTimeline`) ?? `none`
      }
      get projectShowEmptySubGroupsBoard() {
          return this.getPreference(`projectShowEmptySubGroupsBoard`) ?? `all`
      }
      get showCompletedProjects() {
          return this.getPreference(`showCompletedProjects`) ?? `all`
      }
      get timelineChronologyShowCycleTeamIds() {
          return this.getPreference(`timelineChronologyShowCycleTeamIds`) ?? []
      }
      get timelineChronologyShowWeekNumbers() {
          return this.getPreference(`timelineChronologyShowWeekNumbers`) ?? !1
      }
      get timelineZoomScale() {
          return this.getPreference(`timelineZoomScale`) ?? fE.defaultZoomLevel
      }
      get initiativesViewOrdering() {
          return this.getPreference(`initiativesViewOrdering`) ?? `sortOrder`
      }
      get initiativeFieldProjects() {
          return this.getPreference(`initiativeFieldProjects`) ?? !0
      }
      get initiativeFieldTeams() {
          return this.getPreference(`initiativeFieldTeams`) ?? !1
      }
      get initiativeFieldDescription() {
          return this.getPreference(`initiativeFieldDescription`) ?? !0
      }
      get initiativeFieldOwner() {
          return this.getPreference(`initiativeFieldOwner`) ?? !0
      }
      get initiativeFieldTargetDate() {
          return this.getPreference(`initiativeFieldTargetDate`) ?? !0
      }
      get initiativeFieldActivity() {
          return this.getPreference(`initiativeFieldActivity`) ?? !0
      }
      get initiativeFieldActiveProjectsHealth() {
          return this.getPreference(`initiativeFieldHealth`) ?? !0
      }
      get initiativeFieldInitiativeHealth() {
          return this.getPreference(`initiativeFieldInitiativeHealth`) ?? !0
      }
      get showNestedInitiatives() {
          return this.getPreference(`showNestedInitiatives`) ?? !0
      }
      get customersViewOrdering() {
          return this.getPreference(`customersViewOrdering`) ?? `createdAt`
      }
      get customerFieldRequestCount() {
          return this.getPreference(`customerFieldRequestCount`) ?? !0
      }
      get customerFieldRevenue() {
          return this.getPreference(`customerFieldRevenue`) ?? !0
      }
      get customerFieldOwner() {
          return this.getPreference(`customerFieldOwner`) ?? !0
      }
      get customerFieldStatus() {
          return this.getPreference(`customerFieldStatus`) ?? !0
      }
      get currentFieldDomains() {
          return this.getPreference(`customerFieldDomains`) ?? !1
      }
      get customerFieldSize() {
          return this.getPreference(`customerFieldSize`) ?? !0
      }
      get customerFieldSource() {
          return this.getPreference(`customerFieldSource`) ?? !1
      }
      get customerFieldTier() {
          return this.getPreference(`customerFieldTier`) ?? !0
      }
      get customerPageNeedsViewGrouping() {
          let e = this.getPreference(`customerPageNeedsViewGrouping`);
          return e === `important` ? `none` : e ?? `none`
      }
      get customerPageNeedsViewOrdering() {
          let e = this.getPreference(`customerPageNeedsViewOrdering`);
          return e === `priority` ? `createdAt` : e ?? `createdAt`
      }
      get customerPageNeedsFieldIssueIdentifier() {
          return this.getPreference(`customerPageNeedsFieldIssueIdentifier`) ?? !1
      }
      get customerPageNeedsFieldIssuePriority() {
          return this.getPreference(`customerPageNeedsFieldIssuePriority`) ?? !1
      }
      get customerPageNeedsFieldIssueStatus() {
          return this.getPreference(`customerPageNeedsFieldIssueStatus`) ?? !0
      }
      get customerPageNeedsFieldIssueTargetDueDate() {
          return this.getPreference(`customerPageNeedsFieldIssueTargetDueDate`) ?? !1
      }
      get customerPageNeedsShowImportantFirst() {
          return this.getPreference(`customerPageNeedsShowImportantFirst`) ?? !0
      }
      get customerPageNeedsShowCompletedIssuesAndProjects() {
          return this.getPreference(`customerPageNeedsShowCompletedIssuesAndProjects`) || this.getPreference(`showCompletedIssues`) || `all`
      }
      get embeddedCustomerNeedsShowImportantFirst() {
          return this.getPreference(`embeddedCustomerNeedsShowImportantFirst`) ?? !0
      }
      get projectCustomerNeedsViewOrdering() {
          return this.getPreference(`projectCustomerNeedsViewOrdering`) ?? `createdAt`
      }
      get projectCustomerNeedsViewGrouping() {
          return this.getPreference(`projectCustomerNeedsViewGrouping`) === `customerStage` ? `customerStatus` : this.getPreference(`projectCustomerNeedsViewGrouping`) ?? `issue`
      }
      get projectCustomerNeedsShowImportantFirst() {
          return this.getPreference(`projectCustomerNeedsShowImportantFirst`) ?? !0
      }
      get teamFieldIdentifier() {
          return this.getPreference(`teamFieldIdentifier`) ?? !0
      }
      get teamFieldMembership() {
          return this.getPreference(`teamFieldMembership`) ?? !0
      }
      get teamFieldOwner() {
          return this.getPreference(`teamFieldOwner`) ?? !1
      }
      get teamFieldMembers() {
          return this.getPreference(`teamFieldMembers`) ?? !0
      }
      get teamFieldProjects() {
          return this.getPreference(`teamFieldProjects`) ?? !0
      }
      get teamFieldCycle() {
          return this.getPreference(`teamFieldCycle`) ?? !0
      }
      get teamFieldDateCreated() {
          return this.getPreference(`teamFieldDateCreated`) ?? !1
      }
      get teamFieldDateUpdated() {
          return this.getPreference(`teamFieldDateUpdated`) ?? !1
      }
      get customViewsOrdering() {
          return this.getPreference(`customViewsOrdering`) ?? `name`
      }
      get customViewFieldOwner() {
          return this.getPreference(`customViewFieldOwner`) ?? !0
      }
      get customViewFieldVisibility() {
          return this.getPreference(`customViewFieldVisibility`) ?? !1
      }
      get customViewFieldDateCreated() {
          return this.getPreference(`customViewFieldDateCreated`) ?? !1
      }
      get customViewFieldDateUpdated() {
          return this.getPreference(`customViewFieldDateUpdated`) ?? !1
      }
      get dashboardsOrdering() {
          return this.getPreference(`dashboardsOrdering`) ?? `name`
      }
      get dashboardFieldOwner() {
          return this.getPreference(`dashboardFieldOwner`) ?? !0
      }
      get dashboardFieldDateCreated() {
          return this.getPreference(`dashboardFieldDateCreated`) ?? !1
      }
      get dashboardFieldDateUpdated() {
          return this.getPreference(`dashboardFieldDateUpdated`) ?? !1
      }
      get workspaceMembersViewOrdering() {
          return this.getPreference(`workspaceMembersViewOrdering`) ?? `title`
      }
      get memberFieldStatus() {
          return this.getPreference(`memberFieldStatus`) ?? !0
      }
      get memberFieldJoined() {
          return this.getPreference(`memberFieldJoined`) ?? !0
      }
      get memberFieldTeams() {
          return this.getPreference(`memberFieldTeams`) ?? !0
      }
      get initiativeGrouping() {
          return this.getPreference(`initiativeGrouping`) ?? `none`
      }
      getPreference(e, t) {
          return this.preferences[e] === void 0 ? this.isUserType && this.organizationPreferences?.[e] !== void 0 ? this.organizationPreferences?.[e] : t : this.preferences[e]
      }
      get isUserType() {
          return this.type === HT.user
      }
      get isUserIssuesView() {
          return [k.userProfileCreatedByUser, k.myIssues, k.myIssuesCreatedByMe, k.myIssuesSubscribedTo, k.myIssuesActivity].includes(this.viewType)
      }
      get isIssuesBoard() {
          return this.layout === `board`
      }
      get isProjectsBoard() {
          return this.projectLayout === `board`
      }
  }
}
)), hE, gE, _E, vE, yE, bE, xE, SE, CE, wE, TE, EE, DE, OE, kE, AE = t(( () => {
  hE = [`list`, `board`],
  gE = [`asc`, `desc`],
  _E = [`manual`, `title`, `priority`, `dateCreated`, `dateUpdated`, `dateMyActivity`, `dueDate`, `linkCount`, `estimate`, `workflowState`, `assignee`, `delegate`, `customerCount`, `customerImportantCount`, `customerRevenue`, `accumulatedStateUpdatedAt`],
  vE = [`startedTriage`, `priority`, `dueDate`, `dateCreated`, `reverseDateCreated`],
  yE = [`sortOrder`, `name`, `createdAt`, `updatedAt`, `healthUpdatedAt`, `startDate`, `targetDate`, `status`, `priority`, `customerCount`, `customerImportantCount`, `customerRevenue`, `activity`],
  bE = [`importance`, `title`, `status`, `openedAt`, `updatedAt`, `creator`],
  xE = [`list`, `timeline`, `board`],
  SE = [`year`, `quarter`, `month`, `week`],
  CE = [`currentCycle`, `day`, `week`, `month`, `all`, `none`],
  wE = [`week`, `month`, `all`, `none`, `3months`, `6months`],
  TE = [`sla`, `focus`, `assignee`, `delegate`, `workflowState`, `priority`, `project`, `projectMilestone`, `cycle`, `team`, `rootIssue`, `label`, `labelGroup`, `customer`, `activityDate`, `none`],
  EE = [...TE, `focus`],
  DE = [`activity`, `lead`, `member`, `health`, `none`, `status`, `priority`, `label`, `labelGroup`, `roadmap`, `initiative`, `subInitiative`, `team`, `startDate`, `targetDate`, `rolloutStage`],
  OE = [`name`, `targetDate`, `status`, `priority`],
  kE = `issueGrouping.issueSubGrouping.showSubIssues.issueNesting.showSupervisedIssues.showCompletedIssues.showTriageIssues.closedIssuesOrderedByRecency.showSubTeamIssues.projectGrouping.projectSubGrouping.projectLayout.projectZoomLevel.timelineZoomScale.projectGroupingDateResolution.showCompletedProjects.showSubTeamProjects.showNestedInitiatives.layout.viewOrdering.viewOrderingDirection.projectViewOrdering.showEmptyGroupsBoard.showEmptySubGroupsBoard.showEmptyGroupsList.showEmptySubGroupsList.issueGroupingLabelGroupId.issueSubGroupingLabelGroupId.projectShowEmptyGroups.projectShowEmptyGroupsList.projectShowEmptyGroupsBoard.projectShowEmptySubGroups.projectShowEmptySubGroupsList.projectShowEmptySubGroupsBoard.projectGroupingLabelGroupId.projectSubGroupingLabelGroupId.reviewGrouping.reviewViewOrdering.projectGroupOrdering`.split(`.`)
}
));
function jE(e, t) {
  return {
      label: e,
      defaultDirection: t
  }
}
function ME(e, t) {
  return {
      label: e,
      defaultDirection: t,
      fixedDirection: !0
  }
}
function NE() {
  return {
      label: `Status`,
      defaultDirection: `asc`
  }
}
function PE() {
  return {
      label: `Priority`,
      defaultDirection: `desc`
  }
}
function FE(e) {
  return {
      label: e,
      defaultDirection: `asc`,
      directionLabel: e => e === `asc` ? `AZ` : `ZA`
  }
}
function IE(e) {
  return {
      label: e,
      defaultDirection: `desc`,
      directionLabel: e => e === `asc` ? `09` : `90`
  }
}
function LE(e) {
  return {
      label: e,
      defaultDirection: `asc`,
      directionLabel: e => e === `asc` ? `Oldest first` : `Newest first`
  }
}
function RE(e) {
  return {
      label: e,
      defaultDirection: `desc`,
      directionLabel: e => e === `asc` ? `Oldest first` : `Newest first`
  }
}
function nce(e) {
  return {
      label: e,
      defaultDirection: `asc`,
      directionLabel: e => e === `asc` ? `Longest first` : `Shortest first`
  }
}
var zE, BE, VE, HE, UE, WE, GE, KE, qE, JE, YE, XE, ZE, QE, $E, eD = t(( () => {
  zn(),
  zE = class e {
      constructor(e) {
          this.spec = e
      }
      isValidType(e) {
          return Object.keys(this.spec).includes(e)
      }
      labelForType(e) {
          return this.spec[e]?.label ?? `Unknown`
      }
      defaultDirectionForType(e) {
          return this.spec[e]?.defaultDirection ?? `asc`
      }
      canChangeDirectionOfType(e) {
          return !this.spec[e]?.fixedDirection
      }
      labelForDirection(e, t) {
          return this.spec[e]?.directionLabel?.(t) ?? (t === `asc` ? `Ascending` : `Descending`)
      }
      static labelForType(t) {
          return e.helperFor(t).labelForType(t)
      }
      static defaultDirectionForType(t) {
          return e.helperFor(t).defaultDirectionForType(t)
      }
      static canChangeDirectionOfType(t) {
          return e.helperFor(t).canChangeDirectionOfType(t)
      }
      static labelForDirection(t, n) {
          return e.helperFor(t).labelForDirection(t, n)
      }
      static helperFor(t) {
          return VE.isValidType(t) ? VE : GE.isValidType(t) ? GE : HE.isValidType(t) ? HE : UE.isValidType(t) ? UE : WE.isValidType(t) ? WE : KE.isValidType(t) ? KE : qE.isValidType(t) ? qE : ZE.isValidType(t) ? ZE : BE.isValidType(t) ? BE : $E.isValidType(t) ? $E : QE.isValidType(t) ? QE : (y(t),
          new e({}))
      }
  }
  ,
  BE = new zE({
      title: FE(`Name`),
      status: jE(`Status`, `asc`),
      joined: LE(`Joined`)
  }),
  VE = new zE({
      manual: ME(`Manual`, `asc`),
      title: FE(`Title`),
      assignee: FE(`Assignee`),
      delegate: FE(`Agent`),
      workflowState: NE(),
      priority: PE(),
      estimate: jE(`Estimate`, `desc`),
      dateCreated: RE(`Created`),
      dateUpdated: RE(`Updated`),
      dateMyActivity: RE(`My activity date`),
      dueDate: LE(`Due date`),
      linkCount: jE(`Link count`, `desc`),
      customerCount: jE(`Customer count`, `desc`),
      customerImportantCount: jE(`Important count`, `desc`),
      customerRevenue: jE(`Customer revenue`, `desc`),
      accumulatedStateUpdatedAt: nce(`Time in status`)
  }),
  HE = new zE({
      relevance: ME(`Most relevant`, `desc`),
      createdAt: ME(`Last created`, `desc`),
      updatedAt: ME(`Last updated`, `desc`)
  }),
  UE = new zE({
      priority: PE(),
      movedToInboxAt: ME(`Newest`, `desc`),
      reverseMovedToInboxAt: ME(`Oldest`, `asc`)
  }),
  WE = new zE({
      priority: PE(),
      startedTriage: RE(`Added to triage`),
      dateCreated: ME(`Newest`, `desc`),
      reverseDateCreated: ME(`Oldest`, `asc`),
      dueDate: LE(`Due date`)
  }),
  GE = new zE({
      sortOrder: ME(`Manual`, `asc`),
      name: FE(`Name`),
      status: NE(),
      priority: PE(),
      startDate: LE(`Start date`),
      targetDate: LE(`Target date`),
      createdAt: RE(`Created`),
      updatedAt: RE(`Updated`),
      healthUpdatedAt: RE(`Health updated`),
      customerCount: jE(`Customer count`, `desc`),
      customerImportantCount: jE(`Important count`, `desc`),
      customerRevenue: jE(`Customer revenue`, `desc`),
      activity: jE(`Activity`, `desc`)
  }),
  KE = new zE({
      name: FE(`Name`),
      createdAt: RE(`Created`),
      updatedAt: RE(`Updated`)
  }),
  qE = new zE({
      name: FE(`Name`),
      owner: FE(`Owner`),
      createdAt: RE(`Created`),
      updatedAt: RE(`Updated`)
  }),
  JE = new zE({
      name: FE(`Name`),
      owner: FE(`Owner`),
      createdAt: RE(`Created`),
      updatedAt: RE(`Updated`)
  }),
  YE = new zE({
      name: FE(`Name`),
      owner: FE(`Owner`),
      createdAt: RE(`Created`),
      approximateNeedCount: IE(`Request count`),
      revenue: IE(`Revenue`),
      size: IE(`Size`),
      status: ME(`Status`, `asc`),
      tier: ME(`Tier`, `asc`)
  }),
  XE = new zE({
      createdAt: RE(`Created date`),
      customerName: FE(`Customer`),
      customerRevenue: IE(`Revenue`)
  }),
  ZE = new zE({
      importance: ME(`Importance`, `asc`),
      title: FE(`Name`),
      creator: FE(`Author`),
      status: NE(),
      openedAt: RE(`Opened`),
      updatedAt: RE(`Updated`)
  }),
  QE = new zE({
      name: FE(`Name`),
      sortOrder: ME(`Manual`, `asc`),
      updatedAt: RE(`Updated`),
      healthUpdatedAt: RE(`Health updated`),
      targetDate: LE(`Target date`),
      activity: jE(`Activity`, `desc`)
  }),
  $E = new zE({
      name: FE(`Name`),
      targetDate: LE(`Target date`),
      status: NE(),
      priority: PE()
  })
}
)), tD, nD = t(( () => {
  zt(),
  Am(),
  tD = class extends km {
      get isFiltering() {
          return this.filters.length > 0
      }
      get filterCount() {
          return this.filters.length
      }
      constructor(e) {
          super(),
          this.filters = [],
          e && this.addFilter(e),
          At(this, {
              addFilter: Ft,
              reset: Ft,
              isFiltering: Bt,
              filterCount: Bt,
              filters: Vt
          })
      }
      addFilter(e) {
          this.filters.push(e)
      }
      reset() {
          this.filters = []
      }
      filterElement(e) {
          return this.filters.every(t => t(e))
      }
  }
}
)), rD, iD, aD, oD, sD, cD, lD, uD, dD, fD = t(( () => {
  Yr(),
  nD(),
  ws(),
  rD = new tD(e => !(e.snoozedBy !== void 0 || e.snoozedUntilAt)),
  iD = new tD(e => !e.parent),
  aD = new tD(e => !e.state.isTriage),
  oD = e => new tD(sD(e)),
  sD = e => t => {
      let n = t.doneAt
        , r = Date.now();
      return !(n && (e === `none` || e === `week` && r - n.valueOf() > b.WEEK || e === `month` && r - n.valueOf() > b.MONTH || e === `3months` && r - n.valueOf() > 3 * b.MONTH || e === `6months` && r - n.valueOf() > 6 * b.MONTH))
  }
  ,
  cD = e => new tD(lD(e)),
  lD = e => t => {
      let n = t.doneAt
        , r = Date.now();
      if (n) {
          if (e === `none` || e === `week` && r - n.valueOf() > b.WEEK || e === `month` && r - n.valueOf() > b.MONTH || e === `day` && r - n.valueOf() > b.DAY)
              return !1;
          if (e === `currentCycle`) {
              let e = t.team.previousCycle?.completedAt?.valueOf() || t.team.activeCycle?.startsAt.valueOf();
              if (!e || n.valueOf() < e)
                  return !1
          }
      }
      return !0
  }
  ,
  uD = e => {
      if (e)
          try {
              return JSON.stringify(e)
          } catch {
              w.warning(`Failed to serialize view preferences`, {
                  viewPreferences: e
              })
          }
  }
  ,
  dD = e => {
      try {
          return e && typeof e == `string` ? JSON.parse(e) : e
      } catch {
          w.warning(`Failed to deserialize view preferences`, {
              viewPreferences: e
          })
      }
  }
}
)), pD, mD, hD, gD, _D = t(( () => {
  nt(),
  St(),
  pD = class e {
      static addDuration(e, t) {
          if (e = typeof e == `string` ? Xe(e) : tee(e),
          isNaN(e.getTime()))
              throw TypeError(`invalid date: "${e.toString()}"`);
          let n = hD.exec(t);
          if (!n || t.length < 3)
              throw TypeError(`invalid duration: "${t}". Must be an ISO 8601 duration. See https://en.wikipedia.org/wiki/ISO_8601#Durations`);
          let r = n[1] === `-` ? `sub` : `add`
            , i = gD.reduce( (e, t, r) => {
              let i = n[r + 2];
              return i && (e[t] = parseInt(i, 10)),
              e
          }
          , {});
          return (r === `sub` ? it : tt)(e, i)
      }
      static isDuration(e) {
          return e.length >= 3 && hD.test(e)
      }
      static format(t) {
          let n = t.match(/\-?P(\d)W$/)
            , r = t.match(/\-?P(\d)M$/);
          if (n) {
              let e = parseInt(n[1], 10);
              return `${e} week${e > 1 ? `s` : ``}`
          }
          return nee(e.addDuration(new Date, t), {
              unit: r ? `month` : void 0,
              roundingMethod: `round`
          })
      }
      static msToDurationString(e) {
          if (e < 0)
              throw Error(`Duration cannot be negative`);
          return `PT${(e / 1e3).toFixed(3).replace(/\.?0+$/, ``)}S`
      }
  }
  ,
  mD = yt(),
  hD = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/,
  gD = [`years`, `months`, `weeks`, `days`, `hours`, `minutes`, `seconds`]
}
));
function vD(e) {
  return typeof e == `string` && e.match(/^\d{4}-([0]\d|1[0-2])-([0-2]\d|3[01])$/) !== null
}
var yD, bD, xD, SD, CD, wD, TD = t(( () => {
  zn(),
  vb(),
  yD = () => new Date().toTimelessDate(),
  bD = e => {
      let t = yD();
      if (typeof e != `object` || !e)
          return !1;
      let n = e;
      return `lt`in n && n.lt === t || `lte`in n && n.lte === t || `gt`in n && n.gt === t || `gte`in n && n.gte === t
  }
  ,
  xD = e => {
      if (typeof e != `object` || !e)
          return !1;
      let t = e;
      return `lt`in t && t.lt === `P0D` || `lte`in t && t.lte === `P0D` || `gt`in t && t.gt === `P0D` || `gte`in t && t.gte === `P0D`
  }
  ,
  SD = e => e === `not` || e === `after` ? {
      gte: `P0D`
  } : e === `is` || e === `before` ? {
      lt: `P0D`
  } : {
      gte: `P0D`
  },
  CD = e => ({
      ...e,
      key: e.property,
      create: t => ({
          [e.property]: wD(t, e)
      }),
      match: t => e.property in t,
      allowMultiSelect: !1,
      getCompareOptionLabel: t => e.labelMapping && t in e.labelMapping ? e.labelMapping[t] : t,
      getCompareOption: t => {
          let n = t[e.property];
          if (bD(n) || xD(n)) {
              if (`lt`in n || `lte`in n)
                  return `is`;
              if (`gt`in n || `gte`in n)
                  return `not`
          }
          if (`null`in n)
              return n.null ? `is` : `not`;
          if (`gte`in n && `lt`in n || `in`in n)
              return `within`;
          if (`lte`in n)
              return n.lte === `P0D` ? `is` : `before`;
          if (`lt`in n)
              return n.lt === `P0D` ? `not` : `before`;
          if (`gt`in n)
              return n.gt === `P0D` ? `not` : `after`;
          if (`gte`in n)
              return n.gte === `P0D` ? `is` : `after`;
          throw new Rn(n)
      }
      ,
      selectedValues(t) {
          let n = t[e.property];
          if (bD(n) || xD(n))
              return [`P0D`];
          if (`null`in n)
              return [ob];
          if (`gte`in n && `lt`in n)
              return [[n.gte, n.lt]];
          if (`neq`in n && n.neq) {
              if (`gte`in n)
                  return [[n.neq, n.gte]];
              if (`gt`in n)
                  return [[n.neq, n.gt]];
              if (`lt`in n)
                  return [[n.lt, n.neq]];
              if (`lte`in n)
                  return [[n.lte, n.neq]];
              throw new Rn(n)
          } else if (`lte`in n)
              return [n.lte];
          else if (`lt`in n)
              return [n.lt];
          else if (`gte`in n)
              return [n.gte];
          else if (`gt`in n)
              return [n.gt];
          else if (`in`in n)
              throw Error(`invariant: patchLegacyDateFilter not working`);
          throw new Rn(n)
      },
      compareOptions: e => {
          let t = e[0];
          return t === `____null____` || t === `P0D` ? `equalValue` : Array.isArray(t) ? `dateRange` : `date`
      }
      ,
      defaultCompareOption: t => {
          let n = t[0];
          return n === `P0D` || n === `____null____` ? `is` : Array.isArray(n) ? `within` : e.defaultCompareOptionForDates
      }
  }),
  wD = (e, t) => {
      let {compareOption: n, values: r} = e
        , {defaultCompareOptionForDates: i} = t
        , a = r[0];
      if (Array.isArray(r) && r.length === 2)
          throw Error(`invariant: should only be a single value not ${JSON.stringify(r)}`);
      if (Array.isArray(a) && a.length === 2) {
          let[e,t] = a;
          if (n === `within` || n === `is`)
              return {
                  gte: e,
                  lt: t
              };
          if (n === `before`)
              return {
                  lt: e,
                  neq: t
              };
          if (n === `after`)
              return {
                  gte: t,
                  neq: e
              };
          throw Error(`Invalid compare option ${n} for date range`)
      }
      if (a === `____null____`)
          return {
              null: n !== `not`
          };
      if (typeof a == `string` && a === `P0D`)
          return SD(n);
      let o = i === `before` ? `lte` : `gte`;
      return typeof a == `string` && n === `within` ? i === `before` ? o === `lte` ? {
          lte: a
      } : {
          lt: a
      } : o === `gte` ? {
          gte: a
      } : {
          gt: a
      } : n === `before` || n === `is` ? o === `lte` ? {
          lte: a
      } : {
          lt: a
      } : o === `gte` ? {
          gte: a
      } : {
          gt: a
      }
  }
}
));
function ED(e, t) {
  return typeof e == `string` ? e.toLowerCase() === t.toLowerCase() : e === t
}
function DD(e) {
  return typeof e == `string` && e.match(/^\d{4}-([0]\d|1[0-2])-([0-2]\d|3[01])T\d{2}:\d{2}:\d{2}.\d{3}Z$/) !== null
}
function OD(e, t) {
  for (let n = 0; n < e.length; n++)
      if (t(e[n]))
          return !0;
  return !1
}
function kD(e, t) {
  for (let n = 0; n < e.length; n++)
      if (!t(e[n]))
          return !1;
  return !0
}
var AD, jD, MD = t(( () => {
  um(),
  _D(),
  Om(),
  TD(),
  AD = class {
      constructor(e) {
          this.comparatorOverrides = e
      }
      matchElement(e, t) {
          for (let n in lm.isLazy(t) ? t = t.value : Dm.isCollection(t) && (t = t.elements),
          e) {
              let r = e[n];
              if (r === void 0)
                  continue;
              let i = this.comparatorOverrides?.[n];
              if (i) {
                  if (!i.call(this, n, t, r))
                      return !1;
                  continue
              }
              let a = jD[n];
              if (a !== void 0) {
                  if (!a.call(this, n, t, r))
                      return !1;
                  continue
              }
              if (Array.isArray(t))
                  return this.matchElement({
                      some: {
                          [n]: r
                      }
                  }, t);
              if (typeof r != `object` || !this.matchElement(r, t?.[n]))
                  return !1
          }
          return !0
      }
  }
  ,
  jD = {
      or(e, t, n) {
          let r = n;
          return t == null ? OD(r, e => `null`in e && e.null === !0) : OD(r, e => this.matchElement(e, t))
      },
      and(e, t, n) {
          let r = n;
          return t == null ? kD(r, e => `null`in e && e.null === !0) : kD(r, e => this.matchElement(e, t))
      },
      null(e, t, n) {
          return n ? t == null : t != null
      },
      eq(e, t, n) {
          return t === n
      },
      eqIgnoreCase(e, t, n) {
          return ED(t, n)
      },
      neq(e, t, n) {
          return t !== n
      },
      neqIgnoreCase(e, t, n) {
          return !ED(t, n)
      },
      gte(e, t, n) {
          let r = Date.now();
          if (vD(t) && (pD.isDuration(n) && (r = new Date().toTimelessDate()),
          t = t.toLocalDate()),
          t instanceof Date) {
              if (pD.isDuration(n))
                  return t >= pD.addDuration(r, n);
              if (vD(n))
                  return t >= n.toLocalDate();
              if (DD(n))
                  return t >= new Date(n)
          }
          return t >= n
      },
      gt(e, t, n) {
          let r = Date.now();
          if (vD(t) && (pD.isDuration(n) && (r = new Date().toTimelessDate()),
          t = t.toLocalDate()),
          t instanceof Date) {
              if (pD.isDuration(n))
                  return t > pD.addDuration(r, n);
              if (vD(n))
                  return t > n.toLocalDate();
              if (DD(n))
                  return t > new Date(n)
          }
          return t > n
      },
      lt(e, t, n) {
          let r = Date.now();
          if (vD(t) && (pD.isDuration(n) && (r = new Date().toTimelessDate()),
          t = t.toLocalDate()),
          t instanceof Date) {
              if (pD.isDuration(n))
                  return t < pD.addDuration(r, n);
              if (vD(n))
                  return t < n.toLocalDate();
              if (DD(n))
                  return t < new Date(n)
          }
          return t < n
      },
      lte(e, t, n) {
          let r = Date.now();
          return vD(t) && (pD.isDuration(n) && (r = new Date().toTimelessDate()),
          t = t.toLocalDate()),
          pD.isDuration(n) ? t <= pD.addDuration(r, n) : vD(n) ? t <= n.toLocalDate() : DD(n) ? t <= new Date(n) : t <= n
      },
      contains(e, t, n) {
          let r = t
            , i = n;
          return r !== void 0 && r.toLowerCase().indexOf(i.toLowerCase()) > -1
      },
      notContains(e, t, n) {
          let r = t
            , i = n;
          return r.toLowerCase().indexOf(i.toLowerCase()) === -1
      },
      containsIgnoreCase(e, t, n) {
          let r = t
            , i = n;
          return r !== void 0 && r.toLowerCase().indexOf(i.toLowerCase()) > -1
      },
      notContainsIgnoreCase(e, t, n) {
          let r = t
            , i = n;
          return r.toLowerCase().indexOf(i.toLowerCase()) === -1
      },
      startsWith(e, t, n) {
          let r = t
            , i = n;
          return r.toLowerCase().indexOf(i.toLowerCase()) === 0
      },
      notStartsWith(e, t, n) {
          let r = t
            , i = n;
          return r.toLowerCase().indexOf(i.toLowerCase()) !== 0
      },
      endsWith(e, t, n) {
          let r = t
            , i = n;
          return r.toLowerCase().indexOf(i.toLowerCase()) === r.length - i.length
      },
      notEndsWith(e, t, n) {
          let r = t
            , i = n;
          return r.toLowerCase().indexOf(i.toLowerCase()) !== r.length - i.length
      },
      length(e, t, n) {
          return !t || !Array.isArray(t) ? !1 : this.matchElement(n, t.length)
      },
      some(e, t, n) {
          return !t || !Array.isArray(t) ? !1 : t.some(e => this.matchElement(n, e))
      },
      every(e, t, n) {
          return !t || !Array.isArray(t) || t.length === 0 ? !1 : t.every(e => this.matchElement(n, e))
      },
      in(e, t, n) {
          return !n || !Array.isArray(n) ? !1 : n.find(e => t === e) !== void 0
      },
      nin(e, t, n) {
          return !n || !Array.isArray(n) ? !0 : n.find(e => t === e) === void 0
      }
  }
}
)), ND, PD, FD = t(( () => {
  vb(),
  ND = class e {
      static createUserFilterBlock(e) {
          let {values: t, compareOption: n} = e;
          if (t.includes(`____any____`))
              return n === `is` ? {
                  null: !1
              } : {
                  null: !0
              };
          let r = []
            , i = !1
            , a = !1
            , o = !1
            , s = !1
            , c = !1;
          for (let e of t)
              e === `____null____` ? i = !0 : e === `__isMe__` ? a = !0 : e === `__isSuspended__` ? o = !0 : e === `__isAppUser__` ? s = !0 : e === `__isInvited__` ? c = !0 : r.push(e);
          if (n === `is`) {
              let e = {
                  or: []
              };
              return i && e.or.push({
                  null: !0
              }),
              a && e.or.push({
                  isMe: {
                      eq: !0
                  }
              }),
              o && e.or.push({
                  and: [{
                      active: {
                          eq: !1
                      }
                  }, {
                      isInvited: {
                          eq: !1
                      }
                  }]
              }),
              s && e.or.push({
                  app: {
                      eq: !0
                  }
              }),
              c && e.or.push({
                  isInvited: {
                      eq: !0
                  }
              }),
              r.length && e.or.push({
                  id: {
                      in: r
                  }
              }),
              e
          } else {
              let e = {
                  and: r.length ? [{
                      id: {
                          nin: r
                      }
                  }] : []
              };
              return i && e.and.push({
                  null: !1
              }),
              a && e.and.push({
                  or: [{
                      null: !0
                  }, {
                      isMe: {
                          eq: !1
                      }
                  }]
              }),
              o && e.and.push({
                  or: [{
                      null: !0
                  }, {
                      or: [{
                          active: {
                              eq: !0
                          }
                      }, {
                          isInvited: {
                              eq: !0
                          }
                      }]
                  }]
              }),
              s && e.and.push({
                  or: [{
                      null: !0
                  }, {
                      app: {
                          eq: !1
                      }
                  }]
              }),
              c && e.and.push({
                  or: [{
                      null: !0
                  }, {
                      isInvited: {
                          eq: !1
                      }
                  }]
              }),
              e
          }
      }
      static getUserCompareOption(e) {
          return `null`in e && typeof e.null == `boolean` ? e.null ? `not` : `is` : `or`in e || `id`in e && `in`in e.id ? `is` : `not`
      }
      static getSelectedUserValues(e) {
          if (`null`in e && typeof e.null == `boolean`)
              return [sb];
          if (`id`in e)
              return `in`in e.id ? e.id.in : e.id.nin;
          if (`or`in e) {
              let t = [];
              for (let n of e.or)
                  `id`in n ? t.push(...n.id.in) : `null`in n ? t.push(ob) : `isMe`in n ? t.push(cb) : `active`in n || `and`in n && n.and.some(e => `active`in e) ? t.push(ub) : `app`in n ? t.push(db) : `isInvited`in n && t.push(lb);
              return t
          } else if (`and`in e) {
              let t = [];
              for (let n of e.and)
                  if (`id`in n)
                      t.push(...n.id.nin);
                  else if (`null`in n)
                      t.push(ob);
                  else if (`isMe`in n)
                      t.push(cb);
                  else if (`active`in n || `or`in n && n.or.some(e => `active`in e))
                      t.push(ub);
                  else if (`app`in n)
                      t.push(db);
                  else if (`isInvited`in n)
                      t.push(lb);
                  else if (`or`in n)
                      for (let e of n.or)
                          `isMe`in e ? t.push(cb) : `active`in e || `or`in e && e.or.some(e => `active`in e) ? t.push(ub) : `app`in e ? t.push(db) : `isInvited`in e && t.push(lb);
              return t
          }
          return []
      }
      static createUserListFilterBlock(e) {
          let {values: t, compareOption: n} = e
            , r = t.includes(cb);
          return n === `contains` ? r ? {
              or: [{
                  isMe: {
                      eq: !0
                  }
              }, {
                  id: {
                      in: t.filter(e => e !== cb)
                  }
              }]
          } : {
              or: [{
                  id: {
                      in: t
                  }
              }]
          } : {
              or: [{
                  every: {
                      and: PD([{
                          id: {
                              nin: t.filter(e => e !== cb)
                          }
                      }, r ? {
                          isMe: {
                              eq: !1
                          }
                      } : void 0])
                  }
              }, {
                  length: {
                      eq: 0
                  }
              }]
          }
      }
      static getUserListCompareOption(e) {
          return e.or?.some(e => `length`in e) ? `notContains` : `contains`
      }
      static getSelectedUserListValues(t) {
          let n = e.getUserListCompareOption(t), r, i;
          return n === `contains` ? (i = t.or.filter(e => !(`isMe`in e))[0].id.in,
          r = t.or.some(e => `isMe`in e) ? cb : void 0) : (i = t.or[0].every.and[0].id.nin,
          r = t.or[0].every.and[1] === void 0 ? void 0 : cb),
          r ? [r].concat(i) : i
      }
  }
  ,
  PD = e => e.filter(e => e !== void 0)
}
)), ID, LD = t(( () => {
  St(),
  ID = [_t({
      and: Dt(_t({
          id: _t({
              eq: yt()
          })
      }))
  }), _t({
      or: Dt(_t({
          id: _t({
              eq: yt()
          })
      }))
  }), _t({
      or: Dt(mt([_t({
          every: _t({
              id: _t({
                  neq: yt()
              })
          })
      }), _t({
          length: _t({
              eq: Tt()
          })
      })]))
  }), _t({
      or: Dt(mt([_t({
          every: _t({
              id: _t({
                  nin: Dt(yt())
              })
          })
      }), _t({
          length: _t({
              eq: Tt()
          })
      })]))
  })]
}
)), RD, zD = t(( () => {
  St(),
  FD(),
  LD(),
  TD(),
  (function(e) {
      e.id = {
          key: `id`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  or: [{
                      id: {
                          in: t
                      }
                  }, {
                      ancestors: {
                          some: {
                              id: {
                                  in: t
                              }
                          }
                      }
                  }]
              } : {
                  and: [{
                      id: {
                          nin: t
                      }
                  }, {
                      ancestors: {
                          or: [{
                              every: {
                                  id: {
                                      nin: t
                                  }
                              }
                          }, {
                              length: {
                                  eq: 0
                              }
                          }]
                      }
                  }]
              }
          }
          ,
          match: e => `and`in e && `id`in e.and[0] || `or`in e && `id`in e.or[0],
          getCompareOption: e => `and`in e ? `not` : `is`,
          selectedValues(e) {
              return `and`in e && `id`in e.and[0] ? e.and[0].id.nin : e.or[0].id.in
          }
      },
      e.owner = {
          key: `owner`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => ({
              owner: ND.createUserFilterBlock(e)
          }),
          match: e => `owner`in e,
          getCompareOption: e => ND.getUserCompareOption(e.owner),
          selectedValues(e) {
              return ND.getSelectedUserValues(e.owner)
          }
      },
      e.creator = {
          key: `creator`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => ({
              creator: ND.createUserFilterBlock(e)
          }),
          match: e => `creator`in e,
          getCompareOption: e => ND.getUserCompareOption(e.creator),
          selectedValues(e) {
              return ND.getSelectedUserValues(e.creator)
          }
      },
      mt([...ID, _t({
          length: _t({
              eq: Tt().int().min(0)
          })
      })]),
      e.teams = {
          key: `teams`,
          compareOptions: `collection`,
          defaultCompareOption: `any`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return t.length === 0 && [`all`, `any`].indexOf(n) > -1 ? {
                  teams: {
                      length: {
                          eq: 0
                      }
                  }
              } : n === `all` ? {
                  teams: {
                      and: t.map(e => ({
                          id: {
                              eq: e
                          }
                      }))
                  }
              } : n === `any` ? {
                  teams: {
                      or: t.map(e => ({
                          id: {
                              eq: e
                          }
                      }))
                  }
              } : n === `notAll` ? {
                  teams: {
                      or: [...t.map(e => ({
                          every: {
                              id: {
                                  neq: e
                              }
                          }
                      })), {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              } : {
                  teams: {
                      or: [{
                          every: {
                              id: {
                                  nin: t
                              }
                          }
                      }, {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              }
          }
          ,
          match: e => `teams`in e,
          getCompareOption: e => {
              let t = `length`in e.teams || `and`in e.teams || e.teams.or.find(e => e.every?.id?.neq !== void 0) !== void 0
                , n = `length`in e.teams || `and`in e.teams || `or`in e.teams && `id`in (e.teams.or[0] || {});
              return t ? n ? `all` : `notAll` : n ? `any` : `neither`
          }
          ,
          selectedValues(e) {
              return `length`in e.teams ? [] : `and`in e.teams ? e.teams.and.map(e => e.id.eq) : e.teams.or.flatMap(e => {
                  if (`id`in e)
                      return e.id.eq;
                  if (`every`in e)
                      return `nin`in e.every.id ? e.every.id.nin : e.every.id.neq
              }
              ).filter(Boolean)
          }
      },
      e.status = {
          key: `status`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  status: {
                      in: t
                  }
              } : {
                  status: {
                      nin: t
                  }
              }
          }
          ,
          match: e => `status`in e,
          getCompareOption: e => `in`in e.status ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.status ? e.status.in : e.status.nin
          }
      },
      e.createdAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `createdAt`,
          nullable: !1
      }),
      e.updatedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `updatedAt`,
          nullable: !1
      }),
      e.targetDate = CD({
          defaultCompareOptionForDates: `before`,
          property: `targetDate`,
          nullable: !0
      })
  }
  )(RD ||= {})
}
)), BD, VD = t(( () => {
  FD(),
  TD(),
  (function(e) {
      e.team = {
          key: `team`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  team: {
                      id: {
                          in: t
                      }
                  }
              } : {
                  team: {
                      id: {
                          nin: t
                      }
                  }
              }
          }
          ,
          match: e => `team`in e,
          selectedValues(e) {
              return `in`in e.team.id ? e.team.id.in : e.team.id.nin
          },
          getCompareOption: e => `in`in e.team.id ? `is` : `not`
      },
      e.createdAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `createdAt`,
          nullable: !1
      }),
      e.updatedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `updatedAt`,
          nullable: !1
      }),
      e.creator = {
          key: `creator`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          selectedValues(e) {
              return ND.getSelectedUserValues(e.creator)
          },
          getCompareOption: e => ND.getUserCompareOption(e.creator),
          create: e => ({
              creator: ND.createUserFilterBlock(e)
          }),
          match: e => `creator`in e
      },
      e.assignee = {
          key: `assignee`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          selectedValues(e) {
              return ND.getSelectedUserValues(e.assignee)
          },
          getCompareOption: e => ND.getUserCompareOption(e.assignee),
          create: e => ({
              assignee: ND.createUserFilterBlock(e)
          }),
          match: e => `assignee`in e
      },
      e.delegate = {
          key: `delegate`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          selectedValues(e) {
              return ND.getSelectedUserValues(e.delegate)
          },
          getCompareOption: e => ND.getUserCompareOption(e.delegate),
          create: e => ({
              delegate: ND.createUserFilterBlock(e)
          }),
          match: e => `delegate`in e
      },
      e.statusType = {
          key: `statusType`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          selectedValues(e) {
              return `in`in e.statusType ? e.statusType.in : e.statusType.nin
          },
          getCompareOption: e => `in`in e.statusType ? `is` : `not`,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  statusType: {
                      in: t
                  }
              } : {
                  statusType: {
                      nin: t
                  }
              }
          }
          ,
          match: e => `statusType`in e
      }
  }
  )(BD ||= {})
}
));
function rce(e) {
  switch (e) {
  case `is`:
  case `not`:
      return `is`;
  case `contains`:
  case `notContains`:
      return `contains`;
  case `all`:
  case `notAll`:
      return `all`;
  case `any`:
  case `neither`:
      return `any`;
  case `eq`:
  case `neq`:
      return `eq`;
  case `before`:
  case `after`:
  case `within`:
  case `gt`:
  case `gte`:
  case `lt`:
  case `lte`:
      return e;
  default:
      throw new Rn(e)
  }
}
var HD, UD, WD, GD, KD, qD = t(( () => {
  zn(),
  HD = `__linear_deleted_`,
  UD = Symbol(`FILTER_METADATA`),
  WD = [{
      value: `gte`,
      label: `greater than or equals`
  }, {
      value: `lte`,
      label: `less than or equals`
  }, {
      value: `eq`,
      label: `equals`
  }, {
      value: `neq`,
      label: `not equals`
  }],
  GD = (e, t) => e > 1 ? t ? [`eq`, `contains`, `any`].includes(t) ? [{
      value: `any`,
      label: `is any of`
  }] : [{
      value: `neither`,
      label: `is none of`
  }] : [{
      value: `any`,
      label: `is any of`
  }, {
      value: `neither`,
      label: `is none of`
  }] : [{
      value: `eq`,
      label: `equals`
  }, {
      value: `neq`,
      label: `not equals`
  }, {
      value: `contains`,
      label: `contains`
  }, {
      value: `notContains`,
      label: `does not contain`
  }],
  KD = [{
      value: `eq`,
      label: `is`
  }]
}
)), JD, YD, XD, ZD, QD = t(( () => {
  JD = e(he(), 1),
  qD(),
  YD = `${HD}label__`,
  XD = e => {
      let {key: t, match: n, filterToLabels: r, labelsToFilter: i} = e;
      return {
          key: t,
          compareOptions: `collection`,
          defaultCompareOption: `all`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e
                , r = {};
              return r = t.length === 0 && [`all`, `any`].indexOf(n) > -1 ? {
                  length: {
                      eq: 0
                  }
              } : n === `all` ? {
                  and: t.map(e => ({
                      or: [{
                          name: {
                              eq: e
                          }
                      }, {
                          parent: {
                              name: {
                                  eq: e
                              }
                          }
                      }]
                  }))
              } : n === `any` ? {
                  or: t.map(e => ({
                      or: [{
                          name: {
                              eq: e
                          }
                      }, {
                          parent: {
                              name: {
                                  eq: e
                              }
                          }
                      }]
                  }))
              } : n === `notAll` ? {
                  or: [...t.map(e => ({
                      every: {
                          and: ZD([{
                              name: {
                                  neq: e
                              }
                          }, {
                              parent: {
                                  name: {
                                      neq: e
                                  }
                              }
                          }])
                      }
                  })), {
                      length: {
                          eq: 0
                      }
                  }, {
                      null: !0
                  }]
              } : {
                  or: [{
                      every: {
                          and: [{
                              name: {
                                  nin: t
                              }
                          }, {
                              parent: {
                                  name: {
                                      nin: t
                                  }
                              }
                          }]
                      }
                  }, {
                      length: {
                          eq: 0
                      }
                  }, {
                      null: !0
                  }]
              },
              i(r)
          }
          ,
          match: n,
          getCompareOption: e => {
              let t = r(e)
                , n = `length`in t || `and`in t || Array.isArray(t.or) && t.or.find(e => (0,
              JD.default)(e, [`every`, `and`, 0, `name`, `neq`]) || (0,
              JD.default)(e, [`every`, `and`, 0, `name`, `neqIgnoreCase`])) !== void 0
                , i = `length`in t || `and`in t || `or`in t && `or`in t.or[0] && `name`in (t.or[0].or[0] || {});
              return n ? i ? `all` : `notAll` : i ? `any` : `neither`
          }
          ,
          selectedValues(e) {
              let t = r(e);
              return `length`in t ? [] : `and`in t ? t.and.flatMap(e => e.or.map(e => `parent`in e ? `eq`in e.parent.name ? e.parent.name.eq : e.parent.name.eqIgnoreCase : `eq`in e.name ? e.name.eq : e.name.eqIgnoreCase)).distinct() : t.or.flatMap(e => {
                  if (`or`in e)
                      return e.or.map(e => `parent`in e ? `eq`in e.parent.name ? e.parent.name.eq : e.parent.name.eqIgnoreCase : `eq`in e.name ? e.name.eq : e.name.eqIgnoreCase);
                  if (`every`in e)
                      return e.every.and.flatMap(e => `parent`in e ? `nin`in e.parent.name ? e.parent.name.nin : `neq`in e.parent.name ? e.parent.name.neq : e.parent.name.neqIgnoreCase : `nin`in e.name ? e.name.nin : `neq`in e.name ? e.name.neq : e.name.neqIgnoreCase)
              }
              ).distinct().filter(Boolean)
          }
      }
  }
  ,
  ZD = e => e
}
));
function $D(e, t) {
  for (let n of e)
      if (typeof n == `object` && n && (`or`in n && Array.isArray(n.or) && $D(n.or, t) || `and`in n && Array.isArray(n.and) && $D(n.and, t) || t in n))
          return !0;
  return !1
}
var eO, tO, nO, rO, iO = t(( () => {
  eO = e(v(), 1),
  tO = e(he(), 1),
  Il(),
  QD(),
  FD(),
  TD(),
  vb(),
  (function(e) {
      e.assignee = {
          key: `assignee`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => ({
              assignee: ND.createUserFilterBlock(e)
          }),
          match: e => `assignee`in e,
          getCompareOption: e => ND.getUserCompareOption(e.assignee),
          selectedValues(e) {
              return ND.getSelectedUserValues(e.assignee)
          }
      },
      e.delegate = {
          key: `delegate`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => ({
              delegate: ND.createUserFilterBlock(e)
          }),
          match: e => `delegate`in e,
          getCompareOption: e => ND.getUserCompareOption(e.delegate),
          selectedValues(e) {
              return ND.getSelectedUserValues(e.delegate)
          }
      },
      e.attachments = {
          key: `attachments`,
          compareOptions: `collection`,
          defaultCompareOption: `any`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return t.length === 0 && [`all`, `any`].indexOf(n) > -1 ? {
                  attachments: {
                      length: {
                          eq: 0
                      }
                  }
              } : n === `all` ? {
                  attachments: {
                      and: t.map(e => ({
                          sourceType: {
                              eq: e
                          }
                      }))
                  }
              } : n === `any` ? {
                  attachments: {
                      or: t.map(e => ({
                          sourceType: {
                              eq: e
                          }
                      }))
                  }
              } : n === `notAll` ? {
                  attachments: {
                      or: [...t.map(e => ({
                          every: {
                              sourceType: {
                                  neq: e
                              }
                          }
                      })), {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              } : {
                  attachments: {
                      or: [{
                          every: {
                              sourceType: {
                                  nin: t
                              }
                          }
                      }, {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              }
          }
          ,
          match: e => `attachments`in e,
          getCompareOption: e => {
              let t = `length`in e.attachments || `and`in e.attachments || e.attachments.or.find(e => (0,
              tO.default)(e, [`every`, `sourceType`, `neq`])) !== void 0
                , n = `length`in e.attachments || `and`in e.attachments || `or`in e.attachments && `sourceType`in (e.attachments.or[0] || {});
              return t ? n ? `all` : `notAll` : n ? `any` : `neither`
          }
          ,
          selectedValues(e) {
              return `length`in e.attachments ? [] : `and`in e.attachments ? e.attachments.and.map(e => e.sourceType.eq) : e.attachments.or.flatMap(e => {
                  if (`sourceType`in e)
                      return e.sourceType.eq;
                  if (`every`in e)
                      return `nin`in e.every.sourceType ? e.every.sourceType.nin : e.every.sourceType.neq
              }
              ).filter(Boolean)
          }
      },
      e.completedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `completedAt`,
          nullable: !0
      }),
      e.updatedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `updatedAt`,
          nullable: !1
      }),
      e.startedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `startedAt`,
          nullable: !1
      }),
      e.triagedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `triagedAt`,
          nullable: !1
      }),
      e.createdAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `createdAt`,
          nullable: !1
      }),
      e.timeInStatus = CD({
          defaultCompareOptionForDates: `before`,
          property: `accumulatedStateUpdatedAt`,
          nullable: !0,
          labelMapping: {
              before: `longer than`,
              after: `less than`
          }
      }),
      e.dueDate = CD({
          defaultCompareOptionForDates: `before`,
          property: `dueDate`,
          nullable: !0
      }),
      e.autoClosedAt = {
          key: `autoClosedAt`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  autoClosedAt: {
                      null: t !== `is`
                  }
              }
          }
          ,
          match: e => `autoClosedAt`in e,
          getCompareOption: e => e.autoClosedAt.null ? `not` : `is`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`
      },
      e.creator = {
          key: `creator`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => ({
              creator: ND.createUserFilterBlock(e)
          }),
          match: e => `creator`in e,
          getCompareOption: e => ND.getUserCompareOption(e.creator),
          selectedValues(e) {
              return ND.getSelectedUserValues(e.creator)
          }
      },
      e.cycle = {
          key: `cycle`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e
                , [r,i] = (0,
              eO.default)(t, e => e !== ob)
                , a = i.length > 0
                , o = e => n === `not` ? {
                  or: [{
                      null: !0
                  }, {
                      [e]: {
                          eq: !1
                      }
                  }]
              } : {
                  [e]: {
                      eq: !0
                  }
              }
                , s = rO([r.includes(`__nextCycle__`) ? o(`isNext`) : void 0, r.includes(`__previousCycle__`) ? o(`isPrevious`) : void 0, r.includes(`__activeCycle__`) ? o(`isActive`) : void 0, r.includes(`__inCooldown__`) ? o(`isInCooldown`) : void 0, r.includes(`__pastCycles__`) ? o(`isPast`) : void 0, r.includes(`__futureCycles__`) ? o(`isFuture`) : void 0, a ? {
                  null: n === `is`
              } : void 0]);
              return n === `is` ? {
                  cycle: {
                      or: s
                  }
              } : {
                  cycle: {
                      and: s
                  }
              }
          }
          ,
          match: e => `cycle`in e,
          getCompareOption: e => `or`in e.cycle ? `is` : `not`,
          selectedValues(e) {
              let t = `or`in e.cycle ? e.cycle.or : `and`in e.cycle ? e.cycle.and : [];
              if (t.find(e => `id`in e))
                  throw Error(`Incompatible cycle filter`);
              return [$D(t, `isPrevious`) ? hb : void 0, $D(t, `isNext`) ? mb : void 0, $D(t, `isActive`) ? fb : void 0, $D(t, `isInCooldown`) ? pb : void 0, $D(t, `isPast`) ? gb : void 0, $D(t, `isFuture`) ? _b : void 0, $D(t, `null`) ? ob : void 0].concrete()
          }
      },
      e.addedToCyclePeriod = {
          key: `addedToCyclePeriod`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  addedToCyclePeriod: {
                      in: t
                  }
              } : {
                  addedToCyclePeriod: {
                      nin: t
                  }
              }
          }
          ,
          match: e => `addedToCyclePeriod`in e,
          getCompareOption: e => `in`in e.addedToCyclePeriod ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.addedToCyclePeriod ? e.addedToCyclePeriod.in : e.addedToCyclePeriod.nin
          }
      },
      e.slaStatus = {
          key: `slaStatus`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e
                , [r,i] = (0,
              eO.default)(t, e => e !== ob)
                , a = i.length > 0;
              return a && n === `is` ? {
                  or: [{
                      slaStatus: {
                          in: r
                      }
                  }, {
                      slaStatus: {
                          null: !0
                      }
                  }]
              } : a && n === `not` ? {
                  and: [{
                      slaStatus: {
                          nin: r
                      }
                  }, {
                      slaStatus: {
                          null: !1
                      }
                  }]
              } : r.length > 0 && n === `is` ? {
                  slaStatus: {
                      in: r
                  }
              } : r.length > 0 && n === `not` ? {
                  slaStatus: {
                      nin: r
                  }
              } : {
                  slaStatus: {
                      in: []
                  }
              }
          }
          ,
          match: e => `slaStatus`in e ? !0 : `and`in e && Array.isArray(e.and) && typeof e.and[0] == `object` ? `slaStatus`in e.and[0] : `or`in e && Array.isArray(e.or) && typeof e.or[0] == `object` ? `slaStatus`in e.or[0] : !1,
          getCompareOption: e => `or`in e || `slaStatus`in e && `in`in e.slaStatus ? `is` : `not`,
          selectedValues(e) {
              return `or`in e ? [...e.or[0].slaStatus.in, ob] : `and`in e ? [...e.and[0].slaStatus.nin, ob] : `in`in e.slaStatus ? [...e.slaStatus.in] : `nin`in e.slaStatus ? [...e.slaStatus.nin] : []
          }
      },
      e.estimate = {
          key: `estimate`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e
                , r = (0,
              eO.default)(t, e => e !== ob)
                , i = r[0]
                , a = r[1].length > 0;
              return a && n === `is` ? {
                  estimate: {
                      or: [{
                          in: i
                      }, {
                          null: !0
                      }]
                  }
              } : a && n === `not` ? {
                  estimate: {
                      and: [{
                          nin: i
                      }, {
                          null: !1
                      }]
                  }
              } : n === `is` ? {
                  estimate: {
                      in: i
                  }
              } : {
                  estimate: {
                      nin: i
                  }
              }
          }
          ,
          match: e => `estimate`in e,
          getCompareOption: e => `or`in e.estimate || `in`in e.estimate ? `is` : `not`,
          selectedValues(e) {
              return `or`in e.estimate ? [...e.estimate.or[0].in, ob] : `and`in e.estimate ? [...e.estimate.and[0].nin, ob] : `in`in e.estimate ? e.estimate.in : e.estimate.nin
          }
      },
      e.labels = XD({
          key: `labels`,
          match: e => `labels`in e,
          filterToLabels: e => e.labels,
          labelsToFilter: e => ({
              labels: e
          })
      }),
      e.priority = {
          key: `priority`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  priority: {
                      in: t
                  }
              } : {
                  priority: {
                      nin: t
                  }
              }
          }
          ,
          match: e => `priority`in e,
          getCompareOption: e => `in`in e.priority ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.priority ? e.priority.in : e.priority.nin
          }
      };
      let t = e.projectInitiative = {
          key: `project`,
          compareOptions: `collection`,
          defaultCompareOption: `any`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return t.length === 0 && [`all`, `any`].indexOf(n) > -1 ? {
                  project: {
                      initiatives: {
                          length: {
                              eq: 0
                          }
                      }
                  }
              } : n === `all` ? {
                  project: {
                      initiatives: {
                          and: t.map(e => ({
                              id: {
                                  eq: e
                              }
                          }))
                      }
                  }
              } : n === `any` ? {
                  project: {
                      initiatives: {
                          or: t.map(e => ({
                              id: {
                                  eq: e
                              }
                          }))
                      }
                  }
              } : n === `notAll` ? {
                  project: {
                      or: [{
                          initiatives: {
                              or: [...t.map(e => ({
                                  every: {
                                      id: {
                                          neq: e
                                      }
                                  }
                              })), {
                                  length: {
                                      eq: 0
                                  }
                              }]
                          }
                      }, {
                          null: !0
                      }]
                  }
              } : {
                  project: {
                      or: [{
                          initiatives: {
                              or: [{
                                  every: {
                                      id: {
                                          nin: t
                                      }
                                  }
                              }, {
                                  length: {
                                      eq: 0
                                  }
                              }]
                          }
                      }, {
                          null: !0
                      }]
                  }
              }
          }
          ,
          match: e => (0,
          tO.default)(e, [`project`, `initiatives`]) || (0,
          tO.default)(e, [`project`, `or`, 0, `initiatives`]),
          getCompareOption: e => {
              if (`or`in e.project)
                  return (0,
                  tO.default)(e.project, [`or`, 0, `initiatives`, `or`, 0, `every`, `id`, `nin`]) ? `neither` : `notAll`;
              let t = `length`in e.project.initiatives || `and`in e.project.initiatives || e.project.initiatives.or.find(e => e.every?.id?.neq !== void 0) !== void 0
                , n = `length`in e.project.initiatives || `and`in e.project.initiatives || `or`in e.project.initiatives && `id`in (e.project.initiatives.or[0] || {});
              return t ? n ? `all` : `notAll` : n ? `any` : `neither`
          }
          ,
          selectedValues(e) {
              return `or`in e.project ? `length`in e.project.or[0].initiatives ? [] : `and`in e.project.or[0].initiatives ? e.project.or[0].initiatives.and.map(e => e.id.eq) : e.project.or[0].initiatives.or.flatMap(e => {
                  if (`id`in e)
                      return e.id.eq;
                  if (`every`in e)
                      return `nin`in e.every.id ? e.every.id.nin : e.every.id.neq
              }
              ).filter(Boolean) : `length`in e.project.initiatives ? [] : `and`in e.project.initiatives ? e.project.initiatives.and.map(e => e.id.eq) : e.project.initiatives.or.flatMap(e => {
                  if (`id`in e)
                      return e.id.eq;
                  if (`every`in e)
                      return `nin`in e.every.id ? e.every.id.nin : e.every.id.neq
              }
              ).filter(Boolean)
          }
      };
      e.project = {
          key: `project`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e
                , [r,i] = (0,
              eO.default)(t, e => e !== ob)
                , a = i.length > 0;
              return a && n === `is` ? {
                  project: {
                      or: [{
                          id: {
                              in: r
                          }
                      }, {
                          null: !0
                      }]
                  }
              } : a && n === `not` ? {
                  project: {
                      and: [{
                          id: {
                              nin: r
                          }
                      }, {
                          null: !1
                      }]
                  }
              } : n === `is` ? {
                  project: {
                      id: {
                          in: r
                      }
                  }
              } : {
                  project: {
                      id: {
                          nin: r
                      }
                  }
              }
          }
          ,
          match: e => `project`in e && !t.match(e) && !s.match(e) && !n.match(e) && !r.match(e) && !i.match(e) && !a.match(e) && !o.match(e),
          getCompareOption: e => `or`in e.project || `id`in e.project && `in`in e.project.id ? `is` : `not`,
          selectedValues(e) {
              return `or`in e.project ? e.project.or[0].id.in.concat(ob) : `and`in e.project ? e.project.and[0].id.nin.concat(ob) : `in`in e.project.id ? e.project.id.in : e.project.id.nin
          }
      };
      let n = e.projectStatus = {
          key: `project`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  project: {
                      status: {
                          id: {
                              in: t
                          }
                      }
                  }
              } : {
                  project: {
                      status: {
                          id: {
                              nin: t
                          }
                      }
                  }
              }
          }
          ,
          match: e => (0,
          tO.default)(e, [`project`, `status`, `id`]) || (0,
          tO.default)(e, [`project`, `status`, `or`, 0, `id`]),
          getCompareOption: e => `status`in e.project && `id`in e.project.status && `in`in e.project.status.id ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.project.status.id ? e.project.status.id.in : e.project.status.id.nin
          }
      }
        , r = e.projectStatusType = {
          key: `project`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  project: {
                      status: {
                          type: {
                              in: t
                          }
                      }
                  }
              } : {
                  project: {
                      or: [{
                          status: {
                              type: {
                                  nin: t
                              }
                          }
                      }, {
                          null: !0
                      }]
                  }
              }
          }
          ,
          match: e => (0,
          tO.default)(e, [`project`, `status`, `type`]) || (0,
          tO.default)(e, [`project`, `or`, 0, `status`, `type`]),
          getCompareOption: e => `status`in e.project ? `is` : `not`,
          selectedValues(e) {
              return `status`in e.project ? e.project.status.type.in : e.project.or[0].status.type.nin
          }
      }
        , i = e.projectPriority = {
          key: `project`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  project: {
                      priority: {
                          in: t
                      }
                  }
              } : {
                  project: {
                      priority: {
                          nin: t
                      }
                  }
              }
          }
          ,
          match: e => (0,
          tO.default)(e, [`project`, `priority`]),
          getCompareOption: e => `in`in e.project.priority ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.project.priority ? e.project.priority.in : e.project.priority.nin
          }
      }
        , a = e.projectLabels = XD({
          key: `project`,
          match: e => (0,
          tO.default)(e, [`project`, `labels`]),
          filterToLabels: e => e.project.labels,
          labelsToFilter: e => ({
              project: {
                  labels: e
              }
          })
      })
        , o = e.projectLead = {
          key: `project`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => ({
              project: {
                  lead: ND.createUserFilterBlock(e)
              }
          }),
          match: e => (0,
          tO.default)(e, [`project`, `lead`]),
          getCompareOption: e => ND.getUserCompareOption(e.project.lead),
          selectedValues(e) {
              return ND.getSelectedUserValues(e.project.lead)
          }
      };
      e.projectMilestone = {
          key: `projectMilestone`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e
                , r = t.filter(e => e !== ob)
                , i = t.some(e => e === ob);
              if (n === `is`) {
                  let e = {
                      projectMilestone: {
                          id: {
                              in: r
                          }
                      }
                  };
                  return i ? {
                      or: [e, {
                          projectMilestone: {
                              null: !0
                          }
                      }]
                  } : e
              } else {
                  let e = {
                      projectMilestone: {
                          id: {
                              nin: r
                          }
                      }
                  };
                  return i ? {
                      and: [e, {
                          projectMilestone: {
                              null: !1
                          }
                      }]
                  } : {
                      or: [e, {
                          projectMilestone: {
                              null: !0
                          }
                      }]
                  }
              }
          }
          ,
          match: e => (`projectMilestone`in e || (0,
          tO.default)(e, [`or`, 0, `projectMilestone`]) || (0,
          tO.default)(e, [`and`, 0, `projectMilestone`])) && !s.match(e),
          getCompareOption: e => `projectMilestone`in e || `or`in e && `in`in e.or[0].projectMilestone.id ? `is` : `not`,
          selectedValues(e) {
              return `projectMilestone`in e ? `in`in e.projectMilestone.id ? e.projectMilestone.id.in : e.projectMilestone.id.nin : `and`in e ? e.and.length === 2 ? [...e.and[0].projectMilestone.id.nin, ob] : e.and[0].projectMilestone.id.nin : `or`in e ? `in`in e.or[0].projectMilestone.id ? [...e.or[0].projectMilestone.id.in, ob] : e.or[0].projectMilestone.id.nin : []
          }
      };
      let s = e.projectMilestoneName = {
          key: `projectMilestone`,
          compareOptions: `containsValue`,
          defaultCompareOption: `contains`,
          allowMultiSelect: !1,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `contains` ? {
                  projectMilestone: {
                      name: {
                          containsIgnoreCase: t[0]
                      }
                  }
              } : {
                  projectMilestone: {
                      or: [{
                          name: {
                              notContainsIgnoreCase: t[0]
                          }
                      }, {
                          name: {
                              null: !0
                          }
                      }]
                  }
              }
          }
          ,
          match: e => {
              let t = `projectMilestone`in e ? e.projectMilestone : void 0;
              return t ? `name`in t || `or`in t && `name`in t.or[0] : !1
          }
          ,
          getCompareOption: e => `name`in e.projectMilestone ? `contains` : `notContains`,
          selectedValues(e) {
              return `name`in e.projectMilestone ? [e.projectMilestone.name.containsIgnoreCase] : [e.projectMilestone.or[0].name.notContainsIgnoreCase]
          }
      };
      e.searchableContent = {
          key: `searchableContent`,
          compareOptions: `containsValue`,
          defaultCompareOption: `contains`,
          allowMultiSelect: !1,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `contains` ? {
                  searchableContent: {
                      contains: t[t.length - 1].trim()
                  }
              } : {
                  searchableContent: {
                      notContains: t[t.length - 1].trim()
                  }
              }
          }
          ,
          match: e => `searchableContent`in e,
          getCompareOption: e => `contains`in e.searchableContent ? `contains` : `notContains`,
          selectedValues(e) {
              return `contains`in e.searchableContent ? [e.searchableContent.contains] : [e.searchableContent.notContains]
          }
      },
      e.state = {
          key: `state`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return {
                  state: {
                      name: n === `is` ? {
                          in: t
                      } : {
                          nin: t
                      }
                  }
              }
          }
          ,
          match: e => `state`in e && !c.match(e),
          getCompareOption: e => `in`in e.state.name ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.state.name ? e.state.name.in : e.state.name.nin
          }
      };
      let c = e.stateType = {
          key: `state`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  state: {
                      type: {
                          in: t
                      }
                  }
              } : {
                  state: {
                      type: {
                          nin: t
                      }
                  }
              }
          }
          ,
          match: e => (0,
          tO.default)(e, [`state`, `type`]) || (0,
          tO.default)(e, [`state`, `or`, 0, `type`]),
          getCompareOption: e => `type`in e.state && `in`in e.state.type ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.state.type ? e.state.type.in : e.state.type.nin
          }
      };
      e.parentIssue = {
          key: `children`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  children: {
                      length: t === `is` ? {
                          gt: 0
                      } : {
                          eq: 0
                      }
                  }
              }
          }
          ,
          match: e => `children`in e,
          getCompareOption: e => `gt`in e.children.length ? `is` : `not`
      },
      e.subscribers = {
          key: `subscribers`,
          compareOptions: `containsValue`,
          defaultCompareOption: `contains`,
          allowMultiSelect: !0,
          create: e => ({
              subscribers: ND.createUserListFilterBlock(e)
          }),
          match: e => `subscribers`in e,
          getCompareOption: e => ND.getUserListCompareOption(e.subscribers),
          selectedValues(e) {
              return ND.getSelectedUserListValues(e.subscribers)
          }
      },
      e.team = {
          key: `team`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  team: {
                      id: {
                          in: t
                      }
                  }
              } : {
                  team: {
                      id: {
                          nin: t
                      }
                  }
              }
          }
          ,
          match: e => `team`in e,
          getCompareOption: e => `in`in e.team.id ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.team.id ? e.team.id.in : e.team.id.nin
          }
      },
      e.subIssue = {
          key: `parent`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  parent: {
                      null: t === `not`
                  }
              }
          }
          ,
          match: e => `parent`in e,
          getCompareOption: e => e.parent.null ? `not` : `is`
      },
      e.blockingRelation = {
          key: `hasBlockingRelations`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  hasBlockingRelations: {
                      eq: t === `is`
                  }
              }
          }
          ,
          match: e => `hasBlockingRelations`in e,
          getCompareOption: e => e.hasBlockingRelations.eq ? `is` : `not`
      },
      e.blockedRelation = {
          key: `hasBlockedByRelations`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  hasBlockedByRelations: {
                      eq: t === `is`
                  }
              }
          }
          ,
          match: e => `hasBlockedByRelations`in e,
          getCompareOption: e => e.hasBlockedByRelations.eq ? `is` : `not`
      },
      e.duplicateRelation = {
          key: `hasDuplicateRelations`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  hasDuplicateRelations: {
                      eq: t === `is`
                  }
              }
          }
          ,
          match: e => `hasDuplicateRelations`in e,
          getCompareOption: e => e.hasDuplicateRelations.eq ? `is` : `not`
      },
      e.relatedRelation = {
          key: `hasRelatedRelations`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  hasRelatedRelations: {
                      eq: t === `is`
                  }
              }
          }
          ,
          match: e => `hasRelatedRelations`in e,
          getCompareOption: e => e.hasRelatedRelations.eq ? `is` : `not`,
          getCompareOptionLabel: e => {
              switch (e) {
              case `is`:
                  return `has`;
              case `not`:
              case `is not`:
                  return `has no`;
              default:
                  return e
              }
          }
      },
      e.hasRelatedSuggestions = {
          key: `hasSuggestedRelatedIssues`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  hasSuggestedRelatedIssues: {
                      eq: t === `is`
                  }
              }
          }
          ,
          match: e => `hasSuggestedRelatedIssues`in e,
          getCompareOption: e => e.hasSuggestedRelatedIssues.eq ? `is` : `not`,
          getCompareOptionLabel: e => {
              switch (e) {
              case `is`:
                  return `has`;
              case `not`:
              case `is not`:
                  return `has no`;
              default:
                  return e
              }
          }
      },
      e.hasDuplicateSuggestions = {
          key: `hasSuggestedSimilarIssues`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  hasSuggestedSimilarIssues: {
                      eq: t === `is`
                  }
              }
          }
          ,
          match: e => `hasSuggestedSimilarIssues`in e,
          getCompareOption: e => e.hasSuggestedSimilarIssues.eq ? `is` : `not`,
          getCompareOptionLabel: e => {
              switch (e) {
              case `is`:
                  return `has`;
              case `not`:
              case `is not`:
                  return `has no`;
              default:
                  return e
              }
          }
      };
      function l(e) {
          return (0,
          tO.default)(e, [`suggestions`]) || `hasSuggestedAssignees`in e || `hasSuggestedProjects`in e || `hasSuggestedLabels`in e || `hasSuggestedTeams`in e
      }
      function u(e) {
          if (`hasSuggestedAssignees`in e)
              return Nl.assignee;
          if (`hasSuggestedProjects`in e)
              return Nl.project;
          if (`hasSuggestedLabels`in e)
              return Nl.label;
          if (`hasSuggestedTeams`in e)
              return Nl.team;
          if (`suggestions`in e && (0,
          tO.default)(e, [`suggestions`, `some`, `type`, `eq`]))
              return e.suggestions.some?.type?.eq;
          if (`suggestions`in e && (0,
          tO.default)(e, [`suggestions`, `every`, `or`]))
              return (e.suggestions.every?.or.find(e => `type`in e))?.type?.neq
      }
      e.suggestedAssignee = {
          key: `suggestions`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return t.includes(`____any____`) ? {
                  hasSuggestedAssignees: {
                      eq: n === `is`
                  }
              } : n === `is` ? {
                  suggestions: {
                      some: {
                          type: {
                              eq: Nl.assignee
                          },
                          state: {
                              in: [Pl.active, Pl.accepted]
                          },
                          suggestedUser: {
                              id: {
                                  in: t
                              }
                          }
                      }
                  }
              } : {
                  suggestions: {
                      every: {
                          or: [{
                              type: {
                                  neq: Nl.assignee
                              }
                          }, {
                              state: {
                                  nin: [Pl.active, Pl.accepted]
                              }
                          }, {
                              suggestedUser: {
                                  id: {
                                      nin: t
                                  }
                              }
                          }]
                      }
                  }
              }
          }
          ,
          match: e => `hasSuggestedAssignees`in e ? !0 : l(e) ? u(e) === Nl.assignee : !1,
          getCompareOption: e => `hasSuggestedAssignees`in e ? e.hasSuggestedAssignees.eq ? `is` : `not` : `some`in e.suggestions ? `is` : `not`,
          selectedValues(e) {
              return `hasSuggestedAssignees`in e ? [sb] : e.suggestions.some ? e.suggestions.some.suggestedUser?.id?.in ?? [] : (e.suggestions.every?.or)?.find(e => `suggestedUser`in e)?.suggestedUser?.id?.nin ?? []
          }
      },
      e.suggestedProject = {
          key: `suggestions`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return t.includes(`____any____`) ? {
                  hasSuggestedProjects: {
                      eq: n === `is`
                  }
              } : n === `is` ? {
                  suggestions: {
                      some: {
                          type: {
                              eq: Nl.project
                          },
                          state: {
                              in: [Pl.active, Pl.accepted]
                          },
                          suggestedProject: {
                              id: {
                                  in: t
                              }
                          }
                      }
                  }
              } : {
                  suggestions: {
                      every: {
                          or: [{
                              type: {
                                  neq: Nl.project
                              }
                          }, {
                              state: {
                                  nin: [Pl.active, Pl.accepted]
                              }
                          }, {
                              suggestedProject: {
                                  id: {
                                      nin: t
                                  }
                              }
                          }]
                      }
                  }
              }
          }
          ,
          match: e => `hasSuggestedProjects`in e ? !0 : l(e) ? u(e) === Nl.project : !1,
          getCompareOption: e => `hasSuggestedProjects`in e ? e.hasSuggestedProjects.eq ? `is` : `not` : `some`in e.suggestions ? `is` : `not`,
          selectedValues(e) {
              return `hasSuggestedProjects`in e ? [sb] : e.suggestions.some ? e.suggestions.some.suggestedProject?.id?.in ?? [] : (e.suggestions.every?.or)?.find(e => `suggestedProject`in e)?.suggestedProject?.id?.nin ?? []
          }
      },
      e.suggestedLabel = {
          key: `suggestions`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return t.includes(`____any____`) ? {
                  hasSuggestedLabels: {
                      eq: n === `is`
                  }
              } : n === `is` ? {
                  suggestions: {
                      some: {
                          type: {
                              eq: Nl.label
                          },
                          state: {
                              in: [Pl.active, Pl.accepted]
                          },
                          suggestedLabel: {
                              or: [{
                                  name: {
                                      in: t
                                  }
                              }, {
                                  parent: {
                                      name: {
                                          in: t
                                      }
                                  }
                              }]
                          }
                      }
                  }
              } : {
                  suggestions: {
                      every: {
                          or: [{
                              type: {
                                  neq: Nl.label
                              }
                          }, {
                              state: {
                                  nin: [Pl.active, Pl.accepted]
                              }
                          }, {
                              suggestedLabel: {
                                  and: [{
                                      name: {
                                          nin: t
                                      }
                                  }, {
                                      parent: {
                                          name: {
                                              nin: t
                                          }
                                      }
                                  }]
                              }
                          }]
                      }
                  }
              }
          }
          ,
          match: e => `hasSuggestedLabels`in e ? !0 : l(e) ? u(e) === Nl.label : !1,
          getCompareOption: e => `hasSuggestedLabels`in e ? e.hasSuggestedLabels.eq ? `is` : `not` : `some`in e.suggestions ? `is` : `not`,
          selectedValues(e) {
              if (`hasSuggestedLabels`in e)
                  return [sb];
              if (e.suggestions.some) {
                  let t = e.suggestions.some.suggestedLabel?.or ?? [];
                  return [...t.find(e => `name`in e)?.name?.in ?? [], ...t.find(e => `parent`in e)?.parent?.name?.in ?? []].distinct()
              } else {
                  let t = e.suggestions.every?.or.filter(e => `suggestedLabel`in e).flatMap(e => e.suggestedLabel?.and ?? []) ?? [];
                  return [...t.find(e => `name`in e)?.name?.nin ?? [], ...t.find(e => `parent`in e)?.parent?.name?.nin ?? []].distinct()
              }
          }
      },
      e.suggestedTeam = {
          key: `suggestions`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return t.includes(`____any____`) ? {
                  hasSuggestedTeams: {
                      eq: n === `is`
                  }
              } : n === `is` ? {
                  suggestions: {
                      some: {
                          type: {
                              eq: Nl.team
                          },
                          state: {
                              in: [Pl.active, Pl.accepted]
                          },
                          suggestedTeam: {
                              id: {
                                  in: t
                              }
                          }
                      }
                  }
              } : {
                  suggestions: {
                      every: {
                          or: [{
                              type: {
                                  neq: Nl.team
                              }
                          }, {
                              state: {
                                  nin: [Pl.active, Pl.accepted]
                              }
                          }, {
                              suggestedTeam: {
                                  id: {
                                      nin: t
                                  }
                              }
                          }]
                      }
                  }
              }
          }
          ,
          match: e => `hasSuggestedTeams`in e ? !0 : l(e) ? u(e) === Nl.team : !1,
          getCompareOption: e => `hasSuggestedTeams`in e ? e.hasSuggestedTeams.eq ? `is` : `not` : `some`in e.suggestions ? `is` : `not`,
          selectedValues(e) {
              return `hasSuggestedTeams`in e ? [sb] : e.suggestions.some ? e.suggestions.some.suggestedTeam?.id?.in ?? [] : (e.suggestions.every?.or)?.find(e => `suggestedTeam`in e)?.suggestedTeam?.id?.nin ?? []
          }
      },
      e.sourceMetadata = {
          key: `sourceMetadata`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e
                , r = t.filter(e => e !== ob)
                , i = t.some(e => e === ob);
              if (n === `is`) {
                  let e = {
                      sourceMetadata: {
                          subType: {
                              in: r
                          }
                      }
                  };
                  return i ? {
                      or: [e, {
                          sourceMetadata: {
                              null: !0
                          }
                      }]
                  } : e
              } else {
                  let e = {
                      sourceMetadata: {
                          subType: {
                              nin: r
                          }
                      }
                  };
                  return i ? {
                      and: [e, {
                          sourceMetadata: {
                              null: !1
                          }
                      }]
                  } : {
                      or: [e, {
                          sourceMetadata: {
                              null: !0
                          }
                      }]
                  }
              }
          }
          ,
          match: e => (0,
          tO.default)(e, [`sourceMetadata`, `subType`]) || (0,
          tO.default)(e, [`or`, 0, `sourceMetadata`, `subType`]) || (0,
          tO.default)(e, [`and`, 0, `sourceMetadata`, `subType`]),
          getCompareOption: e => `sourceMetadata`in e || `or`in e && `in`in e.or[0].sourceMetadata.subType ? `is` : `not`,
          selectedValues(e) {
              return `sourceMetadata`in e ? `in`in e.sourceMetadata.subType ? e.sourceMetadata.subType.in : e.sourceMetadata.subType.nin : `and`in e ? e.and.length === 2 ? [...e.and[0].sourceMetadata.subType.nin, ob] : e.and[0].sourceMetadata.subType.nin : `or`in e ? `in`in e.or[0].sourceMetadata.subType ? [...e.or[0].sourceMetadata.subType.in, ob] : e.or[0].sourceMetadata.subType.nin : []
          }
      };
      function d(e) {
          return {
              key: e,
              compareOptions: `equalValue`,
              defaultCompareOption: `is`,
              allowMultiSelect: !0,
              create: t => {
                  let {values: n, compareOption: r} = t
                    , i = []
                    , a = !1;
                  for (let e of n)
                      e === `____null____` ? a = !0 : i.push(e);
                  if (r === `is`) {
                      let t = {
                          or: []
                      };
                      return a && t.or.push({
                          null: !0
                      }),
                      i.length && t.or.push({
                          id: {
                              in: i
                          }
                      }),
                      {
                          [e]: t
                      }
                  } else {
                      let t = {
                          and: i.length ? [{
                              id: {
                                  nin: i
                              }
                          }] : []
                      };
                      return a && t.and.push({
                          null: !1
                      }),
                      {
                          [e]: t
                      }
                  }
              }
              ,
              match: t => e in t,
              getCompareOption: t => `or`in t[e] || `id`in t[e] && `in`in t[e].id ? `is` : `not`,
              selectedValues: t => {
                  if (`id`in t[e])
                      return `in`in t[e].id ? t[e].id.in : t[e].id.nin;
                  if (`or`in t[e]) {
                      let n = [];
                      for (let r of t[e].or)
                          `id`in r ? n.push(...r.id.in) : `null`in r && n.push(ob);
                      return n
                  } else if (`and`in t[e]) {
                      let n = [];
                      for (let r of t[e].and)
                          `id`in r ? n.push(...r.id.nin) : `null`in r && n.push(ob);
                      return n
                  }
                  return []
              }
          }
      }
      e.lastAppliedTemplate = d(`lastAppliedTemplate`),
      e.recurringIssueTemplate = d(`recurringIssueTemplate`),
      e.needsCount = {
          key: `needs`,
          compareOptions: `number`,
          defaultCompareOption: `gte`,
          allowMultiSelect: !1,
          create: e => {
              let {values: t, compareOption: n} = e
                , r = t[0];
              return n === `eq` ? {
                  needs: {
                      length: {
                          eq: r
                      }
                  }
              } : n === `neq` ? {
                  needs: {
                      length: {
                          neq: r
                      }
                  }
              } : n === `gte` ? {
                  needs: {
                      length: {
                          gte: r
                      }
                  }
              } : n === `lte` ? {
                  needs: {
                      length: {
                          lte: r
                      }
                  }
              } : {
                  needs: {
                      length: {
                          neq: 0
                      }
                  }
              }
          }
          ,
          match: e => (0,
          tO.default)(e, [`needs`, `length`]),
          getCompareOption: e => `length`in e.needs ? `eq`in e.needs.length ? `eq` : `neq`in e.needs.length ? `neq` : `gte`in e.needs.length ? `gte` : `lte`in e.needs.length ? `lte` : `gte` : `gte`,
          selectedValues(e) {
              if (`length`in e.needs) {
                  if (`eq`in e.needs.length)
                      return [e.needs.length.eq];
                  if (`neq`in e.needs.length)
                      return [e.needs.length.neq];
                  if (`gte`in e.needs.length)
                      return [e.needs.length.gte];
                  if (`lte`in e.needs.length)
                      return [e.needs.length.lte]
              }
              return []
          }
      }
  }
  )(nO ||= {}),
  rO = e => e.filter(e => e !== void 0)
}
)), aO, oO, sO = t(( () => {
  St(),
  aO = e(he(), 1),
  QD(),
  _D(),
  FD(),
  LD(),
  TD(),
  vb(),
  (function(e) {
      e.id = {
          key: `id`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  id: {
                      in: t
                  }
              } : {
                  id: {
                      nin: t
                  }
              }
          }
          ,
          match: e => `id`in e,
          getCompareOption: e => `nin`in e.id ? `not` : `is`,
          selectedValues(e) {
              return `nin`in e.id ? e.id.nin : e.id.in
          }
      },
      _t({
          status: _t({
              id: mt([_t({
                  in: Dt(yt())
              }), _t({
                  nin: Dt(yt())
              })])
          })
      }),
      e.status = {
          key: `status`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return {
                  status: {
                      id: n === `is` ? {
                          in: t
                      } : {
                          nin: t
                      }
                  }
              }
          }
          ,
          match: e => (0,
          aO.default)(e, [`status`, `id`]),
          getCompareOption: e => `in`in e.status.id ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.status.id ? e.status.id.in : e.status.id.nin
          }
      },
      _t({
          status: _t({
              type: mt([_t({
                  in: Dt(yt())
              }), _t({
                  nin: Dt(yt())
              })])
          })
      }),
      e.statusType = {
          key: `status`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return {
                  status: {
                      type: n === `is` ? {
                          in: t
                      } : {
                          nin: t
                      }
                  }
              }
          }
          ,
          match: e => (0,
          aO.default)(e, [`status`, `type`]),
          getCompareOption: e => `in`in e.status.type ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.status.type ? e.status.type.in : e.status.type.nin
          }
      },
      e.priority = {
          key: `priority`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  priority: {
                      in: t
                  }
              } : {
                  priority: {
                      nin: t
                  }
              }
          }
          ,
          match: e => `priority`in e,
          getCompareOption: e => `in`in e.priority ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.priority ? e.priority.in : e.priority.nin
          }
      },
      e.labels = XD({
          key: `labels`,
          match: e => `labels`in e,
          filterToLabels: e => e.labels,
          labelsToFilter: e => ({
              labels: e
          })
      }),
      e.initiatives = {
          key: `initiatives`,
          compareOptions: `collection`,
          defaultCompareOption: `any`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `all` ? {
                  initiatives: {
                      and: t.map(e => ({
                          id: {
                              eq: e
                          }
                      }))
                  }
              } : n === `any` ? {
                  initiatives: {
                      or: t.map(e => ({
                          id: {
                              eq: e
                          }
                      }))
                  }
              } : n === `notAll` ? {
                  initiatives: {
                      or: [...t.map(e => ({
                          every: {
                              id: {
                                  neq: e
                              }
                          }
                      })), {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              } : {
                  initiatives: {
                      or: [{
                          every: {
                              id: {
                                  nin: t
                              }
                          }
                      }, {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              }
          }
          ,
          match: e => `initiatives`in e && !n.match(e) && !t.match(e),
          getCompareOption: e => {
              let t = `length`in e.initiatives || `and`in e.initiatives || e.initiatives.or.find(e => e.every?.id?.neq !== void 0) !== void 0
                , n = `length`in e.initiatives || `and`in e.initiatives || `or`in e.initiatives && `id`in (e.initiatives.or[0] || {});
              return t ? n ? `all` : `notAll` : n ? `any` : `neither`
          }
          ,
          selectedValues(e) {
              return `length`in e.initiatives ? [] : `and`in e.initiatives ? e.initiatives.and.map(e => e.id.eq) : e.initiatives.or.flatMap(e => {
                  if (`id`in e)
                      return e.id.eq;
                  if (`every`in e)
                      return `nin`in e.every.id ? e.every.id.nin : e.every.id.neq
              }
              ).filter(Boolean)
          }
      };
      let t = e.noInitiatives = {
          key: `initiatives`,
          compareOptions: `equalValue`,
          defaultCompareOption: `not`,
          allowMultiSelect: !0,
          create: e => {
              let {compareOption: t} = e;
              return {
                  initiatives: {
                      length: t === `not` ? {
                          eq: 0
                      } : {
                          neq: 0
                      }
                  }
              }
          }
          ,
          match: e => (0,
          aO.default)(e, [`initiatives`, `length`, `eq`]) || (0,
          aO.default)(e, [`initiatives`, `length`, `neq`]),
          getCompareOption: e => (0,
          aO.default)(e, [`initiatives`, `length`, `eq`]) ? `not` : `is`,
          getCompareOptionLabel: e => {
              switch (e) {
              case `is`:
                  return `has`;
              case `not`:
              case `is not`:
                  return `has no`;
              default:
                  return e
              }
          }
      }
        , n = e.initiativeStatus = {
          key: `initiatives`,
          compareOptions: `collection`,
          defaultCompareOption: `any`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `all` ? {
                  initiatives: {
                      and: t.map(e => ({
                          status: {
                              eq: e
                          }
                      }))
                  }
              } : n === `any` ? {
                  initiatives: {
                      or: t.map(e => ({
                          status: {
                              eq: e
                          }
                      }))
                  }
              } : n === `notAll` ? {
                  initiatives: {
                      or: [...t.map(e => ({
                          every: {
                              status: {
                                  neq: e
                              }
                          }
                      })), {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              } : {
                  initiatives: {
                      or: [{
                          every: {
                              status: {
                                  nin: t
                              }
                          }
                      }, {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              }
          }
          ,
          match: e => (0,
          aO.default)(e, [`initiatives`, `or`, 0, `status`]) || (0,
          aO.default)(e, [`initiatives`, `and`, 0, `status`]) || (0,
          aO.default)(e, [`initiatives`, `or`, 0, `every`, `status`]),
          getCompareOption: e => {
              let t = `length`in e.initiatives || `and`in e.initiatives || e.initiatives.or.find(e => e.every?.status?.neq !== void 0) !== void 0
                , n = `length`in e.initiatives || `and`in e.initiatives || `or`in e.initiatives && `status`in (e.initiatives.or[0] || {});
              return t ? n ? `all` : `notAll` : n ? `any` : `neither`
          }
          ,
          selectedValues(e) {
              return `length`in e.initiatives ? [] : `and`in e.initiatives ? e.initiatives.and.map(e => e.status.eq) : e.initiatives.or.flatMap(e => {
                  if (`status`in e)
                      return e.status.eq;
                  if (`every`in e)
                      return `nin`in e.every.status ? e.every.status.nin : e.every.status.neq
              }
              ).filter(Boolean)
          }
      };
      _t({
          searchableContent: mt([_t({
              contains: yt()
          }), _t({
              notContains: yt()
          })])
      }),
      e.searchableContent = {
          key: `searchableContent`,
          compareOptions: `containsValue`,
          defaultCompareOption: `contains`,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `contains` ? {
                  searchableContent: {
                      contains: t[t.length - 1]
                  }
              } : {
                  searchableContent: {
                      notContains: t[t.length - 1]
                  }
              }
          }
          ,
          match: e => `searchableContent`in e,
          getCompareOption: e => `contains`in e.searchableContent ? `contains` : `notContains`,
          selectedValues(e) {
              return `contains`in e.searchableContent ? [e.searchableContent.contains] : [e.searchableContent.notContains]
          }
      },
      e.lead = {
          key: `lead`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => ({
              lead: ND.createUserFilterBlock(e)
          }),
          match: e => `lead`in e,
          getCompareOption: e => ND.getUserCompareOption(e.lead),
          selectedValues(e) {
              return ND.getSelectedUserValues(e.lead)
          }
      },
      e.creator = {
          key: `creator`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => ({
              creator: ND.createUserFilterBlock(e)
          }),
          match: e => `creator`in e,
          getCompareOption: e => ND.getUserCompareOption(e.creator),
          selectedValues(e) {
              return ND.getSelectedUserValues(e.creator)
          }
      },
      e.members = {
          key: `members`,
          compareOptions: `containsValue`,
          defaultCompareOption: `contains`,
          allowMultiSelect: !0,
          create: e => ({
              members: ND.createUserListFilterBlock(e)
          }),
          match: e => `members`in e,
          getCompareOption: e => ND.getUserListCompareOption(e.members),
          selectedValues(e) {
              return ND.getSelectedUserListValues(e.members)
          }
      },
      mt([...ID, _t({
          length: _t({
              eq: Tt().int().min(0)
          })
      })]),
      e.teams = {
          key: `accessibleTeams`,
          compareOptions: `collection`,
          defaultCompareOption: `any`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return t.length === 0 && [`all`, `any`].indexOf(n) > -1 ? {
                  accessibleTeams: {
                      length: {
                          eq: 0
                      }
                  }
              } : n === `all` ? {
                  accessibleTeams: {
                      and: t.map(e => ({
                          id: {
                              eq: e
                          }
                      }))
                  }
              } : n === `any` ? {
                  accessibleTeams: {
                      or: t.map(e => ({
                          id: {
                              eq: e
                          }
                      }))
                  }
              } : n === `notAll` ? {
                  accessibleTeams: {
                      or: [...t.map(e => ({
                          every: {
                              id: {
                                  neq: e
                              }
                          }
                      })), {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              } : {
                  accessibleTeams: {
                      or: [{
                          every: {
                              id: {
                                  nin: t
                              }
                          }
                      }, {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              }
          }
          ,
          match: e => `accessibleTeams`in e,
          getCompareOption: e => {
              let t = `length`in e.accessibleTeams || `and`in e.accessibleTeams || e.accessibleTeams.or.find(e => e.every?.id?.neq !== void 0) !== void 0
                , n = `length`in e.accessibleTeams || `and`in e.accessibleTeams || `or`in e.accessibleTeams && `id`in (e.accessibleTeams.or[0] || {});
              return t ? n ? `all` : `notAll` : n ? `any` : `neither`
          }
          ,
          selectedValues(e) {
              return `length`in e.accessibleTeams ? [] : `and`in e.accessibleTeams ? e.accessibleTeams.and.map(e => e.id.eq) : e.accessibleTeams.or.flatMap(e => {
                  if (`id`in e)
                      return e.id.eq;
                  if (`every`in e)
                      return `nin`in e.every.id ? e.every.id.nin : e.every.id.neq
              }
              ).filter(Boolean)
          }
      },
      e.completedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `completedAt`,
          nullable: !0
      }),
      e.updatedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `updatedAt`,
          nullable: !1
      }),
      e.startDate = CD({
          defaultCompareOptionForDates: `before`,
          property: `startDate`,
          nullable: !0
      }),
      e.targetDate = CD({
          defaultCompareOptionForDates: `before`,
          property: `targetDate`,
          nullable: !0
      }),
      e.createdAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `createdAt`,
          nullable: !1
      }),
      _t({
          projectUpdates: mt([_t({
              some: _t({
                  createdAt: _t({
                      gte: mD
                  })
              })
          }), _t({
              every: _t({
                  createdAt: _t({
                      lt: mD
                  })
              })
          }), _t({
              length: _t({
                  eq: Tt()
              })
          }), _t({
              length: _t({
                  gt: Tt()
              })
          })])
      }),
      e.lastProjectUpdateAt = {
          key: `projectUpdates`,
          compareOptions: e => e[0] === `____null____` ? `equalValue` : `date`,
          defaultCompareOption: e => e[0] === `____null____` ? `is` : `after`,
          allowMultiSelect: !1,
          create: e => {
              let {values: t, compareOption: n} = e;
              return t[0] === `____null____` ? n === `is` ? {
                  projectUpdates: {
                      length: {
                          eq: 0
                      }
                  }
              } : {
                  projectUpdates: {
                      length: {
                          gt: 0
                      }
                  }
              } : n === `before` ? {
                  projectUpdates: {
                      every: {
                          createdAt: {
                              lt: t[0]
                          }
                      }
                  }
              } : {
                  projectUpdates: {
                      some: {
                          createdAt: {
                              gte: t[0]
                          }
                      }
                  }
              }
          }
          ,
          match: e => `projectUpdates`in e,
          getCompareOption: e => `length`in e.projectUpdates ? `eq`in e.projectUpdates.length ? `is` : `not` : `some`in e.projectUpdates ? `after` : `before`,
          selectedValues(e) {
              return `length`in e.projectUpdates ? [ob] : `some`in e.projectUpdates ? [e.projectUpdates.some.createdAt.gte] : `every`in e.projectUpdates ? [e.projectUpdates.every.createdAt.lt] : []
          }
      },
      _t({
          hasRelatedRelations: _t({
              eq: bt()
          })
      }),
      e.relatedRelations = {
          key: `hasRelatedRelations`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  hasRelatedRelations: {
                      eq: t === `is`
                  }
              }
          }
          ,
          match: e => `hasRelatedRelations`in e,
          getCompareOption: e => e.hasRelatedRelations.eq ? `is` : `not`,
          getCompareOptionLabel: e => {
              switch (e) {
              case `is`:
                  return `has`;
              case `not`:
              case `is not`:
                  return `has no`;
              default:
                  return e
              }
          }
      },
      _t({
          hasBlockingRelations: _t({
              eq: bt()
          })
      }),
      e.blockingRelations = {
          key: `hasBlockingRelations`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  hasBlockingRelations: {
                      eq: t === `is`
                  }
              }
          }
          ,
          match: e => `hasBlockingRelations`in e,
          getCompareOption: e => e.hasBlockingRelations.eq ? `is` : `not`
      },
      _t({
          hasBlockedByRelations: _t({
              eq: bt()
          })
      }),
      e.blockedByRelations = {
          key: `hasBlockedByRelations`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  hasBlockedByRelations: {
                      eq: t === `is`
                  }
              }
          }
          ,
          match: e => `hasBlockedByRelations`in e,
          getCompareOption: e => e.hasBlockedByRelations.eq ? `is` : `not`
      },
      _t({
          hasViolatedRelations: _t({
              eq: bt()
          })
      }),
      e.violatedRelations = {
          key: `hasViolatedRelations`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          create: e => {
              let {compareOption: t} = e;
              return {
                  hasViolatedRelations: {
                      eq: t === `is`
                  }
              }
          }
          ,
          match: e => `hasViolatedRelations`in e,
          getCompareOption: e => e.hasViolatedRelations.eq ? `is` : `not`,
          getCompareOptionLabel: e => {
              switch (e) {
              case `is`:
                  return `has`;
              case `not`:
              case `is not`:
                  return `has no`;
              default:
                  return e
              }
          }
      },
      e.nextMilestone = {
          key: `nextProjectMilestone`,
          compareOptions: `containsValue`,
          defaultCompareOption: `contains`,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `contains` ? {
                  nextProjectMilestone: {
                      name: {
                          contains: t[0]
                      }
                  }
              } : {
                  nextProjectMilestone: {
                      or: [{
                          name: {
                              notContains: t[0]
                          }
                      }, {
                          name: {
                              null: !0
                          }
                      }]
                  }
              }
          }
          ,
          match: e => `nextProjectMilestone`in e,
          getCompareOption: e => `name`in e.nextProjectMilestone ? `contains` : `notContains`,
          selectedValues(e) {
              return `name`in e.nextProjectMilestone ? [e.nextProjectMilestone.name.contains] : [e.nextProjectMilestone.or[0].name.notContains]
          }
      },
      e.completedMilestones = {
          key: `completedProjectMilestones`,
          compareOptions: `containsValue`,
          defaultCompareOption: `contains`,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `contains` ? {
                  completedProjectMilestones: {
                      some: {
                          name: {
                              contains: t[0]
                          }
                      }
                  }
              } : {
                  completedProjectMilestones: {
                      or: [{
                          every: {
                              name: {
                                  notContains: t[0]
                              }
                          }
                      }, {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              }
          }
          ,
          match: e => `completedProjectMilestones`in e,
          getCompareOption: e => `some`in e.completedProjectMilestones ? `contains` : `notContains`,
          selectedValues(e) {
              return `some`in e.completedProjectMilestones ? [e.completedProjectMilestones.some.name.contains] : [e.completedProjectMilestones.or[0].every.name.notContains]
          }
      },
      _t({
          lastAppliedTemplate: mt([_t({
              id: _t({
                  in: Dt(yt())
              })
          }), _t({
              id: _t({
                  nin: Dt(yt())
              })
          }), _t({
              or: Dt(mt([_t({
                  id: _t({
                      in: Dt(yt())
                  })
              }), _t({
                  null: pt(!0)
              })]))
          }), _t({
              and: Dt(mt([_t({
                  id: _t({
                      nin: Dt(yt())
                  })
              }), _t({
                  null: pt(!1)
              })]))
          })])
      }),
      e.lastAppliedTemplate = {
          key: `lastAppliedTemplate`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e
                , r = []
                , i = !1;
              for (let e of t)
                  e === `____null____` ? i = !0 : r.push(e);
              if (n === `is`) {
                  let e = {
                      or: []
                  };
                  return i && e.or.push({
                      null: !0
                  }),
                  r.length && e.or.push({
                      id: {
                          in: r
                      }
                  }),
                  {
                      lastAppliedTemplate: e
                  }
              } else {
                  let e = {
                      and: r.length ? [{
                          id: {
                              nin: r
                          }
                      }] : []
                  };
                  return i && e.and.push({
                      null: !1
                  }),
                  {
                      lastAppliedTemplate: e
                  }
              }
          }
          ,
          match: e => `lastAppliedTemplate`in e,
          getCompareOption: e => `or`in e.lastAppliedTemplate || `id`in e.lastAppliedTemplate && `in`in e.lastAppliedTemplate.id ? `is` : `not`,
          selectedValues(e) {
              if (`id`in e.lastAppliedTemplate)
                  return `in`in e.lastAppliedTemplate.id ? e.lastAppliedTemplate.id.in : e.lastAppliedTemplate.id.nin;
              if (`or`in e.lastAppliedTemplate) {
                  let t = [];
                  for (let n of e.lastAppliedTemplate.or)
                      `id`in n ? t.push(...n.id.in) : `null`in n && t.push(ob);
                  return t
              } else if (`and`in e.lastAppliedTemplate) {
                  let t = [];
                  for (let n of e.lastAppliedTemplate.and)
                      `id`in n ? t.push(...n.id.nin) : `null`in n && t.push(ob);
                  return t
              }
              return []
          }
      }
  }
  )(oO ||= {})
}
)), cO, lO, uO = t(( () => {
  cO = function(e) {
      return e.draft = `draft`,
      e.open = `open`,
      e.inReview = `inReview`,
      e.approved = `approved`,
      e.merged = `merged`,
      e.closed = `closed`,
      e
  }({}),
  lO = function(e) {
      return e.blocked = `blocked`,
      e.ready = `ready`,
      e.merging = `merging`,
      e.merged = `merged`,
      e
  }({})
}
)), dO, fO = t(( () => {
  St(),
  uO(),
  FD(),
  TD(),
  (function(e) {
      _t({
          status: mt([_t({
              in: Dt(vt(cO))
          }), _t({
              nin: Dt(vt(cO))
          })])
      }),
      e.status = {
          key: `status`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  status: {
                      in: t
                  }
              } : {
                  status: {
                      nin: t
                  }
              }
          }
          ,
          match: e => `status`in e,
          getCompareOption: e => `in`in e.status ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.status ? e.status.in : e.status.nin
          }
      },
      _t({
          searchableContent: mt([_t({
              contains: yt()
          }), _t({
              notContains: yt()
          })])
      }),
      e.searchableContent = {
          key: `searchableContent`,
          compareOptions: `containsValue`,
          defaultCompareOption: `contains`,
          allowMultiSelect: !1,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `contains` ? {
                  searchableContent: {
                      contains: t[t.length - 1]
                  }
              } : {
                  searchableContent: {
                      notContains: t[t.length - 1]
                  }
              }
          }
          ,
          match: e => `searchableContent`in e,
          getCompareOption: e => `contains`in e.searchableContent ? `contains` : `notContains`,
          selectedValues(e) {
              return `contains`in e.searchableContent ? [e.searchableContent.contains] : [e.searchableContent.notContains]
          }
      },
      e.creator = {
          key: `creator`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => ({
              creator: ND.createUserFilterBlock(e)
          }),
          match: e => `creator`in e,
          getCompareOption: e => ND.getUserCompareOption(e.creator),
          selectedValues(e) {
              return ND.getSelectedUserValues(e.creator)
          }
      },
      e.reviewerUsers = {
          key: `reviewerUsers`,
          compareOptions: `containsValue`,
          defaultCompareOption: `contains`,
          allowMultiSelect: !0,
          create: e => ({
              reviewerUsers: ND.createUserListFilterBlock(e)
          }),
          match: e => `reviewerUsers`in e,
          getCompareOption: e => ND.getUserListCompareOption(e.reviewerUsers),
          selectedValues(e) {
              return ND.getSelectedUserListValues(e.reviewerUsers)
          }
      },
      _t({
          repository: dt({
              owner: mt([_t({
                  in: Dt(yt())
              }), _t({
                  nin: Dt(yt())
              })])
          })
      }),
      e.repositoryOwner = {
          key: `repository`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  repository: {
                      owner: {
                          in: t
                      }
                  }
              } : {
                  repository: {
                      owner: {
                          nin: t
                      }
                  }
              }
          }
          ,
          match: e => `repository`in e && typeof e.repository == `object` && `owner`in e.repository,
          getCompareOption: e => `in`in e.repository.owner ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.repository.owner ? e.repository.owner.in : e.repository.owner.nin
          }
      },
      _t({
          repository: dt({
              name: mt([_t({
                  in: Dt(yt())
              }), _t({
                  nin: Dt(yt())
              })])
          })
      }),
      e.repositoryName = {
          key: `repository`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => {
              let {values: t, compareOption: n} = e;
              return n === `is` ? {
                  repository: {
                      name: {
                          in: t
                      }
                  }
              } : {
                  repository: {
                      name: {
                          nin: t
                      }
                  }
              }
          }
          ,
          match: e => `repository`in e && typeof e.repository == `object` && `name`in e.repository,
          getCompareOption: e => `in`in e.repository.name ? `is` : `not`,
          selectedValues(e) {
              return `in`in e.repository.name ? e.repository.name.in : e.repository.name.nin
          }
      },
      e.openedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `openedAt`,
          nullable: !1
      }),
      e.updatedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `updatedAt`,
          nullable: !1
      }),
      e.mergedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `mergedAt`,
          nullable: !0
      }),
      e.closedAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `closedAt`,
          nullable: !0
      })
  }
  )(dO ||= {})
}
));
function ice(e, t) {
  let n = {};
  for (let r in e)
      Object.prototype.hasOwnProperty.call(e, r) && (n[r] = t(e[r]));
  return n
}
var pO, mO, hO, gO = t(( () => {
  pO = e(xe(), 1),
  mO = e(se(), 1),
  KT(),
  Kd(),
  gc(),
  zD(),
  VD(),
  iO(),
  sO(),
  fO(),
  hO = class e {
      static addBlock(e, t, n, r) {
          n ??= this.getActiveKey(e);
          let i = this.getTopFilterContents(e);
          if (r?.length) {
              let a = [...r]
                , o = a.shift()
                , s = a.length > 0 ? a : void 0
                , c = i.at(o);
              return c && (this.isAndFilter(c) || this.isOrFilter(c)) ? {
                  ...e,
                  [n]: i.map( (e, n) => n === o ? this.addBlock(c, t, void 0, s) : e)
              } : {
                  ...e,
                  [n]: [...i, t]
              }
          }
          return {
              ...e,
              [n]: i ? [...i, t] : [t]
          }
      }
      static replaceBlockAtIndex(e, t, n) {
          let r = this.getActiveKey(e)
            , i = this.getTopFilterContents(e);
          if (Array.isArray(t) && t.length > 1) {
              let a = [...t]
                , o = a.shift()
                , s = i.at(o);
              return s && !this.isEmpty(s) ? {
                  ...e,
                  [r]: i.map( (e, t) => t === o ? this.replaceBlockAtIndex(s, a, n) : e)
              } : e
          }
          let a = Array.isArray(t) ? t[0] : t
            , o = [...i ?? []];
          return o.length > a ? (o[a] = n,
          {
              ...e,
              [r]: o
          }) : a === 0 && o.length === 0 ? {
              ...e,
              [r]: [n]
          } : (o.push(n),
          {
              ...e,
              [r]: o
          })
      }
      static removeAtIndex(e, t) {
          if (this.isEmpty(t))
              return t;
          let n = this.getActiveKey(t)
            , r = this.getTopFilterContents(t);
          if (e.length > 1) {
              let i = [...e]
                , a = i.shift()
                , o = r.map( (e, t) => t === a ? this.removeAtIndex(i, e) : e).filter(e => !this.isEmpty(e));
              return {
                  ...t,
                  [n]: o
              }
          }
          let i = e.at(0);
          return {
              ...t,
              [n]: r?.filter( (e, t) => t !== i)
          }
      }
      static getActiveKey(e) {
          return this.isOrFilter(e) ? `or` : `and`
      }
      static setActiveKey(e, t) {
          return {
              [t]: this.getTopFilterContents(e)
          }
      }
      static simplifyFilter(e) {
          return this.simplifyFilterRec(e)
      }
      static simplifyFilterRec(e) {
          if (typeof e != `object` || !e || Array.isArray(e))
              return e;
          if (e = {
              ...e
          },
          this.isAndFilter(e) && (e.and = e.and.map(this.simplifyFilterRec.bind(this)).filter(e => typeof e == `object` && !!e && Object.keys(e).length !== 0),
          e.and.length === 0)) {
              if (Object.keys(e).length === 1)
                  return {};
              let {and: t, ...n} = e;
              e = n
          }
          if (this.isOrFilter(e) && (e.or = e.or.map(this.simplifyFilterRec.bind(this)),
          e.or.length === 0 || e.or.some(e => Object.keys(e).length === 0))) {
              if (Object.keys(e).length === 1)
                  return {};
              let {or: t, ...n} = e;
              e = n
          }
          if (Object.keys(e).length === 1) {
              if (this.isAndFilter(e))
                  return e.and.length === 1 ? this.simplifyFilterRec(e.and[0]) : e;
              if (this.isOrFilter(e))
                  return e.or.length === 1 ? this.simplifyFilterRec(e.or[0]) : e;
              if (`in`in e && Array.isArray(e.in) && e.in.length === 1)
                  return {
                      eq: e.in[0]
                  };
              if (`nin`in e && Array.isArray(e.nin) && e.nin.length === 1)
                  return {
                      neq: e.nin[0]
                  }
          }
          return ice(e, e => this.simplifyFilterRec(e))
      }
      static findBlocks(e, t) {
          return (this.getTopFilterContents(e) ?? []).map(e => [t.find(t => t.match(e)), e]).filter( ([e]) => e)
      }
      static findBlock(e, t) {
          return this.getAllFilterBlocks(e).find(e => t.match(e))
      }
      static findBlockIndex(e, t) {
          return this.getAllFilterBlocks(e).findIndex(e => t.match(e))
      }
      static hasBlock(e, t) {
          return !!this.findBlock(e, t)
      }
      static hasExtraFilters(e, t) {
          if (Object.keys(t).length > 1)
              return !0;
          let n = this.getAllFilterBlocks(t) ?? []
            , r = n.filter(t => e.some(e => e.match(t))).length;
          return n.length > 0 && r < n.length
      }
      static isEmpty(t) {
          return e.getBlocksCount(t) === 0
      }
      static getBlocksCount(e) {
          return this.getAllFilterBlocks(e).length
      }
      static isValid(e, t) {
          if (e.isValid)
              return e.isValid(t);
          try {
              return e.allowMultiSelect && e.selectedValues ? e.selectedValues(t).length > 0 : !0
          } catch {
              return !1
          }
      }
      static getBlockDefByName(e, t) {
          if (typeof e == `object` && e && t in e)
              return e[t]
      }
      static convertFilterBlockToModel(e, t, n) {
          let r = [{
              Issue: nO.team,
              Project: oO.teams,
              Initiative: RD.teams,
              SearchResult: BD.team,
              Document: BD.team
          }, {
              Issue: [nO.stateType, {
                  from: e => e in E ? e : void 0
              }],
              Project: [oO.statusType, {
                  from: e => e in Wd ? e : void 0
              }],
              Initiative: [RD.status, {
                  from: e => {
                      if (e === `started`)
                          return GT.Active;
                      let t = (0,
                      pO.default)(e);
                      return t in GT ? t : void 0
                  }
                  ,
                  to: e => e === GT.Active ? `started` : (0,
                  mO.default)(e)
              }],
              SearchResult: BD.statusType
          }, {
              Issue: nO.assignee,
              Project: oO.lead,
              Initiative: RD.owner,
              PullRequest: dO.reviewerUsers,
              SearchResult: BD.assignee
          }, {
              Issue: nO.creator,
              SearchResult: BD.creator,
              Document: BD.creator,
              PullRequest: dO.creator
          }, {
              Issue: nO.updatedAt,
              Project: oO.updatedAt,
              Initiative: RD.updatedAt,
              SearchResult: BD.updatedAt,
              Document: BD.updatedAt,
              PullRequest: dO.updatedAt
          }, {
              Issue: nO.createdAt,
              Project: oO.createdAt,
              Initiative: RD.createdAt,
              SearchResult: BD.createdAt,
              Document: BD.createdAt,
              PullRequest: dO.openedAt
          }];
          for (let i of r) {
              let r = i[t]
                , [a,o] = Array.isArray(r) ? r : [r, void 0]
                , s = i[n]
                , [c,l] = Array.isArray(s) ? s : [s, void 0];
              if (!a || !c || !a.match(e))
                  continue;
              let u = a.selectedValues(e).map(e => (o?.to && (e = o.to(e)),
              l?.from && (e = l.from(e)),
              e)).concrete()
                , d = a.getCompareOption(e)
                , f = typeof c.compareOptions == `string` ? c.compareOptions : c.compareOptions(u);
              if ((typeof a.compareOptions == `string` ? a.compareOptions : a.compareOptions(u)) !== f) {
                  for (let[e,t] of [[[`all`, `any`], `is`], [[`neither`, `notAll`], `not`], [[`is`], `any`], [[`not`], `neither`]])
                      if (e.includes(d)) {
                          d = t;
                          break
                      }
              }
              if (u.length)
                  return [c.create({
                      values: u,
                      compareOption: d
                  }), c]
          }
          return null
      }
      static convertFilterToModel(e, t, n) {
          if (t.toString() === n.toString() || this.isEmpty(e))
              return [e, {}];
          try {
              let r = this.getActiveKey(e)
                , i = this.getTopFilterContents(e)
                , a = {
                  [r]: []
              }
                , o = {
                  [r]: []
              };
              for (let e of i)
                  if (this.isAndFilter(e) || this.isOrFilter(e)) {
                      let[r,i] = this.convertFilterToModel(e, t, n);
                      this.isEmpty(r) || (a = this.addBlock(a, r)),
                      this.isEmpty(i) || (o = this.addBlock(o, i))
                  } else {
                      let r = this.convertFilterBlockToModel(e, t, n);
                      r ? a = this.addBlock(a, r[0]) : o = this.addBlock(o, e)
                  }
              return [a, o]
          } catch {
              return [{}, e]
          }
      }
      static mergeBlocks(e, t, n) {
          let r = n.getCompareOption(e);
          if (r !== n.getCompareOption(t))
              return null;
          let i = n.selectedValues?.(e) ?? []
            , a = n.selectedValues?.(t) ?? []
            , o = [...i, ...a].distinct();
          return n.create({
              values: o,
              compareOption: r
          })
      }
      static mergeBlockIntoFilter(e, t, n, r) {
          let i = this.getActiveKey(e)
            , a = this.getTopFilterContents(e);
          if (r?.length) {
              let o = [...r]
                , s = o.shift()
                , c = a.at(s);
              if (c && (this.isAndFilter(c) || this.isOrFilter(c))) {
                  let r = o.length > 0 ? o : void 0;
                  return {
                      ...e,
                      [i]: a.map( (e, i) => i === s ? this.mergeBlockIntoFilter(c, t, n, r) : e)
                  }
              }
          }
          let o = {
              ...e,
              [i]: [...a ?? []]
          }
            , s = a.findIndex(e => n.match(e))
            , c = s >= 0 ? a[s] : void 0
            , l = c ? this.mergeBlocks(t, c, n) : null;
          return l ? this.replaceBlockAtIndex(o, [s], l) : this.addBlock(o, t)
      }
      static removeOrBlockAtIndex(e, t) {
          let n = [...t];
          if (n.length > 1) {
              let t = n.shift()
                , r = this.getTopFilterContents(e)
                , i = r.at(t);
              if (i && (this.isAndFilter(i) || this.isOrFilter(i))) {
                  let a = this.getActiveKey(e);
                  return {
                      ...e,
                      [a]: r.map( (e, r) => r === t ? this.removeOrBlockAtIndex(i, n) : e)
                  }
              }
              return e
          }
          if (!this.isOrFilter(e))
              return e;
          let r = n[0]
            , i = e.or;
          if (r < 0 || r >= i.length || i.length === 1)
              return e;
          let a = r < i.length - 1 ? r : r - 1
            , o = i[a]
            , s = i[a + 1]
            , c = this.isAndFilter(o) ? o.and : [o]
            , l = this.isAndFilter(s) ? s.and : [s]
            , u = {
              and: [...c, ...l]
          };
          return {
              or: [...i.slice(0, a), u, ...i.slice(a + 2)]
          }
      }
      static splitAtIndex(e, t) {
          let n = [...t]
            , r = this.getTopFilterContents(e);
          if (n.length > 1) {
              let t = n.shift()
                , i = r.at(t);
              if (i && (this.isAndFilter(i) || this.isOrFilter(i))) {
                  let a = this.splitAtIndex(i, n);
                  if (this.isOrFilter(e) && this.isOrFilter(a))
                      return {
                          or: [...r.slice(0, t), ...a.or, ...r.slice(t + 1)]
                      };
                  let o = this.getActiveKey(e);
                  return {
                      ...e,
                      [o]: r.map( (e, n) => n === t ? a : e)
                  }
              }
              return e
          }
          let i = n[0];
          if (r.length === 0)
              return {
                  or: []
              };
          let a = Math.min(i + 1, r.length)
            , o = {
              and: r.slice(0, a)
          }
            , s = {
              and: r.slice(a)
          }
            , c = [];
          return this.isEmpty(o) || c.push(o),
          this.isEmpty(s) || c.push(s),
          {
              or: c
          }
      }
      static isAndFilter(e) {
          return `and`in e && Array.isArray(e.and)
      }
      static isOrFilter(e) {
          return `or`in e && Array.isArray(e.or)
      }
      static isSubFilter(e) {
          return this.isAndFilter(e) || this.isOrFilter(e)
      }
      static getTopFilterContents(e) {
          return this.isAndFilter(e) ? e.and : this.isOrFilter(e) ? e.or : []
      }
      static getAllFilterBlocks(e) {
          return Array.isArray(e) ? e.flatMap(e => this.getAllFilterBlocks(e)) : typeof e == `object` && e && Object.keys(e).length === 0 ? [] : this.isAndFilter(e) ? e.and.flatMap(e => this.getAllFilterBlocks(e)) : this.isOrFilter(e) ? e.or.flatMap(e => this.getAllFilterBlocks(e)) : [e]
      }
      static getFilterLayerCount(e) {
          return this.isAndFilter(e) ? 1 + e.and.reduce( (e, t) => this.isSubFilter(t) ? Math.max(e, this.getFilterLayerCount(t)) : e, 0) : this.isOrFilter(e) ? 1 + e.or.reduce( (e, t) => this.isSubFilter(t) ? Math.max(e, this.getFilterLayerCount(t)) : e, 0) : 1
      }
  }
}
)), _O, vO, yO, bO, xO, SO, CO, wO, TO, EO, DO, OO, kO = t(( () => {
  _O = e(he(), 1),
  vb(),
  vO = e => {
      let {key: t, create: n, selectedValues: r, getCompareOption: i, pathKeys: a} = e;
      return {
          key: t,
          compareOptions: `collection`,
          defaultCompareOption: `any`,
          allowMultiSelect: !0,
          create: n,
          match: e => a.map(t => (0,
          _O.default)(e, [`needs`, `and`, 0, `every`, `customer`, t]) || (0,
          _O.default)(e, [`needs`, `and`, 0, `some`, `customer`, t]) || (0,
          _O.default)(e, [`needs`, `or`, 0, `some`, `customer`, t]) || (0,
          _O.default)(e, [`needs`, `or`, 0, `every`, `customer`, t]) || (0,
          _O.default)(e, [`needs`, `or`, 0, `every`, `customer`, `and`, 0, t]) || (0,
          _O.default)(e, [`needs`, `or`, 0, `length`])).some(e => e),
          getCompareOption: e => {
              if (i)
                  return i(e);
              if (`and`in e.needs) {
                  if (e.needs.and.some(e => `some`in e && (0,
                  _O.default)(e, [`some`, `customer`])))
                      return `all`;
                  if (e.needs.and.some(e => `every`in e && (0,
                  _O.default)(e, [`every`, `customer`])))
                      return `neither`
              }
              if (`or`in e.needs) {
                  if (e.needs.or.some(e => `some`in e && (0,
                  _O.default)(e, [`some`, `customer`])))
                      return `any`;
                  if (e.needs.or.some(e => `every`in e && (0,
                  _O.default)(e, [`every`, `customer`, `and`, 0, `id`, `nin`])))
                      return `neither`;
                  if (e.needs.or.some(e => `every`in e && (0,
                  _O.default)(e, [`every`, `customer`])))
                      return `notAll`
              }
              return `any`
          }
          ,
          selectedValues: r
      }
  }
  ,
  yO = e => {
      let {create: t, selectedValues: n, getCompareOption: r, pathKeys: i} = e;
      return {
          key: e.key,
          compareOptions: `number`,
          defaultCompareOption: `gt`,
          allowMultiSelect: !1,
          create: t,
          match: e => i.map(t => (0,
          _O.default)(e, [`needs`, `and`, 0, `every`, `customer`, t]) || (0,
          _O.default)(e, [`needs`, `and`, 0, `some`, `customer`, t]) || (0,
          _O.default)(e, [`needs`, `or`, 0, `some`, `customer`, t]) || (0,
          _O.default)(e, [`needs`, `or`, 0, `every`, `customer`, t])).some(e => e),
          getCompareOption: r,
          selectedValues: n
      }
  }
  ,
  bO = {
      needs: {
          or: [{
              length: {
                  gte: 0
              }
          }]
      }
  },
  xO = vO({
      key: `needs`,
      create: e => {
          let {values: t, compareOption: n} = e
            , r = t.map(e => ({
              some: {
                  customer: e === `____null____` ? {
                      null: !0
                  } : {
                      id: {
                          eq: e
                      }
                  }
              }
          }))
            , i = t.map(e => ({
              every: {
                  customer: e === `____null____` ? {
                      null: !1
                  } : {
                      id: {
                          neq: e
                      }
                  }
              }
          }));
          return t.length === 0 ? bO : n === `all` ? {
              needs: {
                  and: r
              }
          } : n === `notAll` ? {
              needs: {
                  or: [...i, {
                      length: {
                          eq: 0
                      }
                  }]
              }
          } : n === `any` ? {
              needs: {
                  or: r
              }
          } : t.includes(`____null____`) ? {
              needs: {
                  or: [{
                      every: {
                          customer: {
                              and: [{
                                  id: {
                                      nin: t.filter(e => e !== ob)
                                  }
                              }, {
                                  null: !1
                              }]
                          }
                      }
                  }, {
                      length: {
                          eq: 0
                      }
                  }]
              }
          } : {
              needs: {
                  or: [{
                      every: {
                          customer: {
                              id: {
                                  nin: t
                              }
                          }
                      }
                  }, {
                      length: {
                          eq: 0
                      }
                  }]
              }
          }
      }
      ,
      selectedValues: e => {
          let t = []
            , n = !1;
          return `or`in e.needs ? (n = e.needs.or.some(e => (0,
          _O.default)(e, [`some`, `customer`, `null`]) || (0,
          _O.default)(e, [`every`, `customer`, `null`])) || e.needs.or.some(e => (0,
          _O.default)(e, [`every`, `customer`, `and`, 1, `null`])),
          t.push(...[...e.needs.or.map(e => `some`in e && e.some && `id`in e.some.customer && `eq`in e.some.customer.id ? e.some.customer.id.eq : void 0), ...e.needs.or.map(e => `every`in e && `id`in e.every.customer && `neq`in e.every.customer.id ? e.every.customer.id.neq : void 0), ...e.needs.or.flatMap(e => `every`in e && `id`in e.every.customer && `nin`in e.every.customer.id ? e.every.customer.id.nin : void 0), ...e.needs.or.flatMap(e => `every`in e && `and`in e.every.customer && `id`in e.every.customer.and[0] && `nin`in e.every.customer.and[0].id ? e.every.customer.and[0].id.nin : void 0)].filter(Boolean))) : `and`in e.needs && (n = e.needs.and.some(e => (0,
          _O.default)(e, [`some`, `customer`, `null`]) || (0,
          _O.default)(e, [`every`, `customer`, `null`])),
          t.push(...[...e.needs.and.map(e => `some`in e && `id`in e.some.customer && `eq`in e.some.customer.id ? e.some.customer.id.eq : void 0), ...e.needs.and.map(e => `every`in e && `id`in e.every.customer && `neq`in e.every.customer.id ? e.every.customer.id.neq : void 0)].filter(Boolean))),
          n && t.push(ob),
          t
      }
      ,
      pathKeys: [`id`, `null`]
  }),
  SO = vO({
      key: `needs`,
      create: e => {
          let {values: t, compareOption: n} = e;
          if (t.length === 0)
              return bO;
          let r = t.filter(e => e !== `____null____` && e !== `__isMe__`)
            , i = t.includes(ob)
            , a = t.includes(cb)
            , o = [];
          if (n === `any`)
              return i && o.push({
                  some: {
                      customer: {
                          owner: {
                              null: !0
                          }
                      }
                  }
              }),
              a && o.push({
                  some: {
                      customer: {
                          owner: {
                              isMe: {
                                  eq: !0
                              }
                          }
                      }
                  }
              }),
              r.forEach(e => {
                  o.push({
                      some: {
                          customer: {
                              owner: {
                                  id: {
                                      eq: e
                                  }
                              }
                          }
                      }
                  })
              }
              ),
              {
                  needs: {
                      or: o
                  }
              };
          if (n === `all`)
              return i && o.push({
                  some: {
                      customer: {
                          owner: {
                              null: !0
                          }
                      }
                  }
              }),
              a && o.push({
                  some: {
                      customer: {
                          owner: {
                              isMe: {
                                  eq: !0
                              }
                          }
                      }
                  }
              }),
              r.forEach(e => {
                  o.push({
                      some: {
                          customer: {
                              owner: {
                                  id: {
                                      eq: e
                                  }
                              }
                          }
                      }
                  })
              }
              ),
              {
                  needs: {
                      and: o
                  }
              };
          if (n === `notAll`)
              return i && o.push({
                  every: {
                      customer: {
                          owner: {
                              null: !1
                          }
                      }
                  }
              }),
              a && o.push({
                  every: {
                      customer: {
                          owner: {
                              isMe: {
                                  eq: !1
                              }
                          }
                      }
                  }
              }),
              r.forEach(e => {
                  o.push({
                      every: {
                          customer: {
                              owner: {
                                  id: {
                                      neq: e
                                  }
                              }
                          }
                      }
                  })
              }
              ),
              {
                  needs: {
                      or: [...o, {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              };
          let s = [];
          return r.length > 0 && s.push({
              owner: {
                  id: {
                      nin: r
                  }
              }
          }),
          i && s.push({
              owner: {
                  null: !1
              }
          }),
          a && s.push({
              owner: {
                  isMe: {
                      eq: !1
                  }
              }
          }),
          {
              needs: {
                  or: [{
                      every: {
                          customer: {
                              and: s
                          }
                      }
                  }, {
                      length: {
                          eq: 0
                      }
                  }]
              }
          }
      }
      ,
      selectedValues: e => {
          let t = []
            , n = e => {
              e && (`id`in e && e.id && (`eq`in e.id && e.id.eq && t.push(e.id.eq),
              `neq`in e.id && e.id.neq && t.push(e.id.neq),
              `nin`in e.id && e.id.nin && t.push(...e.id.nin)),
              `null`in e && (e.null === !0 || e.null === !1) && t.push(ob),
              `isMe`in e && e.isMe && (e.isMe.eq === !0 || e.isMe.eq === !1) && t.push(cb))
          }
            , r = e => {
              for (let t of e)
                  if (`some`in t && t.some?.customer)
                      t.some.customer && `owner`in t.some.customer && n(t.some.customer.owner);
                  else if (`every`in t && t.every?.customer) {
                      let e = t.every.customer;
                      if (e && `owner`in e && n(e.owner),
                      e && `and`in e && Array.isArray(e.and))
                          for (let t of e.and)
                              typeof t == `object` && t && `owner`in t && n(t.owner)
                  }
          }
          ;
          return `or`in e.needs && e.needs.or ? r(e.needs.or) : `and`in e.needs && e.needs.and && r(e.needs.and),
          [...new Set(t)]
      }
      ,
      getCompareOption: e => {
          let {needs: t} = e;
          if (`and`in t && t.and.length > 0 && t.and.every(e => `some`in e && (0,
          _O.default)(e, [`some`, `customer`, `owner`])))
              return `all`;
          if (`or`in t && t.or.length > 0 && !t.or.some(e => `length`in e) && t.or.every(e => `some`in e && (0,
          _O.default)(e, [`some`, `customer`, `owner`])))
              return `any`;
          if (`or`in t) {
              let e = t.or.filter(e => `length`in e && typeof e.length == `object` && e.length !== null && `eq`in e.length && e.length.eq === 0);
              if (t.or.length === 2 && e.length === 1 && t.or.some(e => `every`in e && (0,
              _O.default)(e, [`every`, `customer`, `and`])))
                  return `neither`;
              if (e.length === 1 && t.or.some(e => `every`in e && (0,
              _O.default)(e, [`every`, `customer`, `owner`]) && !(0,
              _O.default)(e, [`every`, `customer`, `and`])))
                  return `notAll`
          }
          return `any`
      }
      ,
      pathKeys: [`owner`]
  }),
  CO = vO({
      key: `needs`,
      create: e => {
          let {values: t, compareOption: n} = e
            , r = n === `all` || n === `notAll`
            , i = n === `neither` || n === `notAll`
            , a = r && !i || !r && i
            , o = t.map(e => ({
              some: {
                  customer: {
                      status: {
                          id: {
                              eq: e
                          }
                      }
                  }
              }
          }))
            , s = t.map(e => ({
              every: {
                  customer: {
                      status: {
                          id: {
                              neq: e
                          }
                      }
                  }
              }
          }));
          return t.length === 0 ? bO : {
              needs: a ? {
                  and: i ? s : o
              } : {
                  or: i ? s : o
              }
          }
      }
      ,
      selectedValues: e => `or`in e.needs ? [...e.needs.or.map(e => `some`in e && e.some && `status`in e.some.customer && `id`in e.some.customer.status && `eq`in e.some.customer.status.id ? e.some.customer.status.id.eq : void 0), ...e.needs.or.map(e => `every`in e && `status`in e.every.customer && `id`in e.every.customer.status && `neq`in e.every.customer.status.id ? e.every.customer.status.id.neq : void 0)].filter(Boolean) : `and`in e.needs ? [...e.needs.and.map(e => `some`in e && `status`in e.some.customer && `id`in e.some.customer.status && `eq`in e.some.customer.status.id ? e.some.customer.status.id.eq : void 0), ...e.needs.and.map(e => `every`in e && `status`in e.every.customer && `id`in e.every.customer.status && `neq`in e.every.customer.status.id ? e.every.customer.status.id.neq : void 0)].filter(Boolean) : [],
      pathKeys: [`status`]
  }),
  wO = vO({
      key: `needs`,
      create: e => {
          let {values: t, compareOption: n} = e
            , r = n === `all` || n === `notAll`
            , i = n === `neither` || n === `notAll`
            , a = r && !i || !r && i
            , o = t.map(e => ({
              some: {
                  customer: {
                      tier: {
                          id: {
                              eq: e
                          }
                      }
                  }
              }
          }))
            , s = t.map(e => ({
              every: {
                  customer: {
                      tier: {
                          id: {
                              neq: e
                          }
                      }
                  }
              }
          }));
          return t.length === 0 ? bO : {
              needs: a ? {
                  and: i ? s : o
              } : {
                  or: i ? s : o
              }
          }
      }
      ,
      selectedValues: e => `or`in e.needs ? [...e.needs.or.map(e => `some`in e && e.some && `tier`in e.some.customer && `id`in e.some.customer.tier && `eq`in e.some.customer.tier.id ? e.some.customer.tier.id.eq : void 0), ...e.needs.or.map(e => `every`in e && `tier`in e.every.customer && `id`in e.every.customer.tier && `neq`in e.every.customer.tier.id ? e.every.customer.tier.id.neq : void 0)].filter(Boolean) : `and`in e.needs ? [...e.needs.and.map(e => `some`in e && `tier`in e.some.customer && `id`in e.some.customer.tier && `eq`in e.some.customer.tier.id ? e.some.customer.tier.id.eq : void 0), ...e.needs.and.map(e => `every`in e && `tier`in e.every.customer && `id`in e.every.customer.tier && `neq`in e.every.customer.tier.id ? e.every.customer.tier.id.neq : void 0)].filter(Boolean) : [],
      pathKeys: [`tier`]
  }),
  TO = yO({
      key: `needs`,
      create: e => {
          let {values: t, compareOption: n} = e
            , r = {
              gte: t[0]
          }
            , i = {
              lte: t[0]
          }
            , a = {
              eq: t[0]
          }
            , o = {
              neq: t[0]
          };
          return t.length === 0 ? {
              needs: {
                  and: [{
                      some: {
                          customer: {
                              revenue: {
                                  neq: -1
                              }
                          }
                      }
                  }]
              }
          } : {
              needs: {
                  and: [{
                      some: {
                          customer: {
                              revenue: n === `gte` ? r : n === `lte` ? i : n === `eq` ? a : n === `neq` ? o : r
                          }
                      }
                  }]
              }
          }
      }
      ,
      getCompareOption: e => {
          if (`and`in e.needs && `some`in e.needs.and[0] && `revenue`in e.needs.and[0].some.customer) {
              let t = e.needs.and[0].some.customer.revenue;
              if (`gte`in t)
                  return `gte`;
              if (`lte`in t)
                  return `lte`;
              if (`eq`in t)
                  return `eq`;
              if (`neq`in t)
                  return `neq`
          }
          return `gte`
      }
      ,
      selectedValues: e => {
          if (`and`in e.needs && `some`in e.needs.and[0] && `revenue`in e.needs.and[0].some.customer) {
              let t = e.needs.and[0].some.customer.revenue;
              if (`gte`in t)
                  return [t.gte];
              if (`lte`in t)
                  return [t.lte];
              if (`eq`in t)
                  return [t.eq];
              if (`neq`in t)
                  return [t.neq]
          }
          return []
      }
      ,
      pathKeys: [`revenue`]
  }),
  EO = yO({
      key: `needs`,
      create: e => {
          let {values: t, compareOption: n} = e
            , r = {
              gte: t[0]
          }
            , i = {
              lte: t[0]
          }
            , a = {
              eq: t[0]
          }
            , o = {
              neq: t[0]
          };
          return t.length === 0 ? {
              needs: {
                  and: [{
                      some: {
                          customer: {
                              size: {
                                  neq: -1
                              }
                          }
                      }
                  }]
              }
          } : {
              needs: {
                  and: [{
                      some: {
                          customer: {
                              size: n === `gte` ? r : n === `lte` ? i : n === `eq` ? a : n === `neq` ? o : r
                          }
                      }
                  }]
              }
          }
      }
      ,
      getCompareOption: e => {
          if (`and`in e.needs && `some`in e.needs.and[0] && `size`in e.needs.and[0].some.customer) {
              let t = e.needs.and[0].some.customer.size;
              if (`gte`in t)
                  return `gte`;
              if (`lte`in t)
                  return `lte`;
              if (`eq`in t)
                  return `eq`;
              if (`neq`in t)
                  return `neq`
          }
          return `gte`
      }
      ,
      selectedValues: e => {
          if (`and`in e.needs && `some`in e.needs.and[0] && `size`in e.needs.and[0].some.customer) {
              let t = e.needs.and[0].some.customer.size;
              if (`gte`in t)
                  return [t.gte];
              if (`lte`in t)
                  return [t.lte];
              if (`eq`in t)
                  return [t.eq];
              if (`neq`in t)
                  return [t.neq]
          }
          return []
      }
      ,
      pathKeys: [`size`]
  }),
  DO = {
      key: `needs`,
      compareOptions: `number`,
      defaultCompareOption: `gte`,
      allowMultiSelect: !1,
      create: e => {
          let {values: t, compareOption: n} = e
            , r = t[0];
          return n === `eq` ? {
              customerCount: {
                  eq: r
              }
          } : n === `neq` ? {
              customerCount: {
                  neq: r
              }
          } : n === `gte` ? {
              customerCount: {
                  gte: r
              }
          } : n === `lte` ? {
              customerCount: {
                  lte: r
              }
          } : {
              customerCount: {
                  neq: 0
              }
          }
      }
      ,
      match: e => `customerCount`in e,
      getCompareOption: e => `eq`in e.customerCount ? `eq` : `neq`in e.customerCount ? `neq` : `gte`in e.customerCount ? `gte` : `lte`in e.customerCount ? `lte` : `gte`,
      selectedValues(e) {
          return `eq`in e.customerCount ? [e.customerCount.eq] : `neq`in e.customerCount ? [e.customerCount.neq] : `gte`in e.customerCount ? [e.customerCount.gte] : `lte`in e.customerCount ? [e.customerCount.lte] : []
      }
  },
  OO = {
      key: `needs`,
      compareOptions: `number`,
      defaultCompareOption: `gte`,
      allowMultiSelect: !1,
      create: e => {
          let {values: t, compareOption: n} = e
            , r = t[0];
          return n === `eq` ? {
              customerImportantCount: {
                  eq: r
              }
          } : n === `neq` ? {
              customerImportantCount: {
                  neq: r
              }
          } : n === `gte` ? {
              customerImportantCount: {
                  gte: r
              }
          } : n === `lte` ? {
              customerImportantCount: {
                  lte: r
              }
          } : {
              customerImportantCount: {
                  neq: 0
              }
          }
      }
      ,
      match: e => `customerImportantCount`in e,
      getCompareOption: e => `eq`in e.customerImportantCount ? `eq` : `neq`in e.customerImportantCount ? `neq` : `gte`in e.customerImportantCount ? `gte` : `lte`in e.customerImportantCount ? `lte` : `gte`,
      selectedValues(e) {
          return `eq`in e.customerImportantCount ? [e.customerImportantCount.eq] : `neq`in e.customerImportantCount ? [e.customerImportantCount.neq] : `gte`in e.customerImportantCount ? [e.customerImportantCount.gte] : `lte`in e.customerImportantCount ? [e.customerImportantCount.lte] : []
      }
  }
}
));
function AO(e, t) {
  return e.needs?.and && e.needs.and.length > 1 && e.needs.and.every(e => !!e.some) ? e.needs.and.some(e => MO.matchElement({
      needs: e
  }, t)) : MO.matchElement(e, t)
}
function jO({customers: e, hasActiveFilters: t, viewActiveFilterBlocks: n, customViewActiveFilterBlocks: r}) {
  return {
      hasActiveFilters: t,
      matchingCustomers: e,
      matchingCustomerCount: e.length,
      matchingImportantCustomerCount: e.filter(e => e.isImportant).length,
      matchingCustomersAggregatedRevenue: e.reduce( (e, t) => e + (t.customer?.displayRevenue ?? 0), 0),
      viewActiveFilterBlocks: n,
      customViewActiveFilterBlocks: r
  }
}
var MO, NO, PO, FO, IO, LO = t(( () => {
  MD(),
  gO(),
  kO(),
  MO = new AD,
  NO = [xO, SO, CO, wO, TO, EO],
  PO = new Map([[xO, `Customer name`], [SO, `Customer owner`], [CO, `Customer status`], [wO, `Customer tier`], [TO, `Customer revenue`], [EO, `Customer size`]]),
  FO = (e, t, n) => {
      let r = e.flatMap(e => e.allNeeds.map(e => ({
          customer: e.customer?.value,
          id: e.customer?.id ?? e.id,
          isImportant: e.priority.isImportant
      })))
        , i = new Map;
      for (let {customer: e, id: t, isImportant: n} of r)
          if (!i.has(t))
              i.set(t, {
                  customer: e,
                  isImportant: n
              });
          else if (n) {
              let e = i.get(t);
              e && (e.isImportant = !0)
          }
      let a = Array.from(i.values())
        , {viewActiveFilterBlocks: o, customViewActiveFilterBlocks: s} = IO(t, n);
      if (o.length === 0 && s.length === 0)
          return jO({
              customers: a,
              hasActiveFilters: !1,
              viewActiveFilterBlocks: o,
              customViewActiveFilterBlocks: s
          });
      let c = !!t?.universal.matchingFilterForKey(`needs`, `all`)
        , l = n?.isMatchingAllFilters;
      return jO({
          customers: a.filter( ({customer: e}) => {
              let t = {
                  needs: [{
                      customer: e ?? null
                  }]
              }
                , n = o.length === 0
                , r = s.length === 0;
              return o.length > 0 && (n = c ? o.every( ([e,n]) => AO(n, t)) : o.some( ([e,n]) => AO(n, t))),
              s.length > 0 && (r = l ? s.every( ([e,n]) => AO(n, t)) : s.some( ([e,n]) => AO(n, t))),
              n && r
          }
          ),
          hasActiveFilters: !0,
          viewActiveFilterBlocks: o,
          customViewActiveFilterBlocks: s
      })
  }
  ,
  IO = (e, t) => {
      let n = [];
      if (e) {
          let t = hO.findBlocks(e.universal.filter, NO);
          n.push(...t.map( ([e,t]) => [PO.get(e) ?? `Unknown`, t]))
      }
      let r = [];
      if (t) {
          let e = hO.findBlocks(t.filter, NO);
          r.push(...e.map( ([e,t]) => [PO.get(e) ?? `Unknown`, t]))
      }
      return {
          viewActiveFilterBlocks: n,
          customViewActiveFilterBlocks: r
      }
  }
}
)), RO, zO, BO, VO = t(( () => {
  LO(),
  RO = (e, t, n) => t || n ? FO([e], t, n).matchingCustomerCount : e.customerCount,
  zO = (e, t, n) => t || n ? FO([e], t, n).matchingImportantCustomerCount : e.customerImportantCount,
  BO = (e, t, n) => t || n ? FO([e], t, n).matchingCustomersAggregatedRevenue : e.aggregatedCustomersRevenue
}
)), HO, UO, WO = t(( () => {
  Bl(),
  qb(),
  Nm(),
  Lq(),
  HO = e => e.priority.isNoPriority ? e.modelClass === Y ? zl.allPriorities.length : Kb.allPriorities.length : e.priority.priority,
  UO = e => new P(HO,e === `asc` ? `desc` : `asc`).and(`prioritySortOrder`, e === `asc` ? `desc` : `asc`)
}
)), GO, KO = t(( () => {
  gc(),
  Nm(),
  VO(),
  WO(),
  GO = {
      manualSortOrder: e => new P(`sortOrder`,e).and(`createdAt`, `desc`),
      manualNestedSortOrder: e => new P(`nestedSubIssueSortOrder`,e).and(`createdAt`, `desc`),
      manualSubIssueOrder: e => new P(`subIssueSortOrder`,e).and(`createdAt`, `desc`),
      priorityOrder: UO,
      titleOrder: e => new P(`title`,e),
      assigneeOrder: e => new P(e => e.assignee?.name,e),
      delegateOrder: e => new P(e => e.delegate?.name,e),
      dateCreatedOrder: e => new P(`createdAt`,e),
      reverseDateCreatedOrder: e => new P(`createdAt`,e),
      startedTriageOrder: e => new P(`startedTriageOrCreatedAt`,e),
      completionOrder: e => new P(`completedAt`,e),
      cancellationOrder: e => new P(`canceledAt`,e),
      doneOrder: e => new P(`doneAt`,e),
      dateUpdatedOrder: e => new P(`updatedAt`,e),
      dateMyActivityOrder: e => new P(`lastActivityAt`,e),
      dueDateOrder: (e, t) => new P(e => (t ? e.slaBreachesAt : void 0) ?? e.dueDate?.toLocalDate(),e).and(HO, e).and(`sortOrder`),
      accumulatedStateUpdatedAtOrder: e => new P(e => e.accumulatedStateUpdatedAt ?? new Date(0),e).and(HO, e).and(`sortOrder`),
      workflowStateOrder: e => new P(e => hc.customStatusOrdering[e.state.type],e).and(e => e.state.isClosed ? -e.state.position : e.state.position, e === `desc` ? `asc` : `desc`).and(e => HO(e), e).and(`prioritySortOrder`),
      linkCountOrder: e => new P(e => e.standardAttachments.length,e).and(`sortOrder`),
      estimateOrder: e => new P(e => e.estimate ?? -1,e).and(`sortOrder`),
      customerCountOrder: (e, t, n) => new P(e => RO(e, t, n),e).and(e => zO(e, t, n), e).and(`sortOrder`),
      customerImportantCountOrder: (e, t, n) => new P(e => zO(e, t, n),e).and(e => RO(e, t, n), e).and(`sortOrder`),
      customerRevenueOrder: (e, t, n) => new P(e => BO(e, t, n),e).and(e => RO(e, t, n), e).and(`sortOrder`),
      focusOrder: () => new P(e => e.state.isBacklog,`asc`).and(e => e.state.isStarted, `desc`).and(e => e.state.type, `desc`).and(e => e.state.indexWithinStateType, `desc`).and(HO, `asc`).and(`createdAt`, `desc`)
  }
}
));
function qO(e) {
  if (e instanceof _m)
      return e.isResolved() ? !0 : (JO(`Expected reference to be hydrated`, e.logMetadata),
      !1);
  if (e instanceof Um)
      return e.isHydrated() ? !0 : (JO(`Expected collection to be hydrated`, e.logMetadata),
      !1);
  if (e instanceof qh)
      return e.isHydrated() ? !0 : (JO(`Expected model to be hydrated`, {
          type: `Model`,
          modelName: e.modelName,
          modelId: e.id
      }),
      !1);
  if (Array.isArray(e)) {
      for (let t of e)
          if (!qO(t))
              return !1;
      return !0
  }
  return !0
}
function JO(e, t) {
  if (Jn.IS_PRODUCTION_ENV) {
      let n = YO < 10;
      !n && Date.now() - XO > 10 * b.MINUTE && (YO = 0,
      n = !0),
      n && (YO++,
      XO = Date.now(),
      w.remote(e, {
          ...t,
          path: window.location.pathname
      }));
      return
  }
  if (!((pQ().developerOptions?.snoozeHydrationErrorsUntil ?? 0) > Date.now()))
      throw new ZO(e,t)
}
var YO, XO, ZO, QO = t(( () => {
  Yr(),
  Xn(),
  hQ(),
  ws(),
  F(),
  Wm(),
  Sm(),
  YO = 0,
  XO = 0,
  ZO = class extends Error {
      constructor(e, t) {
          super(e),
          this.metadata = t
      }
  }
}
)), $O, ek, tk = t(( () => {
  vd(),
  Md(),
  F(),
  eu(),
  V(),
  N(),
  $O = function(e) {
      return e.ADMIN = `Admin`,
      e.MEMBER = `Member`,
      e.GUEST = `Guest`,
      e.LEFT = `Left workspace`,
      e.DOWNGRADED = `Downgraded`,
      e.SUSPENDED = `Suspended`,
      e.INVITED = `Invited`,
      e.DISABLED = `Disabled`,
      e.TEAM_OWNER = `Team owner`,
      e.OWNER = `Owner`,
      e
  }({}),
  ek = class e extends qh {
      static get modelName() {
          return `Member`
      }
      constructor() {
          super(),
          this.modelName = `Member`
      }
      static create(t) {
          let n = new e;
          return n.user = t.user,
          n.teamMembership = t.teamMembership,
          n.lastSeen = t.lastSeen,
          n
      }
      get name() {
          return this.user.name
      }
      get teams() {
          return this.user.teams
      }
      get displayName() {
          return this.user.displayName
      }
      get email() {
          return this.user.email
      }
      get joinedOrInvitedAt() {
          return this.user.createdAt
      }
      get status() {
          let e = _d.canAccess(gd.workspaceOwners, this.user.organization.featureTier)
            , t = this.teamMembership?.team;
          return this.user.hasLeftWorkspace ? $O.LEFT : this.user.isDowngraded ? $O.DOWNGRADED : this.user.isSuspended ? $O.SUSPENDED : !this.user.isActive && !this.user.isInvited ? $O.DISABLED : this.user.isOwner ? e ? $O.OWNER : $O.ADMIN : this.user.isAdmin ? $O.ADMIN : t?.getUserRoleOnTeam(this.user) === kd.owner ? $O.TEAM_OWNER : this.user.guest ? $O.GUEST : $O.MEMBER
      }
      matchInlineFind(e) {
          return $l([this.name, this.displayName, this.email].concrete().join(` `)).toLowerCase().indexOf(e) !== -1
      }
      static #e = this.userStatusToPriority = {
          [$O.TEAM_OWNER]: 0,
          [$O.OWNER]: 1,
          [$O.ADMIN]: 2,
          [$O.MEMBER]: 3,
          [$O.GUEST]: 4,
          [$O.INVITED]: 5,
          [$O.DOWNGRADED]: 6,
          [$O.DISABLED]: 7,
          [$O.LEFT]: 8,
          [$O.SUSPENDED]: 9
      }
  }
  ,
  M([L], ek.prototype, `name`, null),
  M([L], ek.prototype, `teams`, null),
  M([L], ek.prototype, `displayName`, null),
  M([L], ek.prototype, `email`, null),
  M([L], ek.prototype, `joinedOrInvitedAt`, null),
  M([L], ek.prototype, `status`, null),
  ek.prototype.modelName = `Member`
}
)), nk, rk = t(( () => {
  zm(),
  nk = class extends Rm {
      get constructorName() {
          return `CombinedCollection<${this.modelClass.modelName}>`
      }
      constructor(e, t, n) {
          super(e, [], n),
          this.collections = [],
          this.collections = t,
          this.options = n
      }
      get rootRawElements() {
          if (this.options?.dedupe) {
              let e = new Set;
              for (let t of this.collections)
                  for (let n of t)
                      e.add(n);
              return Array.from(e)
          }
          return this.collections.flatMap(e => e.rawElements)
      }
  }
}
)), ik, ak = t(( () => {
  Xp(),
  ik = class extends Array {
      constructor(e) {
          super(),
          this.hydrateFn = e
      }
      isHydrated() {
          return !!this.hydrationPromise && !this.hydrationPromise.error && !this.hydrationPromise.isPending
      }
      hydrate() {
          return this.isHydrated() ? Yp : (this.hydrationPromise ||= new Jp(async (e, t) => {
              try {
                  let t = await this.hydrateFn();
                  this.push(...t),
                  e()
              } catch (e) {
                  t(e)
              }
          }
          ),
          this.hydrationPromise)
      }
  }
}
)), ok, sk = t(( () => {
  rk(),
  Xp(),
  ak(),
  ok = class extends nk {
      get constructorName() {
          return `CombinedLazyCollection<${this.modelClass.modelName}>`
      }
      constructor(e, t, n) {
          super(e, t, n)
      }
      isHydrated() {
          return (this.collections instanceof ik ? this.collections.isHydrated() : !0) && this.collections.every(e => e.isHydrated())
      }
      hydrationFailed() {
          return this.collections.some(e => e.hydrationFailed())
      }
      isLocallyAvailable() {
          return Promise.all(this.collections.map(e => e.isLocallyAvailable())).then(e => e.every(e => e))
      }
      hydrate(e) {
          return this.isHydrated() ? Yp : new Jp(async (t, n) => {
              this.collections instanceof ik && await this.collections.hydrate(),
              Promise.all(this.collections.map(t => t.hydrate(e))).then( () => t()).catch(n)
          }
          )
      }
  }
}
)), ck, lk, uk, dk, fk, pk = t(( () => {
  ck = e(_(), 1),
  lk = e(ye(), 1),
  nt(),
  uk = class e {
      static formatUpdateToXML(e) {
          return `<Update>
${Object.entries(e).filter( ([,e]) => e).map( ([e,t]) => `<${(0,
          lk.default)(e)}>${t}</${(0,
          lk.default)(e)}>`).join(`
`)}
</Update>`
      }
      static formatXmlItemsToFeedInput(e) {
          return e.filter(Boolean).reduce( (e, t) => {
              let n = e ? `${e}\n${t}` : t;
              return n.length > 1e5 ? e : n
          }
          , ``)
      }
      static jsonSummaryToMarkdown(e) {
          try {
              let {updates: t=[]} = JSON.parse(e) || {};
              return t.length > 0 ? this.updatesToList(t) : ``
          } catch {
              return e
          }
      }
      static updatesToMarkdown(e) {
          return (0,
          ck.default)(Object.values(e), ({priority: e}) => e).filter( ({updates: e}) => e.length > 0).map( ({title: e, updates: t}) => t.length === 0 ? void 0 : `### ${e}\n${this.updatesToList(t)}`).join(`

`)
      }
      static async groupUpdates(t, n) {
          let r = (await Promise.all(t.map(async e => e.summary ? {
              ...e,
              summaryData: await n(e.summary)
          } : void 0))).concrete().sort( (e, t) => new Date(t.created).getTime() - new Date(e.created).getTime()).reduce( (e, t) => {
              let n = t.parentModelId;
              return e[n] = [...e[n] || [], t],
              e
          }
          , {});
          return Object.values(r).flat().reduce( (e, t) => {
              let n = t.type;
              return {
                  ...e,
                  [n]: {
                      ...e[n],
                      updates: [...e[n].updates, t]
                  }
              }
          }
          , e.defaultGroupedUpdates)
      }
      static updatesToList(e) {
          return (e ?? []).map(e => e.summary ? `**${e.title}**\n${e.summary}` : ``).concrete().join(`

`)
      }
      static #e = this.defaultGroupedUpdates = {
          team: {
              title: `Teams`,
              priority: 0,
              updates: []
          },
          initiative: {
              title: `Initiatives`,
              priority: 1,
              updates: []
          },
          project: {
              title: `Projects`,
              priority: 2,
              updates: []
          },
          other: {
              title: ``,
              priority: 3,
              updates: []
          }
      };
      static getExistingSubscription(e, t) {
          let n = e[t];
          return n ? {
              isSubscribed: n.isSubscribed,
              isSubscribedToSubProjects: n.isSubscribedToSubProjects
          } : void 0
      }
      static isSubscribedToInitiativeByDefault({initiativeOwnerId: e, initiativeProjectMemberIds: t, userId: n}) {
          return e === n ? {
              subscribed: !0,
              reason: dk.initiativeOwner
          } : t.includes(n) ? {
              subscribed: !0,
              reason: dk.initiativeProjectMember
          } : {
              subscribed: !1
          }
      }
      static isSubscribedToTeamByDefault({teamId: e, userTeamIds: t}) {
          return t.includes(e) ? {
              subscribed: !0,
              reason: dk.teamMember
          } : {
              subscribed: !1
          }
      }
      static isSubscribedToProjectByDefault({projectTeamIds: e, projectMemberIds: t, initiativeOwnerIds: n, initiativeIds: r, userId: i, userTeamIds: a, subscriptions: o}) {
          if (t.includes(i))
              return {
                  subscribed: !0,
                  reason: dk.projectMember
              };
          if (n.includes(i))
              return {
                  subscribed: !0,
                  reason: dk.projectInitiativeOwner
              };
          let s = r.filter(e => this.getExistingSubscription(o, e)?.isSubscribedToSubProjects)
            , c = e.filter(e => this.getExistingSubscription(o, e)?.isSubscribedToSubProjects ?? a.includes(e));
          return s.length || c.length ? {
              subscribed: !0,
              reason: dk.subProjectInitiativeOrTeamSubscription,
              data: {
                  initiativeIds: s,
                  teamIds: c
              }
          } : {
              subscribed: !1
          }
      }
      static getModelSubscriptionReason(e) {
          switch (e) {
          case `Team`:
              return dk.teamSubscription;
          case `Project`:
              return dk.projectSubscription;
          case `Initiative`:
              return dk.initiativeSubscription;
          default:
              throw Error(`Unsupported model provided to getModelSubscriptionReason`)
          }
      }
      static #t = this.POPULARITY_LAMBDA_IN_SECONDS = 86400;
      static #n = this.POPULARITY_AGE_NORMALIZATION_DATE = `2024-09-06T00:00:00Z`;
      static getPopularityScore(t) {
          let n = new Date(e.POPULARITY_AGE_NORMALIZATION_DATE)
            , r = aee(new Date(t.createdAt.toISOString()), n)
            , i = t.reactionData.reduce( (e, t) => e + t.reactions.length, 0)
            , a = t.commentsCount + i + 1;
          return Math.log(a) + r / e.POPULARITY_LAMBDA_IN_SECONDS
      }
      static #r = this.maxAudioSummaryLength = 4e3
  }
  ,
  dk = function(e) {
      return e.initiativeOwner = `initiativeOwner`,
      e.initiativeProjectMember = `initiativeProjectMember`,
      e.initiativeSubscription = `initiativeSubscription`,
      e.teamMember = `teamMember`,
      e.teamSubscription = `teamSubscription`,
      e.projectMember = `projectMember`,
      e.projectInitiativeOwner = `projectInitiativeOwner`,
      e.subProjectInitiativeOrTeamSubscription = `subProjectInitiativeOrTeamSubscription`,
      e.projectSubscription = `projectSubscription`,
      e.userMention = `userMention`,
      e.userAuthor = `userAuthor`,
      e
  }({}),
  fk = function(e) {
      return e.project = `project`,
      e.initiative = `initiative`,
      e.summary = `summary`,
      e.team = `team`,
      e
  }({})
}
)), mk, hk, gk = t(( () => {
  St(),
  mk = e(he(), 1),
  QD(),
  pk(),
  Rb(),
  LD(),
  FD(),
  TD(),
  (function(e) {
      let t = mt([_t({
          in: Dt(yt())
      }), _t({
          nin: Dt(yt())
      })])
        , n = _t({
          id: t
      })
        , r = e => _t({
          [e]: mt([...ID, _t({
              length: _t({
                  eq: Tt().int().min(0)
              })
          })])
      })
        , i = e => ({
          compareOptions: `collection`,
          defaultCompareOption: `any`,
          match: t => e in t,
          create: ({values: t, compareOption: n}) => t.length === 0 && [`all`, `any`].indexOf(n) > -1 ? {
              [e]: {
                  length: {
                      eq: 0
                  }
              }
          } : n === `all` ? {
              [e]: {
                  and: t.map(e => ({
                      id: {
                          eq: e
                      }
                  }))
              }
          } : n === `any` ? {
              [e]: {
                  or: t.map(e => ({
                      id: {
                          eq: e
                      }
                  }))
              }
          } : n === `notAll` ? {
              [e]: {
                  or: [...t.map(e => ({
                      every: {
                          id: {
                              neq: e
                          }
                      }
                  })), {
                      length: {
                          eq: 0
                      }
                  }]
              }
          } : {
              [e]: {
                  or: [{
                      every: {
                          id: {
                              nin: t
                          }
                      }
                  }, {
                      length: {
                          eq: 0
                      }
                  }]
              }
          },
          getCompareOption: t => {
              let n = `length`in t[e] || `and`in t[e] || t[e].or.find(e => e.every?.id?.neq !== void 0) !== void 0
                , r = `length`in t[e] || `and`in t[e] || `or`in t[e] && `id`in (t[e].or[0] || {});
              return n ? r ? `all` : `notAll` : r ? `any` : `neither`
          }
          ,
          selectedValues: t => `length`in t[e] ? [] : `and`in t[e] ? t[e].and.map(e => e.id.eq) : t[e].or.flatMap(e => `id`in e ? e.id.eq : `every`in e ? `nin`in e.every.id ? e.every.id.nin : e.every.id.neq : void 0).filter(Boolean)
      });
      _t({
          projectUpdate: _t({
              project: n
          })
      }),
      e.project = {
          key: `project`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: ({values: e, compareOption: t}) => ({
              projectUpdate: {
                  project: {
                      id: t === `is` ? {
                          in: e
                      } : {
                          nin: e
                      }
                  }
              }
          }),
          match: e => (0,
          mk.default)(e, [`projectUpdate`, `project`, `id`]),
          getCompareOption: e => `in`in e.projectUpdate.project.id ? `is` : `not`,
          selectedValues: e => `in`in e.projectUpdate.project.id ? e.projectUpdate.project.id.in : e.projectUpdate.project.id.nin
      },
      e.projectMembers = {
          key: `projectMember`,
          compareOptions: `containsValue`,
          defaultCompareOption: `contains`,
          allowMultiSelect: !0,
          create: e => ({
              projectUpdate: {
                  project: {
                      members: ND.createUserListFilterBlock(e)
                  }
              }
          }),
          match: e => (0,
          mk.default)(e, [`projectUpdate`, `project`, `members`]),
          getCompareOption: e => ND.getUserListCompareOption(e.projectUpdate.project.members),
          selectedValues: e => ND.getSelectedUserListValues(e.projectUpdate.project.members)
      },
      _t({
          projectUpdate: _t({
              project: _t({
                  status: n
              })
          })
      }),
      e.projectStatus = {
          key: `projectStatus`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: ({values: e, compareOption: t}) => ({
              projectUpdate: {
                  project: {
                      status: {
                          id: t === `is` ? {
                              in: e
                          } : {
                              nin: e
                          }
                      }
                  }
              }
          }),
          match: e => (0,
          mk.default)(e, [`projectUpdate`, `project`, `status`, `id`]),
          getCompareOption: e => `in`in e.projectUpdate.project.status.id ? `is` : `not`,
          selectedValues: e => `in`in e.projectUpdate.project.status.id ? e.projectUpdate.project.status.id.in : e.projectUpdate.project.status.id.nin
      },
      _t({
          projectUpdate: _t({
              project: _t({
                  status: _t({
                      type: t
                  })
              })
          })
      }),
      e.projectStatusType = {
          key: `projectStatusType`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: ({values: e, compareOption: t}) => ({
              projectUpdate: {
                  project: {
                      status: {
                          type: t === `is` ? {
                              in: e
                          } : {
                              nin: e
                          }
                      }
                  }
              }
          }),
          match: e => (0,
          mk.default)(e, [`projectUpdate`, `project`, `status`, `type`]),
          getCompareOption: e => `in`in e.projectUpdate.project.status.type ? `is` : `not`,
          selectedValues: e => `in`in e.projectUpdate.project.status.type ? e.projectUpdate.project.status.type.in : e.projectUpdate.project.status.type.nin
      },
      e.projectLabels = XD({
          key: `projectLabels`,
          match: e => (0,
          mk.default)(e, [`projectUpdate`, `project`, `labels`]),
          filterToLabels: e => e.projectUpdate.project.labels,
          labelsToFilter: e => ({
              projectUpdate: {
                  project: {
                      labels: e
                  }
              }
          })
      }),
      r(`relatedTeams`),
      e.team = {
          key: `team`,
          allowMultiSelect: !0,
          ...i(`relatedTeams`)
      },
      r(`relatedInitiatives`),
      e.initiative = {
          key: `initiative`,
          allowMultiSelect: !0,
          ...i(`relatedInitiatives`)
      },
      e.author = {
          key: `author`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: e => ({
              author: ND.createUserFilterBlock(e)
          }),
          match: e => `author`in e,
          getCompareOption: e => ND.getUserCompareOption(e.author),
          selectedValues: e => ND.getSelectedUserValues(e.author)
      },
      _t({
          updateType: mt([_t({
              in: Dt(vt(fk))
          }), _t({
              nin: Dt(vt(fk))
          })])
      }),
      e.updateType = {
          key: `updateType`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: ({values: e, compareOption: t}) => ({
              updateType: t === `is` ? {
                  in: e
              } : {
                  nin: e
              }
          }),
          match: e => `updateType`in e,
          getCompareOption: e => `in`in e.updateType ? `is` : `not`,
          selectedValues: e => `in`in e.updateType ? e.updateType.in : e.updateType.nin
      },
      _t({
          updateHealth: mt([_t({
              in: Dt(vt(Fb))
          }), _t({
              nin: Dt(vt(Fb))
          })])
      }),
      e.updateHealth = {
          key: `updateHealth`,
          compareOptions: `equalValue`,
          defaultCompareOption: `is`,
          allowMultiSelect: !0,
          create: ({values: e, compareOption: t}) => ({
              updateHealth: t === `is` ? {
                  in: e
              } : {
                  nin: e
              }
          }),
          match: e => `updateHealth`in e,
          getCompareOption: e => `in`in e.updateHealth ? `is` : `not`,
          selectedValues: e => `in`in e.updateHealth ? e.updateHealth.in : e.updateHealth.nin
      },
      e.createdAt = CD({
          defaultCompareOptionForDates: `after`,
          property: `createdAt`,
          nullable: !1
      })
  }
  )(hk ||= {})
}
));
function _k(e, t, n) {
  return hO.findBlocks(t, e).reduce( (e, [t,r]) => {
      try {
          let i = t.getCompareOption(r)
            , a = (n?.exclusive ?? !1 ? [`neither`, `not`, `notAll`, `notContains`] : [`all`, `any`, `is`, `contains`]).indexOf(i) > -1
            , o = t.selectedValues?.(r);
          return !a || !o ? e : (0,
          vk.default)(e[t.key]) ? {
              ...e,
              [t.key]: [...e[t.key], ...o]
          } : {
              ...e,
              [t.key]: o
          }
      } catch {
          return e
      }
  }
  , {})
}
var vk, yk = t(( () => {
  vk = e(c(), 1),
  gO()
}
));
function ace(e, t) {
  return t == null ? [] : Array.isArray(t[e]) ? t[e] : Sk.isEmpty(t) ? [] : [t]
}
var bk, xk, Sk, Ck = t(( () => {
  zt(),
  bk = e(ue(), 1),
  xk = e(me(), 1),
  gO(),
  qD(),
  zn(),
  iO(),
  sO(),
  zD(),
  gk(),
  yk(),
  Sk = class extends hO {
      static setMetadata(e, t, n) {
          return Mt( () => (e[UD] || (e[UD] = {}),
          Object.assign(e[UD], {
              [t]: n
          }),
          e))
      }
      static projectFilterValueForKey(e, t) {
          if (!(`or`in t && (t.or?.length ?? 0) > 1))
              switch (e) {
              case `accessibleTeams`:
                  return _k([oO.teams], t).accessibleTeams;
              case `initiatives`:
                  return _k([oO.initiatives], t).initiatives;
              case `initiativeStatus`:
                  return _k([oO.initiativeStatus], t).initiatives;
              default:
                  y(e);
                  return
              }
      }
      static initiativeFilterValueForKey(e, t) {
          if (!(`or`in t && (t.or?.length ?? 0) > 1))
              switch (e) {
              case `teams`:
                  return _k([RD.teams], t).teams;
              case `id`:
                  return _k([RD.id], t).id;
              default:
                  y(e);
                  return
              }
      }
      static issueFilterValueForKey(e, t) {
          if (!(`or`in t && (t.or?.length ?? 0) > 1))
              switch (e) {
              case `assignee`:
                  return _k([nO.assignee], t).assignee;
              case `cycle`:
                  return _k([nO.cycle], t).cycle;
              case `team`:
                  return _k([nO.team], t).team;
              case `project`:
                  return _k([nO.project], t).project;
              default:
                  y(e);
                  return
              }
      }
      static getIssueLabelsFromFilter(e) {
          return _k([nO.labels], e).labels ?? []
      }
      static getProjectLabelsFromFilter(e) {
          return _k([nO.projectLabels], e).project ?? []
      }
      static feedItemFilterValueForKey(e, t) {
          if (!(`or`in t && (t.or?.length ?? 0) > 1))
              switch (e) {
              case `team`:
                  return _k([hk.team], t).team;
              case `project`:
                  return _k([hk.project], t).project;
              case `initiative`:
                  return _k([hk.initiative], t).initiative;
              default:
                  y(e);
                  return
              }
      }
      static getMetadata(e, t) {
          return e[UD]?.[t]
      }
      static filtersCanBeCombined(e, t) {
          let n = !!e?.filter.and || e?.filter.or?.length === 1 || (0,
          bk.default)(t)
            , r = !!t?.and || (t?.or ?? []).length <= 1
            , i = t?.and ?? (t?.or ? [t?.or[0]] : [t])
            , a = e?.filter.and ?? [(e?.filter.or ?? [])[0]];
          return (0,
          xk.default)(i.concrete().flatMap(e => Object.keys(e)), a.concrete().flatMap(e => Object.keys(e))).length > 0 ? !1 : n && r
      }
      static #e = this.combineFilters = (e, t) => {
          if (!this.filtersCanBeCombined(e, t))
              return t ?? {};
          if (t === void 0 || (0,
          bk.default)(t))
              return e?.filter ?? {};
          let n = t?.and ?? (t?.or ? [t?.or[0]] : [t])
            , r = e?.filter.and ?? [(e?.filter.or ?? [])[0]];
          return {
              and: [...n, ...r]
          }
      }
      ;
      static combineModelFilters(e, t) {
          if (t.length === 0)
              return {};
          if (t.length === 1)
              return t[0] ?? {};
          let n = t.flatMap(t => ace(e, t));
          return n.length === 0 ? {} : n.length === 1 ? n[0] : e === `or` ? {
              or: n
          } : {
              and: n
          }
      }
  }
}
)), wk, Tk, Ek, Dk = t(( () => {
  wk = e(Ee(), 1),
  wv(),
  Ev(),
  Av(),
  Pv(),
  Bu(),
  Bv(),
  up(),
  iU(),
  GU(),
  V(),
  F(),
  Vm(),
  Nm(),
  eu(),
  sk(),
  iz(),
  FA(),
  bH(),
  Ih(),
  Ck(),
  N(),
  Ek = Tk = class extends Yh {
      constructor(...e) {
          super(...e),
          this.toggleFavorite = () => {
              if (this.favorite)
                  return this.favorite.delete(),
                  !1;
              {
                  let e = yH.create({
                      reference: this
                  });
                  return e.save(!0),
                  e
              }
          }
      }
      get identifier() {
          return this.name.toLowerCase().replace(/[^\w]/g, `_`)
      }
      get team() {}
      get inheritedFrom() {}
      get inheritedBy() {
          return new Bm(Tk)
      }
      get sortName() {
          return Cv.normalizeString(this.name)
      }
      get allProjects() {
          return new ok(G,[this.projects, ...this.children.map(e => e.projects)])
      }
      get type() {
          return this.children.length > 0 ? kv.Group : this.parent ? kv.Child : kv.Root
      }
      get isRetired() {
          return !!this.retiredAt || !!this.parent?.isRetired
      }
      getViewPreferences() {
          return this._viewPreferences
      }
      get _viewPreferences() {
          return NA.getOrCreateFrom(this.viewPreferences, k.projectLabel, {
              projectLabel: this
          })
      }
      get usedByTriageRuleCount() {
          return this.associatedTriageRules.length
      }
      get associatedTriageRules() {
          let e = new Set([this.name, ...this.children.elements.map(e => e.name)]);
          return this.organization.triageWorkflowDefinitions.filter(t => t.enabled ? t.conditions?.some(t => t?.issueFilter && Sk.getProjectLabelsFromFilter(t.issueFilter).some(t => typeof t == `string` && e.has(t))) ?? !1 : !1)
      }
      get usedBySLARuleCount() {
          return this.associatedSLARules.length
      }
      get associatedSLARules() {
          let e = new Set([this.name, ...this.children.elements.map(e => e.name)]);
          return this.organization.workflowDefinitions.filter(t => !!(t.type === op.sla && t.enabled && t.conditions?.some(t => t?.issueFilter && Sk.getProjectLabelsFromFilter(t.issueFilter).some(t => typeof t == `string` && e.has(t)))))
      }
      get isInBatchOperation() {
          if (this.parent?.isInBatchOperation)
              return !0;
          let e = [Rv.LabelMerge];
          return !!this.organization.batchOperations.filter(t => t.status !== Lv.finished && e.includes(t.type)).find(e => {
              if (e.type === Rv.LabelMerge) {
                  let {toLabelId: t, fromLabelIds: n=[]} = e.parameters?.labelMergeParameters || {};
                  return t === this.id || n.includes(this.id)
              }
              return !1
          }
          )
      }
      getActualLabel() {
          return this
      }
      getOwner() {
          return this.organization
      }
      getUsedByCount() {
          return this.allProjects.length
      }
      getAssociatedModels() {
          return this.projects.elements
      }
      getIsExternal() {
          return !1
      }
      getMaxLabelsPerGroupQuota() {
          return jv.maxProjectLabelsPerGroup
      }
      static create({parent: e, owner: t, isGroup: n}) {
          let r = Tk.createEmpty();
          return r.parent = e,
          r.name = ``,
          r.organization = t instanceof q ? t : t.organization,
          r.color = e?.color ?? (0,
          wk.default)(Tv.colorsList) ?? Tv.defaultTeamIconBackground,
          r.isGroup = n ?? !1,
          r
      }
      matchesLabelName(e) {
          return this.name.toLowerCase().trim() === e.name.toLowerCase().trim()
      }
      matchInlineFind(e) {
          return $l([this.name, this.parent?.name].concrete().join(`   `)).toLowerCase().indexOf(e) !== -1
      }
  }
  ,
  M([R({
      default: ``
  })], Ek.prototype, `name`, void 0),
  M([R()], Ek.prototype, `description`, void 0),
  M([R({
      default: `#f00`
  })], Ek.prototype, `color`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Ek.prototype, `lastAppliedAt`, void 0),
  M([R({
      serializer: Ah
  })], Ek.prototype, `retiredAt`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !0,
      nullable: !1
  })], Ek.prototype, `retiredBy`, void 0),
  M([R({
      default: !1
  })], Ek.prototype, `isGroup`, void 0),
  M([B( () => q, `allProjectLabels`, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], Ek.prototype, `organization`, void 0),
  M([ug({
      nullable: !0
  })], Ek.prototype, `favorite`, void 0),
  M([z( () => G, {
      index: `labelIds`
  })], Ek.prototype, `projects`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !0,
      nullable: !1
  })], Ek.prototype, `creator`, void 0),
  M([B( () => Ek, `children`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], Ek.prototype, `parent`, void 0),
  M([z( () => Ek, {
      index: `parentId`,
      order: new P(`name`)
  })], Ek.prototype, `children`, void 0),
  M([z( () => NA, {
      index: `projectLabelId`,
      canSkipHydration: e => e.organization.viewPreferences.isHydrated()
  })], Ek.prototype, `viewPreferences`, void 0),
  M([L], Ek.prototype, `sortName`, null),
  M([L], Ek.prototype, `allProjects`, null),
  M([L], Ek.prototype, `type`, null),
  M([L], Ek.prototype, `isRetired`, null),
  M([L], Ek.prototype, `_viewPreferences`, null),
  M([L], Ek.prototype, `usedByTriageRuleCount`, null),
  M([L], Ek.prototype, `associatedTriageRules`, null),
  M([L], Ek.prototype, `usedBySLARuleCount`, null),
  M([L], Ek.prototype, `associatedSLARules`, null),
  M([L], Ek.prototype, `isInBatchOperation`, null),
  Ek = Tk = M([mg(`ProjectLabel`)], Ek)
}
)), Ok, kk = t(( () => {
  (function(e) {
      function t(e) {
          return new Set(e.filter(e => !!Ok.attentionNeededSince(e)).map(e => e.userId))
      }
      e.calculateAttentionSet = t;
      function n(e) {
          if (!e?.attentionLastNeededAt)
              return;
          let t = e.attentionLastNeededAt;
          if (e.lastActivityAt && e.lastActivityAt > t && (t = e.lastActivityAt),
          e.lastDismissedAt && e.lastDismissedAt > t && (t = e.lastDismissedAt),
          !(t > e.attentionLastNeededAt))
              return e.attentionLastNeededAt
      }
      e.attentionNeededSince = n
  }
  )(Ok ||= {})
}
)), Ak, oce = t(( () => {
  Ak = class {
      static latestReviewsByAllUsers(e) {
          let t = new Set
            , n = new Set
            , r = []
            , i = [];
          for (let a = e.length - 1; a >= 0; a--) {
              let o = e[a];
              o.userId && !t.has(o.userId) ? (t.add(o.userId),
              r.push(o)) : o.externalUserId && !n.has(o.externalUserId) && (n.add(o.externalUserId),
              i.push(o))
          }
          return [...r, ...i]
      }
  }
}
)), jk, Mk = t(( () => {
  jk = function(e) {
      return e.file = `file`,
      e.diffHunk = `diffHunk`,
      e
  }({})
}
)), Nk, sce = t(( () => {
  Nk = function(e) {
      return e[e.hasChildren = 0] = `hasChildren`,
      e[e.hasCreatedIssues = 1] = `hasCreatedIssues`,
      e
  }({})
}
)), Pk, Fk = t(( () => {
  Pk = function(e) {
      return e.source = `source`,
      e.graphite = `graphite`,
      e
  }({})
}
)), Ik, Lk = t(( () => {
  Xs(),
  Fk(),
  zn(),
  pi(),
  Ik = class e {
      static formatShortCommitSha(e) {
          return e.substring(0, 7)
      }
      static gitAttachmentReviewInfo(t) {
          if (!t.isPullRequest || !t.pullRequestAttachment)
              return {
                  tool: Pk.source,
                  url: t.url
              };
          let n = e.integrationForGitAttachment(t);
          if (!n)
              return {
                  tool: Pk.source,
                  url: t.url
              };
          let r = this.reviewToolForIntegration(n);
          if (!this.integrationSupportsReviewTool(n.service, r))
              return {
                  tool: Pk.source,
                  url: t.url
              };
          let {repoLogin: i, repoName: a, number: o} = t.pullRequestAttachment;
          switch (r) {
          case Pk.source:
              return {
                  tool: Pk.source,
                  url: t.url
              };
          case Pk.graphite:
              return {
                  tool: Pk.graphite,
                  url: this.graphiteUrl(i, a, o)
              };
          default:
              return y(r),
              {
                  tool: Pk.source,
                  url: t.url
              }
          }
      }
      static pullRequestReviewInfo(t) {
          let n = e.integrationForPullRequest(t);
          if (!n)
              return {
                  tool: Pk.source,
                  url: t.url
              };
          let r = this.reviewToolForIntegration(n);
          if (!this.integrationSupportsReviewTool(n.service, r))
              return {
                  tool: Pk.source,
                  url: t.url
              };
          switch (r) {
          case Pk.source:
              return {
                  tool: Pk.source,
                  url: t.url
              };
          case Pk.graphite:
              return {
                  tool: Pk.graphite,
                  url: this.graphiteUrl(t.repository.owner, t.repository.name, t.number)
              };
          default:
              return y(r),
              {
                  tool: Pk.source,
                  url: t.url
              }
          }
      }
      static reviewToolForIntegration(e) {
          let t;
          return e.service === T.github ? t = e.settings.gitHub : e.service === T.gitlab && (t = e.settings.gitLab),
          t?.pullRequestReviewTool ?? Pk.source
      }
      static integrationSupportsReviewTool(e, t) {
          switch (t) {
          case Pk.source:
              return !0;
          case Pk.graphite:
              return e === T.github;
          default:
              return y(t),
              !1
          }
      }
      static reviewToolLabel(e, t) {
          switch (t) {
          case Pk.source:
              return Ys.getDisplayName(e);
          case Pk.graphite:
              return `Graphite`;
          default:
              y(t);
              return
          }
      }
      static graphiteUrl(e, t, n) {
          return `https://app.graphite.dev/github/pr/${e}/${t}/${n}`
      }
      static integrationServiceForGitAttachment(e) {
          if (!(e.sourceMetadata?.type !== `integration` || !e.pullRequestAttachment))
              return e.sourceMetadata.subType
      }
      static integrationForGitAttachment(e) {
          if (!e.pullRequestAttachment)
              return;
          let t = this.integrationServiceForGitAttachment(e);
          if (t === T.github) {
              let {repoLogin: t} = e.pullRequestAttachment;
              return e.store.organization.getIntegration(T.github, e => e.settings.gitHub?.orgLogin === t)
          }
          if (t === T.gitlab)
              return e.store.organization.getIntegration(T.gitlab)
      }
      static integrationServiceForPullRequest(e) {
          if (e.sourceMetadata?.type === `integration`)
              return e.sourceMetadata.subType
      }
      static integrationForPullRequest(e) {
          let t = this.integrationServiceForPullRequest(e);
          if (t === T.github)
              return e.store.organization.getIntegration(T.github, t => t.settings.gitHub?.orgLogin === e.repository.owner);
          if (t === T.gitlab)
              return e.store.organization.getIntegration(T.gitlab)
      }
      static userHasCodeReviewAccess(e) {
          return !ui.isEnabled(ui.codeReviews) || !ui.isEnabled(ui.githubCodeAccess) ? !1 : !!e.getIntegration(T.githubCodeAccessPersonal)
      }
  }
}
));
function Rk(e) {
  return e.issue?.value?.allAttachments.filter(e => e.sourceType === T.slack).elements || []
}
var zk, Bk = t(( () => {
  Ns(),
  L_(),
  Xs(),
  Ul(),
  Wv(),
  fy(),
  ml(),
  pi(),
  XB(),
  qk(),
  Ry(),
  ML(),
  Lk(),
  (function(e) {
      function t(e) {
          return e ? e.includes(g_(``)) : !1
      }
      e.isAnyCommentInHash = t;
      function n(e, t) {
          return e ? e.includes(g_(t)) : !1
      }
      e.isCommentIdInHash = n;
      async function r(e) {
          switch (e.sourceMetadata?.subType) {
          case T.github:
              return await e.issue?.value?.allAttachments.transientlyHydrateElements(),
              e.issue?.value?.syncedGithubIssueAttachment?.title;
          case T.jira:
              return await e.issue?.value?.externalEntityRelations.transientlyHydrateElements(),
              e.issue?.value?.externalEntityRelations.find(e => e.externalEntityType === Vl.jiraIssue)?.metadata?.jiraIssueMetadata?.issueKey;
          case T.slack:
          case T.slackAsks:
              return i(e);
          default:
              return
          }
      }
      e.getExternalParentEntityName = r;
      async function i(e) {
          if (ee(e, `isPrivateChannel`))
              return `Private channel`;
          let t = await _(e) ?? (e.parent?.value ? await _(e.parent.value) : void 0)
            , n = ee(e, `channelName`) || (e.parent?.value ? ee(e.parent.value, `channelName`) : void 0) || t?.metadata?.channelName;
          return n ? Uv.Slack.channelNameToDisplay(n) : void 0
      }
      e.syncedSlackThreadChannelName = i;
      function a(e) {
          switch (e.sourceMetadata?.subType) {
          case T.github:
              return e.issue?.value.syncedGithubIssueAttachment?.url;
          case T.jira:
              return e.issue?.value?.syncedJiraIssueAttachment?.url;
          case T.slack:
          case T.slackAsks:
              return o(e);
          default:
              return
          }
      }
      e.getExternalThreadUrl = a;
      function o(e) {
          if (e.isSlackSynced)
              return ee(e, `messageUrl`) || (e.parent?.value ? ee(e.parent.value, `messageUrl`) : void 0) || Rk(e).find(e => e.source?.syncedCommentId !== void 0)?.url
      }
      e.syncedSlackThreadUrl = o;
      function s(e) {
          let t = o(e)?.replace(/\/p\d+$/, ``)
            , n = ee(e, `parentMessageTs`)
            , r = ee(e, `threadedMessageEventTs`)
            , i = ee(e, `channelId`);
          if (!(!t || !r || !i))
              return `${t}/${`p` + r.replace(`.`, ``)}?thread_ts=${n}&cid=${i}`
      }
      e.syncedSlackThreadedMessageUrl = s;
      function c(e, t) {
          if (e instanceof YB)
              switch (e.sourceMetadata?.subType) {
              case T.jira:
                  return !e.issue?.value?.externalEntityRelations.find(e => e.externalEntityType === Vl.jiraIssue);
              case T.github:
                  return !e.issue?.value?.externalEntityRelations.find(e => e.externalEntityType === Vl.githubIssue);
              case T.slack:
              case T.slackAsks:
                  return ui.isEnabled(ui.slackIntegrationOptOutOfReadingMessageHistory) || e.isRootUnsyncedSlackComment || !e?.externalEntityRelations.find(e => e.externalEntityType === Vl.slackMessage) || !t?.organization.integrations.find(t => t.service === e.sourceMetadata.subType && !t.isArchived);
              default:
                  return !1
              }
          else
              return !1
      }
      e.isThreadDisconnected = c;
      function l(e) {
          switch (e.sourceMetadata?.subType) {
          case T.jira:
          case T.github:
          case T.gitlab:
          case T.email:
              return Ys.getDisplayName(e.sourceMetadata?.subType);
          case T.slack:
          case T.slackAsks:
              return Ys.getDisplayName(T.slack);
          default:
              return
          }
      }
      e.getExternalServiceDisplayName = l;
      function u(e) {
          switch (e.sourceMetadata?.subType) {
          case T.jira:
          case T.github:
              return `Comment`;
          default:
              return `Reply`
          }
      }
      e.getExternalServiceReplyType = u;
      function d(e, t) {
          if (t instanceof YB && e.guest && e.organization.restrictAgentInvocationToMembers && t.getTrait(dy.hasAgentSession))
              return !1;
          let n;
          switch (t.sourceMetadata?.subType) {
          case T.github:
              let r = t instanceof Kk ? t.pullRequest.value : void 0;
              n = r ? Ik.integrationForPullRequest(r) : void 0;
              break;
          case T.jira:
              n = e.organization.getIntegration(T.jira);
              break;
          default:
              break
          }
          return n?.userHasMatchingPersonalIntegration(e) ?? !0
      }
      e.canUserReplyToComment = d;
      function f(e) {
          if (e.bodyData)
              try {
                  let t = dl.nodeFromJSON(e.bodyData);
                  if (t.childCount === 1) {
                      let e = t.child(0);
                      if (e.type.name === `paragraph` && e.childCount > 0) {
                          let t = !0;
                          if (e.content.forEach(e => {
                              e.type.name !== `emoji` && (t = !1)
                          }
                          ),
                          t)
                              return !0
                      }
                  }
                  if (t.content.content.length === 1 && t.content.content[0].isTextblock) {
                      let e = t.textContent;
                      return e.length > 0 && e.replace(Ms(), ``) === ``
                  }
                  return !1
              } catch {
                  return !1
              }
          return !1
      }
      e.hasEmojiOnlyBody = f;
      function p(e) {
          return e instanceof YB && !!e.projectUpdate?.value
      }
      e.hasProjectUpdate = p;
      function m(e) {
          return e instanceof YB && !!e.initiativeUpdate?.value
      }
      e.hasInitiativeUpdate = m;
      function h(e) {
          return e instanceof YB && e.parent === void 0 && !!e.sourceMetadata?.emailIntakeMetadata
      }
      e.isRootEmailIntakeComment = h;
      function g(e, t) {
          if (!e.bodyData || !e.author)
              return;
          let {organization: n, user: r} = t
            , i = n.findUser(e.author?.id ?? ``) !== void 0
            , a = e.author ? Ly.getUsername(r.settings, e.author) : void 0
            , o = e instanceof YB ? e.issue?.value : void 0
            , s = e instanceof YB ? e.projectUpdate?.value : void 0
            , c = e instanceof YB ? e.initiativeUpdate?.value : void 0
            , l = e instanceof Kk ? e.pullRequest.value : void 0;
          return {
              type: `doc`,
              content: [{
                  type: `paragraph`,
                  content: [i ? {
                      type: `suggestion_userMentions`,
                      attrs: {
                          id: e.author.id,
                          label: a
                      }
                  } : {
                      type: `text`,
                      text: e.author.name,
                      marks: [{
                          type: `strong`,
                          attrs: {}
                      }]
                  }, {
                      type: `text`,
                      text: o || l ? ` said in ` : ` said`
                  }, ...s ? [{
                      type: `text`,
                      text: ` in a project update comment for `
                  }, {
                      type: `entityMention`,
                      attrs: {
                          id: s.project.id,
                          label: s.project.name,
                          href: pP(e)
                      }
                  }] : [], ...c ? [{
                      type: `text`,
                      text: ` in an initiative update comment for `
                  }, {
                      type: `entityMention`,
                      attrs: {
                          id: c.initiative.id,
                          label: c.initiative.name,
                          href: pP(e)
                      }
                  }] : [], o ? {
                      type: `issueMention`,
                      attrs: {
                          id: o.id,
                          label: o.identifier,
                          href: pP(e),
                          title: o.title
                      }
                  } : void 0, l ? {
                      type: `entityMention`,
                      attrs: {
                          id: l.id,
                          label: l.identifier,
                          href: pP(e)
                      }
                  } : void 0, {
                      type: `text`,
                      text: `:`
                  }].concrete()
              }, {
                  type: `blockquote`,
                  content: e.bodyData.content || []
              }].filter(Boolean)
          }
      }
      e.wrapEditorDataInBlockquote = g;
      async function _(e) {
          let t = await e.hydrate();
          if (!(!t.isSlackSynced || !t.issue?.value))
              return await t.issue.value.allAttachments.transientlyHydrateElements(),
              Rk(t).find(t => t.source?.syncedCommentId === e.id)
      }
      function ee(e, t) {
          return e.sourceMetadata?.slackSyncMetadata?.[t] ?? e.externalEntityRelations.first?.metadata?.slackSyncMetadata?.[t]
      }
  }
  )(zk ||= {})
}
)), Vk, cce = t(( () => {
  Vk = {
      unreviewed: `unreviewed`,
      reviewed: `reviewed`,
      changedAfterReview: `changedAfterReview`
  }
}
));
async function lce(e, t) {
  let n = Ut`
  mutation PullRequestPendingReviewSubmit($id: String!, $decision: String!) {
    pullRequestPendingReviewSubmit(id: $id, decision: $decision) {
      lastSyncId
    }
  }
`;
  return await e.mutate(n, t)
}
var uce = t(( () => {
  Wt()
}
)), Hk, Uk, Wk = t(( () => {
  cce(),
  V(),
  F(),
  om(),
  Nm(),
  TA(),
  qk(),
  GU(),
  Sm(),
  uce(),
  Ih(),
  N(),
  Uk = class extends Yh {
      static #e = Hk = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      get isSubmitted() {
          return !!this.submittedAt
      }
      async submit(e) {
          this.decision = e,
          this.submittedAt = new Date;
          try {
              await lce(this.store.graphQLClient, {
                  id: this.id,
                  decision: e
              })
          } catch (e) {
              throw this.decision = null,
              this.submittedAt = null,
              e
          }
      }
      getFileReviewState(e) {
          return this.reviewedFiles.find(t => t.path === e)?.state ?? Vk.unreviewed
      }
      isFileReviewed(e) {
          return this.getFileReviewState(e) === Vk.reviewed
      }
      isFileChangedAfterReview(e) {
          return this.getFileReviewState(e) === Vk.changedAfterReview
      }
      markFileAsReviewed(e, t) {
          let n = this.reviewedFiles.findIndex(t => t.path === e)
            , r = {
              path: e,
              state: Vk.reviewed,
              reviewedAtSha: t,
              reviewedAt: new Date
          };
          n >= 0 ? this.reviewedFiles = [...this.reviewedFiles.slice(0, n), r, ...this.reviewedFiles.slice(n + 1)] : this.reviewedFiles = [...this.reviewedFiles, r],
          this.save(!0)
      }
      unmarkFileAsReviewed(e) {
          this.reviewedFiles = this.reviewedFiles.filter(t => t.path !== e),
          this.save(!0)
      }
      static create(e) {
          let {pullRequest: t, reviewer: n, decision: r} = e
            , i = Hk.createEmpty();
          i.reviewer = n,
          i.pullRequest = vm.wrap(t),
          i.decision = r;
          let a = t.currentUserLastSubmittedReview;
          return a && a.reviewedFiles.length > 0 && (i.reviewedFiles = [...a.reviewedFiles]),
          i
      }
  }
  ,
  M([R()], Uk.prototype, `decision`, void 0),
  M([R({
      serializer: Ah
  })], Uk.prototype, `submittedAt`, void 0),
  M([R({
      serializer: Mh,
      shallowObservation: !0,
      default: []
  })], Uk.prototype, `reviewedFiles`, void 0),
  M([sg( () => U, `pendingReviews`, {
      nullable: !1,
      optional: !1,
      indexed: !0,
      persistence: `createOnly`
  })], Uk.prototype, `pullRequest`, void 0),
  M([B( () => J, `pendingReviews`, {
      nullable: !1,
      optional: !1,
      indexed: !0,
      persistence: `none`
  })], Uk.prototype, `reviewer`, void 0),
  M([z( () => Kk, {
      index: `pendingReviewId`,
      order: new P(`createdAt`)
  })], Uk.prototype, `comments`, void 0),
  M([I], Uk.prototype, `submit`, null),
  M([I], Uk.prototype, `markFileAsReviewed`, null),
  M([I], Uk.prototype, `unmarkFileAsReviewed`, null),
  M([I], Uk, `create`, null),
  Uk = Hk = M([mg(`PullRequestPendingReview`)], Uk)
}
)), Gk, Kk, qk = t(( () => {
  Mk(),
  sce(),
  ml(),
  _y(),
  Oy(),
  DC(),
  cc(),
  Sy(),
  V(),
  F(),
  om(),
  Vm(),
  Nm(),
  Iy(),
  Sm(),
  TA(),
  Ih(),
  GU(),
  sR(),
  Ry(),
  Bk(),
  Lq(),
  AM(),
  Lk(),
  Wk(),
  N(),
  Kk = class extends Yh {
      static #e = Gk = this;
      constructor(...e) {
          super(...e),
          this.resolvingComment = void 0,
          this.isSyncedExternalThreadRoot = !1
      }
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      getTrait(e) {
          return sc(this.traits, e)
      }
      get author() {
          return this.user ?? this.externalUser?.value
      }
      get parentModel() {
          return this.pullRequest?.value
      }
      get bodyMarkdown() {
          return this.bodyData ? Hp.serialize(this.bodyData) : ``
      }
      get isTopLevel() {
          return !this.parent
      }
      get supportsThreading() {
          return this.isThread || !!this.anchor
      }
      get isThread() {
          return !!this.parent || this.children.length > 0
      }
      get canResolve() {
          return !this.parent && !this.anchor ? !0 : !!this.anchor && !!this.externalThreadId
      }
      allowEdit(e) {
          let t = this.pullRequest.value;
          return this.user !== e || !t ? !1 : Ik.integrationForPullRequest(t)?.userHasMatchingPersonalIntegration(e) ?? !1
      }
      allowDelete(e) {
          return this.allowEdit(e) && (!this.decision || this.decision === EC.approved)
      }
      get hasPendingReview() {
          return !this.pullRequest.value?.isSubmittingPendingReview && !!this.pendingReview?.value && !this.pendingReview.value.isSubmitted
      }
      get hasPendingUploads() {
          return !!this.pendingUploads && this.pendingUploads.size > 0
      }
      get root() {
          return this.parent?.id ? this.parent.value : this
      }
      get threadComments() {
          if (this.root)
              return Bm.of(Gk, [...new Set([this.root, ...this.root.children])])
      }
      get isResolved() {
          return !!this.resolvedAt
      }
      get sourceMetadata() {
          return this.pullRequest.value?.sourceMetadata
      }
      get hasEmojiOnlyBody() {
          return zk.hasEmojiOnlyBody(this)
      }
      get notificationText() {
          let e = this.store;
          if (this.bodyData)
              return Ty(this.bodyData, {
                  getDisplayUserLabel(t, n) {
                      let r = e.findById(J, t);
                      return r ? Ly.getUsername(e.user.settings, r) : n
                  }
              })
      }
      get bodyTextContent() {
          return this.bodyData ? gy(dl.nodeFromJSON(this.bodyData)) : ``
      }
      get outdated() {
          return this.anchor?.outdated ?? this.parent?.value?.anchor?.outdated ?? !1
      }
      get multilineRange() {
          let {anchor: e} = this;
          if (e?.type !== jk.diffHunk)
              return;
          let {start: t, end: n} = e;
          if (!(!t?.line || !n?.line || t.line === n.line))
              return {
                  start: t.line,
                  end: n.line
              }
      }
      static create(e) {
          let {id: t, pullRequest: n, user: r, bodyData: i, parent: a, anchor: o, pendingReview: s} = e
            , c = Gk.createEmpty();
          return t && (c.id = t),
          c.user = r,
          c.pullRequest = vm.wrap(n),
          a && (c.parent = vm.wrap(a)),
          c.bodyData = i || pl(),
          o && (c.anchor = o),
          s && (c.pendingReview = vm.wrap(s)),
          c
      }
  }
  ,
  M([R({
      shallowObservation: !0,
      default: {}
  })], Kk.prototype, `bodyData`, void 0),
  M([R({
      serializer: Mh,
      persistence: `createOnly`
  })], Kk.prototype, `anchor`, void 0),
  M([R({
      persistence: `none`
  })], Kk.prototype, `externalThreadId`, void 0),
  M([sg( () => Uk, `comments`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], Kk.prototype, `pendingReview`, void 0),
  M([R({
      persistence: `createOnly`
  })], Kk.prototype, `decision`, void 0),
  M([R({
      persistence: `none`
  })], Kk.prototype, `traits`, void 0),
  M([sg( () => U, `comments`, {
      nullable: !1,
      optional: !1,
      indexed: !0,
      persistence: `createOnly`
  })], Kk.prototype, `pullRequest`, void 0),
  M([og( () => iR)], Kk.prototype, `notifications`, void 0),
  M([sg( () => Kk, `children`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      cascadeHydration: !0,
      persistence: `createOnly`
  })], Kk.prototype, `parent`, void 0),
  M([z( () => Kk, {
      index: `parentId`,
      order: new P(`createdAt`),
      canSkipHydration: e => !e.getTrait(Nk.hasChildren)
  })], Kk.prototype, `children`, void 0),
  M([og( () => kM)], Kk.prototype, `draftReplies`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Kk.prototype, `editedAt`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `updateOnly`
  })], Kk.prototype, `resolvingUser`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Kk.prototype, `resolvedAt`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !0,
      nullable: !1
  })], Kk.prototype, `user`, void 0),
  M([lg( () => Fy, {
      nullable: !0,
      indexed: !0,
      persistence: `none`
  })], Kk.prototype, `externalUser`, void 0),
  M([R({
      persistence: `none`,
      serializer: Mh,
      default: []
  })], Kk.prototype, `reactionData`, void 0),
  M([R({
      persistence: `none`
  })], Kk.prototype, `pendingUploads`, void 0),
  M([z( () => Y, {
      index: `sourcePullRequestCommentId`,
      canSkipHydration: e => !e.getTrait(Nk.hasCreatedIssues)
  })], Kk.prototype, `createdIssues`, void 0),
  M([L], Kk.prototype, `root`, null),
  M([L], Kk.prototype, `threadComments`, null),
  M([L], Kk.prototype, `hasEmojiOnlyBody`, null),
  M([L], Kk.prototype, `notificationText`, null),
  M([L], Kk.prototype, `bodyTextContent`, null),
  M([I], Kk, `create`, null),
  Kk = Gk = M([mg(`PullRequestComment`)], Kk)
}
)), Jk, Yk = t(( () => {
  zn(),
  (function(e) {
      let t = function(e) {
          return e.titleRepo = `titleRepo`,
          e.title = `title`,
          e
      }({});
      e.Option = t,
      e.defaultOption = t.title,
      e.AllOptions = [t.title, t.titleRepo];
      function n(e) {
          switch (e) {
          case t.titleRepo:
              return `Title + Repository`;
          case t.title:
              return `Title`;
          default:
              throw y(e)
          }
      }
      e.labelForGitAttachmentDisplayPreference = n
  }
  )(Jk ||= {})
}
));
function dce(e) {
  switch (e) {
  case _l.approved:
      return EC.approved;
  case _l.changesRequested:
      return EC.changesRequested;
  case _l.commented:
      return EC.commented;
  case _l.pending:
      return EC.pending;
  case _l.dismissed:
      return EC.pending;
  default:
      return y(e),
      EC.pending
  }
}
var Xk, Zk = t(( () => {
  nt(),
  zn(),
  vl(),
  Fc(),
  Xs(),
  DC(),
  uO(),
  AV(),
  TA(),
  Lk(),
  Xk = class e {
      static create(t) {
          return new e(t)
      }
      constructor(e) {
          this.model = e
      }
      static matchModel(e, t) {
          return e instanceof U ? t.pr(e) : e instanceof kV ? e.pullRequestEntity ? t.pr(e.pullRequestEntity) : t.attachment(e) : t?.default?.() ?? void 0
      }
      get title() {
          return e.matchModel(this.model, {
              pr: e => e.title,
              attachment: e => {
                  let t = e.metadata;
                  return `title`in t && t.title ? t.title : e.title
              }
          }) ?? ``
      }
      get externalReviewInfo() {
          return e.matchModel(this.model, {
              pr: e => Ik.pullRequestReviewInfo(e),
              attachment: e => Ik.gitAttachmentReviewInfo(e)
          })
      }
      get externalReviewToolLabel() {
          let e = this.integrationService
            , t = this.externalReviewInfo;
          if (!e && this.model instanceof kV && (e = T[this.model.sourceType]),
          !(!t || !e))
              return Ik.reviewToolLabel(e, t.tool)
      }
      get externalReviewUrl() {
          let t = this.externalReviewInfo;
          return e.matchModel(this.model, {
              pr: e => t?.url ?? e.url,
              attachment: e => t?.url ?? e.url
          })
      }
      get integrationService() {
          return e.matchModel(this.model, {
              pr: e => Ik.integrationServiceForPullRequest(e),
              attachment: e => Ik.integrationServiceForGitAttachment(e)
          })
      }
      get integration() {
          return e.matchModel(this.model, {
              pr: e => Ik.integrationForPullRequest(e),
              attachment: e => Ik.integrationForGitAttachment(e)
          })
      }
      get prNumber() {
          return e.matchModel(this.model, {
              pr: e => `${e.isSyncedWithGitLab ? `!` : `#`}${e.number}`,
              attachment: e => {
                  let t = Pc.getSourceType(e);
                  return !(t === T.github || t === T.gitlab) || e.metadata.number === void 0 ? `` : (t === T.gitlab ? `!` : `#`) + e.metadata.number
              }
          }) ?? ``
      }
      get linkKind() {
          return e.matchModel(this.model, {
              pr: e => void 0,
              attachment: e => {
                  let t = e.metadata;
                  return `linkKind`in t && t.linkKind ? t.linkKind : gl.closes
              }
          })
      }
      get repoOwnerAndName() {
          return [this.repoOwner, this.repoName].filter(Boolean).join(`/`)
      }
      get repoName() {
          return e.matchModel(this.model, {
              pr: e => e.repository.name,
              attachment: e => e.isPullRequest || e.isGithubCommit ? e.metadata.repoName : ``
          }) ?? ``
      }
      get repoOwner() {
          return e.matchModel(this.model, {
              pr: e => e.repository.owner,
              attachment: e => e.isPullRequest || e.isGithubCommit ? e.metadata.repoLogin : ``
          }) ?? ``
      }
      get branchName() {
          return e.matchModel(this.model, {
              pr: e => e.sourceBranch,
              attachment: e => {
                  if (e.isPullRequest)
                      return e.metadata.branch;
                  if (e.isGithubCommit) {
                      let t = e.metadata
                        , n = t.branchRef
                        , r = t.branch;
                      return !r && n && n.startsWith(`refs/heads/`) && (r = n.replace(`refs/heads/`, ``)),
                      r
                  }
                  return ``
              }
          }) ?? ``
      }
      get targetBranchName() {
          return e.matchModel(this.model, {
              pr: e => e.targetBranch,
              attachment: e => e.metadata.targetBranch
          }) ?? ``
      }
      get fullIdentifier() {
          let e = this.repoOwner;
          return `${e ? `${e}/` : ``}${this.repoName}${this.prNumber}`
      }
      get commitSha() {
          return e.matchModel(this.model, {
              pr: () => void 0,
              attachment: e => {
                  let t = e.metadata;
                  if (`commitId`in e.metadata && e.metadata.commitId)
                      return Ik.formatShortCommitSha(t.commitId)
              }
          }) ?? void 0
      }
      get latestReviewsByAllUsers() {
          return e.matchModel(this.model, {
              pr: e => e.latestReviewsByAllUsers.map(t => ({
                  user: e.getUserFromReviewer(t),
                  reviewerLogin: void 0,
                  reviewerAvatarUrl: void 0,
                  decision: t.decision,
                  lastReviewedAt: t.lastReviewedAt
              })),
              attachment: e => {
                  let t = e.metadata;
                  if (`reviews`in t && Array.isArray(t.reviews) && t.reviews.length > 0) {
                      let e = t.reviews;
                      return [...new Set(e.map(e => e.reviewerLogin))].map(t => e.findLast(e => e.reviewerLogin === t)).filter(Boolean).map(e => ({
                          user: void 0,
                          reviewerLogin: e.reviewerLogin,
                          reviewerAvatarUrl: e.reviewerAvatarUrl,
                          decision: dce(e.state),
                          lastReviewedAt: e.submittedAt ? new Date(e.submittedAt) : void 0
                      }))
                  }
                  return []
              }
          }) ?? []
      }
      get status() {
          return e.matchModel(this.model, {
              pr: e => e.status,
              attachment: e => {
                  let t = e.metadata
                    , n = t.status
                    , r = !1;
                  switch (`reviews`in t && (t.reviews?.length ?? 0) > 0 && (r = t.reviews?.some(e => e.state === _l.approved) ?? !1),
                  n) {
                  case hl.open:
                      return r ? cO.approved : cO.open;
                  case hl.merged:
                      return cO.merged;
                  case hl.closed:
                      return cO.closed;
                  case hl.draft:
                      return cO.draft;
                  case hl.inReview:
                      return r ? cO.approved : cO.inReview;
                  case hl.reopened:
                      return r ? cO.approved : cO.open;
                  default:
                      y(n);
                      return
                  }
              }
          })
      }
      get mergeStatus() {
          return e.matchModel(this.model, {
              pr: e => e.mergeStatus,
              attachment: () => void 0
          })
      }
      get mergeQueueEnqueuedAt() {
          return e.matchModel(this.model, {
              pr: e => e.mergeQueueEnqueuedAt,
              attachment: () => void 0
          })
      }
      get hasReviews() {
          return e.matchModel(this.model, {
              pr: e => !e.hasNoReviewersAssigned,
              attachment: e => {
                  let t = e.metadata;
                  return !!(`reviews`in t && Array.isArray(t.reviews) && t.reviews.length > 0)
              }
          }) ?? !1
      }
      get isMerged() {
          return e.matchModel(this.model, {
              pr: e => e.isMerged,
              attachment: e => e.metadata.status === hl.merged
          }) ?? !1
      }
      get mergedAt() {
          return e.matchModel(this.model, {
              pr: e => e.mergedAt,
              attachment: e => {
                  let t = e.metadata;
                  if (`mergedAt`in t && t.mergedAt)
                      return new Date(t.mergedAt)
              }
          })
      }
      get updateAt() {
          return e.matchModel(this.model, {
              pr: e => e.updatedAt,
              attachment: e => {
                  let t = e.metadata;
                  if (`updatedAt`in t && t.updatedAt)
                      return new Date(t.updatedAt)
              }
          })
      }
      get previewLinks() {
          return e.matchModel(this.model, {
              pr: e => e.previewLinks,
              attachment: e => {
                  let t = e.metadata;
                  return `previewLinks`in t && t.previewLinks && Array.isArray(t.previewLinks) ? t.previewLinks : []
              }
          }) || []
      }
      get shouldDisplayPreviewLinks() {
          let e = this.updateAt || this.createdAt;
          return e ? $e(new Date, e) < 30 : !0
      }
      get lastApprovedAt() {
          return e.matchModel(this.model, {
              pr: e => e.lastApprovedAt,
              attachment: e => {
                  let t = e.metadata;
                  if (`reviews`in t && Array.isArray(t.reviews) && t.reviews.length > 0) {
                      let e = t.reviews.filter(e => e.state === _l.approved).map(e => e.submittedAt).concrete().map(e => new Date(e)).filter(e => !isNaN(e.getTime()));
                      return e.length === 0 ? void 0 : e.sort( (e, t) => t.getTime() - e.getTime())[0]
                  }
              }
          })
      }
      getTimestampInfo() {
          let e, t, n, r = this.status;
          if (this.mergeStatus === lO.merging)
              return e = `Queued`,
              n = `Queued`,
              t = this.mergeQueueEnqueuedAt ?? null,
              t && isNaN(t.getTime()) && (t = null),
              {
                  statusText: e,
                  timestamp: t,
                  timestampText: n
              };
          switch (r) {
          case cO.open:
              e = `Open`,
              n = `Created`,
              t = this.openedAt ?? null;
              break;
          case cO.merged:
              e = `Merged`,
              n = `Merged`,
              t = this.mergedAt ?? this.updateAt ?? null;
              break;
          case cO.closed:
              e = `Closed`,
              n = `Closed`,
              t = this.closedAt ?? this.updateAt ?? null;
              break;
          case cO.inReview:
              e = `In review`,
              n = `Updated`,
              t = this.updateAt ?? null;
              break;
          case cO.draft:
              e = `Draft`,
              n = `Created`,
              t = this.createdAt ?? null;
              break;
          case cO.approved:
              e = `Approved`,
              n = `Approved`,
              t = this.lastApprovedAt ?? this.updateAt ?? null;
              break;
          default:
              r && y(r),
              e = `Open`,
              t = this.createdAt ?? null,
              n = `Created`;
              break
          }
          return t && isNaN(t.getTime()) && (t = null),
          {
              statusText: e,
              timestamp: t,
              timestampText: n
          }
      }
      get createdAt() {
          return e.matchModel(this.model, {
              pr: e => e.createdAt,
              attachment: e => {
                  let t = e.metadata;
                  return `createdAt`in t && t.createdAt ? new Date(t.createdAt) : e.createdAt
              }
          })
      }
      get closedAt() {
          return e.matchModel(this.model, {
              pr: e => e.closedAt,
              attachment: e => {
                  let t = e.metadata;
                  if (`closedAt`in t && t.closedAt)
                      return new Date(t.closedAt)
              }
          })
      }
      get openedAt() {
          return e.matchModel(this.model, {
              pr: e => e.openedAt,
              attachment: e => {
                  let t = e.metadata;
                  return `createdAt`in t && t.createdAt ? new Date(t.createdAt) : e.createdAt
              }
          })
      }
      get diffStats() {
          return e.matchModel(this.model, {
              pr: e => e.diffStats,
              attachment: () => void 0
          })
      }
      hydrateExternalUsers() {
          return e.matchModel(this.model, {
              pr: e => e.reviewerExternalUsers.hydrate(),
              attachment: () => void 0
          })
      }
  }
}
)), Qk, $k = t(( () => {
  V(),
  om(),
  F(),
  TA(),
  N(),
  Qk = class extends qh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular
  }
  ,
  M([sg( () => U, `history`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], Qk.prototype, `pullRequest`, void 0),
  M([R({
      default: []
  })], Qk.prototype, `entries`, void 0),
  Qk = M([mg(`PullRequestHistory`)], Qk)
}
)), fce = n(( (e, t) => {
  async function *n(e, t, n) {
      let r = new Set;
      async function i() {
          let[e,t] = await Promise.race(r);
          return r.delete(e),
          t
      }
      for (let a of t) {
          let o = (async () => await n(a, t))().then(e => [o, e]);
          r.add(o),
          r.size >= e && (yield await i())
      }
      for (; r.size; )
          yield await i()
  }
  t.exports = n
}
)), eA, tA, nA = t(( () => {
  eA = function(e) {
      return e.deleted = `File has been deleted`,
      e.too_large = `Large diffs are not shown by default`,
      e.lock_file = `Lock files are not shown by default`,
      e
  }({}),
  tA = function(e) {
      return e.added = `added`,
      e.changed = `changed`,
      e.copied = `copied`,
      e.deleted = `deleted`,
      e.modified = `modified`,
      e.renamed = `renamed`,
      e
  }({})
}
)), rA, iA, aA = t(( () => {
  rA = e(ie(), 1),
  nA(),
  iA = class e {
      static #e = this.HUNK_HEADER_REGEX = /@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@(?: (.*))?/;
      static trimDiffHunk(e, t, n) {
          let r = {
              source: 0,
              destination: 0
          }
            , i = [];
          for (let a of e.content)
              if (a.line.source && (r.source = a.line.source),
              a.line.destination && (r.destination = a.line.destination),
              !(t.line > r[t.side])) {
                  if (n.line < r[n.side])
                      break;
                  i.push(a)
              }
          if (i.length === 0)
              return;
          let a = i.find(e => e.line.source)
            , o = (0,
          rA.default)(i, e => !!e.line.source)
            , s = i.find(e => e.line.destination)
            , c = (0,
          rA.default)(i, e => !!e.line.destination);
          return {
              heading: e.heading,
              source: a && o ? {
                  start: a.line.source,
                  length: o.line.source - a.line.source + 1
              } : void 0,
              destination: s && c ? {
                  start: s.line.destination,
                  length: c.line.destination - s.line.destination + 1
              } : void 0,
              content: i
          }
      }
      static parseDiffHunk(t) {
          let n = e.parseDiffHunks(t);
          if (n.length === 1)
              return n[0]
      }
      static formatDiffHunk(e) {
          return [this.formatDiffHunkHeader(e), ...e.content.map(e => `${e.type === `insertion` ? `+` : e.type === `deletion` ? `-` : ` `}${e.content}`)].join(`
`)
      }
      static formatDiffHunkHeader(e) {
          return `@@ -${e.source?.start ?? 0},${e.source?.length ?? 0} +${e.destination?.start ?? 0},${e.destination?.length ?? 0} @@${e.heading ? ` ${e.heading}` : ``}`
      }
      static calculateAdditionsAndDeletions(e) {
          let t = 0
            , n = 0;
          if (!e)
              return {
                  additions: t,
                  deletions: n
              };
          let r = e.split(`
`);
          for (let e of r)
              e.startsWith(`+`) && !e.startsWith(`+++`) ? t += 1 : e.startsWith(`-`) && !e.startsWith(`---`) && (n += 1);
          return {
              additions: t,
              deletions: n
          }
      }
      static parseFiles(e) {
          return e.split(/\n(?=diff --git)/g).flatMap(e => {
              let t = e.match(this.HUNK_HEADER_REGEX)
                , n = t ? e.slice(0, t.index) : e
                , [r,i] = n.match(/a\/(.*) b\/(.*)/)?.slice(1) ?? [``, ``];
              if (!r && !i)
                  return [];
              let a, o, s, c = tA.modified, l = !1;
              for (let e of n.split(`
`))
                  e.startsWith(`--- /dev/null`) ? (r = ``,
                  c = tA.added) : e.startsWith(`+++ /dev/null`) ? (i = ``,
                  c = tA.deleted) : (a = e.match(/^index [a-f0-9]+\.\.[a-f0-9]+ (100644|100755|120000|160000)/)) ? (o = a[1],
                  s = a[1]) : (a = e.match(/^old mode (100644|100755|120000|160000)/)) ? o = a[1] : (a = e.match(/^new mode (100644|100755|120000|160000)/)) ? s = a[1] : (a = e.match(/^deleted file mode (100644|100755|120000|160000)/)) ? (o = a[1],
                  c = tA.deleted) : (a = e.match(/^new file mode (100644|100755|120000|160000)/)) ? (s = a[1],
                  c = tA.added) : (a = e.match(/^(rename|copy) (from|to) (.*)/)) ? (c = a[1] === `rename` ? tA.renamed : tA.copied,
                  a[2] === `from` ? r = a[3] : i = a[3]) : e.startsWith(`Binary files`) && e.endsWith(`differ`) && (l = !0);
              let u = t ? e.slice(t.index) : void 0
                , {additions: d, deletions: f} = this.calculateAdditionsAndDeletions(u)
                , p = this.modeToType(s);
              return {
                  key: r + i + p,
                  path: i || r,
                  type: p,
                  oldType: o !== s && o ? this.modeToType(o) : void 0,
                  binary: l,
                  additions: d,
                  deletions: f,
                  changeType: c,
                  oldPath: r,
                  newPath: i,
                  diff: u
              }
          }
          )
      }
      static modeToType(e) {
          switch (e) {
          case `160000`:
              return `submodule`;
          case `120000`:
              return `symlink`;
          case `100644`:
              return `file`;
          case `100755`:
              return `executable`;
          default:
              return `unknown`
          }
      }
      static parseDiffHunks(e) {
          let t = [], n = () => {
              if (r !== null) {
                  let {hunk: e, position: n} = r;
                  e.source && (e.source.length = n.source - e.source.start + 1),
                  e.destination && (e.destination.length = n.destination - e.destination.start + 1),
                  t.push(e)
              }
          }
          , r = null, i;
          for (let t of e.split(`
`)) {
              if (t.startsWith(`@@`) && (i = t.match(this.HUNK_HEADER_REGEX))) {
                  n();
                  let e = {
                      heading: i[5],
                      source: {
                          start: parseInt(i[1], 10),
                          length: parseInt(i[2] || `1`, 10)
                      },
                      destination: {
                          start: parseInt(i[3], 10),
                          length: parseInt(i[4] || `1`, 10)
                      },
                      content: []
                  };
                  r = {
                      hunk: e,
                      position: {
                          source: e.source?.start ?? parseInt(i[1], 10),
                          destination: e.destination?.start ?? parseInt(i[3], 10)
                      },
                      offset: {
                          source: 0,
                          destination: 0
                      }
                  }
              }
              if (r === null)
                  continue;
              let e = this.parseDiffHunkContentLine(t, r.position, r.offset);
              e && r.hunk.content.push(e)
          }
          return n(),
          t
      }
      static parseDiffHunkContentLine(e, t, n) {
          let r = {
              ...n
          };
          return e.startsWith(`+`) ? (n.destination += e.length,
          {
              type: `insertion`,
              line: {
                  destination: t.destination++
              },
              offset: {
                  destination: r.destination
              },
              content: e.slice(1)
          }) : e.startsWith(`-`) ? (n.source += e.length,
          {
              type: `deletion`,
              line: {
                  source: t.source++
              },
              offset: {
                  source: r.source
              },
              content: e.slice(1)
          }) : e.startsWith(` `) ? (n.source += e.length,
          n.destination += e.length,
          {
              type: `unchanged`,
              line: {
                  source: t.source++,
                  destination: t.destination++
              },
              offset: {
                  source: r.source,
                  destination: r.destination
              },
              content: e.slice(1)
          }) : null
      }
  }
}
)), oA, sA = t(( () => {
  oA = class e {
      static computeFileDiff(t) {
          return e.implementation ? e.implementation.computeFileDiff(t) : (async function*() {
              yield{
                  rows: void 0,
                  language: `Text`,
                  state: `error`
              }
          }
          )()
      }
      static register(t) {
          e.implementation = t
      }
  }
}
)), cA, pce = t(( () => {
  Xn(),
  cA = class {
      static async fetchAndParse(e, t, n) {
          try {
              let r = await fetch(`${Jn.API_SERVER_URL}/vcs/blob/${e}/.gitattributes`, {
                  headers: {
                      accept: `text/plain`,
                      user: n.id,
                      userAccount: n.userAccountId,
                      organization: n.organizationId,
                      "x-pullrequest-id": t
                  },
                  credentials: `include`
              });
              if (r.ok) {
                  let e = await r.text();
                  return this.parse(e)
              }
              return null
          } catch {
              return null
          }
      }
      static parse(e) {
          let t = []
            , n = e.split(/\r?\n/);
          for (let e of n) {
              let n = e.trim();
              if (!(!n || n.startsWith(`#`)) && n.includes(`linguist-generated=true`)) {
                  let e = n.split(/\s+/)[0];
                  e && t.push(e)
              }
          }
          return t
      }
      static matchesPatterns(e, t) {
          return !e || e.length === 0 ? !1 : e.some(e => this.matchGlobPattern(e, t))
      }
      static matchGlobPattern(e, t) {
          if (!e.includes(`/`)) {
              let n = t.split(`/`).pop() || ``;
              return this.matchGlobToRegex(e, n)
          }
          return this.matchGlobToRegex(e, t)
      }
      static matchGlobToRegex(e, t) {
          let n = e;
          return n = n.replace(/\*\*/g, `DOUBLE_STAR_PLACEHOLDER`),
          n = n.replace(/[.+^${}()|[\]\\]/g, `\\$&`),
          n = n.replace(/\*/g, `[^/]*`),
          n = n.replace(/DOUBLE_STAR_PLACEHOLDER/g, `.*`),
          n = n.replace(/\?/g, `.`),
          RegExp(`^${n}$`).test(t)
      }
  }
}
));
function mce(e) {
  let {status: t, details: n} = e, r;
  switch (t) {
  case 403:
      r = Error(`You are not allowed to access this pull request`);
      break;
  case 404:
      r = Error(`Pull request not found`);
      break;
  default:
      r = Error(`Something unforeseen has happened`)
  }
  return n && (r.cause = n),
  r
}
function hce(e, t) {
  if (t?.matchesGitAttributes(e.path) || uA(e))
      return !0;
  let n = lA(e);
  return !!(n.includes(`.generated.`) || n.includes(`.gen.`))
}
function lA(e) {
  return e.path.toLowerCase().split(`/`).pop() || ``
}
function uA(e) {
  let t = lA(e);
  return t.endsWith(`.lock`) || t.endsWith(`-lock.json`) || t.endsWith(`-lock.yaml`) || t.endsWith(`-lock.yml`) || t === `go.sum` || t === `bun.lockb`
}
function dA(e) {
  if (e.binary || e.type !== `executable` && e.type !== `file` && e.type !== `unknown`)
      return;
  if (e.changeType === `deleted`)
      return eA.deleted;
  if (uA(e))
      return eA.lock_file;
  if (!e.diff)
      return;
  if (e.diff.length > gA)
      return eA.too_large;
  let t = e.diff.split(/\r\n|\r|\n/, hA * 2 + 1).length;
  if (e.changeType === `added` && t > hA * 2 || t > hA)
      return eA.too_large
}
var fA, pA, mA, hA, gA, _A, vA, yA, bA = t(( () => {
  fA = e(fce(), 1),
  Cn(),
  zt(),
  nA(),
  aA(),
  Xn(),
  sA(),
  V(),
  om(),
  F(),
  TA(),
  Sm(),
  pce(),
  ws(),
  N(),
  mA = 20,
  hA = 1e3,
  gA = hA * 120,
  _A = {
      serialize: e => {
          if (!e)
              return null;
          let t = {};
          for (let[n,r] of e.entries())
              t[n] = r;
          return JSON.stringify(t)
      }
      ,
      deserialize: e => {
          if (!e)
              return null;
          if (e instanceof Map)
              return Vt.map(e);
          let t = JSON.parse(e)
            , n = Vt.map();
          for (let[e,r] of Object.entries(t))
              n.set(e, r);
          return n
      }
  },
  vA = {
      serialize: e => {
          if (!e)
              return null;
          let t = {};
          for (let[n,r] of e.entries()) {
              let e = {};
              for (let[t,n] of r.entries())
                  e[t] = {
                      ...n,
                      commentableLines: n.commentableLines ? {
                          original: Array.from(n.commentableLines.original),
                          modified: Array.from(n.commentableLines.modified)
                      } : void 0
                  };
              t[n] = e
          }
          return JSON.stringify(t)
      }
      ,
      deserialize: e => {
          if (!e)
              return null;
          if (e instanceof Map) {
              let t = Vt.map({}, {
                  deep: !1
              });
              for (let[n,r] of e.entries()) {
                  let e = Vt.map({}, {
                      deep: !1
                  });
                  for (let[t,n] of r.entries()) {
                      let r = Vt({
                          ...n,
                          commentableLines: n.commentableLines ? {
                              original: n.commentableLines.original instanceof Set ? n.commentableLines.original : new Set(Array.isArray(n.commentableLines.original) ? n.commentableLines.original : Array.from(n.commentableLines.original)),
                              modified: n.commentableLines.modified instanceof Set ? n.commentableLines.modified : new Set(Array.isArray(n.commentableLines.modified) ? n.commentableLines.modified : Array.from(n.commentableLines.modified))
                          } : void 0
                      }, {
                          rows: Vt.ref
                      });
                      e.set(t, r)
                  }
                  t.set(n, e)
              }
              return t
          }
          let t = JSON.parse(e)
            , n = Vt.map({}, {
              deep: !1
          });
          for (let[e,r] of Object.entries(t)) {
              let t = Vt.map({}, {
                  deep: !1
              });
              for (let[e,n] of Object.entries(r)) {
                  let r = Vt({
                      ...n,
                      commentableLines: n.commentableLines ? {
                          original: new Set(Array.isArray(n.commentableLines.original) ? n.commentableLines.original : Array.from(n.commentableLines.original)),
                          modified: new Set(Array.isArray(n.commentableLines.modified) ? n.commentableLines.modified : Array.from(n.commentableLines.modified))
                      } : void 0
                  }, {
                      rows: Vt.ref
                  });
                  t.set(e, r)
              }
              n.set(e, t)
          }
          return n
      }
  },
  yA = class extends Yh {
      static #e = pA = this;
      constructor(...e) {
          super(...e),
          this.fileContentRequests = new Map,
          this.diffComputations = new Map
      }
      static #t = this.loadStrategy = rm.local;
      static #n = this.partialLoadMode = im.regular;
      static create(e, t, n) {
          if (e.displayedDiff?.baseSha === t && e.displayedDiff?.headSha === n)
              return e.displayedDiff;
          let r = e.diffs.find(e => e.baseSha === t && e.headSha === n);
          if (r)
              return r;
          let i = pA.createEmpty();
          i.pullRequest = vm.wrap(e),
          i.baseSha = t,
          i.headSha = n;
          let a = e.displayedDiff;
          a && a.collapsedFiles.size > 0 && i.inheritCollapseState(a),
          i.save(!0);
          let o = e.diffs.filter(t => t !== i && t !== e.displayedDiff);
          for (let e of o)
              e.delete();
          return i
      }
      get needsFetch() {
          return !!(this.loadingState !== `success` || this.hydrateDiffError || this.diff === void 0 || this.sourceFiles === null && !this.fetchFilesPromise)
      }
      inheritCollapseState(e) {
          this.previousDiffForCollapseState = e
      }
      applyInheritedCollapseState() {
          let e = this.previousDiffForCollapseState;
          if (!e)
              return;
          if (!e.diff || !this.diff) {
              this.collapsedFiles = new Set(e.collapsedFiles);
              return
          }
          let t = e.files
            , n = this.files
            , r = new Map(t.map(e => [e.path, e]))
            , i = new Set;
          for (let t of n) {
              let n = r.get(t.path);
              n && e.collapsedFiles.has(n.key) && n.diff === t.diff && i.add(t.key)
          }
          this.collapsedFiles = i,
          this.previousDiffForCollapseState = void 0
      }
      toggleCollapse(e) {
          let t = new Set([...this.collapsedFiles]);
          t.has(e.key) ? t.delete(e.key) : t.add(e.key),
          this.collapsedFiles = t,
          this.save()
      }
      expandAll() {
          this.collapsedFiles = new Set,
          this.save()
      }
      collapseAll() {
          let e = this.files.map(e => e.key);
          this.collapsedFiles = new Set(e),
          this.save()
      }
      getComputedFileDiff(e, t) {
          let n = this.computedDiffs?.get(e)?.get(t);
          if (n && n.rows !== void 0)
              return n;
          let r = t === `structural` ? `basic` : `structural`
            , i = this.computedDiffs?.get(e)?.get(r)
            , a = i && i.rows !== void 0 && i.state === `done` ? i : void 0
            , o = this.files.find(t => t.key === e);
          return !o || o.originalContent === void 0 || (!n || n.state === `error`) && this.computeFileDiffForFile(o, t, o.originalContent),
          a
      }
      get files() {
          return this.diff ? iA.parseFiles(this.diff).map(e => {
              let t = dA(e)
                , n = hce(e, this)
                , r = this.sourceFiles?.get(e.key)
                , i = r !== void 0 && e.diff ? Sn(r, e.diff) : !1;
              return r === void 0 || i === !1 ? {
                  ...e,
                  autoCollapseReason: t,
                  isGenerated: n
              } : {
                  ...e,
                  autoCollapseReason: t,
                  originalContent: r,
                  modifiedContent: i,
                  isGenerated: n
              }
          }
          ) : []
      }
      async fetchDiff() {
          if (!this.needsFetch || this.hydratePromise || this.fetchFilesPromise || this.store.connectivity.isOffline || !this.baseSha || !this.headSha)
              return;
          let e = this.store.user;
          if (!e)
              return;
          let t = await this.pullRequest;
          this.hydratePromise = fetch(`${Jn.API_SERVER_URL}/vcs/${this.pullRequest.id}/changes/${this.baseSha}/${this.headSha}`, {
              headers: {
                  accept: `text/plain`,
                  user: e.id,
                  userAccount: e.userAccountId,
                  organization: e.organization.id
              },
              credentials: `include`
          });
          let n = this.fetchGitAttributes();
          try {
              let e = await this.hydratePromise
                , r = await e.text();
              if (e.ok)
                  w.debug(`[diff] Fetched changes for PR`, {
                      pr: t.fullIdentifier,
                      baseSha: this.baseSha,
                      headSha: this.headSha,
                      diff: r
                  }),
                  Mt( () => {
                      this.hydrateDiffError = void 0,
                      this.diff = r,
                      this.loadingState = `success`,
                      this.save()
                  }
                  ),
                  this.onFetchSuccess(),
                  await n,
                  this.fetchFilesPromise ||= this.fetchSourceFiles(this.files);
              else
                  throw mce({
                      status: e.status,
                      details: r
                  })
          } catch (e) {
              w.debug(`[diff] Failed to fetch changes for PR`, {
                  pr: t.fullIdentifier,
                  baseSha: this.baseSha,
                  headSha: this.headSha
              }),
              this.onFetchError(e)
          }
          delete this.hydratePromise
      }
      async fetchSourceFiles(e) {
          let t = this.store.user;
          if (!t)
              return;
          let n = t.settings.showReviewAsStructuralDiff ? `structural` : `basic`
            , r = await this.pullRequest
            , i = r?.comments.transientlyHydratedElements || []
            , a = new Set(i.filter(e => e.anchor && !e.anchor.outdated).map(e => e.anchor.path))
            , o = e.filter(e => {
              let t = a.has(e.path);
              return dA(e) ? t ?? !1 : !0
          }
          );
          w.debug(`[diff] Starting to process files`, {
              pr: r.fullIdentifier,
              filesToFetch: o
          });
          for await(let e of (0,
          fA.default)(mA, o, async e => {
              let i = await this.fetchFile(t, e);
              return w.debug(`[diff] Finished fetching file content`, {
                  pr: r.fullIdentifier,
                  file: e.path,
                  content: i
              }),
              i !== void 0 && await this.computeFileDiffForFile(e, n, i),
              {
                  file: e,
                  content: i
              }
          }
          )) {
              let {file: t, content: n} = e;
              n !== void 0 && this.storeSourceFile(t.key, n)
          }
          w.debug(`[diff] Done processing files`, {
              pr: r.fullIdentifier
          }),
          this.save(),
          delete this.fetchFilesPromise
      }
      storeComputedDiff(e, t, n) {
          let r = this.computedDiffs;
          r || (r = Vt.map({}, {
              deep: !1
          }),
          this.computedDiffs = r);
          let i = r.get(e);
          i || (i = Vt.map({}, {
              deep: !1
          }),
          r.set(e, i)),
          i.set(t, Vt(n, {
              rows: Vt.ref
          }))
      }
      storeSourceFile(e, t) {
          let n = this.sourceFiles;
          n || (n = Vt.map(),
          this.sourceFiles = n),
          n.set(e, t)
      }
      async computeFileDiffForFile(e, t, n) {
          let r = await this.pullRequest;
          if (e.binary)
              return;
          let i = `${e.key}:${t}`
            , a = this.diffComputations.get(i);
          if (a)
              return w.debug(`[diff] File diff computation already in flight, reusing`, {
                  pr: r.fullIdentifier,
                  file: e.path,
                  variant: t
              }),
              a;
          w.debug(`[diff] Starting to compute file diff`, {
              pr: r.fullIdentifier,
              file: e.path,
              originalContent: n,
              variant: t
          });
          let o = this.computedDiffs?.get(e.key)?.get(t);
          if (o && o.state === `done`)
              return w.debug(`[diff] File diff already computed, returning`, {
                  pr: r.fullIdentifier,
                  file: e.path,
                  variant: t,
                  existingComputedDiff: o
              }),
              o;
          let s = this.computeFileDiffInternal(e, t, n);
          this.diffComputations.set(i, s);
          try {
              return await s
          } finally {
              this.diffComputations.delete(i)
          }
      }
      async computeFileDiffInternal(e, t, n) {
          let r = await this.pullRequest, i;
          if (e.changeType !== `deleted`) {
              if (!e.diff)
                  return;
              let a = Sn(n, e.diff);
              if (a === !1) {
                  w.debug(`[diff] Failed to apply patch, attempting to fetch modified content directly`, {
                      pr: r.fullIdentifier,
                      file: e.path,
                      variant: t
                  });
                  let n = this.store.user
                    , a = n && this.headSha ? await this.fetchFile(n, e, {
                      sha: this.headSha,
                      filePath: e.path,
                      skipSpecialHandling: !0
                  }) : void 0;
                  if (a === void 0) {
                      w.debug(`[diff] Failed to fetch modified content, storing error state`, {
                          pr: r.fullIdentifier,
                          file: e.path,
                          variant: t
                      });
                      let n = {
                          rows: void 0,
                          language: `Text`,
                          state: `error`
                      };
                      return this.storeComputedDiff(e.key, t, n),
                      n
                  }
                  i = a,
                  w.debug(`[diff] Successfully fetched modified content as fallback`, {
                      pr: r.fullIdentifier,
                      file: e.path,
                      variant: t
                  })
              } else
                  i = a
          }
          let a = e.changeType === `added` ? void 0 : n, o;
          try {
              w.debug(`[diff] Identified original and modified content, computing diff`, {
                  pr: r.fullIdentifier,
                  file: e.path,
                  variant: t,
                  originalContent: n,
                  modifiedContent: i
              });
              for await(let n of oA.computeFileDiff({
                  filename: e.path,
                  original: a,
                  modified: e.changeType === `deleted` ? void 0 : i,
                  options: {
                      enableStructuralDiff: t === `structural`,
                      enableMoveDetection: t === `structural`
                  }
              }))
                  w.debug(`[diff] Diff update received from worker`, {
                      pr: r.fullIdentifier,
                      file: e.path,
                      variant: t,
                      diff: n
                  }),
                  o = n,
                  this.storeComputedDiff(e.key, t, n)
          } catch {
              let n = {
                  rows: void 0,
                  language: `Text`,
                  state: `error`
              };
              return this.storeComputedDiff(e.key, t, n),
              n
          }
          return o
      }
      async fetchFile(e, t, n) {
          let r = await this.pullRequest
            , i = n?.sha ?? this.baseSha
            , a = n?.filePath ?? (t.oldPath || t.path);
          if (i) {
              if (t.binary) {
                  w.debug(`[diff] File is binary, skipping`, {
                      pr: r.fullIdentifier,
                      file: t.path
                  });
                  return
              }
              if (t.type !== `file` && t.type !== `executable` && t.type !== `unknown`) {
                  w.debug(`[diff] File is not a file, skipping`, {
                      pr: r.fullIdentifier,
                      file: t.path
                  });
                  return
              }
              if (n?.skipSpecialHandling) {
                  if (t.changeType === `deleted`) {
                      w.debug(`[diff] File is deleted, skipping`, {
                          pr: r.fullIdentifier,
                          file: t.path
                      });
                      return
                  }
              } else {
                  if (t.changeType === `added`)
                      return w.debug(`[diff] File is added, skipping`, {
                          pr: r.fullIdentifier,
                          file: t.path
                      }),
                      ``;
                  if (t.changeType === `deleted` && t.diff)
                      return w.debug(`[diff] File is deleted, applying reverse patch`, {
                          pr: r.fullIdentifier,
                          file: t.path
                      }),
                      Sn(``, dte(ute(t.diff)[0])) || void 0
              }
              w.debug(`[diff] Fetching file content`, {
                  pr: r.fullIdentifier,
                  file: t.path,
                  sha: i
              });
              try {
                  let n = await fetch(`${Jn.API_SERVER_URL}/vcs/blob/${i}/${encodeURIComponent(a)}`, {
                      headers: {
                          accept: `text/plain`,
                          user: e.id,
                          userAccount: e.userAccountId,
                          organization: e.organization.id,
                          "x-pullrequest-id": this.pullRequest.id || ``
                      },
                      credentials: `include`
                  });
                  if (!n.ok) {
                      w.debug(`[diff] Failed to fetch file content`, {
                          pr: r.fullIdentifier,
                          file: t.path,
                          sha: i,
                          status: n.status
                      });
                      return
                  }
                  return await n.text()
              } catch (e) {
                  w.debug(`[diff] Error fetching file content`, {
                      pr: r.fullIdentifier,
                      file: t.path,
                      sha: i,
                      error: e
                  });
                  return
              }
          }
      }
      async precomputeOtherVariant(e) {
          let t = e === `structural` ? `basic` : `structural`
            , n = this.files.filter(e => {
              let n = this.computedDiffs?.get(e.key)?.get(t);
              return !(n && n.state === `done` || e.binary || !this.sourceFiles?.has(e.key))
          }
          );
          for await(let e of (0,
          fA.default)(mA, n, async e => {
              let n = this.sourceFiles?.get(e.key);
              n !== void 0 && await this.computeFileDiffForFile(e, t, n)
          }
          ))
              ;
          this.store.developerOptions?.preventDiffCaching || Mt( () => this.save())
      }
      async fetchFileContent(e) {
          if (this.sourceFiles?.has(e))
              return;
          let t = this.fileContentRequests.get(e);
          if (t)
              return t;
          let n = this.store.user
            , r = this.files.find(t => t.key === e);
          if (!n || !r)
              return;
          let i = (async () => {
              try {
                  let t = await this.fetchFile(n, r);
                  t !== void 0 && (this.storeSourceFile(e, t),
                  await this.computeFileDiffForFile(r, n.settings.showReviewAsStructuralDiff ? `structural` : `basic`, t))
              } finally {
                  this.fileContentRequests.delete(e),
                  this.store.developerOptions?.preventDiffCaching || Mt( () => this.save())
              }
          }
          )();
          return this.fileContentRequests.set(e, i),
          i
      }
      async fetchGitAttributes() {
          let e = this.store.user;
          if (!e || !this.headSha)
              return;
          let t = await cA.fetchAndParse(this.headSha, this.pullRequest.id || ``, {
              id: e.id,
              userAccountId: e.userAccountId,
              organizationId: e.organization.id
          });
          t && Mt( () => {
              this.gitAttributesPatterns = t,
              this.save()
          }
          )
      }
      matchesGitAttributes(e) {
          return cA.matchesPatterns(this.gitAttributesPatterns, e)
      }
      onFetchSuccess() {
          this.previousDiffForCollapseState ? this.applyInheritedCollapseState() : this.autoCollapseReviewedFiles(),
          this.save()
      }
      autoCollapseReviewedFiles() {
          let e = this.pullRequest.value;
          if (!e)
              return;
          let t = e.currentUserLatestReview;
          if (!t)
              return;
          let n = new Set;
          for (let e of this.files)
              t.isFileReviewed(e.path) && n.add(e.key);
          this.collapsedFiles = n
      }
      onFetchError(e) {
          this.hydrateDiffError = e,
          this.loadingState = `error`,
          this.save()
      }
  }
  ,
  M([sg( () => U, `diffs`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], yA.prototype, `pullRequest`, void 0),
  M([R({
      default: new Set
  })], yA.prototype, `collapsedFiles`, void 0),
  M([R({
      default: null,
      serializer: _A
  })], yA.prototype, `sourceFiles`, void 0),
  M([R({
      default: null,
      serializer: vA
  })], yA.prototype, `computedDiffs`, void 0),
  M([R({
      default: null
  })], yA.prototype, `gitAttributesPatterns`, void 0),
  M([R()], yA.prototype, `baseSha`, void 0),
  M([R()], yA.prototype, `headSha`, void 0),
  M([R()], yA.prototype, `diff`, void 0),
  M([R()], yA.prototype, `hydrateDiffError`, void 0),
  M([R({
      default: `pending`
  })], yA.prototype, `loadingState`, void 0),
  M([R({
      persistence: `none`
  })], yA.prototype, `previousDiffForCollapseState`, void 0),
  M([R({
      shallowObservation: !0
  })], yA.prototype, `virtuosoStateSnapshot`, void 0),
  M([I], yA.prototype, `inheritCollapseState`, null),
  M([I], yA.prototype, `applyInheritedCollapseState`, null),
  M([I], yA.prototype, `toggleCollapse`, null),
  M([I], yA.prototype, `expandAll`, null),
  M([I], yA.prototype, `collapseAll`, null),
  M([L], yA.prototype, `files`, null),
  M([I], yA.prototype, `storeComputedDiff`, null),
  M([I], yA.prototype, `storeSourceFile`, null),
  M([I], yA.prototype, `computeFileDiffForFile`, null),
  M([I], yA.prototype, `onFetchSuccess`, null),
  M([I], yA.prototype, `autoCollapseReviewedFiles`, null),
  M([I], yA.prototype, `onFetchError`, null),
  yA = pA = M([mg(`PullRequestDiff`)], yA)
}
)), xA, gce = t(( () => {
  zt(),
  N(),
  xA = class {
      constructor(e) {
          this._explicitlyModifiedFiles = new Set,
          At(this),
          this.pullRequest = e
      }
      initializeTracking(e) {
          if (!e || e.needsFetch)
              return;
          this.initialHeadSha = e.headSha;
          let t = e.files;
          this.initialFilePaths = new Set(t.map(e => e.path)),
          this.initialFileSnapshots = new Map(t.map(e => [e.path, {
              diff: e.diff,
              additions: e.additions,
              deletions: e.deletions
          }]))
      }
      clearTracking() {
          this.initialFilePaths = void 0,
          this.initialFileSnapshots = void 0,
          this.initialHeadSha = void 0,
          this._explicitlyModifiedFiles.clear()
      }
      markFileAsModified(e) {
          this._explicitlyModifiedFiles.add(e)
      }
      clearFileModified(e) {
          this._explicitlyModifiedFiles.delete(e)
      }
      checkForChanges(e) {
          if (!this.isInitialized) {
              this.initializeTracking(e);
              return
          }
          if (!(!e || e.needsFetch || !this.initialHeadSha) && e.headSha !== this.initialHeadSha) {
              let t = e.files;
              for (let e of t) {
                  let t = this.initialFileSnapshots?.get(e.path);
                  t ? (t.diff !== e.diff || t.additions !== e.additions || t.deletions !== e.deletions) && this._explicitlyModifiedFiles.add(e.path) : this._explicitlyModifiedFiles.add(e.path)
              }
              if (this.initialFilePaths) {
                  let e = new Set(t.map(e => e.path));
                  for (let t of this.initialFilePaths)
                      e.has(t) || this._explicitlyModifiedFiles.add(t)
              }
          }
      }
      isFileModified(e) {
          return this._explicitlyModifiedFiles.has(e.path)
      }
      get modifiedFiles() {
          return this._explicitlyModifiedFiles
      }
      get isInitialized() {
          return this.initialHeadSha !== void 0
      }
  }
  ,
  M([Vt], xA.prototype, `initialFilePaths`, void 0),
  M([Vt], xA.prototype, `initialFileSnapshots`, void 0),
  M([Vt], xA.prototype, `initialHeadSha`, void 0),
  M([Vt], xA.prototype, `_explicitlyModifiedFiles`, void 0),
  M([Vt], xA.prototype, `pullRequest`, void 0),
  M([Ft], xA.prototype, `initializeTracking`, null),
  M([Ft], xA.prototype, `clearTracking`, null),
  M([Ft], xA.prototype, `markFileAsModified`, null),
  M([Ft], xA.prototype, `clearFileModified`, null),
  M([Ft], xA.prototype, `checkForChanges`, null)
}
)), SA, CA, wA, U, TA = t(( () => {
  zt(),
  kC(),
  uO(),
  kk(),
  zn(),
  Xs(),
  Mu(),
  Sy(),
  DC(),
  oce(),
  pi(),
  Xn(),
  eu(),
  bH(),
  Lq(),
  qk(),
  AM(),
  Yk(),
  Lk(),
  Zk(),
  Nm(),
  V(),
  F(),
  om(),
  Iy(),
  GU(),
  iU(),
  Ih(),
  sR(),
  $k(),
  bA(),
  Wk(),
  gce(),
  N(),
  SA = function(e) {
      return e.todo = `todo`,
      e.waiting = `waiting`,
      e.completed = `completed`,
      e
  }({}),
  CA = function(e) {
      return e.pullRequestToReview = `pullRequestToReview`,
      e.pullRequestInReview = `pullRequestInReview`,
      e.yourPullRequests = `yourPullRequests`,
      e.completedPullRequests = `completedPullRequests`,
      e
  }({}),
  wA = {
      open: 1,
      inReview: 2,
      approved: 3,
      merged: 4,
      closed: 5,
      draft: 6
  },
  U = class extends qh {
      constructor(...e) {
          super(...e),
          this.toggleFavorite = () => {
              if (this.favorite)
                  return this.favorite.delete(),
                  !1;
              let e = yH.create({
                  reference: this
              });
              return e.save(!0),
              e
          }
          ,
          this.mergeQueueCurrentTime = Date.now()
      }
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular;
      static #n = this.partialPreloadForTeam = am.secondPriority;
      get pullRequestAdapter() {
          return new Xk(this)
      }
      get prNumber() {
          return this.pullRequestAdapter.prNumber
      }
      get fullIdentifier() {
          return this.pullRequestAdapter.fullIdentifier
      }
      get identifier() {
          return this.store.user.settings.gitAttachmentDisplayPreference === Jk.Option.titleRepo ? this.fullIdentifier : this.prNumber
      }
      get descriptionMarkdown() {
          return this.descriptionData ? Hp.serialize(this.descriptionData) : ``
      }
      get slug() {
          return `${ju(this.title)}-${this.slugId}`
      }
      get isSyncedWithGitHub() {
          return this.sourceMetadata?.subType === T.github
      }
      get isSyncedWithGitLab() {
          return this.sourceMetadata?.subType === T.gitlab
      }
      get isDraft() {
          return this.status === cO.draft
      }
      get isMerged() {
          return this.status === cO.merged
      }
      get attentionSet() {
          return Ok.calculateAttentionSet(this.userState)
      }
      get currentUserPendingReview() {
          if (!this.isSubmittingPendingReview)
              return this.pendingReviews.find(e => e.reviewer.id === this.store.user.id && !e.isSubmitted)
      }
      get currentUserLatestReview() {
          let e = [...this.pendingReviews].filter(e => e.reviewer.id === this.store.user.id);
          return e.length === 0 ? void 0 : e.find(e => !e.submittedAt) || e.sort( (e, t) => (t.submittedAt?.getTime() ?? 0) - (e.submittedAt?.getTime() ?? 0))[0]
      }
      get currentUserLastSubmittedReview() {
          return [...this.pendingReviews].filter(e => e.reviewer.id === this.store.user.id && e.submittedAt).sort( (e, t) => (t.submittedAt?.getTime() ?? 0) - (e.submittedAt?.getTime() ?? 0))[0]
      }
      get changesUrl() {
          if (this.isSyncedWithGitHub)
              return `${this.url}/files`
      }
      get isOpen() {
          switch (this.status) {
          case cO.draft:
          case cO.open:
          case cO.inReview:
          case cO.approved:
              return !0;
          case cO.merged:
          case cO.closed:
              return !1;
          default:
              return y(this.status),
              !0
          }
      }
      get isClosed() {
          switch (this.status) {
          case cO.draft:
          case cO.open:
          case cO.inReview:
          case cO.approved:
              return !1;
          case cO.merged:
          case cO.closed:
              return !0;
          default:
              return y(this.status),
              !1
          }
      }
      get openedByCurrentUser() {
          return this.creator?.id === this.store.user.id
      }
      responsibilityForUser(e) {
          if (!this.isOpen)
              return SA.completed;
          let t = this.creator?.id === e;
          if (this.isDraft)
              return t ? SA.todo : SA.waiting;
          if (this.mergeStatus === lO.merging)
              return SA.completed;
          if (t) {
              if (this.reviewers.length === 0 || (this.status === cO.approved || this.autoMergeEnabled) && (this.hasConflicts || this.hasFailedRequiredChecks))
                  return SA.todo;
              if (this.mergeStatus === lO.ready && !this.hasPendingChecks)
                  return this.autoMergeEnabled ? SA.completed : SA.todo
          }
          if (this.lastReviewByCurrentUser) {
              if (this.lastReviewByCurrentUser.decision === EC.approved)
                  return SA.completed;
              if (this.lastReviewByCurrentUser.decision === EC.changesRequested)
                  return SA.waiting
          }
          return this.attentionSet.has(e) || t && (this.reviewers.length === 0 || !this.reviewers.some(t => {
              let n = t.userId;
              return !n || n === e ? !1 : this.responsibilityForUser(n) === SA.todo
          }
          )) ? SA.todo : SA.waiting
      }
      newResponsibilityForUser(e) {
          let t = this.creator?.id === e;
          if (!this.isOpen || this.mergeStatus === lO.merging)
              return CA.completedPullRequests;
          if (t)
              return this.mergeStatus === lO.ready && !this.hasPendingChecks && this.autoMergeEnabled ? CA.completedPullRequests : CA.yourPullRequests;
          {
              let t = this.reviewers.findLast(t => t.userId === e);
              return t ? t.decision === EC.approved ? CA.completedPullRequests : t.decision === EC.pending ? this.isDraft ? CA.pullRequestInReview : CA.pullRequestToReview : CA.pullRequestInReview : CA.pullRequestInReview
          }
      }
      get hasFailedRequiredChecks() {
          return this.checks.some(e => e.status === OC.failed && e.isRequired)
      }
      get hasPendingChecks() {
          return this.checks.some(e => e.status === OC.pending)
      }
      get hasPendingRequiredChecks() {
          return this.checks.some(e => e.status === OC.pending && e.isRequired)
      }
      needsAttentionOfUserLegacy(e) {
          return this.responsibilityForUser(e) === SA.todo && !this.isDraft
      }
      userHasConnectedIntegration(e) {
          return Ik.integrationForPullRequest(this)?.userHasMatchingPersonalIntegration(e) ?? !1
      }
      allowComment(e) {
          return this.userHasConnectedIntegration(e)
      }
      allowReaction(e) {
          return this.userHasConnectedIntegration(e)
      }
      get externalReviewUrl() {
          return this.pullRequestAdapter.externalReviewUrl
      }
      get externalReviewToolLabel() {
          return this.pullRequestAdapter.externalReviewToolLabel
      }
      get searchableContent() {
          let e = this.descriptionData ? Hp.serialize(this.descriptionData) : ``;
          return this.title + `

` + e
      }
      matchInlineFind(e) {
          let t = $l([this.searchableContent, this.fullIdentifier, this.creator?.name, this.creator?.displayName, this.externalCreator?.value?.name, this.externalCreator?.value?.displayName].concat(this.reviewers.map(e => {
              let t = e.userId ? this.organization.allUsers.findById(e.userId) : e.externalUserId ? this.organization.externalUsers.findById(e.externalUserId) : void 0;
              return [t?.name, t?.displayName].concrete().join(` `)
          }
          )).concrete().join(` `)).toLowerCase();
          return e.split(` `).reduce( (e, n) => e && t.indexOf(n) !== -1, !0)
      }
      markNotificationAsRead(e) {
          let t = this.notifications.find(t => t.id === e);
          if (!t)
              return;
          let n = t?.groupingEntityId;
          this.notifications.forEach(e => {
              e.readAt === void 0 && e.groupingEntityId === n && (e.markAsRead(),
              e.save())
          }
          )
      }
      markReviewNotificationsAsRead() {
          let e = e => !0;
          this.notifications.forEach(t => {
              e(t) && (t.markAsRead(),
              t.save())
          }
          )
      }
      get workspaceHasConnectedGitHubIntegration() {
          return this.isSyncedWithGitHub ? this.store.organization.integrations.some(e => (e.service === T.github || e.service === T.githubEnterpriseServer) && e.settings.gitHub?.orgLogin === this.repository.owner && !e.isArchived) : !1
      }
      get workspaceHasConnectedGitLabIntegration() {
          return this.isSyncedWithGitLab ? this.store.organization.integrations.some(e => e.service === T.gitlab && !e.isArchived) : !1
      }
      get isQuickToReview() {
          if (!this.diffStats || !this.isOpen)
              return !1;
          let e = this.lastReviewByCurrentUser;
          return e && e.decision !== EC.pending ? !1 : this.diffStats.additions + this.diffStats.deletions + this.diffStats.changes <= 10 ? !0 : this.diffStats.additions <= 3 && this.diffStats.changes <= 3 && this.diffStats.deletions <= 100
      }
      get latestDiff() {
          if (this.baseSha && this.headSha)
              return this.store.isBootstrapped ? this.matchingDiff ?? yA.create(this, this.baseSha, this.headSha) : this.matchingDiff
      }
      get matchingDiff() {
          return this.diffs.find(e => e.baseSha === this.baseSha && e.headSha === this.headSha)
      }
      get shouldPrefetchDiff() {
          if (!ui.isEnabled(ui.codeReviews) || this.isClosed || this.matchingDiff?.loadingState === `success`)
              return !1;
          let e = this.newResponsibilityForUser(this.store.user.id);
          return e === CA.pullRequestToReview || e === CA.pullRequestInReview || e === CA.yourPullRequests
      }
      hydrateExtra() {
          return ui.isEnabled(ui.codeReviews) ? {
              hydrate: async () => {
                  if (!this.baseSha || !this.headSha)
                      return;
                  await this.diffs.hydrate();
                  let e = this.latestDiff;
                  e?.needsFetch && await e.fetchDiff()
              }
              ,
              isHydrated: () => this.latestDiff ? this.latestDiff.loadingState !== `pending` : !0
          } : {
              hydrate: async () => {}
              ,
              isHydrated: () => !0
          }
      }
      get mergeQueueTrueEta() {
          if (!this.mergeQueueEstimatedTimeToMerge || !this.mergeQueueEnqueuedAt)
              return;
          let e = Math.floor((this.mergeQueueCurrentTime - this.mergeQueueEnqueuedAt.getTime()) / 1e3)
            , t = this.mergeQueueEstimatedTimeToMerge - e;
          return t > 0 && t <= this.mergeQueueEstimatedTimeToMerge ? t : void 0
      }
      get fileChangeTracker() {
          return this._fileChangeTracker ||= new xA(this),
          this._fileChangeTracker
      }
      markAsDisplayed() {
          ui.isEnabled(ui.codeReviews) && (this.isDisplayed || (this.isDisplayed = !0,
          this._fileChangeTracker?.clearTracking(),
          this.diffs.hydrate(),
          this.ensureDisplayedDiffAutorun()))
      }
      markAsHidden() {
          this.isDisplayed && (this.isDisplayed = !1,
          this.displayedDiffDisposer?.(),
          this.displayedDiffDisposer = void 0,
          this.displayedDiffFetchToken = void 0,
          this.displayedDiff = void 0,
          this.isLoadingDisplayedDiff = !1,
          this._fileChangeTracker?.clearTracking())
      }
      startMergeQueueStatusMonitoring() {
          this.mergeStatus === lO.merging && (this.mergeQueueStatusInterval || (this.fetchMergeQueueStatus(),
          this.mergeQueueStatusInterval = setInterval( () => {
              this.fetchMergeQueueStatus()
          }
          , 6e4),
          this.mergeQueueTimeUpdateInterval = setInterval( () => {
              this.mergeQueueCurrentTime = Date.now()
          }
          , 1e4)))
      }
      stopMergeQueueStatusMonitoring() {
          this.mergeQueueStatusInterval &&= (clearInterval(this.mergeQueueStatusInterval),
          void 0),
          this.mergeQueueTimeUpdateInterval &&= (clearInterval(this.mergeQueueTimeUpdateInterval),
          void 0),
          this.mergeQueueEnqueuedAt = void 0,
          this.mergeQueueEstimatedTimeToMerge = void 0,
          this.mergeQueuePosition = void 0
      }
      requestReview(e) {
          this.reviewers = [...this.reviewers, e instanceof J ? {
              userId: e.id,
              decision: EC.pending
          } : {
              externalUserId: e.id,
              decision: EC.pending
          }]
      }
      removeReviewer(e) {
          this.reviewers = this.reviewers.filter(t => e instanceof J ? t.userId !== e.id : t.externalUserId !== e.id)
      }
      get lastReviewByCurrentUser() {
          return this.lastReviewByUser(this.store.user)
      }
      lastReviewByUser(e) {
          return this.reviewers.findLast(t => e instanceof J ? t.userId === e.id : t.externalUserId === e.id)
      }
      previousReviewByUser(e) {
          let t = this.reviewers.filter(t => e instanceof J ? t.userId === e.id : t.externalUserId === e.id);
          if (!(t.length < 2))
              return t[t.length - 2]
      }
      get approvedByCurrentUser() {
          return this.lastReviewByCurrentUser?.decision === EC.approved
      }
      get changesRequestedByCurrentUser() {
          return this.lastReviewByCurrentUser?.decision === EC.changesRequested
      }
      get hasNoReviewersAssigned() {
          return this.reviewers.length === 0
      }
      hasAnyReviewSubmitted() {
          return this.reviewers.some(e => e.lastReviewedAt)
      }
      isUserAskedToReview(e) {
          return this.lastReviewByUser(e)?.decision === EC.pending
      }
      get isCurrentUserAskedToReview() {
          return this.isUserAskedToReview(this.store.user)
      }
      get uniqueReviewerUserIds() {
          return new Set(this.reviewers.filter(e => e.userId).map(e => e.userId))
      }
      get uniqueReviewerExternalUserIds() {
          return new Set(this.reviewers.filter(e => e.externalUserId).map(e => e.externalUserId))
      }
      getUserFromReviewer(e) {
          if (e.userId)
              return this.reviewerUsers.findById(e.userId) || this.store.findById(J, e.userId);
          if (e.externalUserId)
              return this.reviewerExternalUsers.findById(e.externalUserId) || this.store.findById(Fy, e.externalUserId)
      }
      get latestReviewsByAllUsers() {
          return Ak.latestReviewsByAllUsers(this.reviewers)
      }
      optimisticallyUpdateCurrentUserReview(e, t={
          isWithoutComment: !1
      }) {
          let n = this.reviewers.map(e => ({
              ...e
          }))
            , r = this.store.user.id
            , i = new Date
            , a = this.lastReviewByUser(this.store.user);
          a && a.decision === EC.pending ? this.reviewers = this.reviewers.map(t => t === a ? {
              ...t,
              decision: e,
              lastReviewedAt: i
          } : t) : this.reviewers = [...this.reviewers, {
              decision: e,
              userId: r,
              lastReviewedAt: i
          }];
          let o;
          if (t.isWithoutComment && e === EC.approved) {
              o = {
                  type: `review`,
                  decision: EC.approved,
                  at: Date.now(),
                  actorId: r,
                  externalActorId: void 0,
                  source: void 0
              };
              let e = this.history.transientlyHydratedElements;
              e.length > 0 && (e[0].entries = [...e[0].entries, o])
          }
          return Ft( () => {
              if (this.reviewers = n,
              o) {
                  let e = this.history.transientlyHydratedElements;
                  e.length > 0 && (e[0].entries = e[0].entries.filter(e => e !== o))
              }
          }
          )
      }
      get lastApprovedAt() {
          let e = this.reviewers.filter(e => e.decision === EC.approved).map(e => e.lastReviewedAt).concrete();
          if (e.length !== 0)
              return e.sort( (e, t) => t.getTime() - e.getTime())[0]
      }
      async fetchMergeQueueStatus() {
          if (this.mergeStatus !== lO.merging) {
              this.stopMergeQueueStatusMonitoring();
              return
          }
          let e = await fetch(`${Jn.API_SERVER_URL}/vcs/${this.id}/merge-queue-status`, {
              method: `GET`,
              headers: {
                  "Content-Type": `application/json`,
                  user: this.store.user.id,
                  userAccount: this.store.user.userAccountId,
                  organization: this.organization.id
              },
              credentials: `include`
          });
          if (!e.ok) {
              e.status === 404 && this.stopMergeQueueStatusMonitoring();
              return
          }
          let t = await e.json();
          this.mergeStatus === lO.merging && t.ok && t.mergeQueueStatus && (this.mergeQueueEnqueuedAt = t.mergeQueueStatus.enqueuedAt ? new Date(t.mergeQueueStatus.enqueuedAt) : void 0,
          this.mergeQueueEstimatedTimeToMerge = t.mergeQueueStatus.estimatedTimeToMerge,
          this.mergeQueuePosition = t.mergeQueueStatus.position)
      }
      ensureDisplayedDiffAutorun() {
          this.displayedDiffDisposer ||= Rt( () => {
              if (!this.isDisplayed)
                  return;
              let e = this.latestDiff;
              if (!e) {
                  this.updateDisplayedDiff(void 0);
                  return
              }
              e.loadingState,
              e.needsFetch,
              e.baseSha,
              e.headSha,
              e.hydrateDiffError,
              e.diff,
              this.lastSyncedAt,
              this.updateDisplayedDiff(e)
          }
          )
      }
      async updateDisplayedDiff(e) {
          if (!this.isDisplayed)
              return;
          if (!ui.isEnabled(ui.codeReviews)) {
              Mt( () => {
                  this.displayedDiff = void 0,
                  this.isLoadingDisplayedDiff = !1
              }
              );
              return
          }
          if (!e) {
              Mt( () => {
                  this.displayedDiff = void 0,
                  this.isLoadingDisplayedDiff = !1
              }
              );
              return
          }
          let t = e.id ?? `${e.baseSha ?? ``}:${e.headSha ?? ``}`;
          if (this.displayedDiffFetchToken = t,
          e.needsFetch)
              Mt( () => {
                  this.isLoadingDisplayedDiff = !0
              }
              ),
              await e.fetchDiff();
          else if (e.loadingState !== `success`) {
              Mt( () => {
                  this.isLoadingDisplayedDiff = e.loadingState === `pending`
              }
              );
              return
          }
          if (!(!this.isDisplayed || this.displayedDiffFetchToken !== t)) {
              if (e.loadingState === `success`) {
                  Mt( () => {
                      this.displayedDiff = e,
                      this.isLoadingDisplayedDiff = !1
                  }
                  ),
                  this.fileChangeTracker.checkForChanges(e);
                  return
              }
              Mt( () => {
                  this.isLoadingDisplayedDiff = e.loadingState === `pending`
              }
              )
          }
      }
  }
  ,
  M([B( () => q, `allPullRequests`, {
      indexed: !0,
      nullable: !1,
      optional: !1,
      persistence: `createOnly`
  })], U.prototype, `organization`, void 0),
  M([R({
      indexed: !0,
      default: ``,
      persistence: `createOnly`
  })], U.prototype, `slugId`, void 0),
  M([R({
      default: ``
  })], U.prototype, `title`, void 0),
  M([R()], U.prototype, `descriptionData`, void 0),
  M([R({
      default: {},
      persistence: `createOnly`
  })], U.prototype, `repository`, void 0),
  M([R({
      default: 1,
      persistence: `createOnly`
  })], U.prototype, `number`, void 0),
  M([R({
      default: ``,
      persistence: `createOnly`
  })], U.prototype, `sourceBranch`, void 0),
  M([R({
      default: ``,
      persistence: `createOnly`
  })], U.prototype, `targetBranch`, void 0),
  M([R({
      persistence: `none`
  })], U.prototype, `diffStats`, void 0),
  M([R({
      persistence: `none`
  })], U.prototype, `headSha`, void 0),
  M([R({
      persistence: `none`
  })], U.prototype, `baseSha`, void 0),
  M([R({
      default: ``,
      persistence: `none`
  })], U.prototype, `url`, void 0),
  M([R({
      default: cO.open,
      persistence: `none`
  })], U.prototype, `status`, void 0),
  M([R({
      default: lO.ready,
      persistence: `none`
  })], U.prototype, `mergeStatus`, void 0),
  M([R({
      serializer: Ah,
      default: () => new Date,
      persistence: `none`
  })], U.prototype, `openedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], U.prototype, `closedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], U.prototype, `mergedAt`, void 0),
  M([R({
      persistence: `none`
  })], U.prototype, `mergeCommit`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], U.prototype, `lastSyncedAt`, void 0),
  M([R({
      serializer: kh({
          lastReviewedAt: {
              serializer: Ah,
              nullable: !0
          }
      }),
      default: []
  })], U.prototype, `reviewers`, void 0),
  M([R({
      default: [],
      persistence: `none`
  })], U.prototype, `suggestedReviewerExternalIds`, void 0),
  M([R({
      default: [],
      persistence: `none`
  })], U.prototype, `previewLinks`, void 0),
  M([R({
      serializer: kh({
          startedAt: {
              serializer: Ah,
              nullable: !0
          },
          completedAt: {
              serializer: Ah,
              nullable: !0
          }
      }),
      default: [],
      persistence: `none`
  })], U.prototype, `checks`, void 0),
  M([R({
      default: [],
      persistence: `none`
  })], U.prototype, `commits`, void 0),
  M([R({
      default: !1,
      persistence: `none`
  })], U.prototype, `hasConflicts`, void 0),
  M([R({
      default: !1,
      persistence: `none`
  })], U.prototype, `autoMergeEnabled`, void 0),
  M([R({
      persistence: `none`
  })], U.prototype, `mergeSettings`, void 0),
  M([R({
      default: [],
      persistence: `updateOnly`,
      serializer: Mh
  })], U.prototype, `issueLinks`, void 0),
  M([pg( () => Y, `linkedPullRequests`, {
      indexed: !0,
      order: new P(`identifier`,`asc`),
      persistence: `none`
  })], U.prototype, `linkedIssues`, void 0),
  M([sg( () => U, `stackedPullRequests`, {
      nullable: !0,
      indexed: !0,
      onDelete: `SET NULL`,
      persistence: `none`
  })], U.prototype, `stackedOnPullRequest`, void 0),
  M([z( () => U, {
      index: `stackedOnPullRequestId`
  })], U.prototype, `stackedPullRequests`, void 0),
  M([sg( () => U, `revertingPullRequests`, {
      nullable: !0,
      indexed: !0,
      onDelete: `SET NULL`,
      persistence: `none`
  })], U.prototype, `revertedPullRequest`, void 0),
  M([z( () => U, {
      index: `revertedPullRequestId`
  })], U.prototype, `revertingPullRequests`, void 0),
  M([z( () => Kk, {
      index: `pullRequestId`,
      order: new P(`createdAt`,`asc`)
  })], U.prototype, `comments`, void 0),
  M([z( () => Uk, {
      index: `pullRequestId`,
      order: new P(`createdAt`,`asc`)
  })], U.prototype, `pendingReviews`, void 0),
  M([z( () => kM, {
      index: `pullRequestId`
  })], U.prototype, `draftComments`, void 0),
  M([z( () => Qk, {
      index: `pullRequestId`,
      order: new P(`createdAt`,`asc`)
  })], U.prototype, `history`, void 0),
  M([z( () => yA, {
      index: `pullRequestId`
  })], U.prototype, `diffs`, void 0),
  M([og( () => iR)], U.prototype, `notifications`, void 0),
  M([ug({
      nullable: !0
  })], U.prototype, `favorite`, void 0),
  M([B( () => J, `createdPullRequests`, {
      nullable: !0,
      indexed: !0,
      persistence: `none`
  })], U.prototype, `creator`, void 0),
  M([lg( () => Fy, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      onDelete: `SET NULL`,
      persistence: `none`
  })], U.prototype, `externalCreator`, void 0),
  M([fg( () => J, `reviewerOfPullRequests`, {
      indexed: !0,
      persistence: `none`
  })], U.prototype, `reviewerUsers`, void 0),
  M([pg( () => Fy, void 0, {
      indexed: !0,
      persistence: `none`
  })], U.prototype, `reviewerExternalUsers`, void 0),
  M([cg( () => J, {
      nullable: !0,
      indexed: !0,
      persistence: `none`
  })], U.prototype, `mergedByUser`, void 0),
  M([lg( () => Fy, {
      nullable: !0,
      indexed: !0,
      persistence: `none`
  })], U.prototype, `mergedByExternalUser`, void 0),
  M([R({
      persistence: `none`,
      serializer: Mh,
      default: []
  })], U.prototype, `reactionData`, void 0),
  M([R({
      serializer: kh({
          attentionLastNeededAt: {
              serializer: Ah,
              nullable: !0
          },
          lastActivityAt: {
              serializer: Ah,
              nullable: !0
          },
          lastDismissedAt: {
              serializer: Ah,
              nullable: !0
          }
      }),
      default: [],
      persistence: `none`
  })], U.prototype, `userState`, void 0),
  M([R({
      persistence: `none`
  })], U.prototype, `sourceMetadata`, void 0),
  M([L], U.prototype, `descriptionMarkdown`, null),
  M([L], U.prototype, `attentionSet`, null),
  M([L], U.prototype, `currentUserPendingReview`, null),
  M([L], U.prototype, `currentUserLatestReview`, null),
  M([L], U.prototype, `currentUserLastSubmittedReview`, null),
  M([L], U.prototype, `openedByCurrentUser`, null),
  M([L], U.prototype, `searchableContent`, null),
  M([I], U.prototype, `markNotificationAsRead`, null),
  M([I], U.prototype, `markReviewNotificationsAsRead`, null),
  M([L], U.prototype, `latestDiff`, null),
  M([L], U.prototype, `matchingDiff`, null),
  M([L], U.prototype, `shouldPrefetchDiff`, null),
  M([ag()], U.prototype, `isChangingMergeStatus`, void 0),
  M([ag()], U.prototype, `isSubmittingPendingReview`, void 0),
  M([ag()], U.prototype, `isDisplayed`, void 0),
  M([ag()], U.prototype, `displayedDiff`, void 0),
  M([ag()], U.prototype, `isLoadingDisplayedDiff`, void 0),
  M([ag()], U.prototype, `mergeQueueEnqueuedAt`, void 0),
  M([ag()], U.prototype, `mergeQueueEstimatedTimeToMerge`, void 0),
  M([ag()], U.prototype, `mergeQueuePosition`, void 0),
  M([ag()], U.prototype, `mergeQueueCurrentTime`, void 0),
  M([L], U.prototype, `mergeQueueTrueEta`, null),
  M([I], U.prototype, `markAsDisplayed`, null),
  M([I], U.prototype, `markAsHidden`, null),
  M([I], U.prototype, `startMergeQueueStatusMonitoring`, null),
  M([I], U.prototype, `stopMergeQueueStatusMonitoring`, null),
  M([I], U.prototype, `requestReview`, null),
  M([I], U.prototype, `removeReviewer`, null),
  M([L], U.prototype, `lastReviewByCurrentUser`, null),
  M([L], U.prototype, `approvedByCurrentUser`, null),
  M([L], U.prototype, `changesRequestedByCurrentUser`, null),
  M([L], U.prototype, `uniqueReviewerUserIds`, null),
  M([L], U.prototype, `uniqueReviewerExternalUserIds`, null),
  M([L], U.prototype, `latestReviewsByAllUsers`, null),
  M([I], U.prototype, `optimisticallyUpdateCurrentUserReview`, null),
  M([I], U.prototype, `fetchMergeQueueStatus`, null),
  U = M([mg(`PullRequest`)], U)
}
)), EA, DA, OA = t(( () => {
  EA = e(Gt(), 1),
  $v(),
  vd(),
  Vm(),
  Nm(),
  zm(),
  mH(),
  (function(e) {
      function t(e) {
          let t = n(e);
          return `Restricted to ${t} ${(0,
          EA.default)(`level`, t)} of nesting`
      }
      e.getMaxNestingErrorMessage = t;
      function n(e) {
          return e.canAccess(gd.subTeams) ? Qv.maxNestingDepth : 0
      }
      e.maxNestingDepth = n;
      function r(e) {
          return i(e, new P(`sortOrder`))
      }
      e.sortByUserSortOrder = r;
      function i(e, t=new P(`name`)) {
          let n = new Set(e.map(e => e.id))
            , r = new Set;
          for (let t of e)
              for (let e of t.ancestors)
                  n.has(e.id) || (r.add(e),
                  n.add(e.id));
          let i = (e, r) => {
              if (e.length === 0)
                  return e;
              let a = e.orderBy(t).flatMap(e => r !== e.parent || !n.has(e.id) ? [] : [e, ...i(e.children, e)]);
              return Bm.of(K, a)
          }
            , a = e instanceof Rm ? e.elements : e
            , o = i(Bm.of(K, a.concat(Array.from(r)))).filter(e => !r.has(e));
          return e instanceof Rm ? o : o.elements
      }
      e.sortTeams = i;
      function a(e, t=3) {
          return e.length === 1 ? e[0].name : e.length <= t ? e.map(e => e.key).join(`, `) : e.slice(0, t).map(e => e.key).join(`, `) + `+ ${e.length - t}`
      }
      e.labelForTeams = a;
      function o(e) {
          return e.flatMap(e => e.withAccessibleDescendants).distinct()
      }
      e.withDescendants = o;
      function s(e) {
          let t = null
            , n = new Set;
          for (let r of e) {
              let e = !1;
              for (let i of r.withAncestors.reverse())
                  if (n.has(i) || n.size === 0) {
                      e = !0,
                      (!t || c(i, t)) && (t = i);
                      break
                  }
              if (!e)
                  return null;
              r.withAncestors.forEach(e => n.add(e))
          }
          return t
      }
      e.findClosestCommonParent = s;
      function c(e, t) {
          let n = t.parent;
          for (; n; ) {
              if (n === e)
                  return !0;
              n = n.parent
          }
          return !1
      }
  }
  )(DA ||= {})
}
)), kA, AA, jA, MA, NA, PA, FA = t(( () => {
  kA = e(ue(), 1),
  AA = e(ne(), 1),
  zn(),
  cE(),
  tce(),
  UT(),
  AE(),
  Bu(),
  Kd(),
  ed(),
  eD(),
  pi(),
  fD(),
  Pz(),
  kH(),
  iU(),
  iz(),
  mH(),
  GU(),
  V(),
  F(),
  Nm(),
  nD(),
  KO(),
  Sm(),
  Ih(),
  QO(),
  om(),
  tk(),
  VO(),
  Dk(),
  DM(),
  WO(),
  TA(),
  OA(),
  N(),
  MA = Object.freeze({
      measure: eE.id,
      measureIssueStates: void 0,
      dimension: ZT.stateName,
      subDimension: void 0,
      dimensionDateAggregation: YT.month,
      segment: void 0,
      subSegment: void 0,
      includeArchived: !1,
      hideEmptyDimension: !1,
      hideEmptySegment: !1,
      colorScale: aE.default,
      display: `graph`,
      aggregation: XT.median,
      aggregations: [XT.median, XT.p95],
      latencyYScale: `log`,
      distributionOrder: void 0,
      distributionDirection: void 0,
      latencyOrder: void 0,
      latencyDirection: void 0
  }),
  NA = class extends Yh {
      static #e = jA = this;
      static #t = this.loadStrategy = rm.lazy;
      setPreference(e, t) {
          let n = {
              ...this.preferences
          };
          this.preferences[e] = t,
          this.markPropertyChanged(`preferences`, n)
      }
      setPreferencesInBulk(e) {
          let t = {
              ...this.preferences
          };
          Qu(e).forEach(t => {
              this.preferences[t] = e[t]
          }
          ),
          this.markPropertyChanged(`preferences`, t)
      }
      setAndSavePreference(e, t) {
          this.setPreference(e, t),
          this.viewType !== k.quickView && (this.parentModel && this.parentModel.persisted === !1 || (0,
          kA.default)(this.preferences) && !this.persisted || this.save(!0))
      }
      get currentInsight() {
          return {
              measure: this.getInsightPreference(`measure`),
              dimension: this.getInsightPreference(`dimension`),
              subDimension: this.getInsightPreference(`subDimension`),
              dimensionDateAggregation: this.getInsightPreference(`dimensionDateAggregation`),
              segment: this.getInsightPreference(`segment`),
              subSegment: this.getInsightPreference(`subSegment`),
              includeArchived: this.getInsightPreference(`includeArchived`),
              hideEmptyDimension: this.getInsightPreference(`hideEmptyDimension`),
              hideEmptySegment: this.getInsightPreference(`hideEmptySegment`),
              colorScale: this.getInsightPreference(`colorScale`),
              display: void 0,
              aggregation: void 0,
              aggregations: this.getInsightPreference(`aggregations`),
              latencyYScale: this.getInsightPreference(`latencyYScale`),
              distributionOrder: this.getInsightPreference(`distributionOrder`),
              distributionDirection: this.getInsightPreference(`distributionDirection`),
              latencyOrder: this.getInsightPreference(`latencyOrder`),
              latencyDirection: this.getInsightPreference(`latencyDirection`),
              measureIssueStates: this.getInsightPreference(`measureIssueStates`)
          }
      }
      constructor(e=!0) {
          super(e),
          this.getInsightPreference = e => this.insights == null ? this.isUserType && this.organizationViewPreferences?.insights != null ? this.organizationViewPreferences?.insights[e] ?? MA[e] : MA[e] : this.insights[e] ?? MA[e],
          this.getPreference = e => this.commonViewPreferences[e],
          this.disregardSettings = () => {
              this.isUserType && this.organizationViewPreferences && this.hasUserChanges && this.clearPreferencesOrDelete()
          }
          ,
          this.disregardInsightsSettings = () => {
              this.isUserType && this.insights != null && this.clearInsightsOrDelete()
          }
          ,
          e && (this.organization = this.store.organization)
      }
      static create() {
          return jA.createEmpty()
      }
      setInsights(e) {
          (this.isUserType || this.viewType === k.quickView) && (this.insights = e)
      }
      updateInsights(e) {
          (this.isUserType || this.viewType === k.quickView) && this.setInsights({
              ...this.currentInsight,
              ...e
          })
      }
      setAndSaveInsightPreference(e, t) {
          if ((this.isUserType || this.viewType === k.quickView) && (this.insights == null || this.insights[e] !== t)) {
              if (this.updateInsights({
                  [e]: t
              }),
              this.viewType === k.quickView)
                  return;
              this.save(!0)
          }
      }
      getIssuePreFilter(e) {
          let {ignoreCompletedIssuesPreference: t=!1} = e ?? {}
            , n = this.getPreference(`showSubIssues`)
            , r = this.getPreference(`showSubTeamIssues`)
            , i = this.getPreference(`showCompletedIssues`)
            , a = this.getPreference(`showSnoozedItems`)
            , o = this.team ?? (this.customView && qO(this.customView) ? this.customView.value?.team : void 0)
            , s = this.customView?.value?.stateFilter !== void 0 || this.viewType === k.triage || this.viewType === k.search || this.viewType === k.splitSearch || (this.getPreference(`showTriageIssues`) ?? !1)
            , c = new tD(e => !e.state.isTriage)
            , l = new tD(e => !e.isClone && e.persisted)
            , u = new tD(e => e.activities.length > 0);
          return [i && !t ? cD(i) : void 0, r || !o?.hasSubTeams ? void 0 : new tD(e => e.team === o), this.viewType === k.myIssuesActivity ? u : void 0, n ? void 0 : iD, this.viewType === k.triage && !a ? rD : void 0, s ? void 0 : c, l].concrete()
      }
      issueOrder(e, t) {
          let n = this.viewType === k.triage
            , r = (n ? this.getPreference(`triageViewOrdering`) : this.getPreference(`viewOrdering`)) ?? `dateCreated`
            , i = this.getPreference(`viewOrderingDirection`) ?? zE.defaultDirectionForType(r)
            , a = ui.isEnabled(ui.nestedSubIssues) && this.getPreference(`layout`) === `list` && this.getPreference(`issueNesting`) !== `none`
            , o = GO.priorityOrder(i);
          switch (r) {
          case `priority`:
              return o;
          case `estimate`:
              return GO.estimateOrder(i);
          case `manual`:
              return a ? GO.manualNestedSortOrder(i) : GO.manualSortOrder(i);
          case `startedTriage`:
              return GO.startedTriageOrder(i);
          case `dateCreated`:
              return n ? GO.startedTriageOrder(i) : GO.dateCreatedOrder(i);
          case `dateUpdated`:
              return GO.dateUpdatedOrder(i);
          case `dateMyActivity`:
              return GO.dateMyActivityOrder(i);
          case `dueDate`:
              return GO.dueDateOrder(i, this.slaEnabled);
          case `linkCount`:
              return GO.linkCountOrder(i);
          case `workflowState`:
              return GO.workflowStateOrder(i);
          case `reverseDateCreated`:
              return n ? GO.startedTriageOrder(i) : GO.reverseDateCreatedOrder(i);
          case `title`:
              return GO.titleOrder(i);
          case `assignee`:
              return GO.assigneeOrder(i);
          case `delegate`:
              return GO.delegateOrder(i);
          case `customerCount`:
              return GO.customerCountOrder(i, e, t);
          case `customerImportantCount`:
              return GO.customerImportantCountOrder(i, e, t);
          case `customerRevenue`:
              return GO.customerRevenueOrder(i, e, t);
          case `accumulatedStateUpdatedAt`:
              return GO.accumulatedStateUpdatedAtOrder(i);
          default:
              return y(r),
              o
          }
      }
      getProjectPreFilter() {
          let e = this.getPreference(`showCompletedProjects`)
            , t = this.getPreference(`showSubTeamProjects`)
            , n = this.getPreference(`showSubInitiativeProjects`)
            , r = this.team ?? this.customView?.value?.team
            , i = this.initiative ?? this.customView?.value?.initiative;
          return [new tD(e => !e.isClone && e.persisted), t || !r?.hasSubTeams ? void 0 : new tD(e => e.accessibleTeams.contains(r)), n || !i?.hasSubInitiatives ? void 0 : new tD(e => e.initiatives.contains(i)), e ? oD(e) : void 0].concrete()
      }
      initiativesOrder() {
          let e = this.getPreference(`initiativesViewOrdering`) ?? `sortOrder`
            , t = this.getPreference(`viewOrderingDirection`) ?? zE.defaultDirectionForType(e);
          switch (e) {
          case `sortOrder`:
              return new P(`sortOrder`,t);
          case `name`:
              return new P(`name`,t);
          case `healthUpdatedAt`:
              return new P(e => {
                  let n = t === `desc` ? 0 : 2 ** 53 - 1;
                  return e.healthUpdatedAt ? e.healthUpdatedAt.getTime() : n
              }
              ,t);
          case `targetDate`:
              return new P(`targetDate`,t).and(`sortOrder`, `asc`);
          case `updatedAt`:
              return new P(`updatedAt`,t);
          case `activity`:
              return new P(e => e.activity,t);
          default:
              return y(e),
              new P(`sortOrder`,t)
          }
      }
      workspaceMembersOrder() {
          let e = this.getPreference(`workspaceMembersViewOrdering`) ?? `title`
            , t = this.getPreference(`viewOrderingDirection`) ?? BE.defaultDirectionForType(e);
          switch (e) {
          case `title`:
              return new P(e => e.user.name,t);
          case `status`:
              return new P(e => ek.userStatusToPriority[e.status],t);
          case `joined`:
              return new P(`joinedOrInvitedAt`,t);
          default:
              return y(e),
              new P(e => e.user.name,`desc`)
          }
      }
      projectOrder(e, t, n) {
          let r = this.getPreference(`projectViewOrdering`) ?? `sortOrder`
            , i = this.getPreference(`viewOrderingDirection`) ?? zE.defaultDirectionForType(r);
          switch (r) {
          case `sortOrder`:
              return e instanceof W ? new P(t => t.initiativeToProjects.find(t => t.initiative === e || t.initiative.ancestors.some(t => t === e))?.sortOrder ?? t.sortOrder,i) : new P(`sortOrder`,i);
          case `name`:
              return new P(`name`,i);
          case `createdAt`:
              return new P(`createdAt`,i);
          case `startDate`:
              return new P(`startDate`,i).and(HO, `asc`).and(`prioritySortOrder`, `asc`);
          case `status`:
              return new P(e => Gd.statusListOrdering[e.status.type],i).and(e => e.status.type === Wd.canceled || e.status.type === Wd.completed ? e.status.position : -e.status.position, i).and(e => -e.progress, i);
          case `targetDate`:
              return new P(`targetDate`,i).and(HO, `asc`).and(`prioritySortOrder`, `asc`);
          case `updatedAt`:
              return new P(`lastIssueUpdate`,i).and(`updatedAt`, i);
          case `healthUpdatedAt`:
              return new P(e => {
                  let t = i === `desc` ? 0 : 2 ** 53 - 1;
                  return e.healthUpdatedAt ? e.healthUpdatedAt.getTime() : t
              }
              ,i);
          case `priority`:
              return UO(i);
          case `customerCount`:
              return new P(e => RO(e, t, n),i).and(e => zO(e, t, n), i);
          case `customerImportantCount`:
              return new P(e => zO(e, t, n),i).and(e => RO(e, t, n), i);
          case `customerRevenue`:
              return new P(e => BO(e, t, n),i).and(e => RO(e, t, n), i);
          case `activity`:
              return new P(e => e.activity,i);
          default:
              return y(r),
              new P(`sortOrder`,i)
          }
      }
      get teamOrder() {
          let e = this.getPreference(`teamViewOrdering`) ?? `name`
            , t = this.getPreference(`viewOrderingDirection`) ?? zE.defaultDirectionForType(e);
          switch (e) {
          case `name`:
              return new P(`displayName`,t);
          case `createdAt`:
              return new P(`createdAt`,t);
          case `updatedAt`:
              return new P(`updatedAt`,t);
          default:
              return y(e),
              new P(`name`,t)
          }
      }
      get customViewsOrder() {
          let e = this.getPreference(`customViewsOrdering`) ?? `name`
            , t = this.getPreference(`viewOrderingDirection`) ?? zE.defaultDirectionForType(e);
          switch (e) {
          case `name`:
              return new P(`name`,t);
          case `createdAt`:
              return new P(`createdAt`,t);
          case `updatedAt`:
              return new P(`updatedAt`,t);
          case `owner`:
              return new P(e => e.owner.name ?? ``,t);
          default:
              return y(e),
              new P(`name`,t)
          }
      }
      get dashboardsOrder() {
          let e = this.getPreference(`dashboardsOrdering`) ?? `name`
            , t = this.getPreference(`viewOrderingDirection`) ?? zE.defaultDirectionForType(e);
          switch (e) {
          case `name`:
              return new P(`displayName`,t);
          case `createdAt`:
              return new P(`createdAt`,t);
          case `updatedAt`:
              return new P(`updatedAt`,t);
          case `owner`:
              return new P(e => e.owner.name ?? ``,t);
          default:
              return y(e),
              new P(`displayName`,t)
          }
      }
      reviewOrder(e=`openedAt`) {
          let t = this.getPreference(`reviewViewOrdering`) ?? e
            , n = this.getPreference(`viewOrderingDirection`) ?? zE.defaultDirectionForType(t);
          switch (t) {
          case `title`:
              return new P(`title`,n);
          case `status`:
              return new P(e => wA[e.status],n).and(`updatedAtEphemeral`, `desc`);
          case `openedAt`:
          case `importance`:
              return new P(`openedAt`,n);
          case `updatedAt`:
              return new P(`updatedAtEphemeral`,n).and(`openedAt`, `desc`);
          case `creator`:
              return new P(e => e.creator?.name ?? e.externalCreator?.value?.displayName ?? ``,n).and(`updatedAtEphemeral`, `desc`);
          default:
              return y(t),
              new P(`openedAt`,n)
          }
      }
      get isUserType() {
          return this.type === HT.user
      }
      isUsingManualSort(e) {
          return this.getPreference(e) === `manual` || this.getPreference(e) === `sortOrder`
      }
      isUsingManualPrioritySort(e) {
          return this.getPreference(e) === `priority`
      }
      get hasUserChanges() {
          return this.viewType === k.quickView ? !1 : this.isUserType && this.organizationViewPreferences !== void 0 && Object.keys(this.preferences).find(e => {
              if (e === `showTriageIssues` && this.viewType !== k.triage && this.preferences[e] === !0)
                  return !1;
              let t = this.preferences[e]
                , n = this.organizationViewPreferences?.preferences[e];
              return Array.isArray(t) || Array.isArray(n) ? !(0,
              AA.default)(new Set(Array.isArray(t) ? [JSON.stringify(t)] : []), new Set(Array.isArray(n) ? [JSON.stringify(n)] : [])) : t !== n
          }
          ) !== void 0
      }
      setPreferencesAsDefaultForOrganization() {
          this.isUserType && this.organizationViewPreferences && (this.organizationViewPreferences.setPreferencesInBulk(this.preferences),
          this.organizationViewPreferences.save(!0),
          this.clearPreferencesOrDelete())
      }
      updateInsightOrganizationSettings() {
          this.isUserType && this.insights && this.organizationViewPreferences && (this.organizationViewPreferences.insights = this.insights,
          this.organizationViewPreferences.save(!0),
          this.clearInsightsOrDelete())
      }
      get combinedUserAndOrgPreferences() {
          return Object.keys({
              ...this.organizationViewPreferences?.preferences,
              ...this.preferences
          }).reduce( (e, t) => ({
              ...e,
              [t]: this.getPreference(t)
          }), {})
      }
      get serializedSettings() {
          return JSON.stringify(this.combinedUserAndOrgPreferences)
      }
      get hasDependencies() {
          return this.team != null || this.project != null || this.initiative != null || this.label != null || this.user != null
      }
      getLabelGroupsForTeams(e, t, n) {
          let r = []
            , i = this.organization.issueLabels.filter(e => e.isGroup && (!e.isRetired || [t, n].includes(e.id)));
          i.length > 0 && r.push({
              title: `Workspace`,
              labels: i.elements
          });
          let a = new Map
            , o = e => {
              let r = e.issueLabels.filter(e => e.isGroup && e.inheritedFrom === void 0 && (!e.isRetired || [t, n].includes(e.id)))
                , i = a.get(e) ?? new Set;
              r.forEach(e => i.add(e)),
              !a.has(e) && i.size > 0 && a.set(e, i)
          }
            , s = DA.sortTeams(e);
          for (let e of s)
              e.parent && o(e.parent),
              o(e);
          for (let[e,t] of a)
              r.push({
                  title: e.name,
                  labels: Array.from(t)
              });
          return r
      }
      getLabelGroupOrFallback(e, t=`grouping`) {
          let n = this.getPreference(t === `grouping` ? `issueGroupingLabelGroupId` : `issueSubGroupingLabelGroupId`)
            , r = n ? this.organization.allIssueLabels.findById(n) : void 0;
          if (r || (r = this.organization.issueLabels.find(e => e.isGroup),
          r))
              return r;
          for (let t of e)
              if (r = t.issueLabels.find(e => e.isGroup),
              r)
                  return r
      }
      getProjectLabelGroupOrFallback(e=`grouping`) {
          let t = this.getPreference(e === `grouping` ? `projectGroupingLabelGroupId` : `projectSubGroupingLabelGroupId`)
            , n = t ? this.organization.allProjectLabels.findById(t) : void 0;
          if (n || (n = this.organization.allProjectLabels.find(e => e.isGroup),
          n))
              return n
      }
      get shareableProperties() {
          return kE.reduce( (e, t) => ({
              ...e,
              [t]: this.getPreference(t)
          }), {})
      }
      getModelType() {
          switch (this.viewType) {
          case k.customView:
          case k.quickView:
              return this.customView?.value?.modelType;
          case k.inbox:
          case k.subIssues:
          case k.myIssues:
          case k.myIssuesActivity:
          case k.myIssuesCreatedByMe:
          case k.userProfileCreatedByUser:
          case k.userProfile:
          case k.activeIssues:
          case k.backlog:
          case k.allIssues:
          case k.triage:
          case k.label:
          case k.project:
          case k.cycle:
          case k.completedCycle:
          case k.release:
              return `issue`;
          case k.roadmapAll:
          case k.initiative:
          case k.projects:
          case k.projectsAll:
          case k.projectsBacklog:
          case k.projectsClosed:
          case k.projectLabel:
              return `project`;
          case k.board:
          case k.search:
          case k.customViews:
          case k.teams:
          case k.archive:
          case k.agents:
          default:
              return
          }
      }
      getSaveDialogTitle() {
          let e = `Save display options for `;
          return this.customView?.value ? e += `"${this.customView.value.name}"?` : this.project ? e += `this project?` : this.team ? e += `this team?` : this.initiative ? e += `this initiative?` : this.user ? e += `this profile page?` : this.label ? e += `this label page?` : this.projectLabel ? e += `this project label page?` : e += `this view?`,
          e
      }
      getSaveDialogDescription() {
          let e = `Publishing the configuration will make it the default`;
          if (this.customView?.value)
              switch (this.customView.value.shareType) {
              case `personal`:
                  e += `.`;
                  break;
              case `team`:
                  e += ` for everyone in the team.`;
                  break;
              case `workspace`:
                  e += ` for everyone in the workspace.`;
                  break;
              default:
                  Ln(this.customView.value.shareType)
              }
          else if (this.project) {
              let t = this.project.accessibleTeams.every(e => e.private);
              e += t ? ` for all team members.` : ` for everyone in the workspace.`
          } else
              this.team ? e += this.team.private ? ` for everyone in the team.` : ` for everyone in the workspace.` : e += ` for everyone in the workspace.`;
          return e
      }
      static getOrCreateFrom(e, t, n) {
          let r = zu.includes(t), i, a;
          if (e.forEach(e => {
              e.viewType === t && e.matchesDependencies(n) && (e.type === HT.user ? i = e : !r && e.type === HT.organization && (a = e))
          }
          ),
          !r && a == null) {
              let e = new jA;
              e.setDependencies(n),
              e.viewType = t,
              e.type = HT.organization,
              a = e
          }
          if (!i) {
              let e = new jA;
              e.setDependencies(n),
              e.viewType = t,
              e.type = HT.user,
              i = e
          }
          return r ? i.organizationViewPreferences = void 0 : i.organizationViewPreferences = a,
          i
      }
      get commonViewPreferences() {
          return new mE(this.type,this.viewType,this.preferences,this.organizationViewPreferences?.preferences,this.project?.isArchived ?? !1,this.slaEnabled,this.organization.initiativesEnabled)
      }
      get parentModel() {
          return this.customView?.value ?? this.project ?? this.label ?? this.projectLabel ?? this.user ?? this.initiative ?? this.team
      }
      get slaEnabled() {
          return this.team ? this.team.slaEnabled : this.organization.isSlaAccessible
      }
      clearPreferencesOrDelete() {
          this.insights == null ? this.delete() : (this.preferences = {},
          this.save())
      }
      clearInsightsOrDelete() {
          (0,
          kA.default)(this.preferences) ? this.delete() : (this.insights = void 0,
          this.save())
      }
      matchesDependencies(e) {
          for (let t = 0, n = PA.length; t < n; ++t) {
              let n = PA[t];
              if (e[n]) {
                  let t = this[n];
                  if ((t instanceof _m ? t.value : t) !== e[n])
                      return !1
              } else if (this[n] != null)
                  return !1
          }
          return !0
      }
      setDependencies(e) {
          PA.forEach(t => {
              let n = e[t];
              n ? (this[t] = n instanceof Az ? vm.wrap(n) : n,
              this.organization = n.organization) : this[t] = void 0
          }
          )
      }
  }
  ,
  M([R({
      enum: HT,
      persistence: `createOnly`,
      default: HT.organization
  })], NA.prototype, `type`, void 0),
  M([R({
      enum: k,
      persistence: `createOnly`,
      default: k.allIssues
  })], NA.prototype, `viewType`, void 0),
  M([B( () => K, `viewPreferences`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], NA.prototype, `team`, void 0),
  M([B( () => G, `viewPreferences`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], NA.prototype, `project`, void 0),
  M([B( () => W, `viewPreferences`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], NA.prototype, `initiative`, void 0),
  M([B( () => OH, `viewPreferences`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], NA.prototype, `label`, void 0),
  M([B( () => Ek, `viewPreferences`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], NA.prototype, `projectLabel`, void 0),
  M([B( () => J, `viewPreferences`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], NA.prototype, `user`, void 0),
  M([sg( () => Az, `viewPreferences`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], NA.prototype, `customView`, void 0),
  M([B( () => q, `viewPreferences`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], NA.prototype, `organization`, void 0),
  M([I], NA.prototype, `setPreference`, null),
  M([I], NA.prototype, `setPreferencesInBulk`, null),
  M([I], NA.prototype, `setAndSavePreference`, null),
  M([L], NA.prototype, `currentInsight`, null),
  M([I], NA.prototype, `setInsights`, null),
  M([I], NA.prototype, `updateInsights`, null),
  M([I], NA.prototype, `setAndSaveInsightPreference`, null),
  M([L], NA.prototype, `teamOrder`, null),
  M([L], NA.prototype, `customViewsOrder`, null),
  M([L], NA.prototype, `dashboardsOrder`, null),
  M([L], NA.prototype, `hasUserChanges`, null),
  M([I], NA.prototype, `setPreferencesAsDefaultForOrganization`, null),
  M([I], NA.prototype, `updateInsightOrganizationSettings`, null),
  M([L], NA.prototype, `combinedUserAndOrgPreferences`, null),
  M([L], NA.prototype, `serializedSettings`, null),
  M([L], NA.prototype, `hasDependencies`, null),
  M([L], NA.prototype, `shareableProperties`, null),
  M([L], NA.prototype, `commonViewPreferences`, null),
  M([R({
      serializer: Mh,
      default: {}
  })], NA.prototype, `preferences`, void 0),
  M([R({
      serializer: Mh
  })], NA.prototype, `insights`, void 0),
  NA = jA = M([mg(`ViewPreferences`)], NA),
  PA = [`team`, `project`, `customView`, `label`, `projectLabel`, `initiative`, `user`]
}
)), IA, LA, RA = t(( () => {
  iz(),
  V(),
  F(),
  nx(),
  DM(),
  N(),
  LA = IA = class extends Yh {
      static create(e) {
          let t = e.project.initiativeToProjects.find(t => t.initiative === e.initiative);
          if (t)
              return t;
          IA.hasConnectionToInitiativeDescendant({
              project: e.project,
              initiative: e.initiative
          }).hasConnection && IA.removeFromAllDescendants({
              initiative: e.initiative,
              project: e.project
          });
          let n = IA.createEmpty();
          return n.project = e.project,
          n.initiative = e.initiative,
          n.sortOrder = tx.lastSortOrder(e.initiative.initiativeToProjects, `sortOrder`),
          n
      }
      static removeProjectFromInitiative(e) {
          return e.project.initiativeToProjects.find(t => t.initiative === e.initiative)?.delete()
      }
      static removeProjectFromAllInitiatives(e) {
          return e.project.initiativeToProjects.forEach(e => e.delete())
      }
      static removeFromAllDescendants(e) {
          return e.initiative.descendants.forEach(t => {
              t.initiativeToProjects.find(t => t.project === e.project)?.delete()
          }
          )
      }
      static hasConnectionToInitiativeDescendant(e) {
          let t = e.project.initiativeToProjects.find(t => e.initiative.descendants.contains(t.initiative));
          return {
              hasConnection: t != null,
              initiative: t?.initiative
          }
      }
      static hasConnectionToInitiativeAncestor(e) {
          let t = e.project.initiativeToProjects.find(t => e.initiative.ancestors.contains(t.initiative));
          return {
              hasConnection: t != null,
              initiative: t?.initiative
          }
      }
  }
  ,
  M([B( () => W, `initiativeToProjects`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], LA.prototype, `initiative`, void 0),
  M([B( () => G, `initiativeToProjects`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], LA.prototype, `project`, void 0),
  M([R({
      default: 0
  })], LA.prototype, `sortOrder`, void 0),
  LA = IA = M([mg(`InitiativeToProject`)], LA)
}
));
function zA(e) {
  return [e.type, e]
}
var BA, VA, HA = t(( () => {
  zn(),
  iy(),
  nx(),
  ws(),
  Pz(),
  bH(),
  DM(),
  iU(),
  iz(),
  mH(),
  GU(),
  V(),
  F(),
  Sm(),
  N(),
  VA = BA = class extends Yh {
      constructor(...e) {
          super(...e),
          this.toggleFavorite = () => {
              if (this.favorite)
                  return this.favorite.delete(),
                  !1;
              {
                  let e = yH.create({
                      reference: this
                  });
                  return e.save(!0),
                  e
              }
          }
      }
      get type() {
          return this.targetCustomView ? this.sourceProject ? ny.Project : this.sourceInitiative ? ny.Initiative : this.sourceTeam ? ny.TeamPage : this.sourceOrganization ? ny.WorkspacePage : this.sourceFeedUser ? ny.Feed : (w.info(`Unknown facet type on client`, {
              facetId: this.id
          }),
          ny.Unknown) : (w.warning(`facet.targetCustomView is missing`, {
              facetId: this.id,
              isPersisted: this.persisted,
              isPersistedOnBackend: this.persistedOnBackend,
              hasSourceProject: !!this.sourceProject,
              hasSourceInitiative: !!this.sourceInitiative,
              hasSourceTeam: !!this.sourceTeam,
              hasSourceOrganization: !!this.sourceOrganization,
              hasSourceFeedUser: !!this.sourceFeedUser
          }),
          ny.Unknown)
      }
      getTargetDescription() {
          let[e,t] = zA(this);
          switch (e) {
          case ny.Feed:
          case ny.Project:
              return;
          case ny.Initiative:
          case ny.TeamPage:
          case ny.WorkspacePage:
              return t.targetCustomView.value?.description;
          case ny.Unknown:
              return;
          default:
              throw y(e)
          }
      }
      getIssues() {
          let[e,t] = zA(this);
          switch (e) {
          case ny.Project:
              return t.sourceProject.issues;
          case ny.Initiative:
          case ny.TeamPage:
          case ny.WorkspacePage:
          case ny.Feed:
              return;
          case ny.Unknown:
              return;
          default:
              throw y(e)
          }
      }
      getProjects() {
          let[e,t] = zA(this);
          switch (e) {
          case ny.Project:
              return;
          case ny.Initiative:
              return t.sourceInitiative.projectsInherited;
          case ny.TeamPage:
              return t.sourceTeam.projectsInherited;
          case ny.WorkspacePage:
              return t.sourceOrganization.projects;
          case ny.Feed:
          case ny.Unknown:
              return;
          default:
              throw y(e)
          }
      }
      getFeedItems() {
          let[e,t] = zA(this);
          switch (e) {
          case ny.Feed:
              return t.sourceFeedUser.organization.feed;
          case ny.Project:
          case ny.Initiative:
          case ny.TeamPage:
          case ny.WorkspacePage:
          case ny.Unknown:
              return;
          default:
              throw y(e)
          }
      }
      get hideDescription() {
          return [ny.Feed, ny.Project].includes(this.type)
      }
      static createProjectFacet(e) {
          let t = BA.createEmpty();
          return t.creator = e.creator,
          t.targetCustomView = vm.wrap(e.customView),
          t.sortOrder = tx.lastSortOrder(e.project.facets, `sortOrder`),
          t.sourceProject = e.project,
          t
      }
      static createInitiativeFacet(e) {
          let t = BA.createEmpty();
          return t.creator = e.creator,
          t.targetCustomView = vm.wrap(e.customView),
          t.sortOrder = tx.lastSortOrder(e.initiative.facets, `sortOrder`),
          t.sourceInitiative = e.initiative,
          t
      }
      static createTeamPageFacet(e) {
          let t = BA.createEmpty();
          return t.creator = e.creator,
          t.targetCustomView = vm.wrap(e.customView),
          t.sortOrder = tx.lastSortOrder(e.team.facets, `sortOrder`),
          t.sourceTeam = e.team,
          t.sourcePage = e.sourcePage,
          t
      }
      static createWorkspacePageFacet(e) {
          let t = BA.createEmpty();
          return t.creator = e.creator,
          t.targetCustomView = vm.wrap(e.customView),
          t.sortOrder = tx.lastSortOrder(e.creator.organization.facets, `sortOrder`),
          t.sourceOrganization = e.creator.organization,
          t.sourcePage = e.sourcePage,
          t
      }
      static createFeedFacet(e) {
          let t = BA.createEmpty();
          return t.creator = e.creator,
          t.targetCustomView = vm.wrap(e.customView),
          t.sourceFeedUser = e.creator,
          t
      }
  }
  ,
  M([R({
      default: 0
  })], VA.prototype, `sortOrder`, void 0),
  M([B( () => J, `facets`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], VA.prototype, `creator`, void 0),
  M([ug({
      nullable: !0
  })], VA.prototype, `favorite`, void 0),
  M([B( () => q, `facets`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], VA.prototype, `sourceOrganization`, void 0),
  M([B( () => K, `facets`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], VA.prototype, `sourceTeam`, void 0),
  M([B( () => G, `facets`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], VA.prototype, `sourceProject`, void 0),
  M([B( () => W, `facets`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], VA.prototype, `sourceInitiative`, void 0),
  M([B( () => J, `feedFacets`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], VA.prototype, `sourceFeedUser`, void 0),
  M([R({
      persistence: `createOnly`
  })], VA.prototype, `sourcePage`, void 0),
  M([dg( () => Az, `facet`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      cascadeHydration: !0,
      persistence: `createOnly`
  })], VA.prototype, `targetCustomView`, void 0),
  VA = BA = M([mg(`Facet`)], VA)
}
)), UA, WA = t(( () => {
  Sy(),
  Hb(),
  Od(),
  V(),
  F(),
  N(),
  UA = class extends Jh {
      canEdit(e) {
          return this.user === e
      }
      canDelete(e) {
          return this.user === e || e.hasPermission(Cd.entityManagement)
      }
      get bodyMarkdown() {
          return this.bodyData ? Hp.serialize(this.bodyData) : ``
      }
      get healthAgeInDays() {
          return Vb.getHealthAgeInDays({
              healthUpdatedAt: this.createdAt
          })
      }
      get rootComment() {
          return this.comments.find(e => (e.isRootSlackSyncedComment || e.isRootUnsyncedSlackComment) === !0)
      }
      get numberOfComments() {
          return this.comments.filter(e => !e.isClone && !e.isRootSlackSyncedComment && !e.isRootUnsyncedSlackComment).length
      }
      markNotificationAsRead(e) {
          let t = this.notifications.find(t => t.id === e || t.groupingEntityId === e);
          if (!t)
              return;
          let n = t?.groupingEntityId;
          this.notifications.forEach(e => {
              e.readAt === void 0 && e.groupingEntityId === n && (e.markAsRead(),
              e.save())
          }
          )
      }
      markNotificationsExceptCommentsAsRead() {
          this.notifications.forEach(e => {
              e.readAt === void 0 && !e.comment?.id && (e.markAsRead(),
              e.save())
          }
          )
      }
  }
  ,
  M([L], UA.prototype, `bodyMarkdown`, null),
  M([L], UA.prototype, `rootComment`, null),
  M([L], UA.prototype, `numberOfComments`, null),
  M([I], UA.prototype, `markNotificationAsRead`, null),
  M([I], UA.prototype, `markNotificationsExceptCommentsAsRead`, null)
}
)), GA, KA = t(( () => {
  Ul(),
  XB(),
  Lq(),
  iz(),
  UM(),
  V(),
  F(),
  om(),
  kH(),
  lj(),
  rB(),
  N(),
  GA = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular
  }
  ,
  M([R({
      default: Vl.slackMessage
  })], GA.prototype, `externalEntityType`, void 0),
  M([R({
      default: ``
  })], GA.prototype, `externalId`, void 0),
  M([R()], GA.prototype, `metadata`, void 0),
  M([R()], GA.prototype, `syncErrors`, void 0),
  M([sg( () => YB, `externalEntityRelations`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], GA.prototype, `comment`, void 0),
  M([sg( () => Y, `externalEntityRelations`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], GA.prototype, `issue`, void 0),
  M([sg( () => G, `externalEntityRelations`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], GA.prototype, `project`, void 0),
  M([sg( () => HM, `externalEntityRelations`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], GA.prototype, `projectUpdate`, void 0),
  M([sg( () => cj, `externalEntityRelations`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], GA.prototype, `initiativeUpdate`, void 0),
  M([sg( () => OH, `externalEntityRelations`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], GA.prototype, `label`, void 0),
  M([cg( () => nB, {
      persistence: `none`,
      optional: !0,
      nullable: !1,
      indexed: !0
  })], GA.prototype, `integration`, void 0),
  GA = M([mg(`ExternalEntityRelation`)], GA)
}
)), qA, _ce, vce, yce, bce = t(( () => {
  qA = class e {
      static get priorityValues() {
          return [...[, , , , , ].keys()].map(t => ({
              priority: t,
              label: e.labelForPriority(t)
          }))
      }
      static #e = this.labelForPriority = e => {
          switch (e) {
          case 1:
              return `Urgent`;
          case 2:
              return `High`;
          case 3:
              return `Medium`;
          case 4:
              return `Low`;
          default:
              return `No priority`
          }
      }
      ;
      static #t = this.phraseForPriority = e => {
          switch (e) {
          case 1:
              return `an urgent`;
          case 2:
              return `a high priority`;
          case 3:
              return `a medium priority`;
          case 4:
              return `a low priority`;
          default:
              return
          }
      }
  }
  ,
  _ce = class extends qA {
      static #e = this.description = `The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.`
  }
  ,
  vce = class extends qA {
      static #e = this.description = `The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.`
  }
  ,
  yce = class extends qA {
      static #e = this.description = `Whether the customer need is important or not. 0 = Not important, 1 = Important.`
  }
}
));
function JA(e, t) {
  return e === t ? void 0 : {
      from: e,
      to: t
  }
}
function YA(e, t) {
  if (t && !((e === t || !e) && t === Fb.onTrack))
      return {
          from: e,
          to: t
      }
}
function XA(e, t, n) {
  return e ? Yc.format({
      date: e,
      resolution: t
  }, {
      fiscalYearStartMonth: n
  }) : void 0
}
function xce(e) {
  let t = 0;
  `type`in e && e.type === `added` && (t = 4);
  let n = e.health?.to === Fb.offTrack
    , r = e.health?.to === Fb.atRisk
    , i = e.targetDate?.to && e.targetDate?.from && e.targetDate?.to !== e.targetDate?.from
    , a = 0;
  return a = n ? 0 : r ? .1 : i ? .2 : .3,
  t + a
}
var ZA, QA, $A, Sce = t(( () => {
  ZA = e(_(), 1),
  qb(),
  KT(),
  Rb(),
  Kd(),
  bce(),
  Zc(),
  (function(e) {
      function t(e, t) {
          let n = {};
          for (let t in e.projects)
              YA(void 0, e.projects[t].health) && (n[t] = {
                  type: `changed`,
                  health: YA(void 0, e.projects[t].health)
              });
          let r = {};
          for (let n in e.subInitiatives) {
              let i = YA(void 0, e.subInitiatives[n].health);
              i && (r[n] = {
                  lastSnapshotDate: t,
                  health: i,
                  projects: {},
                  subInitiatives: {}
              })
          }
          return {
              lastSnapshotDate: t,
              health: YA(void 0, e.health),
              projects: n,
              subInitiatives: r
          }
      }
      e.getFirstInitiativeUpdateInfoSnapshotDiff = t;
      function n(e, t, r, i) {
          let a = JA(t.status, e.status)
            , o = JA(t.ownerId, e.ownerId)
            , s = XA(t.targetDate, t.targetDateResolution, i)
            , c = XA(e.targetDate, e.targetDateResolution, i)
            , l = YA(t.health, e.health)
            , u = JA(s, c)
            , d = {};
          for (let n in e.projects) {
              let r = e.projects[n]
                , a = t.projects?.[n];
              r && a ? d[n] = {
                  type: `changed`,
                  statusId: a.statusId === r.statusId ? void 0 : {
                      from: a.statusId,
                      to: r.statusId
                  },
                  targetDate: (e => {
                      let t = `${e}Date`
                        , n = `${e}DateResolution`;
                      return r[t] !== a[t] || r[n] !== a[n]
                  }
                  )(`target`) ? {
                      from: XA(a.targetDate, a.targetDateResolution, i),
                      to: XA(r.targetDate, r.targetDateResolution, i)
                  } : void 0,
                  health: YA(a.health, r.health),
                  priority: ( () => r.priority !== a.priority)() ? {
                      from: a.priority,
                      to: r.priority
                  } : void 0
              } : r && (d[n] = {
                  type: `added`,
                  statusId: {
                      from: void 0,
                      to: r.statusId
                  },
                  targetDate: r.targetDate ? {
                      from: void 0,
                      to: XA(r.targetDate, r.targetDateResolution, i)
                  } : void 0,
                  health: YA(void 0, r.health),
                  priority: r.priority === void 0 ? void 0 : {
                      from: void 0,
                      to: r.priority
                  }
              }),
              Object.entries(d[n]).every( ([e,t]) => e === `type` || t === void 0) && delete d[n]
          }
          let f = {};
          if (e.subInitiatives)
              for (let a in e.subInitiatives) {
                  let o = e.subInitiatives[a]
                    , s = t.subInitiatives?.[a];
                  if (o && s) {
                      let e = n(o, s, r, i);
                      Object.keys(e).filter(e => e !== `lastSnapshotDate`).length > 0 && (f[a] = e)
                  }
              }
          return {
              lastSnapshotDate: r,
              status: a,
              ownerId: o,
              targetDate: u,
              health: l,
              projects: d,
              subInitiatives: f
          }
      }
      e.getInitiativeUpdateInfoSnapshotDiff = n;
      function r(e, t) {
          let n = [];
          for (let[r,i] of Object.entries(e)) {
              let e = xce(i)
                , a = t[r] || r;
              n.push({
                  projectId: r,
                  order: e,
                  changes: i,
                  projectName: a
              })
          }
          return (0,
          ZA.default)(n, [`order`, `projectName`])
      }
      e.sortProjectChanges = r;
      function i(e, t) {
          let n = [];
          for (let[r,i] of Object.entries(e)) {
              let e = xce(i)
                , a = t[r] || r;
              n.push({
                  initiativeId: r,
                  order: e,
                  changes: i,
                  initiativeName: a
              })
          }
          return (0,
          ZA.default)(n, [`order`, `initiativeName`])
      }
      e.sortInitiativeChanges = i;
      async function a(e, t) {
          let n = []
            , r = []
            , i = []
            , a = Object.keys(e.subInitiatives);
          if (e.ownerId?.to && n.push(e.ownerId.to),
          e.projects)
              for (let[t,n] of Object.entries(e.projects))
                  i.push(t),
                  n.statusId?.from && r.push(n.statusId.from),
                  n.statusId?.to && r.push(n.statusId.to);
          let[c,l,u,d] = await Promise.all([n.length > 0 ? t.getUsersById(n) : {}, r.length > 0 ? t.getProjectStatusesById(r) : {}, i.length > 0 ? t.getProjectNamesById(i) : {}, a.length > 0 ? t.getInitiativeNamesById(a) : {}])
            , f = [];
          if (e.status && e.status.from !== e.status.to) {
              let t = e.status.to;
              t && f.push(`**Status**: ${WT(t)}`)
          }
          if (e.ownerId?.to && e.ownerId.from !== e.ownerId.to) {
              let t = c[e.ownerId.to];
              t && f.push(`**Owner**: ${t} assigned`)
          }
          if (e.targetDate && e.targetDate.from !== e.targetDate.to && f.push(`**Target date**: ${$A(e.targetDate.from, e.targetDate.to)}`),
          e.subInitiatives) {
              let t = []
                , n = QA.sortInitiativeChanges(e.subInitiatives, d);
              for (let {initiativeId: e, changes: r} of n) {
                  let n = d[e];
                  if (!n)
                      continue;
                  let i = s({
                      status: {
                          from: r.status?.from,
                          to: r.status?.to
                      },
                      targetDate: r.targetDate,
                      health: r.health
                  });
                  if (i.length > 0) {
                      let e = i.map( ({explanation: e}) => e);
                      t.push(`**${n}** ${e.join(`  `)}`)
                  }
              }
              t.length > 0 && f.push(`
**Sub-initiatives**:
` + t.map(e => `- ${e}`).join(`
`))
          }
          if (e.projects) {
              let t = []
                , n = QA.sortProjectChanges(e.projects, u);
              for (let {projectId: e, changes: r} of n) {
                  let n = u[e];
                  if (!n)
                      continue;
                  let i = o({
                      ...r,
                      status: {
                          from: r.statusId?.from ? l[r.statusId.from] : void 0,
                          to: r.statusId?.to ? l[r.statusId.to] : void 0
                      }
                  });
                  if (i.length > 0) {
                      let e = i.map( ({explanation: e}) => e);
                      t.push(`**${n}** ${e.join(`  `)}`)
                  }
              }
              t.length > 0 && f.push(`
**Projects**:
` + t.map(e => `- ${e}`).join(`
`))
          }
          return f.length > 0 ? f.join(`
`) : ``
      }
      e.formatInitiativeUpdateDiffAsMarkdown = a;
      function o(e) {
          let t = []
            , n = e.status?.to?.type
            , r = !n || n === Wd.planned || n === Wd.started;
          if (n !== Wd.completed && n !== Wd.canceled && t.push(...c(e.health, r)),
          e.status?.to && e.status.from?.type !== e.status.to.type) {
              if (e.status.from) {
                  let n = e.status.from.type === Wd.backlog && e.status.to.type === Wd.planned
                    , r = e.status.from.type === Wd.planned && e.status.to.type === Wd.backlog;
                  if (!(n || r)) {
                      let n = e.status.to.name.toLowerCase()
                        , r = `changed status to ${n}`;
                      n === `completed` ? r = `marked as completed` : n === `canceled` ? r = `marked as canceled` : n === `in progress` ? r = `is in progress` : n === `paused` ? r = `is paused` : n === `backlog` && (r = `moved to backlog`),
                      t.push({
                          key: `status`,
                          explanation: r
                      })
                  }
              } else if (e.type === `added`) {
                  let n = e.status.to.name.toLowerCase()
                    , r = `added to initiative`;
                  n === `completed` || n === `canceled` || n === `paused` ? r = `added to initiative and ${n}` : n === `in progress` && (r = `added to initiative and is in progress`),
                  t.push({
                      key: `status`,
                      explanation: r
                  })
              }
          }
          r && e.targetDate?.from !== e.targetDate?.to && t.push({
              key: `target-date`,
              explanation: !e.targetDate?.from && e.targetDate?.to ? `target date ${e.targetDate.to}` : `target date ${$A(e.targetDate?.from, e.targetDate?.to)}`
          });
          let i = e.priority?.to;
          if (r && i !== void 0) {
              let n = Kb.createFromPriority(i);
              if (n.isUrgent || n.isHigh) {
                  let n = e.priority?.from;
                  t.push({
                      key: `priority-change`,
                      explanation: n === void 0 ? `priority ${qA.labelForPriority(i)}` : `priority ${$A(qA.labelForPriority(n), qA.labelForPriority(i))}`
                  })
              }
          }
          return t
      }
      e.formatProjectChanges = o;
      function s(e) {
          let t = []
            , n = e.status?.to !== GT.Completed;
          if (n && t.push(...c(e.health, n)),
          e.status?.from && e.status?.to && e.status.from !== e.status.to) {
              let n = e.status.to.toLowerCase()
                , r = `changed status to ${n}`;
              n === `completed` ? r = `marked as completed` : n === `active` && (r = `marked as active`),
              t.push({
                  key: `status`,
                  explanation: r
              })
          }
          return n && e.targetDate?.from !== e.targetDate?.to && t.push({
              key: `target-date`,
              explanation: `target date ${$A(e.targetDate?.from, e.targetDate?.to)}`
          }),
          t
      }
      e.formatInitiativeChanges = s;
      function c(e, t) {
          let n = [];
          if (!e || !t)
              return n;
          let {from: r, to: i} = e;
          return r === Fb.atRisk && i === Fb.atRisk ? n.push({
              key: `still-at-risk`,
              explanation: `still at risk`
          }) : r === Fb.offTrack && i === Fb.offTrack ? n.push({
              key: `still-off-track`,
              explanation: `still off track`
          }) : r !== void 0 && r !== Fb.onTrack && i === Fb.onTrack ? n.push({
              key: `back-on-track`,
              explanation: `back on track`
          }) : i === Fb.atRisk ? n.push({
              key: `became-at-risk`,
              explanation: `at risk`
          }) : i === Fb.offTrack && n.push({
              key: `became-off-track`,
              explanation: `off track`
          }),
          n
      }
      e.formatHealthChanges = c
  }
  )(QA ||= {}),
  $A = (e, t) => `${e || `Not set`}  ${t || `Not set`}`
}
)), ej, tj = t(( () => {
  zn(),
  Kd(),
  iU(),
  iz(),
  V(),
  F(),
  Nm(),
  N(),
  ej = class extends Jh {
      static getDefaultColorForType(e, t) {
          switch (e) {
          case Wd.backlog:
              return t.color.orangeBase;
          case Wd.planned:
              return `#e2e2e2`;
          case Wd.started:
              return t.color.yellowBase;
          case Wd.paused:
              return t.color.labelMuted;
          case Wd.completed:
              return t.color.purpleBase;
          case Wd.canceled:
              return t.color.labelMuted;
          default:
              return y(e),
              t.color.labelMuted
          }
      }
      get isInUse() {
          return this.projects.length > 0
      }
      get progress() {
          if (this.type !== Wd.started)
              return;
          let e = this.organization.numProjectStatusesOfType(this.type)
            , t = this.indexWithinStateType;
          return e === 1 ? .5 : e === 2 ? t === 0 ? .3 : .7 : 1 / (e + 1) * (t + 1)
      }
      get indexWithinStateType() {
          let e = this.type
            , t = this.position;
          return this.findIndexWithPredicate(n => n.type === e && n.position < t)
      }
      get globalPosition() {
          let e = this.type;
          return (Gd.statusListOrdering[e] + 1) * 100 + this.indexWithinStateType
      }
      get globalPositionList() {
          let e = this.type
            , t = (Gd.statusListOrdering[e] + 1) * 200;
          return e === Wd.completed || e === Wd.canceled ? t + this.indexWithinStateType : t - this.indexWithinStateType
      }
      findIndexWithPredicate(e) {
          let t = 0
            , n = this.organization.projectStatuses.elements;
          for (let r = 0, i = n.length; r < i; ++r)
              e(n[r]) && ++t;
          return t
      }
  }
  ,
  M([R({
      default: ``
  })], ej.prototype, `name`, void 0),
  M([R({
      default: `#f00`
  })], ej.prototype, `color`, void 0),
  M([R()], ej.prototype, `description`, void 0),
  M([R({
      default: 0
  })], ej.prototype, `position`, void 0),
  M([R({
      default: Wd.backlog
  })], ej.prototype, `type`, void 0),
  M([R({
      default: !1
  })], ej.prototype, `indefinite`, void 0),
  M([og( () => G, {
      order: new P(`sortOrder`)
  })], ej.prototype, `projects`, void 0),
  M([B( () => q, `projectStatuses`, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], ej.prototype, `organization`, void 0),
  M([L], ej.prototype, `indexWithinStateType`, null),
  M([L], ej.prototype, `globalPosition`, null),
  M([L], ej.prototype, `globalPositionList`, null),
  ej = M([mg(`ProjectStatus`)], ej)
}
));
function Cce(e, t) {
  let n = new Map;
  for (let[r,i] of Object.entries(t)) {
      let t = e.findById(G, r);
      if (!t)
          continue;
      let a = {
          type: i.type,
          ...i.statusId && {
              status: {
                  from: i.statusId.from ? e.findById(ej, i.statusId.from) : void 0,
                  to: i.statusId.to ? e.findById(ej, i.statusId.to) : void 0
              }
          },
          ...i.targetDate && {
              targetDate: {
                  from: i.targetDate.from,
                  to: i.targetDate.to
              }
          },
          ...i.health && {
              health: {
                  from: i.health.from,
                  to: i.health.to
              }
          },
          ...i.priority && {
              priority: {
                  from: i.priority.from,
                  to: i.priority.to
              }
          }
      };
      Object.keys(a).length > 1 && n.set(t, a)
  }
  return n.size > 0 ? {
      projects: n
  } : void 0
}
function wce(e, t) {
  let n = new Map;
  for (let[r,i] of Object.entries(t)) {
      let t = e.findById(W, r);
      if (!t)
          continue;
      let a = i.projects ? Cce(e, i.projects) : void 0
        , o = i.subInitiatives ? wce(e, i.subInitiatives) : void 0
        , s = {
          lastSnapshotDate: i.lastSnapshotDate,
          ...i.status && {
              status: i.status
          },
          ...i.targetDate && {
              targetDate: i.targetDate
          },
          ...i.ownerId && {
              owner: {
                  from: i.ownerId.from ? e.findById(J, i.ownerId.from) : void 0,
                  to: i.ownerId.to ? e.findById(J, i.ownerId.to) : void 0
              }
          },
          ...i.health && {
              health: {
                  from: i.health.from,
                  to: i.health.to
              }
          },
          ...a && {
              projects: a.projects
          },
          ...o && {
              subInitiatives: o.subInitiatives
          }
      };
      Object.keys(s).some(e => e !== `lastSnapshotDate`) && n.set(t, s)
  }
  return n.size > 0 ? {
      subInitiatives: n
  } : void 0
}
var nj, rj, ij, Tce = t(( () => {
  zt(),
  Sce(),
  DM(),
  iz(),
  tj(),
  GU(),
  nj = e => {
      let t = {};
      e.projects.map(e => {
          t[e.id] = {
              statusId: e.status.id,
              targetDate: e.targetDate,
              targetDateResolution: e.targetDateResolution,
              health: e.health,
              priority: e.priority.priority
          }
      }
      );
      let n = {};
      return e.children.forEach(e => {
          n[e.id] = nj(e)
      }
      ),
      {
          status: e.status,
          ownerId: e.owner?.id,
          targetDate: e.targetDate,
          targetDateResolution: e.targetDateResolution,
          health: e.health,
          projects: t,
          ...Object.keys(n).length > 0 && {
              subInitiatives: n
          }
      }
  }
  ,
  rj = Ft( (e, t, n) => {
      let r = n ? n?.infoSnapshot : void 0
        , i = t.infoSnapshot || nj(t.initiative);
      if (!i)
          return;
      if (!r)
          return QA.getFirstInitiativeUpdateInfoSnapshotDiff(i, t.createdAt);
      r.subInitiatives ||= {},
      i.subInitiatives ||= {};
      let {fiscalYearStartMonth: a} = e.organization
        , o = n?.createdAt || t.createdAt;
      return QA.getInitiativeUpdateInfoSnapshotDiff(i, r, o, a)
  }
  ),
  ij = {
      calculateDiffBetweenInitiativeUpdates: (e, t, n) => {
          let r = rj(e, t, n);
          if (!r)
              return;
          let i = r.subInitiatives ? wce(e, r.subInitiatives) : void 0
            , a = {
              lastSnapshotDate: r.lastSnapshotDate,
              ...r.status && {
                  status: {
                      from: r.status.from,
                      to: r.status.to
                  }
              },
              ...r.targetDate && {
                  targetDate: {
                      from: r.targetDate.from,
                      to: r.targetDate.to
                  }
              },
              ...r.ownerId && {
                  owner: {
                      from: r.ownerId.from ? e.findById(J, r.ownerId.from) : void 0,
                      to: r.ownerId.to ? e.findById(J, r.ownerId.to) : void 0
                  }
              },
              ...r.projects && Cce(e, r.projects),
              ...r.health && {
                  health: {
                      from: r.health.from,
                      to: r.health.to
                  }
              },
              ...i && {
                  subInitiatives: i.subInitiatives
              }
          }
            , o = a.lastSnapshotDate ? 1 : 0;
          return Object.keys(a).length > o ? a : void 0
      }
      ,
      formatInitiativeUpdateDiffAsMarkdown: (e, t, n) => {
          let r = rj(e, t, n);
          return r ? QA.formatInitiativeUpdateDiffAsMarkdown(r, {
              getUsersById: async t => t.reduce( (t, n) => {
                  let r = e.findById(J, n);
                  return r && (t[n] = r.name),
                  t
              }
              , {}),
              getProjectStatusesById: async t => t.reduce( (t, n) => {
                  let r = e.findById(ej, n);
                  return r && (t[n] = r),
                  t
              }
              , {}),
              getProjectNamesById: async t => t.reduce( (t, n) => {
                  let r = e.findById(G, n);
                  return r && (t[n] = r.name),
                  t
              }
              , {}),
              getInitiativeNamesById: async t => t.reduce( (t, n) => {
                  let r = e.findById(W, n);
                  return r && (t[n] = r.name),
                  t
              }
              , {})
          }) : Promise.resolve(``)
      }
  }
}
)), aj, oj, sj = t(( () => {
  AR(),
  V(),
  F(),
  om(),
  Sm(),
  Ih(),
  lj(),
  UM(),
  XB(),
  N(),
  oj = class extends Yh {
      static #e = aj = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static #r = this.partialPreloadForTeam = am.noPreload;
      static create(e) {
          let {documentContent: t, comment: n, projectUpdate: r, initiativeUpdate: i, assetUrl: a, transcription: o, chapters: s, summary: c, title: l, status: u} = e
            , d = aj.createEmpty();
          if (t)
              d.documentContent = vm.wrap(t);
          else if (n)
              d.comment = vm.wrap(n);
          else if (r)
              d.projectUpdate = vm.wrap(r);
          else if (i)
              d.initiativeUpdate = vm.wrap(i);
          else
              throw Error(`Either documentContent, comment, projectUpdate, or initiativeUpdate must be provided`);
          return d.assetUrl = a,
          o && (d.transcription = o),
          c && (d.summary = c),
          l && (d.title = l),
          s && (d.chapters = s),
          u && (d.status = u),
          d
      }
  }
  ,
  M([R()], oj.prototype, `assetUrl`, void 0),
  M([sg( () => kR, `mediaMetadata`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], oj.prototype, `documentContent`, void 0),
  M([sg( () => YB, `mediaMetadata`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], oj.prototype, `comment`, void 0),
  M([sg( () => HM, `mediaMetadata`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], oj.prototype, `projectUpdate`, void 0),
  M([sg( () => cj, `mediaMetadata`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], oj.prototype, `initiativeUpdate`, void 0),
  M([R({
      serializer: Mh,
      persistence: `updateOnly`
  })], oj.prototype, `transcription`, void 0),
  M([R({
      persistence: `updateOnly`
  })], oj.prototype, `summary`, void 0),
  M([R({
      persistence: `updateOnly`
  })], oj.prototype, `title`, void 0),
  M([R({
      persistence: `none`
  })], oj.prototype, `captionsUrl`, void 0),
  M([R({
      serializer: Mh,
      persistence: `updateOnly`
  })], oj.prototype, `chapters`, void 0),
  M([R({
      persistence: `updateOnly`
  })], oj.prototype, `status`, void 0),
  M([I], oj, `create`, null),
  oj = aj = M([mg(`MediaMetadata`)], oj)
}
)), cj, lj = t(( () => {
  Rb(),
  Hb(),
  Aw(),
  V(),
  DM(),
  iU(),
  XB(),
  WA(),
  ML(),
  GU(),
  Ih(),
  sR(),
  AM(),
  KA(),
  Tce(),
  sj(),
  om(),
  N(),
  cj = class extends UA {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular;
      get previousUpdate() {
          return this.initiative.initiativeUpdates.find(e => e.createdAt < this.createdAt)
      }
      get isStale() {
          return Vb.healthIsOutdated({
              healthAgeInDays: this.healthAgeInDays,
              updateReminderFrequency: this.initiative.updateReminderFrequency,
              frequencyResolution: this.initiative.frequencyResolution,
              orgReminderFrequency: this.initiative.orgReminderFrequency,
              isActive: this.initiative.isActive
          })
      }
      get isSlightlyStale() {
          return Vb.healthIsSlightlyOutdated({
              healthAgeInDays: this.healthAgeInDays,
              updateReminderFrequency: this.initiative.updateReminderFrequency,
              frequencyResolution: this.initiative.frequencyResolution,
              orgReminderFrequency: this.initiative.orgReminderFrequency,
              isActive: this.initiative.isActive
          })
      }
      get parent() {
          return this.initiative
      }
      get snapshotDiff() {
          return ij.calculateDiffBetweenInitiativeUpdates(this.store, this, this.previousUpdate)
      }
      async formatAsMarkdown(e) {
          let t;
          return this.snapshotDiff && (t = await ij.formatInitiativeUpdateDiffAsMarkdown(this.store, this, this.previousUpdate)),
          kw.exportUpdateAsMarkdown({
              parentName: this.initiative.name,
              parentUrl: vP(this.initiative),
              health: this.health,
              userName: this.user?.name,
              createdAt: this.createdAt,
              bodyMarkdown: this.bodyMarkdown,
              diffMarkdown: t,
              comments: this.comments.map(e => ({
                  author: e.user?.name,
                  bodyMarkdown: e.bodyMarkdown,
                  createdAt: e.createdAt,
                  id: e.id,
                  sourceMetadata: e.sourceMetadata,
                  isSyncedExternalThreadRoot: e.isSyncedExternalThreadRoot,
                  resolvingCommentId: e.resolvingComment?.id
              }))
          }, {
              includeComments: e?.includeComments,
              includeName: e?.includeInitiativeName
          })
      }
  }
  ,
  M([R({
      serializer: Mh,
      shallowObservation: !0,
      default: {}
  })], cj.prototype, `bodyData`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], cj.prototype, `editedAt`, void 0),
  M([R({
      enum: Fb,
      default: Fb.onTrack
  })], cj.prototype, `health`, void 0),
  M([R({
      persistence: `none`,
      default: ``,
      indexed: !0
  })], cj.prototype, `slugId`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !0,
      nullable: !1
  })], cj.prototype, `user`, void 0),
  M([z( () => GA, {
      index: `initiativeUpdateId`
  })], cj.prototype, `externalEntityRelations`, void 0),
  M([z( () => YB, {
      index: `initiativeUpdateId`
  })], cj.prototype, `comments`, void 0),
  M([z( () => kM, {
      index: `initiativeUpdateId`
  })], cj.prototype, `draftComments`, void 0),
  M([R({
      persistence: `none`,
      serializer: Mh,
      default: []
  })], cj.prototype, `reactionData`, void 0),
  M([og( () => tR)], cj.prototype, `notifications`, void 0),
  M([B( () => W, `initiativeUpdates`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], cj.prototype, `initiative`, void 0),
  M([z( () => oj, {
      index: `initiativeUpdateId`
  })], cj.prototype, `mediaMetadata`, void 0),
  M([cg( () => q, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], cj.prototype, `organization`, void 0),
  M([L], cj.prototype, `previousUpdate`, null),
  M([R({
      serializer: Mh,
      persistence: `none`
  })], cj.prototype, `infoSnapshot`, void 0),
  M([R({
      default: !1
  })], cj.prototype, `isDiffHidden`, void 0),
  M([L], cj.prototype, `snapshotDiff`, null),
  cj = M([mg(`InitiativeUpdate`)], cj)
}
)), uj, Ece = t(( () => {
  zt(),
  Nm(),
  uj = class extends P {
      constructor(e, t=`asc`) {
          super( () => 0),
          this._comparator = e,
          this._direction = t
      }
      compareElements(e, t) {
          let n = this._comparator(e, t);
          return this._direction === `asc` ? n : -n
      }
      orderElements(e) {
          return this.observable || (this.observable = !0,
          At(this, {
              and: Ft,
              reset: Ft
          })),
          [...e].sort( (e, t) => this.compareElements(e, t))
      }
  }
}
)), dj, Dce = t(( () => {
  Ece(),
  dj = new uj( (e, t) => {
      let n = e.ancestorData
        , r = t.ancestorData
        , i = n.array.filter(e => !r.set.has(e))
        , a = r.array.filter(e => !n.set.has(e))
        , o = i[0] ?? e
        , s = a[0] ?? t;
      return o.statusSortOrder === s.statusSortOrder ? n.set.has(t) ? 1 : r.set.has(e) ? -1 : o.sortOrder - s.sortOrder : o.statusSortOrder > s.statusSortOrder ? 1 : -1
  }
  )
}
));
function Oce(e, t) {
  return e.type === t
}
var fj, pj = t(( () => {
  fj = function(e) {
      return e.thought = `thought`,
      e.action = `action`,
      e.response = `response`,
      e.elicitation = `elicitation`,
      e.error = `error`,
      e.prompt = `prompt`,
      e
  }({})
}
));
function kce(e, t, n) {
  if (!e || !t)
      return !1;
  let r = Ace[e];
  return !r || !(t in r) ? !1 : r[t].safeParse(n).success
}
var mj, hj, gj, Ace, _j = t(( () => {
  St(),
  pj(),
  mj = 100,
  hj = 100,
  gj = function(e) {
      return e.stop = `stop`,
      e.continue = `continue`,
      e.auth = `auth`,
      e.select = `select`,
      e
  }({}),
  gj.stop,
  new Set([fj.prompt]),
  gj.continue,
  new Set([fj.response]),
  gj.auth,
  new Set([fj.elicitation]),
  gj.select,
  new Set([fj.elicitation]),
  Ace = {
      [gj.auth]: {
          [fj.elicitation]: dt({
              userId: yt().uuid().optional(),
              providerName: yt().optional(),
              url: yt().url({
                  message: `Auth metadata must include a valid URL.`
              })
          }).strict()
      },
      [gj.select]: {
          [fj.elicitation]: dt({
              options: Dt(dt({
                  value: yt().min(1, `Option value cannot be empty`).max(hj, `Value length cannot exceed ${hj} characters`),
                  label: yt().max(hj, `Label length cannot exceed ${hj} characters`).optional()
              }).strict()).min(1, `At least one option must be provided`).max(mj, `At most ${mj} options can be provided`)
          }).strict()
      }
  }
}
)), vj, yj = t(( () => {
  St(),
  pj(),
  vj = class e {
      static #e = this.maxContentLength = 25e4;
      static #t = this.schemas = {
          thought: dt({
              type: pt(fj.thought),
              body: yt({
                  required_error: `Thought activities must include a 'body' field.`
              }).max(e.maxContentLength, {
                  message: `The 'body' field exceeds the maximum length of ${e.maxContentLength} characters.`
              })
          }),
          action: dt({
              type: pt(fj.action),
              action: yt({
                  required_error: `Action activities must include an 'action' field.`
              }),
              parameter: yt({
                  required_error: `Action activities must include a 'parameter' field.`
              }),
              result: yt({
                  invalid_type_error: `The 'result' field must be a string if provided.`
              }).max(e.maxContentLength, {
                  message: `The 'result' field exceeds the maximum length of ${e.maxContentLength} characters.`
              }).optional()
          }),
          response: dt({
              type: pt(fj.response),
              body: yt({
                  required_error: `Response activities must include a 'body' field.`
              }).max(e.maxContentLength, {
                  message: `The 'body' field exceeds the maximum length of ${e.maxContentLength} characters.`
              })
          }),
          prompt: dt({
              type: pt(fj.prompt),
              body: yt({
                  required_error: `Prompt activities must include a 'body' field.`
              }).max(e.maxContentLength, {
                  message: `The 'body' field exceeds the maximum length of ${e.maxContentLength} characters.`
              })
          }),
          error: dt({
              type: pt(fj.error),
              body: yt({
                  required_error: `Error activities must include a 'body' field.`
              }).max(e.maxContentLength, {
                  message: `The 'body' field exceeds the maximum length of ${e.maxContentLength} characters.`
              })
          }),
          elicitation: dt({
              type: pt(fj.elicitation),
              body: yt({
                  required_error: `Elicitation activities must include a 'body' field.`
              }).max(e.maxContentLength, {
                  message: `The 'body' field exceeds the maximum length of ${e.maxContentLength} characters.`
              })
          })
      };
      static #n = this.contentSchema = Et(`type`, [this.schemas.thought, this.schemas.action, this.schemas.response, this.schemas.prompt, this.schemas.error, this.schemas.elicitation]);
      static #r = this.terminalTypes = new Set([fj.response, fj.error, fj.elicitation])
  }
}
)), jce, Mce = t(( () => {
  yj(),
  pj(),
  ws(),
  jce = {
      serialize: e => JSON.stringify(e),
      deserialize: e => {
          try {
              let t = typeof e == `string` ? JSON.parse(e) : e
                , n = vj.contentSchema.safeParse(t);
              if (n.success)
                  return n.data;
              w.debug(`Agent activity content validation failed`, {
                  errors: n.error.errors,
                  value: e
              })
          } catch (t) {
              w.debug(`Failed to parse agent activity content JSON`, {
                  error: JSON.stringify(t),
                  value: e
              })
          }
          return {
              type: fj.error,
              body: `[Data Error] Failed to parse activity content`
          }
      }
  }
}
)), bj, xj, Sj = t(( () => {
  pj(),
  _j(),
  Oj(),
  XB(),
  V(),
  F(),
  om(),
  Sm(),
  Mce(),
  GU(),
  N(),
  xj = class extends Yh {
      static #e = bj = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static #r = this.partialPreloadForTeam = am.secondPriority;
      createMutation(e) {
          if (this.content.type === fj.prompt) {
              let t = 1
                , n = `agentActivityCreatePromptInput`;
              for (; e.has(n); )
                  n = `agentActivityCreatePromptInput_${++t}`;
              let r = {
                  agentSessionId: this.agentSession?.id,
                  content: this.content
              };
              this.sourceComment?.id && (r.sourceCommentId = this.sourceComment.id),
              this.signal && (r.signal = this.signal),
              this.contextualMetadata && (r.contextualMetadata = this.contextualMetadata),
              this.id && (r.id = this.id);
              let i = `agentActivityCreatePrompt(input: $${n}) { agentActivity { id } lastSyncId }`;
              return this.observePropertyChanges(),
              {
                  mutationText: i,
                  variables: {
                      [n]: r
                  },
                  variableTypes: {
                      [n]: `AgentActivityCreatePromptInput`
                  }
              }
          }
          return super.createMutation(e)
      }
      isStopRequest() {
          return this.content.type === fj.prompt && this.signal === gj.stop
      }
      isAuthElicitation() {
          return this.content.type === fj.elicitation && this.signal === gj.auth && this.signalMetadata !== void 0 && kce(this.signal, fj.elicitation, this.signalMetadata)
      }
      isSelectElicitation() {
          return this.content.type === fj.elicitation && this.signal === gj.select && this.signalMetadata !== void 0 && kce(this.signal, fj.elicitation, this.signalMetadata)
      }
      static createPromptActivityWithSignal(e) {
          let {agentSession: t, user: n, signal: r, body: i} = e
            , a = new bj;
          return a.agentSession = vm.wrap(t),
          a.content = {
              type: fj.prompt,
              body: i ?? r
          },
          a.signal = r,
          a.user = vm.wrap(n),
          a
      }
  }
  ,
  M([sg( () => Dj, `agentActivities`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], xj.prototype, `agentSession`, void 0),
  M([R({
      serializer: jce,
      default: () => ({
          type: `thought`,
          body: ``
      })
  })], xj.prototype, `content`, void 0),
  M([R({
      persistence: `createOnly`
  })], xj.prototype, `signal`, void 0),
  M([R({
      persistence: `createOnly`
  })], xj.prototype, `signalMetadata`, void 0),
  M([R({
      default: !1
  })], xj.prototype, `ephemeral`, void 0),
  M([sg( () => YB, `createdAgentActivities`, {
      nullable: !0,
      indexed: !0,
      persistence: `none`
  })], xj.prototype, `sourceComment`, void 0),
  M([R({
      persistence: `none`
  })], xj.prototype, `sourceMetadata`, void 0),
  M([R({
      persistence: `createOnly`
  })], xj.prototype, `contextualMetadata`, void 0),
  M([sg( () => J, `createdAgentActivities`, {
      nullable: !0,
      indexed: !0,
      persistence: `none`
  })], xj.prototype, `user`, void 0),
  M([I], xj, `createPromptActivityWithSignal`, null),
  xj = bj = M([mg(`AgentActivity`)], xj)
}
)), Cj, Nce = t(( () => {
  zn(),
  pj(),
  L_(),
  (function(e) {
      function t(e, t) {
          if (!e)
              return !1;
          let n = __(t)
            , r = `${Rre}${t.split(`-`)[0]}`;
          return e.includes(n) || e.includes(r)
      }
      e.isAgentSessionInHash = t,
      e.getActivityBody = e => {
          switch (e.content.type) {
          case fj.action:
              return e.content.result;
          case fj.thought:
              return e.content.body;
          case fj.response:
              return e.content.body;
          case fj.error:
              return e.content.body;
          case fj.elicitation:
              return e.content.body;
          case fj.prompt:
              return e.content.body;
          default:
              throw y(e.content)
          }
      }
      ,
      e.getStatusAnimationKey = e => {
          let t = e.agentActivities.last
            , n = e.hasPendingStopRequest;
          return `status-${e.status}-${n ? `stop` : `active`}-${t?.id || `none`}`
      }
  }
  )(Cj ||= {})
}
));
function Pce(e, t) {
  let n = Array.from(new Set([...e.flags, ...t.flags])).join(``);
  return RegExp(`(${e.source}|${t.source})`, n)
}
var wj, Fce = t(( () => {
  wj = () => RegExp(`((?<!\\+)https?:\\/\\/(?:www\\.)?(?:[-\\w.]+?[.@][a-zA-Z\\d]{2,})(?:[-\\w.:%+~#*$!?&/=@]*?(?:,(?!\\s))*?)*)`, `g`)
}
)), Tj, Ice = t(( () => {
  Fce(),
  (function(e) {
      function t(e) {
          try {
              let t = new URL(e);
              return `${t.origin}${t.pathname}`
          } catch {
              return e.replace(/[#?].*$/, ``)
          }
      }
      e.normalizeUrl = t;
      function n(e) {
          let t = [], n = /\[([^\]]+)\]\(([^)]+)\)/g, r;
          for (; (r = n.exec(e)) !== null; )
              t.push(r[2]);
          let i = wj();
          for (; (r = i.exec(e)) !== null; )
              t.push(r[1]);
          return [...new Set(t)]
      }
      e.parseUrlsFromMarkdown = n
  }
  )(Tj ||= {})
}
)), Ej, Dj, Oj = t(( () => {
  ww(),
  _j(),
  pj(),
  yj(),
  V(),
  F(),
  om(),
  GU(),
  XB(),
  Sj(),
  Nm(),
  Lq(),
  Ih(),
  iU(),
  Nce(),
  Ice(),
  N(),
  Dj = class extends Yh {
      static #e = Ej = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static #r = this.partialPreloadForTeam = am.secondPriority;
      get hasPendingStopRequest() {
          return this.agentActivities.last?.isStopRequest() ?? !1
      }
      get hasBeenAcknowledged() {
          return this.externalLink ? !0 : this.agentActivities.some(e => e.content.type !== fj.prompt)
      }
      get isStoppable() {
          return (this.status === bw.active || this.status === bw.pending) && !this.hasPendingStopRequest
      }
      get hasPendingAuthElicitation() {
          return !!this.pendingAuthElicitation
      }
      get pendingAuthElicitation() {
          if (this.status !== bw.awaitingInput)
              return null;
          let e = this.agentActivities.last;
          return e?.isAuthElicitation() ? e : null
      }
      get hasPendingSelectElicitation() {
          return !!this.pendingSelectElicitation
      }
      get pendingSelectElicitation() {
          if (this.status !== bw.awaitingInput)
              return null;
          let e = this.agentActivities.last;
          return e?.isSelectElicitation() ? e : null
      }
      matchInlineFind(e) {
          let t = e.toLowerCase();
          return !!(this.summary?.toLowerCase().includes(t) || this.appUser.name.toLowerCase().includes(t) || this.appUser.displayName.toLowerCase().includes(t) || this.issue?.value?.title.toLowerCase().includes(t) || this.issue?.value?.identifier.toLowerCase().includes(t))
      }
      get lastTerminalActivityTimestamp() {
          let e = Array.from(this.agentActivities);
          for (let t = e.length - 1; t >= 0; t--) {
              let n = e[t];
              if (n && vj.terminalTypes.has(n.content.type)) {
                  if (n.content.type === fj.response && n.signal === gj.continue)
                      continue;
                  return n.createdAt
              }
          }
          return this.createdAt
      }
      get latestSegmentStartTime() {
          let e = this.lastTerminalActivityTimestamp
            , t = Array.from(this.agentActivities);
          for (let n = t.length - 1; n >= 0; n--) {
              let r = t[n];
              if (r.content.type === fj.prompt && r.createdAt > e)
                  return r.createdAt
          }
          return e
      }
      get latestPullRequestAttachment() {
          let e = this.issue?.value;
          if (!e || !e.hasPullRequestAttachments)
              return;
          let t = new Map(e.pullRequestAttachments.elements.map(e => [Tj.normalizeUrl(e.url), e]))
            , n = Array.from(this.agentActivities);
          for (let e = n.length - 1; e >= 0; e--) {
              let r = n[e];
              if (r.content.type !== fj.response)
                  continue;
              let i = Cj.getActivityBody(r);
              if (!i)
                  continue;
              let a = Tj.parseUrlsFromMarkdown(i);
              for (let e of a) {
                  let n = Tj.normalizeUrl(e)
                    , r = t.get(n);
                  if (r)
                      return r
              }
          }
      }
      get latestPullRequest() {
          return this.latestPullRequestAttachment?.pullRequestEntity
      }
      dismiss() {
          let e = this.issue?.value;
          e && e.delegate?.id === this.appUser.id && (e.agentSessions.elements.some(e => e.id !== this.id && e.appUser.id === this.appUser.id && !e.isDismissed) || (e.delegate = void 0,
          e.save())),
          this.dismissedAt = new Date,
          this.dismissedBy = this.store.user,
          this.save()
      }
      undismiss() {
          this.dismissedAt = void 0,
          this.save()
      }
      get isDismissed() {
          return this.dismissedAt !== void 0
      }
      static #i = this.terminalStates = new Set([bw.complete, bw.error, bw.awaitingInput]);
      get isStateTerminal() {
          return Ej.terminalStates.has(this.status)
      }
      isUserInvolved(e) {
          return this.creator?.id === e ? !0 : this.agentActivities.some(t => t.user?.value?.id === e)
      }
  }
  ,
  M([cg( () => J, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], Dj.prototype, `appUser`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0
  })], Dj.prototype, `creator`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0
  })], Dj.prototype, `dismissedBy`, void 0),
  M([B( () => q, `agentSessions`, {
      persistence: `none`,
      nullable: !1,
      optional: !1,
      indexed: !0
  })], Dj.prototype, `organization`, void 0),
  M([sg( () => YB, `agentSessions`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], Dj.prototype, `comment`, void 0),
  M([sg( () => YB, `spawnedAgentSessions`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], Dj.prototype, `sourceComment`, void 0),
  M([sg( () => Y, `agentSessions`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], Dj.prototype, `issue`, void 0),
  M([R({
      default: bw.pending,
      persistence: `none`
  })], Dj.prototype, `status`, void 0),
  M([R({
      default: yw.commentThread,
      persistence: `none`
  })], Dj.prototype, `type`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Dj.prototype, `startedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Dj.prototype, `endedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `updateOnly`
  })], Dj.prototype, `dismissedAt`, void 0),
  M([R({
      persistence: `none`
  })], Dj.prototype, `summary`, void 0),
  M([z( () => xj, {
      index: `agentSessionId`,
      order: new P(`createdAt`,`asc`)
  })], Dj.prototype, `agentActivities`, void 0),
  M([R({
      persistence: `none`
  })], Dj.prototype, `externalLink`, void 0),
  M([R({
      persistence: `none`
  })], Dj.prototype, `plan`, void 0),
  M([L], Dj.prototype, `hasBeenAcknowledged`, null),
  M([L], Dj.prototype, `pendingAuthElicitation`, null),
  M([L], Dj.prototype, `pendingSelectElicitation`, null),
  M([L], Dj.prototype, `lastTerminalActivityTimestamp`, null),
  M([L], Dj.prototype, `latestSegmentStartTime`, null),
  M([L], Dj.prototype, `latestPullRequestAttachment`, null),
  M([L], Dj.prototype, `latestPullRequest`, null),
  Dj = Ej = M([mg(`AgentSession`)], Dj)
}
));
function kj(e, t) {
  for (; t !== 0; ) {
      let n = t;
      t = e % t,
      e = n
  }
  return e
}
var Aj, Lce = t(( () => {
  St(),
  Aj = class e {
      static fraction(e, t) {
          if (!Number.isInteger(e))
              throw Error(`Numerator must be an integer`);
          if (!Number.isInteger(t))
              throw Error(`Denominator must be an integer`);
          if (t === 0)
              throw Error(`Cannot divide by zero`);
          return t < 0 ? [-e, -t] : [e, t]
      }
      static get zero() {
          return [0, 1]
      }
      static get one() {
          return [1, 1]
      }
      static isOne(e) {
          return e[0] === e[1]
      }
      static fromInteger(t) {
          return e.fraction(t, 1)
      }
      static toFloat(e) {
          return e[0] / e[1]
      }
      static parse(t) {
          let[n,r] = t.split(`/`);
          if (!(!n || !r))
              try {
                  let t = parseFloat(n)
                    , i = parseFloat(r);
                  return e.fraction(t, i)
              } catch {
                  return
              }
      }
      static stringify(e) {
          return e[0] + `/` + e[1]
      }
      static #e = this.schema = ft(e => Array.isArray(e) && e.length === 2 && Number.isInteger(e[0]) && Number.isInteger(e[1]) && e[1] !== 0);
      static areEqual(e, t) {
          return e[0] * t[1] === t[0] * e[1]
      }
      static add(t, n) {
          let[r,i] = t
            , [a,o] = n
            , s = r * o + a * i
            , c = i * o
            , l = Math.abs(kj(s, c));
          return e.fraction(s / l, c / l)
      }
      static subtract(t, n) {
          let[r,i] = t
            , [a,o] = n
            , s = r * o - a * i
            , c = i * o
            , l = Math.abs(kj(s, c));
          return e.fraction(s / l, c / l)
      }
      static multiply(t, n) {
          let[r,i] = t
            , [a,o] = n
            , s = r * a
            , c = i * o
            , l = Math.abs(kj(s, c));
          return e.fraction(s / l, c / l)
      }
      static divide(t, n) {
          let r = e.fraction(n[1], n[0]);
          return e.multiply(t, r)
      }
  }
}
)), jj, Rce, zce, Bce = t(( () => {
  St(),
  gc(),
  cE(),
  jj = xt(oE),
  Rce = xt(sE),
  zce = dt({
      measure: vt(eE),
      measureIssueStates: Dt(dt({
          type: vt(E),
          name: yt().optional(),
          id: yt().optional()
      })).optional(),
      dimension: vt(ZT),
      subDimension: yt().optional(),
      dimensionDateAggregation: vt(YT).optional(),
      segment: vt(ZT).optional(),
      subSegment: yt().optional(),
      includeArchived: bt().optional(),
      hideEmptyDimension: bt().optional(),
      hideEmptySegment: bt().optional(),
      colorScale: vt(aE).optional(),
      display: jj.optional(),
      aggregation: vt(XT).optional(),
      latencyYScale: Rce.optional(),
      aggregations: Dt(vt(XT)).optional(),
      distributionOrder: yt().optional(),
      distributionDirection: xt([`asc`, `desc`]).optional(),
      latencyOrder: mt([pt(`total`), vt(XT)]).optional(),
      latencyDirection: xt([`asc`, `desc`]).optional()
  })
}
)), Vce, Hce, Uce = t(( () => {
  St(),
  Bce(),
  Vce = {
      id: yt().uuid(),
      creatorId: yt().uuid().optional(),
      createdAt: yt().datetime(),
      updatedById: yt().uuid().optional(),
      updatedAt: yt().datetime()
  },
  Hce = Et(`variant`, [_t({
      ...Vce,
      variant: pt(`insight`),
      modelName: pt(`issue`),
      name: yt(),
      description: yt().optional(),
      issueFilter: ft(e => !0).optional(),
      insight: zce.optional()
  })])
}
));
function Wce(e, t) {
  if (!e.key)
      return {
          variant: `missingKey`,
          row: t
      };
  let n = e.columns
    , r = new Set
    , i = Aj.zero;
  for (let e = 0, a = n.length; e < a; ++e) {
      let a = n[e];
      if (r.has(a.key))
          return {
              variant: `duplicateKey`,
              row: t,
              column: e
          };
      let o = Gce(a, t, e);
      if (o)
          return o;
      r.add(a.key),
      i = Aj.add(i, a.width)
  }
  return Aj.isOne(i) ? void 0 : {
      variant: `incorrectSize`,
      row: t
  }
}
function Gce(e, t, n) {
  if (!e.key)
      return {
          variant: `missingKey`,
          row: t,
          column: n
      };
  let r = Aj.zero
    , i = e.items;
  for (let e = 0, t = i.length; e < t; ++e)
      r = Aj.add(r, i[e].height);
  return Aj.isOne(r) ? void 0 : {
      variant: `incorrectSize`,
      row: t,
      column: n
  }
}
function Kce(e, t) {
  let n = Aj.zero;
  e.key ||= Yce(t);
  let r = e.columns
    , i = Jce(r)
    , a = [];
  for (let e = 0, t = r.length; e < t; ++e) {
      let t = r[e];
      t.items.length > 0 && (qce(t, i),
      n = Aj.add(n, t.width),
      a.push(t))
  }
  if (a.length !== r.length && (r = a,
  e.columns = a),
  !Aj.isOne(n)) {
      let e = r.length;
      for (let t = 0; t < e; ++t)
          r[t].width = Aj.fraction(1, e)
  }
}
function qce(e, t) {
  let n = e.items;
  e.key ||= Yce(t);
  let r = n.length;
  if (r > 0) {
      let e = Aj.fraction(1, r);
      for (let t = 0; t < r; ++t) {
          let i = n[t];
          Aj.areEqual(e, i.height) || (i.height = Aj.fraction(1, r))
      }
  }
}
function Jce(e) {
  let t = new Set;
  for (let n = 0, r = e.length; n < r; ++n) {
      let r = e[n];
      r.key && (t.has(r.key) ? r.key = `` : t.add(r.key))
  }
  return t
}
function Yce(e) {
  let t = Mj(6);
  for (; e.has(t); )
      t = Mj(6);
  return e.add(t),
  t
}
function Mj(e) {
  let t = ``;
  for (let n = 0; n < e; ++n) {
      let e = Math.floor(Math.random() * 62);
      t += `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`[e]
  }
  return t
}
var Xce, Zce, Qce, $ce, Nj, ele = t(( () => {
  St(),
  ss(),
  Lce(),
  Uce(),
  Xce = _t({
      widget: Hce,
      height: Aj.schema
  }),
  Zce = _t({
      key: yt(),
      width: Aj.schema,
      items: Dt(Xce)
  }),
  Qce = _t({
      key: yt(),
      columns: Dt(Zce)
  }),
  $ce = Et(`version`, [_t({
      version: pt(1),
      rows: Dt(Qce)
  })]),
  Nj = class e {
      static #e = this.minNameLength = 1;
      static #t = this.maxNameLength = 100;
      static #n = this.maxDescriptionLength = 255;
      static #r = this.maxColumnsPerRow = 4;
      static #i = this.defaultName = `New dashboard`;
      static #a = this.defaultWidgetsV1 = {
          version: 1,
          rows: []
      };
      static #o = this.widgetsSchema = $ce;
      static generateLayoutKey() {
          return Mj(6)
      }
      static validateWidgets(e) {
          let t = new Set
            , n = e.rows;
          for (let e = 0, r = n.length; e < r; ++e) {
              let r = n[e];
              if (t.has(r.key))
                  return {
                      variant: `duplicateKey`,
                      row: e
                  };
              t.add(r.key);
              let i = Wce(r, e);
              if (i)
                  return i
          }
      }
      static autofixWidgets(e) {
          let t = e.rows
            , n = Jce(t)
            , r = [];
          for (let e = 0, i = t.length; e < i; ++e) {
              let i = t[e];
              Kce(i, n),
              i.columns.length > 0 && r.push(i)
          }
          r.length !== t.length && (e.rows = r)
      }
      static traverseItems(e, t) {
          let n = e.rows;
          for (let e = 0, r = n.length; e < r; ++e) {
              let r = n[e]
                , i = r.columns;
              for (let n = 0, a = i.length; n < a; ++n) {
                  let a = i[n]
                    , o = a.items;
                  for (let i = 0, s = o.length; i < s; ++i)
                      if (t({
                          row: r,
                          column: a,
                          item: o[i],
                          rowIndex: e,
                          columnIndex: n
                      }))
                          return
              }
          }
      }
      static findWidget(t, n) {
          let r;
          return e.traverseItems(t, ({item: e}) => e.widget.id === n ? (r = e.widget,
          !0) : !1),
          r
      }
      static addWidget(t, n, r) {
          let i = r?.row, a = r?.column, o = !1, s;
          if (i ? s = t.rows.find(e => e.key === i) : (s = {
              key: e.generateLayoutKey(),
              columns: []
          },
          o = !0),
          s == null)
              return;
          let c;
          a ? c = s.columns.find(e => e.key === a) : (c = {
              key: e.generateLayoutKey(),
              width: Aj.one,
              items: []
          },
          s.columns.push(c)),
          c != null && (c.items.push({
              widget: n,
              height: Aj.one
          }),
          o && t.rows.push(s),
          e.autofixWidgets(t))
      }
      static duplicateWidget(t, n) {
          e.traverseItems(t, r => {
              if (r.item.widget.id === n) {
                  let {row: n} = r
                    , i = {
                      key: e.generateLayoutKey(),
                      width: Aj.one,
                      items: [{
                          height: Aj.one,
                          widget: {
                              ...r.item.widget,
                              id: os()
                          }
                      }]
                  };
                  return n.columns.length >= e.maxColumnsPerRow ? t.rows.splice(r.rowIndex + 1, 0, {
                      key: e.generateLayoutKey(),
                      columns: [i]
                  }) : n.columns.splice(r.columnIndex + 1, 0, i),
                  !0
              }
              return !1
          }
          ),
          e.autofixWidgets(t)
      }
      static deleteWidget(t, n) {
          let r;
          e.traverseItems(t, e => e.item.widget.id === n ? (r = e.column,
          !0) : !1),
          r != null && (r.items = r.items.filter(e => e.widget.id !== n),
          e.autofixWidgets(t))
      }
  }
}
)), Pj, Fj, Ij = t(( () => {
  zt(),
  Mu(),
  ele(),
  GU(),
  V(),
  F(),
  om(),
  eu(),
  Ih(),
  iU(),
  mH(),
  bH(),
  nx(),
  Wh(),
  N(),
  Fj = class extends Yh {
      static #e = Pj = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static create(e) {
          let t = Pj.createEmpty();
          t.creator = e.creator,
          t.shared = e.shared,
          t.owner = e.creator,
          t.organization = e.creator.organization,
          t.name = e.name ?? ``,
          t.description = e.description,
          t.icon = e.icon,
          t.color = e.color,
          t.team = e.team;
          let n = e.team ? e.team.dashboards : e.creator.organization.dashboards;
          return t.sortOrder = tx.firstSortOrder(n, `sortOrder`),
          t
      }
      get slug() {
          return this.slugId ? `${ju(this.name)}-${this.slugId}` : void 0
      }
      matchInlineFind(e) {
          return $l(this.name + ` ` + this.description).toLowerCase().indexOf(e) !== -1
      }
      ensureName() {
          this.name ||= Nj.defaultName
      }
      get displayName() {
          return this.name || Nj.defaultName
      }
      get shareType() {
          return this.shared ? this.team ? `team` : `workspace` : `personal`
      }
      get filterTeams() {
          let e = this.team;
          return e ? e.private ? [e] : e.withAccessibleDescendants.filter(e => !e.private) : this.teams.length > 0 ? this.teams.elements.flatMap(e => e.private ? [e] : e.withAccessibleDescendants.filter(e => !e.private)) : this.shared ? this.organization.accessibleTeams.elements.filter(e => !e.private) : this.organization.accessibleTeams.elements
      }
      get isSafeToAutoDelete() {
          return !this.name && !this.archivedAt && this.widgets.rows.length === 0
      }
      toggleFavorite() {
          if (this.favorite)
              return this.favorite.delete(),
              !1;
          let e = yH.create({
              reference: this
          });
          return e.save(!0),
          e
      }
      makePersonal() {
          this.shared = !1,
          this.team = void 0,
          this.teams.clear()
      }
      makeWorkspace() {
          this.shared = !0,
          this.team = void 0,
          this.teams.clear()
      }
      toggleTeam(e) {
          this.shared = !0,
          this.team === e ? (this.team = void 0,
          this.teams.clear()) : this.teams.contains(e) ? (this.teams.remove(e),
          this.teams.length === 1 ? (this.team = this.teams.first,
          this.teams.clear()) : this.team = void 0) : this.team == null ? this.teams.length === 0 ? this.team = e : this.teams.add(e) : (this.teams.clear(),
          this.teams.add(this.team),
          this.teams.add(e),
          this.team = void 0)
      }
      duplicate(e) {
          let t = Pj.create({
              creator: e,
              name: this.name ? `${this.name} (copy)` : ``,
              description: this.description,
              shared: this.shared,
              color: this.color,
              icon: this.icon,
              team: this.team
          });
          return this.teams.forEach(e => {
              t.teams.add(e)
          }
          ),
          t.widgets = Uh.structuredClone(Lt(this.widgets)),
          t.issueFilter = Uh.structuredClone(Lt(this.issueFilter)),
          t.projectFilter = Uh.structuredClone(Lt(this.projectFilter)),
          t
      }
  }
  ,
  M([R({
      default: ``
  })], Fj.prototype, `name`, void 0),
  M([R()], Fj.prototype, `description`, void 0),
  M([R()], Fj.prototype, `icon`, void 0),
  M([R()], Fj.prototype, `color`, void 0),
  M([R({
      default: 0
  })], Fj.prototype, `sortOrder`, void 0),
  M([B( () => q, `allDashboards`, {
      persistence: `none`,
      optional: !1,
      nullable: !1,
      indexed: !0
  })], Fj.prototype, `organization`, void 0),
  M([B( () => K, `dashboards`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], Fj.prototype, `team`, void 0),
  M([fg( () => K, void 0, {
      updateOnSyncGroupChange: !0,
      indexed: !0
  })], Fj.prototype, `teams`, void 0),
  M([cg( () => J, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], Fj.prototype, `creator`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `none`
  })], Fj.prototype, `updatedBy`, void 0),
  M([B( () => J, `dashboards`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], Fj.prototype, `owner`, void 0),
  M([R({
      default: !1
  })], Fj.prototype, `shared`, void 0),
  M([R({
      persistence: `none`
  })], Fj.prototype, `slugId`, void 0),
  M([ug({
      nullable: !0
  })], Fj.prototype, `favorite`, void 0),
  M([R({
      serializer: Fh
  })], Fj.prototype, `issueFilter`, void 0),
  M([R({
      serializer: Fh
  })], Fj.prototype, `projectFilter`, void 0),
  M([R({
      serializer: Mh,
      default: Nj.defaultWidgetsV1
  })], Fj.prototype, `widgets`, void 0),
  M([L], Fj.prototype, `slug`, null),
  M([I], Fj.prototype, `ensureName`, null),
  M([L], Fj.prototype, `displayName`, null),
  M([L], Fj.prototype, `shareType`, null),
  M([L], Fj.prototype, `filterTeams`, null),
  M([I], Fj.prototype, `toggleFavorite`, null),
  M([I], Fj.prototype, `makePersonal`, null),
  M([I], Fj.prototype, `makeWorkspace`, null),
  M([I], Fj.prototype, `toggleTeam`, null),
  Fj = Pj = M([mg(`Dashboard`)], Fj)
}
)), Lj, Rj = t(( () => {
  Oe(),
  Ac(),
  Od(),
  Lq(),
  iU(),
  mH(),
  GU(),
  F(),
  V(),
  Ih(),
  om(),
  N(),
  Lj = class extends Jh {
      static #e = this.loadStrategy = rm.partial;
      get isConfigurable() {
          return this.status === Dc.inProgress && this.mapping !== void 0
      }
      get isComplete() {
          return this.status === Dc.complete
      }
      get isDeletable() {
          return (this.status === Dc.error || this.status === Dc.complete || this.isConfigurable) && De(this.createdAt).diff(De(), `day`) <= 14
      }
      get hasProgress() {
          return this.progress === void 0 || this.progress === null ? !1 : this.status === Dc.inProcess || this.status === Dc.deleting
      }
      get isFetching() {
          return this.status === Dc.inProgress && this.mapping === void 0
      }
      isDeletableBy(e) {
          return this.isDeletable ? e.hasPermission(Cd.import) || this.creator?.id === e.id : !1
      }
      supportsRichFetchProgress() {
          return this.service === Tc.jira || this.service === Tc.asana
      }
      hasGatheredBasicWorkspaceInfo() {
          return this.fetchProgress?.ImportIssueData !== void 0
      }
  }
  ,
  M([R({
      persistence: `createOnly`
  })], Lj.prototype, `teamName`, void 0),
  M([R({
      persistence: `createOnly`,
      default: Tc.linear
  })], Lj.prototype, `service`, void 0),
  M([R({
      persistence: `createOnly`,
      default: Dc.notStarted
  })], Lj.prototype, `status`, void 0),
  M([R({
      persistence: `createOnly`
  })], Lj.prototype, `error`, void 0),
  M([R({
      persistence: `createOnly`
  })], Lj.prototype, `progress`, void 0),
  M([R({
      persistence: `createOnly`
  })], Lj.prototype, `stats`, void 0),
  M([R({
      serializer: Mh
  })], Lj.prototype, `mapping`, void 0),
  M([B( () => J, `issueImports`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], Lj.prototype, `creator`, void 0),
  M([R({
      persistence: `createOnly`
  })], Lj.prototype, `csvFileUrl`, void 0),
  M([B( () => K, `issueImports`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], Lj.prototype, `team`, void 0),
  M([B( () => q, `issueImports`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], Lj.prototype, `organization`, void 0),
  M([z( () => Y, {
      index: `issueImportId`,
      canSkipHydration: e => e.status !== Dc.complete || !e.stats?.issuesImported
  })], Lj.prototype, `issues`, void 0),
  M([R({
      persistence: `createOnly`
  })], Lj.prototype, `fetchProgress`, void 0),
  M([R({
      persistence: `createOnly`
  })], Lj.prototype, `errorMetadata`, void 0),
  M([R({
      persistence: `createOnly`
  })], Lj.prototype, `serviceMetadata`, void 0),
  Lj = M([mg(`IssueImport`)], Lj)
}
)), zj, Bj = t(( () => {
  zj = function(e) {
      return e.summary = `summary`,
      e.update = `update`,
      e
  }({})
}
)), Vj, Hj, Uj = t(( () => {
  Sy(),
  Bj(),
  Mu(),
  hQ(),
  XB(),
  AM(),
  V(),
  F(),
  om(),
  Ih(),
  GU(),
  iU(),
  mH(),
  ML(),
  sR(),
  N(),
  Hj = class extends Yh {
      static #e = Vj = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      get postType() {
          return this.type ?? zj.update
      }
      get isSummary() {
          return this.postType === zj.summary
      }
      get slug() {
          return `${ju(this.title || (this.isSummary ? `Pulse` : `Update`))}-${this.slugId}`
      }
      get numberOfComments() {
          return this.comments.filter(e => !e.isClone && !e.isRootSlackSyncedComment && !e.isRootUnsyncedSlackComment).length
      }
      static create(e) {
          let {bodyData: t, team: n, title: r} = e ?? {}
            , i = new Vj
            , a = pQ().user;
          return i.creator = a,
          i.team = n ?? a.teams.first,
          t && (i.bodyData = t),
          r && (i.title = r),
          i
      }
      get body() {
          return Hp.serialize(this.bodyData)
      }
      async formatAsMarkdown() {
          return [`[${(this.title || (this.team ? `${this.team.name} team update` : `Update`)).replace(/[\[\]]/g, `\\$&`)}](${bP(this)})
`, this.body].join(`
`)
      }
      markNotificationAsRead(e) {
          let t = this.notifications.find(t => t.id === e);
          if (!t)
              return;
          let n = t?.groupingEntityId;
          this.notifications.forEach(e => {
              e.readAt === void 0 && e.groupingEntityId === n && (e.markAsRead(),
              e.save())
          }
          )
      }
  }
  ,
  M([B( () => q, `posts`, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], Hj.prototype, `organization`, void 0),
  M([R({
      persistence: `none`
  })], Hj.prototype, `type`, void 0),
  M([R({
      persistence: `none`
  })], Hj.prototype, `feedSummaryScheduleAtCreate`, void 0),
  M([R({
      serializer: Mh,
      shallowObservation: !0,
      default: {}
  })], Hj.prototype, `bodyData`, void 0),
  M([R({
      serializer: Mh,
      persistence: `none`
  })], Hj.prototype, `writtenSummaryData`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0
  })], Hj.prototype, `creator`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Hj.prototype, `editedAt`, void 0),
  M([R({
      persistence: `none`,
      serializer: Mh,
      default: []
  })], Hj.prototype, `reactionData`, void 0),
  M([z( () => YB, {
      index: `postId`
  })], Hj.prototype, `comments`, void 0),
  M([z( () => kM, {
      index: `postId`
  })], Hj.prototype, `draftComments`, void 0),
  M([B( () => K, `posts`, {
      nullable: !0,
      indexed: !0
  })], Hj.prototype, `team`, void 0),
  M([B( () => J, `posts`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], Hj.prototype, `user`, void 0),
  M([R({
      persistence: `none`,
      default: ``,
      indexed: !0
  })], Hj.prototype, `slugId`, void 0),
  M([R({
      default: ``
  })], Hj.prototype, `title`, void 0),
  M([R({
      persistence: `none`,
      default: ``
  })], Hj.prototype, `evalLogId`, void 0),
  M([og( () => oR)], Hj.prototype, `notifications`, void 0),
  M([L], Hj.prototype, `postType`, null),
  M([L], Hj.prototype, `isSummary`, null),
  M([L], Hj.prototype, `slug`, null),
  M([L], Hj.prototype, `numberOfComments`, null),
  M([I], Hj.prototype, `markNotificationAsRead`, null),
  Hj = Vj = M([mg(`Post`)], Hj)
}
)), Wj, Gj, Kj = t(( () => {
  zn(),
  Wj = function(e) {
      return e.planned = `planned`,
      e.started = `started`,
      e.completed = `completed`,
      e.canceled = `canceled`,
      e
  }({}),
  (function(e) {
      e.releaseStageOrdering = Object.freeze({
          [Wj.planned]: 0,
          [Wj.started]: 1,
          [Wj.completed]: 2,
          [Wj.canceled]: 3
      }),
      e.labelForReleaseStageType = e => {
          switch (e) {
          case Wj.planned:
              return `Planned`;
          case Wj.started:
              return `Started`;
          case Wj.completed:
              return `Completed`;
          case Wj.canceled:
              return `Canceled`;
          default:
              return y(e),
              e
          }
      }
  }
  )(Gj ||= {})
}
)), qj, Jj = t(( () => {
  Kj(),
  qj = class e {
      static getReleaseStageOrder(e) {
          return Gj.releaseStageOrdering[e]
      }
      static getDefaultStageTypeColor(t) {
          let n = e.defaultStages.find(e => e.type === t);
          return n ? n.color : `#D7D8DB`
      }
      static #e = this.defaultStages = [{
          name: `Planned`,
          type: Wj.planned,
          color: `#D7D8DB`
      }, {
          name: `In Progress`,
          type: Wj.started,
          color: `#F2C94C`
      }, {
          name: `Completed`,
          type: Wj.completed,
          color: `#5E6AD2`
      }, {
          name: `Canceled`,
          type: Wj.canceled,
          color: `#8A8F98`
      }]
  }
}
)), Yj, Xj, Zj = t(( () => {
  Kj(),
  Jj(),
  V(),
  F(),
  om(),
  Nm(),
  Sm(),
  eM(),
  oM(),
  N(),
  Xj = class extends Jh {
      static #e = Yj = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static create(e) {
          let t = Yj.createEmpty();
          return t.name = e.name,
          t.pipeline = vm.wrap(e.pipeline),
          t.type = e.type ?? Wj.planned,
          t.position = e.position ?? 0,
          t.color = e.color ?? qj.getDefaultStageTypeColor(t.type),
          t
      }
  }
  ,
  M([R({
      default: ``
  })], Xj.prototype, `name`, void 0),
  M([R({
      default: `#D7D8DB`
  })], Xj.prototype, `color`, void 0),
  M([R({
      default: Wj.planned
  })], Xj.prototype, `type`, void 0),
  M([R({
      default: 0
  })], Xj.prototype, `position`, void 0),
  M([sg( () => $j, `stages`, {
      nullable: !1,
      optional: !1,
      indexed: !0,
      persistence: `createOnly`
  })], Xj.prototype, `pipeline`, void 0),
  M([z( () => aM, {
      index: `stageId`,
      order: new P(`createdAt`,`desc`)
  })], Xj.prototype, `releases`, void 0),
  Xj = Yj = M([mg(`ReleaseStage`)], Xj)
}
)), Qj, $j, eM = t(( () => {
  Jj(),
  V(),
  F(),
  om(),
  Nm(),
  Zj(),
  oM(),
  iU(),
  eu(),
  N(),
  $j = class extends Yh {
      static #e = Qj = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static create(e) {
          let t = Qj.createEmpty();
          return t.name = e.name,
          t
      }
      findFirstStageByType(e) {
          return this.stages.elements.find(t => t.type === e)
      }
      matchInlineFind(e) {
          return $l([this.name, this.slugId].join(`  `)).toLowerCase().indexOf(e) !== -1
      }
  }
  ,
  M([R({
      default: ``
  })], $j.prototype, `name`, void 0),
  M([R({
      indexed: !0,
      default: ``
  })], $j.prototype, `slugId`, void 0),
  M([B( () => q, `releasePipelines`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], $j.prototype, `organization`, void 0),
  M([z( () => Xj, {
      index: `pipelineId`,
      order: new P(e => qj.getReleaseStageOrder(e.type)).and(`position`)
  })], $j.prototype, `stages`, void 0),
  M([z( () => aM, {
      index: `pipelineId`,
      order: new P(`createdAt`,`desc`)
  })], $j.prototype, `releases`, void 0),
  $j = Qj = M([mg(`ReleasePipeline`)], $j)
}
)), tM, nM, rM = t(( () => {
  Lq(),
  oM(),
  V(),
  F(),
  om(),
  Sm(),
  N(),
  nM = class extends qh {
      static #e = tM = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialPreloadForTeam = am.firstPriority;
      static create(e) {
          let t = e.issue.issueToReleases.find(t => t.release.value === e.release);
          if (t)
              return t;
          let n = tM.createEmpty();
          return n.issue = vm.wrap(e.issue),
          n.release = vm.wrap(e.release),
          n
      }
  }
  ,
  M([sg( () => Y, `issueToReleases`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      trait: `useForPartialIndex`,
      cascadeHydration: !0
  })], nM.prototype, `issue`, void 0),
  M([sg( () => aM, `issueToReleases`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      cascadeHydration: !0
  })], nM.prototype, `release`, void 0),
  nM = tM = M([mg(`IssueToRelease`)], nM)
}
)), iM, aM, oM = t(( () => {
  zt(),
  V(),
  F(),
  om(),
  Vm(),
  Nm(),
  Sm(),
  eM(),
  Zj(),
  Lq(),
  eu(),
  rM(),
  iU(),
  N(),
  aM = class extends Jh {
      static #e = iM = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      get issues() {
          return Bm.of(Y, this.issueToReleases.map(e => e.issue.value).filter(Boolean))
      }
      static create(e) {
          let t = iM.createEmpty();
          return Mt( () => {
              t.name = e.name,
              t.pipeline = vm.wrap(e.pipeline),
              t.version = e.version,
              t.commitSha = e.commitSha,
              t.stage = e.stage ? vm.wrap(e.stage) : void 0
          }
          ),
          t
      }
      matchInlineFind(e) {
          return $l([this.name, this.version].join(`  `)).toLowerCase().indexOf(e) !== -1
      }
  }
  ,
  M([R({
      default: ``
  })], aM.prototype, `name`, void 0),
  M([R()], aM.prototype, `version`, void 0),
  M([R()], aM.prototype, `commitSha`, void 0),
  M([cg( () => q, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], aM.prototype, `organization`, void 0),
  M([sg( () => $j, `releases`, {
      nullable: !1,
      optional: !1,
      indexed: !0
  })], aM.prototype, `pipeline`, void 0),
  M([sg( () => Xj, `releases`, {
      nullable: !0,
      indexed: !0
  })], aM.prototype, `stage`, void 0),
  M([z( () => nM, {
      index: `releaseId`,
      order: new P(`createdAt`,`desc`)
  })], aM.prototype, `issueToReleases`, void 0),
  M([L], aM.prototype, `issues`, null),
  aM = iM = M([mg(`Release`)], aM)
}
)), sM, cM, lM = t(( () => {
  Mu(),
  V(),
  F(),
  Nm(),
  PR(),
  _M(),
  DM(),
  iz(),
  mH(),
  GU(),
  om(),
  Sm(),
  N(),
  cM = class extends Yh {
      static #e = sM = this;
      static #t = this.loadStrategy = rm.partial;
      get sourceModel() {
          return this.sourceProject || this.sourceInitiative || this.sourceTeam
      }
      get sourceModelLabel() {
          return this.sourceProject ? `Project` : this.sourceInitiative ? `Initiative` : `Team`
      }
      get slug() {
          return `${ju(this.name || `untitled`)}-${this.slugId}`
      }
      get organization() {
          return this.sourceModel.organization
      }
      static create(e) {
          let t = sM.createEmpty();
          t.name = e.name,
          t.icon = e.icon,
          t.color = e.color,
          t.creator = e.creator,
          t.updatedBy = e.updatedBy ?? e.creator;
          let n, r, i, a = e.parentFolder;
          return a ? (n = a.sourceProject,
          r = a.sourceInitiative,
          i = a.sourceTeam,
          t.parent = vm.wrap(a)) : (n = e.project,
          r = e.initiative,
          i = e.team),
          n ? t.sourceProject = n : r ? t.sourceInitiative = r : i && (t.sourceTeam = i),
          t
      }
      hasInlineFindContent(e) {
          return this.documents.some(t => t.matchInlineFind(e)) || this.links.some(t => t.matchInlineFind(e)) || this.children.some(t => t.hasInlineFindContent(e))
      }
  }
  ,
  M([R({
      default: ``
  })], cM.prototype, `name`, void 0),
  M([R()], cM.prototype, `icon`, void 0),
  M([R()], cM.prototype, `color`, void 0),
  M([R({
      persistence: `none`,
      indexed: !0,
      default: ``
  })], cM.prototype, `slugId`, void 0),
  M([R({
      default: 0
  })], cM.prototype, `sortOrder`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `none`
  })], cM.prototype, `creator`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `none`
  })], cM.prototype, `updatedBy`, void 0),
  M([B( () => K, `resourceFolders`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], cM.prototype, `sourceTeam`, void 0),
  M([B( () => G, `resourceFolders`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], cM.prototype, `sourceProject`, void 0),
  M([B( () => W, `resourceFolders`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], cM.prototype, `sourceInitiative`, void 0),
  M([z( () => NR, {
      index: `resourceFolderId`,
      order: new P(`sortOrder`)
  })], cM.prototype, `documents`, void 0),
  M([z( () => gM, {
      index: `resourceFolderId`,
      order: new P(`sortOrder`)
  })], cM.prototype, `links`, void 0),
  M([R()], cM.prototype, `layout`, void 0),
  M([z( () => cM, {
      index: `parentId`,
      order: new P(`sortOrder`)
  })], cM.prototype, `children`, void 0),
  M([sg( () => cM, `children`, {
      nullable: !0,
      indexed: !0,
      trait: `sameAsSelfPartial`
  })], cM.prototype, `parent`, void 0),
  cM = sM = M([mg(`ResourceFolder`)], cM)
}
));
async function tle(e, t) {
  try {
      let n = t.resolve(e);
      if (n)
          return n
  } catch (e) {
      w.info(`LoadModelWrapper failed to resolve`, e)
  }
  if (t.prefetch)
      try {
          await t.prefetch(e);
          let n = t.resolve(e);
          if (n)
              return n
      } catch (e) {
          w.info(`LoadModelWrapper failed to prefetch`, e)
      }
  if (t.resolveFromArchive)
      try {
          let n = await t.resolveFromArchive(e);
          if (n)
              return n
      } catch (e) {
          w.info(`LoadModelWrapper failed to resolve from archive`, e)
      }
  return await e.waitForSync(),
  t.resolve(e)
}
function uM(e, t) {
  return t === `active` ? e.activeCycle : t === `upcoming` ? e.upcomingCycle(0) : t === `previous` ? e.previousCycle : e.cycles.find(e => e.identifier === t)
}
var dM, fM, pM = t(( () => {
  Ru(),
  qa(),
  ws(),
  Oj(),
  kg(),
  Pz(),
  FB(),
  _H(),
  Ij(),
  PR(),
  DM(),
  lj(),
  Rj(),
  Uj(),
  iz(),
  UM(),
  rB(),
  TA(),
  kH(),
  oM(),
  eM(),
  lM(),
  GU(),
  Tm(),
  dM = {
      AgentSession: e => ({
          name: `Agent session`,
          resolve: t => t.findById(Dj, e),
          prefetch: t => t.hydrateModel(Dj, e)
      }),
      AiPrompt: e => ({
          name: `AI prompt`,
          resolve: t => Ka(e) ? t.findById(Og, e) : t.allModelsOfType(Og).find(t => t.slugId === e),
          prefetch: async t => Ka(e) ? t.hydrateModel(Og, e) : t.hydrateModels(Og, {
              key: `slugId`,
              value: e,
              coveringPartialIndexes: [wm.createPartialIndex({
                  modelClass: Og,
                  indexedKey: `slugId`,
                  keyValue: e
              })]
          })
      }),
      Customer: e => ({
          name: `Customer`,
          resolve: t => Ka(e) ? t.findById(MB, e) : t.allModelsOfType(MB).find(t => t.slugId === e),
          prefetch: async t => Ka(e) ? t.hydrateModel(MB, e) : t.hydrateModels(MB, {
              key: `slugId`,
              value: e,
              coveringPartialIndexes: [wm.createPartialIndex({
                  modelClass: MB,
                  indexedKey: `slugId`,
                  keyValue: e
              })]
          })
      }),
      CustomView: e => ({
          name: `View`,
          resolve: t => Ka(e) ? t.findById(Az, e) : t.allModelsOfType(Az).find(t => t.slugId === e),
          prefetch: t => Ka(e) ? t.hydrateModel(Az, e) : t.hydrateModels(Az, {
              key: `slugId`,
              value: e,
              coveringPartialIndexes: [wm.createPartialIndex({
                  modelClass: Az,
                  indexedKey: `slugId`,
                  keyValue: e
              })]
          }),
          resolveFromArchive: t => t.findArchivedByIdentifier(Az, e)
      }),
      Cycle: (e, t) => ({
          name: `Cycle`,
          resolve: () => {
              if (e.cycles.isHydrated())
                  return uM(e, t)
          }
          ,
          prefetch: () => e.cycles.hydrate(),
          resolveFromArchive: n => fM.includes(t) ? void 0 : n.findArchivedByIdentifier(gH, `${e.identifier}${t}`)
      }),
      Dashboard: e => ({
          name: `Dashboard`,
          resolve: t => Ka(e) ? t.findById(Fj, e) : t.allModelsOfType(Fj).find(t => t.slugId === e),
          prefetch: e => e.user.organization.allDashboards.hydrate(),
          resolveFromArchive: t => t.findArchivedByIdentifier(Fj, e)
      }),
      Document: e => ({
          name: `Document`,
          resolve: t => Ka(e) ? t.findById(NR, e) : t.allModelsOfType(NR).find(t => t.slugId === e),
          prefetch: async t => Ka(e) ? t.hydrateModel(NR, e) : t.hydrateModels(NR, {
              key: `slugId`,
              value: e,
              coveringPartialIndexes: [wm.createPartialIndex({
                  modelClass: NR,
                  indexedKey: `slugId`,
                  keyValue: e
              })]
          }),
          resolveFromArchive: t => t.findArchivedByIdentifier(NR, e)
      }),
      EmailIntakeAddress: e => ({
          name: `Email intake address`,
          resolve: t => t.organization.emailIntakeAddresses.find(t => t.type === Pu.asks && t.id === e),
          prefetch: async t => {
              let n = t.organization.emailIntakeAddresses.findById(e);
              n && await n.hydrateRelations([`team`, `template`])
          }
      }),
      Initiative: e => ({
          name: `Initiative`,
          resolve: t => Ka(e) ? t.findById(W, e) : t.organization.initiatives.find(t => t.slugId === e),
          resolveFromArchive: t => t.findArchivedByIdentifier(W, e)
      }),
      InitiativeUpdate: e => ({
          name: `Initiative update`,
          resolve: t => Ka(e) ? t.findById(cj, e) : t.allModelsOfType(cj).find(t => t.slugId === e),
          prefetch: async t => Ka(e) ? t.hydrateModel(cj, e) : t.hydrateModels(cj, {
              key: `slugId`,
              value: e,
              coveringPartialIndexes: [wm.createPartialIndex({
                  modelClass: cj,
                  indexedKey: `slugId`,
                  keyValue: e
              })]
          }),
          resolveFromArchive: t => t.findArchivedByIdentifier(cj, e)
      }),
      Integration: e => ({
          name: `Integration`,
          resolve: t => t.findById(nB, e),
          prefetch: async t => t.hydrateModel(nB, e)
      }),
      IssueImport: e => ({
          name: `Issue import`,
          resolve: t => t.findById(Lj, e),
          prefetch: async t => t.hydrateModel(Lj, e)
      }),
      OauthClientApproval: e => ({
          name: `Application install request`,
          prefetch: e => e.organization.oauthClientApprovals.hydrate(),
          resolve: t => t.organization.oauthClientApprovals.find(t => t.id === e)
      }),
      Post: e => ({
          name: `Post`,
          resolve: t => Ka(e) ? t.findById(Hj, e) : t.allModelsOfType(Hj).find(t => t.slugId === e),
          prefetch: async t => Ka(e) ? t.hydrateModel(Hj, e) : t.hydrateModels(Hj, {
              key: `slugId`,
              value: e,
              coveringPartialIndexes: [wm.createPartialIndex({
                  modelClass: Hj,
                  indexedKey: `slugId`,
                  keyValue: e
              })]
          }),
          resolveFromArchive: t => t.findArchivedByIdentifier(Hj, e)
      }),
      Project: e => ({
          name: `Project`,
          resolve: t => Ka(e) ? t.findById(G, e) : t.organization.projects.find(t => t.slugId === e),
          resolveFromArchive: t => t.findArchivedByIdentifier(G, e)
      }),
      ProjectUpdate: e => ({
          name: `Project update`,
          resolve: t => Ka(e) ? t.findById(HM, e) : t.allModelsOfType(HM).find(t => t.slugId === e),
          prefetch: async t => Ka(e) ? t.hydrateModel(HM, e) : t.hydrateModels(HM, {
              key: `slugId`,
              value: e,
              coveringPartialIndexes: [wm.createPartialIndex({
                  modelClass: HM,
                  indexedKey: `slugId`,
                  keyValue: e
              })]
          }),
          resolveFromArchive: t => t.findArchivedByIdentifier(HM, e)
      }),
      IssueLabel: e => ({
          name: `Label`,
          resolve: t => Ka(e) ? t.findById(OH, e) : t.organization.issueLabels.find(t => t.identifier === e),
          prefetch: async t => {
              Ka(e) && await t.hydrateModel(OH, e)
          }
      }),
      PullRequest: e => ({
          name: `Pull request`,
          resolve: t => Ka(e) ? t.findById(U, e) : t.allModelsOfType(U).find(t => t.slugId === e),
          prefetch: async t => Ka(e) ? t.hydrateModel(U, e) : t.hydrateModels(U, {
              key: `slugId`,
              value: e,
              coveringPartialIndexes: [wm.createPartialIndex({
                  modelClass: U,
                  indexedKey: `slugId`,
                  keyValue: e
              })]
          }),
          resolveFromArchive: t => t.findArchivedByIdentifier(U, e)
      }),
      Release: e => ({
          name: `Release`,
          resolve: t => t.findById(aM, e),
          prefetch: async t => t.hydrateModel(aM, e)
      }),
      ReleasePipeline: e => ({
          name: `Release pipeline`,
          resolve: t => Ka(e) ? t.findById($j, e) : t.allModelsOfType($j).find(t => t.slugId === e),
          prefetch: async t => Ka(e) ? t.hydrateModel($j, e) : t.hydrateModels($j, {
              key: `slugId`,
              value: e,
              coveringPartialIndexes: [wm.createPartialIndex({
                  modelClass: $j,
                  indexedKey: `slugId`,
                  keyValue: e
              })]
          })
      }),
      ResourceFolder: e => ({
          name: `Folder`,
          resolve: t => Ka(e) ? t.findById(cM, e) : t.allModelsOfType(cM).find(t => t.slugId === e),
          prefetch: async t => Ka(e) ? t.hydrateModel(cM, e) : t.hydrateModels(cM, {
              key: `slugId`,
              value: e,
              coveringPartialIndexes: [wm.createPartialIndex({
                  modelClass: cM,
                  indexedKey: `slugId`,
                  keyValue: e
              })]
          })
      }),
      Team: e => ({
          name: `Team`,
          resolve: t => t.organization.findTeamByKey(e)
      }),
      TeamLabel: (e, t) => ({
          name: `Label`,
          resolve: () => e.allIssueLabels.find(e => e.name.toLowerCase() === t.toLowerCase())
      }),
      Template: e => ({
          name: `Template`,
          resolve: t => t.organization.allTemplates.find(t => t.id === e),
          prefetch: e => e.organization.allTemplates.hydrate()
      }),
      User: e => ({
          name: `User`,
          resolve: t => Ka(e) ? t.findById(J, e) : t.organization.users.find(t => t.displayName === e)
      }),
      WorkspaceLabel: e => ({
          name: `Label`,
          resolve: t => t.organization.issueLabels.find(t => t.name.toLowerCase() === e.toLowerCase())
      }),
      WorkspaceProjectLabel: e => ({
          name: `Project label`,
          resolve: t => t.organization.allProjectLabels.find(t => t.name.toLowerCase() === e.toLowerCase())
      })
  },
  fM = [`active`, `upcoming`, `previous`]
}
)), mM, hM = t(( () => {
  Vg(),
  z_(),
  Xn(),
  PR(),
  TA(),
  hR(),
  pM(),
  Uj(),
  (function(e) {
      function t(e, t) {
          let n = e;
          for (let[e,r] of Object.entries(t)) {
              let t = RegExp(`:${e}\\??`);
              n = n.replace(t, r)
          }
          return n
      }
      e.generatePartialPath = t,
      e.getModelFromUrl = (e, t) => {
          if (!t.startsWith(Jn.CLIENT_URL))
              return null;
          let n = new URL(t)
            , r = n.pathname
            , [i,a] = Ig(r);
          if (!(`orgKey`in a) || a.orgKey !== e.organization.urlKey)
              return null;
          switch (i) {
          case Rg.issue:
              return e.findIssueByIdentifier(a.issueId, {
                  includePreviousIdentifiers: !0,
                  matchUUID: !0
              }) ?? null;
          case Rg.projectUpdate:
          case Rg.project:
              if (n.searchParams.has(`projectMilestoneId`) || R_.isProjectMilestoneURL(t)) {
                  let r = n.searchParams.get(`projectMilestoneId`) ?? R_.getProjectMilestoneId(t);
                  return r ? e.findById(mR, r) ?? null : null
              }
              let r = a.projectId;
              return e.organization.projects.find(e => e.id === r || r.endsWith(e.slugId)) ?? null;
          case Rg.initiativeUpdate:
          case Rg.initiative:
              let i = a.initiativeId;
              return e.organization.initiatives.find(e => e.id === i || i.endsWith(e.slugId)) ?? null;
          case Rg.dashboard:
          case Rg.dashboardWidget:
              {
                  let t = Lg(a.dashboardId);
                  return e.organization.allDashboards.find(e => e.id === t || e.slugId === t) ?? null
              }
          case Rg.document:
              {
                  let t = Lg(a.documentId);
                  return e.allModelsOfType(NR).find(e => e.id === t || e.slugId === t) ?? null
              }
          case Rg.customView:
          case Rg.projectFacet:
          case Rg.allProjectsFacet:
          case Rg.teamIssuesFacet:
          case Rg.pulseFacet:
          case Rg.initiativeFacet:
              let o = a.customViewId;
              return e.organization.allCustomViews.find(e => e.id === o || e.slugId !== void 0 && o.endsWith(e.slugId)) ?? null;
          case Rg.customer:
              let s = a.customerId;
              return e.organization.customers.find(e => e.id === s || s.endsWith(e.slugId)) ?? null;
          case Rg.review:
              let c = a.reviewId;
              return e.allModelsOfType(U).find(e => e.id === c || c.endsWith(e.slugId)) ?? null;
          case Rg.cycle:
              let l = a.teamKey
                , u = e.organization.accessibleTeams.find(e => e.key === l);
              return u ? uM(u, a.cycleIdentifier) ?? null : null;
          case Rg.teamUpdate:
          case Rg.post:
              let d = a.postId;
              return e.allModelsOfType(Hj).find(e => e.id === d || d.endsWith(e.slugId)) ?? null;
          case Rg.user:
              {
                  let t = a.displayName;
                  return e.organization.users.find(e => e.id === t || e.displayName === t) ?? null
              }
          default:
              return null
          }
      }
      ,
      e.removeNoRedirect = e => e.replace(/[\?&]noRedirect=\d+/, ``);
      function n(e) {
          return e.startsWith(`${Jn.CLIENT_URL ?? ``}/`) || e.startsWith(`https://linear.app/`)
      }
      e.isLinearDomain = n;
      function r(e) {
          return e.replace(/^(?:https?:\/\/)?(?:www\.)?/i, ``)
      }
      e.removeProtocolAndWww = r;
      function i(e) {
          return r(new URL(e).hostname)
      }
      e.topLevelDomain = i
  }
  )(mM ||= {})
}
)), gM, _M = t(( () => {
  Xn(),
  hQ(),
  hM(),
  V(),
  F(),
  GU(),
  iz(),
  DM(),
  Lq(),
  om(),
  mH(),
  lM(),
  eu(),
  N(),
  gM = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      get parent() {
          return this.initiative ?? this.project ?? this.team
      }
      get enrichedLabel() {
          if (this.label !== Jn.CLIENT_HOSTNAME)
              return this.label;
          let e = mM.getModelFromUrl(pQ(), this.url);
          if (e) {
              if (e instanceof Y)
                  return e.title;
              if (e instanceof W || e instanceof G || e instanceof K)
                  return e.name
          }
          return this.label
      }
      setLabel(e) {
          if (e && e !== ``)
              this.label = e;
          else if (this.url) {
              let {hostname: e} = new URL(this.url);
              this.label = e.startsWith(`www.`) ? e.slice(4) : e
          }
      }
      matchInlineFind(e) {
          return $l(this.enrichedLabel).toLowerCase().indexOf(e) !== -1
      }
  }
  ,
  M([R({
      default: ``
  })], gM.prototype, `url`, void 0),
  M([R({
      default: ``
  })], gM.prototype, `label`, void 0),
  M([R({
      default: 0
  })], gM.prototype, `sortOrder`, void 0),
  M([B( () => W, `links`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], gM.prototype, `initiative`, void 0),
  M([B( () => G, `links`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], gM.prototype, `project`, void 0),
  M([B( () => K, `links`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], gM.prototype, `team`, void 0),
  M([sg( () => cM, `links`, {
      nullable: !0,
      indexed: !0
  })], gM.prototype, `resourceFolder`, void 0),
  M([cg( () => J, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], gM.prototype, `creator`, void 0),
  M([L], gM.prototype, `enrichedLabel`, null),
  gM = M([mg(`EntityExternalLink`)], gM)
}
)), vM, yM = t(( () => {
  V(),
  om(),
  F(),
  DM(),
  N(),
  vM = class extends qh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular
  }
  ,
  M([B( () => W, `history`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], vM.prototype, `initiative`, void 0),
  M([R({
      default: []
  })], vM.prototype, `entries`, void 0),
  vM = M([mg(`InitiativeHistory`)], vM)
}
)), bM, xM = t(( () => {
  V(),
  Ih(),
  F(),
  iz(),
  GU(),
  Lq(),
  PR(),
  om(),
  DM(),
  N(),
  bM = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.full;
      get parent() {
          return this.issue?.value ?? this.document?.value ?? this.project ?? this.initiative.value
      }
  }
  ,
  M([R()], bM.prototype, `comment`, void 0),
  M([B( () => G, `reminders`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], bM.prototype, `project`, void 0),
  M([sg( () => Y, `reminders`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], bM.prototype, `issue`, void 0),
  M([sg( () => NR, `reminders`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], bM.prototype, `document`, void 0),
  M([sg( () => W, `reminders`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], bM.prototype, `initiative`, void 0),
  M([B( () => J, `reminders`, {
      nullable: !1,
      optional: !1,
      indexed: !0,
      persistence: `none`
  })], bM.prototype, `user`, void 0),
  M([R({
      serializer: Ah
  })], bM.prototype, `remindAt`, void 0),
  M([R({
      serializer: Fh,
      persistence: `createOnly`
  })], bM.prototype, `schedule`, void 0),
  M([L], bM.prototype, `parent`, null),
  bM = M([mg(`Reminder`)], bM)
}
)), SM, CM, wM = t(( () => {
  DM(),
  V(),
  F(),
  nx(),
  N(),
  CM = SM = class extends Yh {
      static create(e) {
          let t = SM.createEmpty();
          return t.initiative = e.initiative,
          t.relatedInitiative = e.relatedInitiative,
          t.sortOrder = e.sortOrder ?? tx.lastSortOrder(e.initiative.childRelations, `sortOrder`),
          t
      }
  }
  ,
  M([B( () => W, `childRelations`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], CM.prototype, `initiative`, void 0),
  M([B( () => W, `parentRelations`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], CM.prototype, `relatedInitiative`, void 0),
  M([R({
      default: 0
  })], CM.prototype, `sortOrder`, void 0),
  CM = SM = M([mg(`InitiativeRelation`)], CM)
}
)), TM, EM, W, DM = t(( () => {
  zt(),
  TM = e(Ee(), 1),
  UT(),
  Bu(),
  Mu(),
  KT(),
  Rb(),
  zn(),
  $se(),
  cc(),
  Un(),
  jb(),
  Hb(),
  Gb(),
  Ev(),
  GU(),
  iU(),
  iz(),
  bH(),
  mH(),
  V(),
  F(),
  FA(),
  Vm(),
  Nm(),
  RA(),
  PR(),
  HA(),
  nx(),
  Pz(),
  eu(),
  lj(),
  AM(),
  Dce(),
  Ih(),
  gx(),
  _M(),
  sR(),
  yM(),
  xM(),
  wM(),
  lM(),
  rk(),
  N(),
  W = EM = class extends Xh {
      get parent() {
          if (this.organization.subInitiativesAvailable)
              return this.parentRelations.find(e => e.relatedInitiative.id === this.id)?.initiative
      }
      get children() {
          return this.organization.subInitiativesAvailable ? new Bm(EM,this.childRelations.map(e => e.relatedInitiative)) : new Bm(EM,[])
      }
      get descendants() {
          return new Bm(EM,this.children.reduce( (e, t) => (e.push(t, ...t.descendants),
          e), []),{
              order: dj
          })
      }
      get orgReminderFrequency() {
          return this.organization.initiativeUpdateReminderFrequencyInWeeks
      }
      get effectiveUpdateReminderFrequency() {
          return this.updateReminderFrequency ?? this.organization.initiativeUpdateReminderFrequencyInWeeks ?? 0
      }
      get effectiveUpdateReminderHour() {
          return this.updateReminderFrequency != null && this.updateRemindersHour != null ? this.updateRemindersHour : this.organization.initiativeUpdateRemindersHour
      }
      get effectiveUpdateReminderDay() {
          return this.updateReminderFrequency != null && this.updateRemindersDay != null ? this.updateRemindersDay : this.organization.initiativeUpdateRemindersDay
      }
      get effectiveUpdateReminderFrequencyResolution() {
          return this.updateReminderFrequency == null ? Ab.weekly : this.frequencyResolution
      }
      get slug() {
          return `${ju(this.name)}-${this.slugId}`
      }
      get healthAgeInDays() {
          return Vb.getHealthAgeInDays(this)
      }
      get healthWithAge() {
          return Vb.getHealthWithAge(this)
      }
      get healthIsStale() {
          return Vb.healthIsOutdated(this)
      }
      get healthIsSlightlyOutdated() {
          return Vb.healthIsSlightlyOutdated(this)
      }
      get isActive() {
          return this.status === GT.Active
      }
      isUserExpectedToWriteUpdate(e) {
          return this.isActive && e.memberOf(this)
      }
      getViewPreferences(e) {
          return e === k.initiativeOverview ? this._projectsViewPreferencesOverview : e === k.initiativeOverviewSubInitiatives ? this._subInitiativesViewPreferences : this._projectsViewPreferences
      }
      get _projectsViewPreferences() {
          return NA.getOrCreateFrom(this.viewPreferences, k.initiative, {
              initiative: this
          })
      }
      get _projectsViewPreferencesOverview() {
          return NA.getOrCreateFrom(this.viewPreferences, k.initiativeOverview, {
              initiative: this
          })
      }
      get _subInitiativesViewPreferences() {
          return NA.getOrCreateFrom(this.viewPreferences, k.initiativeOverviewSubInitiatives, {
              initiative: this
          })
      }
      get progressHistoryEntries() {
          return this.projectsInherited.flatMap(e => e.progressHistoryEntries)
      }
      get reminder() {
          return this.reminders.elements[0]
      }
      get organizationViewPreferences() {
          return this.organization.viewPreferences.find(e => e.initiative === this && e.type === HT.organization) || (this.temporaryViewPreferences ? this.temporaryViewPreferences : Mt( () => {
              let e = new NA;
              return e.initiative = this,
              e.organization = this.organization,
              e.viewType = k.initiative,
              e.type = HT.organization,
              this.temporaryViewPreferences = e,
              e
          }
          ))
      }
      get projects() {
          return Bm.of(G, this.initiativeToProjects.map(e => e.project))
      }
      get projectsInherited() {
          return this.organization.subInitiativesAvailable ? new nk(G,[this.projects, ...this.descendants.map(e => e.projects)],{
              dedupe: !0
          }) : this.projects
      }
      get projectsInheritedOnly() {
          return this.organization.subInitiativesAvailable ? new nk(G,this.descendants.map(e => e.projects),{
              dedupe: !0
          }) : Bm.of(G, [])
      }
      get projectsGroupedByHealth() {
          let e = {
              [Fb.onTrack]: [],
              [Fb.offTrack]: [],
              [Fb.atRisk]: [],
              [Ib.outdated]: [],
              [Ib.noUpdate]: []
          };
          for (let t of this.projectsInherited.elements)
              e[Vb.getHealthWithAge({
                  health: t.health,
                  healthAgeInDays: t.healthAgeInDays,
                  isActive: t.isActive,
                  isDone: t.isDone,
                  updateReminderFrequency: t.updateReminderFrequency,
                  frequencyResolution: t.frequencyResolution,
                  orgReminderFrequency: this.organization.projectUpdateReminderFrequencyInWeeks
              })].push(t);
          return e
      }
      get velocity() {
          return this.projectsInherited.filter(e => e.activity > (e.isActive ? 0 : 3)).reduce( (e, t) => e + t.currentVelocity, 0)
      }
      get activity() {
          let e = this.velocity
            , t = this.organization.initiativeVelocityDeciles;
          if (t.length <= 8)
              return 0;
          for (let n = 0; n < t.length; n++)
              if (e <= t[n])
                  return n;
          return 9
      }
      get activityType() {
          return Wb.getActivityType(this.activity)
      }
      get accessibleTeams() {
          let e = this.projectsInherited;
          if (e.length === 0)
              return Bm.of(K, []);
          let t = new Map;
          for (let n of e)
              for (let e of n.administrableTeams.elements) {
                  let n = t.get(e.id);
                  n ? n.count++ : t.set(e.id, {
                      team: e,
                      count: 1
                  })
              }
          return Bm.of(K, Array.from(t.values()).sort( (e, t) => t.count - e.count).map( ({team: e}) => e).filter(e => e.userCanAccessTeam(q.store.user)))
      }
      get teams() {
          return this.accessibleTeams
      }
      get parents() {
          return Bm.of(EM, this.parent ? [this.parent] : [])
      }
      get ancestors() {
          let e = []
            , t = this.parent;
          for (; t; )
              e.push(t),
              t = t.parent;
          return Bm.of(EM, e)
      }
      get ancestorData() {
          let e = this.ancestors.elements;
          return {
              array: e.toReversed(),
              set: new Set(e)
          }
      }
      get hasSubInitiatives() {
          return this.children.length > 0
      }
      get isDone() {
          return this.status === GT.Completed
      }
      get allDocumentTemplates() {
          return new Bm(hx,[],{
              order: new P(e => !e.isTeamTemplate).and(e => e.name.toLowerCase())
          }).concat(this.accessibleTeams.reduce( (e, t) => e.concat(t.documentTemplates.elements), [])).concat(this.organization.documentTemplates.elements)
      }
      get statusSortOrder() {
          switch (this.status) {
          case GT.Active:
              return 0;
          case GT.Planned:
              return 1;
          case GT.Completed:
              return 2;
          default:
              throw y(this.status)
          }
      }
      get hasUpdateDrafts() {
          return this.draftInitiativeUpdates.length > 0
      }
      get lastDraft() {
          return this.draftInitiativeUpdates.first
      }
      get lastPostedUpdate() {
          return this.lastUpdate?.value ?? this.initiativeUpdates.first
      }
      static create(e) {
          let t = EM.createEmpty();
          return EM.applyDefaultValues(t, e)
      }
      static applyDefaultValues(e, t) {
          return e.temporaryViewPreferences = t.viewPreferences,
          e.creator = t.creator,
          e.name = t.name ?? ``,
          e.status = t.status ?? GT.Active,
          e.description = t.description,
          e.organization = t.creator.organization,
          e.sortOrder = tx.firstSortOrder(t.creator.organization.initiatives, `sortOrder`),
          e.color = t.color ?? (0,
          TM.default)(Tv.colorsList) ?? Tv.defaultTeamIconBackground,
          e
      }
      get isRootFavorited() {
          return this.favorites.some(e => e.initiativeTab == null)
      }
      toggleFavorite(e={}) {
          let {initiativeTab: t} = e
            , n = t ? this.favorites.filter(e => e.initiativeTab === t) : this.favorites.filter(e => e.initiativeTab == null);
          if (n.length > 0)
              return n.forEach(e => e.delete()),
              !1;
          {
              let e = yH.create({
                  reference: this,
                  initiativeTab: t
              });
              return e.save(!0),
              e
          }
      }
      markNotificationAsRead(e) {
          let t = this.notifications.find(t => t.id === e);
          if (!t)
              return;
          let n = t?.groupingEntityId;
          this.notifications.forEach(e => {
              e.readAt === void 0 && e.groupingEntityId === n && (e.markAsRead(),
              e.save())
          }
          )
      }
      matchInlineFind(e) {
          let t = $l([this.name].concat([this.owner?.name, this.owner?.displayName].concrete()).join(` `)).toLowerCase();
          return e.split(` `).reduce( (e, n) => e && t.indexOf(n) !== -1, !0)
      }
      getTrait(e) {
          return sc(this.traits, e)
      }
      getIntegration(e) {
          return this.organization.getIntegration(e, e => e.initiative?.id === this.id)
      }
  }
  ,
  M([R({
      default: ``
  })], W.prototype, `name`, void 0),
  M([R()], W.prototype, `description`, void 0),
  M([R({
      persistence: `none`,
      default: ``
  })], W.prototype, `slugId`, void 0),
  M([R({
      default: 0
  })], W.prototype, `sortOrder`, void 0),
  M([R({
      default: `#bec2c8`
  })], W.prototype, `color`, void 0),
  M([R()], W.prototype, `icon`, void 0),
  M([R({
      persistence: `updateOnly`
  })], W.prototype, `trashed`, void 0),
  M([B( () => q, `initiatives`, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], W.prototype, `organization`, void 0),
  M([B( () => J, `initiatives`, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], W.prototype, `creator`, void 0),
  M([L], W.prototype, `parent`, null),
  M([L], W.prototype, `children`, null),
  M([L], W.prototype, `descendants`, null),
  M([B( () => J, `initiatives`, {
      nullable: !0,
      persistence: `createAndUpdate`
  })], W.prototype, `owner`, void 0),
  M([z( () => Az, {
      index: `initiativeId`,
      order: new P(`name`)
  })], W.prototype, `customViews`, void 0),
  M([z( () => cj, {
      index: `initiativeId`,
      order: new P(`createdAt`,`desc`)
  })], W.prototype, `initiativeUpdates`, void 0),
  M([lg( () => cj, {
      nullable: !0,
      indexed: !0,
      onDelete: `SET NULL`,
      persistence: `none`
  })], W.prototype, `lastUpdate`, void 0),
  M([dg({
      nullable: !0
  })], W.prototype, `integrationsSettings`, void 0),
  M([og( () => kM, {
      order: new P(`createdAt`,`desc`)
  })], W.prototype, `draftInitiativeUpdates`, void 0),
  M([z( () => vM, {
      index: `initiativeId`
  })], W.prototype, `history`, void 0),
  M([og( () => CM, {
      order: new P(`sortOrder`)
  })], W.prototype, `childRelations`, void 0),
  M([og( () => CM, {
      order: new P(`sortOrder`)
  })], W.prototype, `parentRelations`, void 0),
  M([z( () => bM, {
      index: `initiativeId`,
      order: new P(`createdAt`,`desc`)
  })], W.prototype, `reminders`, void 0),
  M([z( () => cM, {
      index: `sourceInitiativeId`,
      order: new P(`sortOrder`),
      canSkipHydration: () => !0
  })], W.prototype, `resourceFolders`, void 0),
  M([dg({
      nullable: !0
  })], W.prototype, `documentContent`, void 0),
  M([R({
      serializer: jh
  })], W.prototype, `targetDate`, void 0),
  M([R()], W.prototype, `targetDateResolution`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], W.prototype, `startedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], W.prototype, `completedAt`, void 0),
  M([R({
      default: GT.Active
  })], W.prototype, `status`, void 0),
  M([R({
      persistence: `none`
  })], W.prototype, `traits`, void 0),
  M([og( () => yH)], W.prototype, `favorites`, void 0),
  M([z( () => NR, {
      index: `initiativeId`,
      order: new P(`createdAt`,`desc`),
      canSkipHydration: e => !e.getTrait(qT.hasDocuments)
  })], W.prototype, `documents`, void 0),
  M([z( () => gM, {
      index: `initiativeId`,
      order: new P(`createdAt`,`desc`)
  })], W.prototype, `links`, void 0),
  M([ug({
      nullable: !0
  })], W.prototype, `subscription`, void 0),
  M([z( () => VA, {
      index: `sourceInitiativeId`,
      order: new P(`sortOrder`)
  })], W.prototype, `facets`, void 0),
  M([R({
      persistence: `none`
  })], W.prototype, `health`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], W.prototype, `healthUpdatedAt`, void 0),
  M([R({
      persistence: `updateOnly`
  })], W.prototype, `updateReminderFrequency`, void 0),
  M([R({
      persistence: `updateOnly`
  })], W.prototype, `frequencyResolution`, void 0),
  M([R({
      enum: Vn,
      persistence: `updateOnly`
  })], W.prototype, `updateRemindersDay`, void 0),
  M([R({
      persistence: `updateOnly`
  })], W.prototype, `updateRemindersHour`, void 0),
  M([og( () => LA, {
      order: new P(`sortOrder`)
  })], W.prototype, `initiativeToProjects`, void 0),
  M([z( () => NA, {
      index: `initiativeId`,
      canSkipHydration: e => e.organization.viewPreferences.isHydrated()
  })], W.prototype, `viewPreferences`, void 0),
  M([L], W.prototype, `_projectsViewPreferences`, null),
  M([L], W.prototype, `_projectsViewPreferencesOverview`, null),
  M([L], W.prototype, `_subInitiativesViewPreferences`, null),
  M([L], W.prototype, `progressHistoryEntries`, null),
  M([L], W.prototype, `reminder`, null),
  M([L], W.prototype, `organizationViewPreferences`, null),
  M([L], W.prototype, `projects`, null),
  M([L], W.prototype, `projectsInherited`, null),
  M([L], W.prototype, `projectsInheritedOnly`, null),
  M([L], W.prototype, `projectsGroupedByHealth`, null),
  M([og( () => $L)], W.prototype, `notifications`, void 0),
  M([L], W.prototype, `velocity`, null),
  M([L], W.prototype, `activity`, null),
  M([L], W.prototype, `activityType`, null),
  M([L], W.prototype, `accessibleTeams`, null),
  M([L], W.prototype, `teams`, null),
  M([L], W.prototype, `parents`, null),
  M([L], W.prototype, `ancestors`, null),
  M([L({
      keepAlive: !0
  })], W.prototype, `ancestorData`, null),
  M([L], W.prototype, `hasSubInitiatives`, null),
  M([L], W.prototype, `allDocumentTemplates`, null),
  M([L], W.prototype, `statusSortOrder`, null),
  M([L], W.prototype, `isRootFavorited`, null),
  M([I], W.prototype, `toggleFavorite`, null),
  M([I], W.prototype, `markNotificationAsRead`, null),
  W = EM = M([mg(`Initiative`)], W)
}
)), OM, kM, AM = t(( () => {
  zn(),
  ml(),
  VT(),
  Lq(),
  V(),
  F(),
  Ih(),
  iz(),
  XB(),
  GU(),
  Sm(),
  UM(),
  ML(),
  DM(),
  lj(),
  TA(),
  qk(),
  Uj(),
  mH(),
  N(),
  kM = OM = class extends Yh {
      get parentModel() {
          return this.issue?.value ?? this.project ?? this.initiative ?? this.parentComment?.value ?? this.projectUpdate?.value ?? this.post?.value ?? this.initiativeUpdate?.value ?? this.pullRequest?.value ?? this.parentPullRequestComment?.value ?? this.team?.value
      }
      set parentModel(e) {
          switch (!0) {
          case e instanceof Y:
              this.issue = vm.wrap(e);
              break;
          case e instanceof G:
              this.project = e;
              break;
          case e instanceof YB:
              this.parentComment = vm.wrap(e);
              break;
          case e instanceof HM:
              this.projectUpdate = vm.wrap(e);
              break;
          case e instanceof Hj:
              this.post = vm.wrap(e);
              break;
          case e instanceof W:
              this.initiative = e;
              break;
          case e instanceof cj:
              this.initiativeUpdate = vm.wrap(e);
              break;
          case e instanceof U:
              this.pullRequest = vm.wrap(e);
              break;
          case e instanceof Kk:
              this.parentPullRequestComment = vm.wrap(e);
              break;
          case e instanceof K:
              this.team = vm.wrap(e);
              break;
          default:
              y(e)
          }
      }
      get topLevelModel() {
          let e = this.parentModel;
          if (e)
              return (e instanceof YB || e instanceof Kk) && e.isHydrated() ? e.parentModel : e
      }
      get location() {
          let e = ``
            , t = {
              draftId: this.id
          }
            , n = this.parentModel
            , r = this.topLevelModel;
          if (!n || !r)
              return;
          n instanceof YB && n.isHydrated() ? (e = DI(n),
          t.highlightCommentThreadInput = !0) : r instanceof Y ? (e ||= CI(r),
          t.highlightCommentComposer = !0) : r instanceof G ? (e ||= uL(r),
          t.highlightUpdateComposer = !0) : r instanceof W ? (e ||= gL(r),
          t.highlightUpdateComposer = !0) : n instanceof HM || n instanceof cj ? (e ||= fL(n),
          t.highlightCommentComposer = !0) : n instanceof U ? (e ||= QF(n),
          t.highlightCommentComposer = !0) : n instanceof Kk && n.isHydrated() && (e ||= eI(n),
          t.highlightCommentThreadInput = !0);
          let i = new URL(e,window.location.origin);
          return {
              to: {
                  pathname: i.pathname,
                  hash: i.hash
              },
              state: t
          }
      }
      get bodyTextContent() {
          return this.bodyData ? gy(dl.nodeFromJSON(this.bodyData)) : ``
      }
      get bodyPersistable() {
          if (this.bodyData) {
              if (this.bodyTextContent.trim().length >= 3)
                  return !0;
              let e = dl.nodeFromJSON(this.bodyData)
                , t = !1;
              return e.nodesBetween(0, e.content.size, e => {
                  if (t)
                      return !1;
                  t = [`embed`, `file`, `figma`, `iframe`, `image`, `video`, `suggestion_userMentions`, `issueMention`, `entityMention`, `entityEmbed`, `documentMention`, `emoji`].includes(e.type.name)
              }
              ),
              t
          }
          return !1
      }
      static hasDraft(e, t) {
          return this.getDraftForModel(e, t) !== void 0
      }
      static getDraftForModel(e, t, n) {
          return ( () => {
              switch (!0) {
              case e instanceof Y:
                  return e.draftComments;
              case e instanceof G:
                  return e.draftProjectUpdates;
              case e instanceof HM:
                  return e.draftComments;
              case e instanceof YB:
                  return e.draftReplies;
              case e instanceof cj:
                  return e.draftComments;
              case e instanceof Hj:
                  return e.draftComments;
              case e instanceof W:
                  return e.draftInitiativeUpdates;
              case e instanceof U:
                  return e.draftComments;
              case e instanceof Kk:
                  return e.draftReplies;
              case e instanceof K:
                  return e.draftPosts;
              default:
                  y(e);
                  return
              }
          }
          )()?.find(e => e.user.id === t.id && e.anchor === n)
      }
      static upsertDraftForModel(e, t, n, r) {
          let i = this.getDraftForModel(e, t);
          if (i)
              i.bodyData = n,
              i.data = {
                  ...i.data,
                  ...r
              },
              i.save();
          else {
              let i = new OM;
              i.bodyData = n,
              i.data = r ?? {},
              i.user = t,
              i.parentModel = e,
              i.save(!0, {
                  transactionOptions: {
                      preventUndo: !0
                  }
              })
          }
      }
  }
  ,
  M([B( () => J, `drafts`, {
      nullable: !1,
      optional: !1,
      persistence: `createOnly`
  })], kM.prototype, `user`, void 0),
  M([R({
      persistence: `none`,
      default: !1
  })], kM.prototype, `isAutogenerated`, void 0),
  M([R({
      persistence: `createOnly`,
      default: !1
  })], kM.prototype, `wasLocalDraft`, void 0),
  M([R({
      default: {}
  })], kM.prototype, `data`, void 0),
  M([R()], kM.prototype, `anchor`, void 0),
  M([sg( () => Y, `draftComments`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      cascadeHydration: !0,
      persistence: `createOnly`
  })], kM.prototype, `issue`, void 0),
  M([sg( () => K, `draftPosts`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createAndUpdate`
  })], kM.prototype, `team`, void 0),
  M([B( () => G, `draftProjectUpdates`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createAndUpdate`
  })], kM.prototype, `project`, void 0),
  M([sg( () => HM, `draftComments`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], kM.prototype, `projectUpdate`, void 0),
  M([B( () => W, `draftInitiativeUpdates`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createAndUpdate`
  })], kM.prototype, `initiative`, void 0),
  M([sg( () => cj, `draftComments`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], kM.prototype, `initiativeUpdate`, void 0),
  M([sg( () => Hj, `draftComments`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], kM.prototype, `post`, void 0),
  M([sg( () => YB, `draftReplies`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      cascadeHydration: !0,
      persistence: `createOnly`
  })], kM.prototype, `parentComment`, void 0),
  M([sg( () => U, `draftComments`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], kM.prototype, `pullRequest`, void 0),
  M([sg( () => Kk, `draftReplies`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      cascadeHydration: !0,
      persistence: `createOnly`
  })], kM.prototype, `parentPullRequestComment`, void 0),
  M([R({
      serializer: Mh,
      default: {}
  })], kM.prototype, `bodyData`, void 0),
  M([L], kM.prototype, `parentModel`, null),
  M([L], kM.prototype, `topLevelModel`, null),
  M([L], kM.prototype, `location`, null),
  M([L], kM.prototype, `bodyTextContent`, null),
  M([L], kM.prototype, `bodyPersistable`, null),
  kM = OM = M([mg(`Draft`)], kM)
}
)), jM, MM, NM, PM, FM, IM, LM, nle = t(( () => {
  jM = e(v(), 1),
  Yr(),
  gc(),
  Cc(),
  Zc(),
  (function(e) {
      function t(e) {
          let t = e.completedCount + Sc.progressMultipliers[E.started] * e.startedCount === 0 ? 0 : (e.completedCount + Sc.progressMultipliers[E.started] * e.startedCount) / (e.completedCount + e.unstartedCount + e.startedCount + e.backlogCount);
          return t = Math.round(t * 100),
          {
              progress: t,
              status: t === 0 ? `unstarted` : t === 100 ? `done` : `next`
          }
      }
      e.getIssueInfoProgressAndStatus = t;
      function n(e, n, r, i) {
          let a = e.statusId === n.statusId ? void 0 : {
              from: n.statusId,
              to: e.statusId
          }
            , o = e.priority === n.priority ? void 0 : {
              from: n.priority,
              to: e.priority
          }
            , s = n.startDate ? Yc.format({
              date: n.startDate,
              resolution: n.startDateResolution
          }, {
              fiscalYearStartMonth: i
          }) : void 0
            , c = e.startDate ? Yc.format({
              date: e.startDate,
              resolution: e.startDateResolution
          }, {
              fiscalYearStartMonth: i
          }) : void 0
            , l = s === c ? void 0 : {
              from: s,
              to: c
          }
            , u = n.targetDate ? Yc.format({
              date: n.targetDate,
              resolution: n.targetDateResolution
          }, {
              fiscalYearStartMonth: i
          }) : void 0
            , d = e.targetDate ? Yc.format({
              date: e.targetDate,
              resolution: e.targetDateResolution
          }, {
              fiscalYearStartMonth: i
          }) : void 0
            , f = u === d ? void 0 : {
              from: u,
              to: d
          }
            , p = e.leadId === n.leadId ? void 0 : {
              from: n.leadId,
              to: e.leadId
          }
            , m = e.memberIds.filter(e => !n.memberIds.some(t => t === e))
            , h = n.memberIds.filter(t => !e.memberIds.some(e => e === t))
            , g = e.memberIds.join(``) === n.memberIds.join(``) ? void 0 : {
              added: m.length > 0 ? m : void 0,
              removed: h.length > 0 ? h : void 0
          }
            , _ = e.teamsInfo.map(e => e.id)
            , ee = n.teamsInfo.map(e => e.id)
            , te = _.filter(e => !ee.some(t => t === e))
            , ne = ee.filter(e => !_.some(t => t === e))
            , re = _.join(``) === ee.join(``) ? void 0 : {
              added: te.length > 0 ? te : void 0,
              removed: ne.length > 0 ? ne : void 0
          }
            , ie = n.milestonesInfo.map(e => {
              let {progress: n, status: r} = t(e.issueInfo);
              return {
                  ...e,
                  progress: n,
                  status: r
              }
          }
          )
            , ae = (0,
          jM.default)(e.milestonesInfo.map(e => {
              let {progress: n, status: r} = t(e.issueInfo);
              return {
                  ...e,
                  progress: n,
                  status: r
              }
          }
          ), e => !ie.some(t => t.id === e.id))
            , oe = ae[0]
            , se = ae[1]
            , ce = ie.filter(e => !se.some(t => t.id === e.id));
          oe = oe.filter(e => e.progress > 0 || e.targetDate !== void 0),
          ce = ce.filter(e => e.progress > 0);
          let le = oe.length > 0 || se.length > 0 || ie.length > 0 ? {
              added: oe.length > 0 ? oe : void 0,
              removed: ce.length > 0 ? ce : void 0,
              changed: se.map(e => {
                  let t = ie.find(t => t.id === e.id);
                  return {
                      name: e.name,
                      id: e.id,
                      fromName: t?.name === e.name ? void 0 : t?.name,
                      targetDate: t?.targetDate === e.targetDate ? void 0 : {
                          from: t?.targetDate,
                          to: e.targetDate
                      },
                      status: {
                          from: t?.status,
                          to: e?.status
                      },
                      currentProgress: e.progress,
                      progress: t && LM(t.progress, e.progress) ? {
                          from: t.progress,
                          to: e.progress
                      } : void 0
                  }
              }
              )
          } : void 0
            , ue = (e, t) => t?.teamsInfo.reduce( (t, n) => t + n.issueInfo[e], 0) ?? 0
            , de = ue(`triageCount`, e)
            , fe = ue(`triageCount`, n)
            , pe = ue(`backlogCount`, e)
            , me = ue(`backlogCount`, n)
            , he = ue(`unstartedCount`, e)
            , ge = ue(`unstartedCount`, n)
            , v = ue(`startedCount`, e)
            , _e = ue(`startedCount`, n)
            , ve = ue(`completedCount`, e)
            , ye = ue(`completedCount`, n)
            , be = ge + fe + me + _e + ye
            , xe = he + de + pe + v + ve
            , Se = Sc.progressMultipliers[E.started]
            , Ce = Math.round(100 * (be > 0 ? (ye + _e * Se) / be : 0))
            , we = Math.round(100 * (xe > 0 ? (ve + v * Se) / xe : 0));
          return {
              lastSnapshotDate: r,
              statusId: a,
              priority: o,
              leadId: p,
              memberIds: g,
              teamIds: re,
              startDate: l,
              targetDate: f,
              milestones: le,
              progress: LM(Ce, we) ? {
                  from: Ce,
                  to: we
              } : void 0,
              issues: {
                  scope: {
                      diff: xe - be,
                      sum: xe
                  },
                  [E.started]: {
                      diff: v - _e,
                      sum: v
                  },
                  [E.completed]: {
                      diff: ve - ye,
                      sum: ve
                  }
              }
          }
      }
      e.getProjectUpdateInfoSnapshotDiff = n;
      async function r(e, t) {
          let n = [];
          if (e.statusId && e.statusId.from !== e.statusId.to) {
              let r = e.statusId.to ? await t.getProjectStatusById(e.statusId.to) : void 0;
              r && n.push(`**Status**: ${r.name}`)
          }
          if (e.priority && e.priority.from !== e.priority.to && n.push(`**Priority**: ${t.getPriorityLabelFromValue(e.priority.to)}`),
          e.leadId && e.leadId.to && e.leadId.from !== e.leadId.to)
              try {
                  let r = (await t.getUsersById([e.leadId.to]))[e.leadId.to];
                  r && n.push(`**Lead**: ${r} assigned`)
              } catch {}
          e.targetDate && e.targetDate.from !== e.targetDate.to && n.push(`**Target date**: ${NM(e.targetDate.from, e.targetDate.to)}`),
          e.startDate && e.startDate.from !== e.startDate.to && n.push(`**Start date**: ${NM(e.startDate.from, e.startDate.to)}`);
          let r = `*Progress since ${xr(e.lastSnapshotDate)}*:`;
          if (e.milestones) {
              let t = []
                , i = e => {
                  let t = `**${e.name}**${e.postfix ? ` ${e.postfix}` : ``}:`
                    , n = e.additionalInfo ? e.additionalInfo.filter(Boolean) : [];
                  return n.length > 0 ? `${t}  ${n.join(`    `)}` : t
              }
              ;
              e.milestones.changed && e.milestones.changed.forEach(e => {
                  (e.progress || e.targetDate) && t.push(i({
                      name: e.name,
                      additionalInfo: [e.progress && e.progress.from !== e.progress.to && e.progress.from !== void 0 && e.progress.to !== void 0 ? IM(e.progress.from, e.progress.to) : ``, e.targetDate && e.targetDate.from !== e.targetDate.to ? PM(e.targetDate.from, e.targetDate.to) : ``]
                  }))
              }
              ),
              e.milestones.added && e.milestones.added.forEach(e => {
                  t.push(i({
                      name: e.name,
                      postfix: `added`,
                      additionalInfo: [FM(e.progress), e.targetDate ? PM(void 0, e.targetDate) : ``]
                  }))
              }
              ),
              e.milestones.removed && e.milestones.removed.forEach(e => {
                  t.push(i({
                      name: e.name,
                      postfix: `removed`,
                      additionalInfo: [FM(e.progress), e.targetDate ? xr(e.targetDate) : ``]
                  }))
              }
              ),
              t.length > 0 && (n.length > 0 && n.push(``),
              n.push(r),
              n.push(...t.map(e => `  ${e}`)))
          } else
              e.progress && e.progress.from !== e.progress.to && e.progress.from !== void 0 && e.progress.to !== void 0 && (n.length > 0 && n.push(``),
              n.push(r + ` ${IM(e.progress.from, e.progress.to)}`));
          return n.length > 0 ? n.join(`
`) : ``
      }
      e.formatProjectUpdateDiffAsMarkdown = r
  }
  )(MM ||= {}),
  NM = (e, t) => `${e || `Not set`}  ${t || `Not set`}`,
  PM = (e, t) => NM(e ? xr(e) : void 0, t ? xr(t) : void 0),
  FM = e => `${e}%`,
  IM = (e, t) => `${FM(e)}  ${FM(t)}`,
  LM = (e=0, t=0) => Math.abs(e - t) > 2
}
));
function RM(e, t, n) {
  let r = n?.infoSnapshot
    , i = t.infoSnapshot || BM(t.project);
  if (!r || !i)
      return;
  let {fiscalYearStartMonth: a} = e.organization
    , o = n?.createdAt || t.createdAt;
  return MM.getProjectUpdateInfoSnapshotDiff(i, r, o, a)
}
function zM(e) {
  return e.reduce( (e, t) => {
      let n = `${t.state.type}Count`;
      return {
          ...e,
          [n]: e[n] + (t.estimate ?? t.team.defaultIssueEstimate)
      }
  }
  , {
      triageCount: 0,
      backlogCount: 0,
      unstartedCount: 0,
      startedCount: 0,
      completedCount: 0,
      canceledCount: 0
  })
}
var BM, VM, rle = t(( () => {
  nle(),
  qb(),
  QO(),
  hR(),
  tj(),
  mH(),
  GU(),
  BM = e => (qO(e.issues),
  qO(e.projectMilestones),
  {
      statusId: e.status.id,
      priority: e.priority.priority,
      leadId: e.lead?.id,
      memberIds: e.members.elements.map(e => e.id),
      startDate: e.startDate,
      startDateResolution: e.startDateResolution,
      targetDate: e.targetDate,
      targetDateResolution: e.targetDateResolution,
      teamsInfo: e.accessibleTeams.map(t => ({
          id: t.id,
          issueInfo: zM(e.issues.filter(e => e.team === t))
      })).concrete(),
      milestonesInfo: e.projectMilestones.map(e => ({
          issueInfo: zM(e.issues),
          targetDate: e.targetDate,
          name: e.name,
          id: e.id
      }))
  }),
  VM = {
      calculateDiffBetweenProjectUpdates: (e, t, n) => {
          let r = RM(e, t, n);
          if (r)
              return {
                  lastSnapshotDate: r.lastSnapshotDate,
                  progress: r.progress,
                  issues: r.issues,
                  status: r.statusId ? {
                      from: r.statusId.from ? e.findById(ej, r.statusId.from) : void 0,
                      to: r.statusId.to ? e.findById(ej, r.statusId.to) : void 0
                  } : void 0,
                  priority: r.priority,
                  startDate: r.startDate,
                  targetDate: r.targetDate,
                  lead: r.leadId ? {
                      from: r.leadId.from ? e.findById(J, r.leadId.from) : void 0,
                      to: r.leadId.to ? e.findById(J, r.leadId.to) : void 0
                  } : void 0,
                  members: r.memberIds ? {
                      added: r.memberIds.added?.map(t => e.findById(J, t)).concrete(),
                      removed: r.memberIds.removed?.map(t => e.findById(J, t)).concrete()
                  } : void 0,
                  teams: r.teamIds ? {
                      added: r.teamIds.added?.map(t => e.findById(K, t)).concrete(),
                      removed: r.teamIds.removed?.map(t => e.findById(K, t)).concrete()
                  } : void 0,
                  milestones: r.milestones ? {
                      changed: r.milestones.changed.map(t => ({
                          milestone: e.findById(mR, t.id),
                          ...t
                      })),
                      added: r.milestones.added?.map(t => ({
                          milestone: e.findById(mR, t.id),
                          ...t
                      })),
                      removed: r.milestones.removed?.map(t => ({
                          milestone: e.findById(mR, t.id),
                          ...t
                      }))
                  } : void 0
              }
      }
      ,
      getDiffSinceLastUpdate: (e, t) => {
          let n = t.lastPostedUpdate
            , r = n?.infoSnapshot
            , i = BM(t);
          if (!r || !i)
              return;
          let {fiscalYearStartMonth: a} = e.organization
            , o = n.createdAt;
          return MM.getProjectUpdateInfoSnapshotDiff(i, r, o, a)
      }
      ,
      formatProjectUpdateDiffAsMarkdown: (e, t, n) => {
          let r = RM(e, t, n);
          return r ? MM.formatProjectUpdateDiffAsMarkdown(r, {
              getUsersById: async t => t.reduce( (t, n) => {
                  let r = e.findById(J, n);
                  return r && (t[n] = r.name),
                  t
              }
              , {}),
              getProjectStatusById: async t => e.findById(ej, t),
              getPriorityLabelFromValue: e => Kb.createFromPriority(e).name
          }) : Promise.resolve(``)
      }
  }
}
)), HM, UM = t(( () => {
  Rb(),
  Hb(),
  Aw(),
  XB(),
  AM(),
  KA(),
  sR(),
  iz(),
  V(),
  Ih(),
  ML(),
  rle(),
  WA(),
  GU(),
  sj(),
  om(),
  N(),
  HM = class extends UA {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular;
      static #n = this.partialPreloadForTeam = am.firstPriority;
      get previousUpdate() {
          return this.project.projectUpdates.find(e => e.createdAt < this.createdAt)
      }
      get isStale() {
          return Vb.healthIsOutdated({
              healthAgeInDays: this.healthAgeInDays,
              updateReminderFrequency: this.project.updateReminderFrequency,
              frequencyResolution: this.project.frequencyResolution,
              orgReminderFrequency: this.project.orgReminderFrequency,
              isActive: this.project.isActive
          })
      }
      get isSlightlyStale() {
          return Vb.healthIsSlightlyOutdated({
              healthAgeInDays: this.healthAgeInDays,
              updateReminderFrequency: this.project.updateReminderFrequency,
              frequencyResolution: this.project.frequencyResolution,
              orgReminderFrequency: this.project.orgReminderFrequency,
              isActive: this.project.isActive
          })
      }
      get parent() {
          return this.project
      }
      get snapshotDiff() {
          return VM.calculateDiffBetweenProjectUpdates(this.store, this, this.previousUpdate)
      }
      async formatAsMarkdown(e) {
          let t;
          return this.snapshotDiff && (t = await VM.formatProjectUpdateDiffAsMarkdown(this.store, this, this.previousUpdate)),
          kw.exportUpdateAsMarkdown({
              parentName: this.project.name,
              parentUrl: gP(this.project),
              health: this.health,
              userName: this.user?.name,
              createdAt: this.createdAt,
              bodyMarkdown: this.bodyMarkdown,
              diffMarkdown: t,
              comments: this.comments.map(e => ({
                  author: e.user?.name,
                  bodyMarkdown: e.bodyMarkdown,
                  createdAt: e.createdAt,
                  id: e.id,
                  sourceMetadata: e.sourceMetadata,
                  isSyncedExternalThreadRoot: e.isSyncedExternalThreadRoot,
                  resolvingCommentId: e.resolvingComment?.id
              }))
          }, {
              includeComments: e?.includeComments,
              includeName: e?.includeProjectName
          })
      }
  }
  ,
  M([R({
      serializer: Mh,
      shallowObservation: !0,
      default: {}
  })], HM.prototype, `bodyData`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], HM.prototype, `editedAt`, void 0),
  M([R({
      enum: Fb,
      default: Fb.onTrack
  })], HM.prototype, `health`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !0,
      nullable: !1
  })], HM.prototype, `user`, void 0),
  M([R({
      persistence: `none`,
      default: ``,
      indexed: !0
  })], HM.prototype, `slugId`, void 0),
  M([B( () => G, `projectUpdates`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], HM.prototype, `project`, void 0),
  M([og( () => eR)], HM.prototype, `notifications`, void 0),
  M([z( () => GA, {
      index: `projectUpdateId`
  })], HM.prototype, `externalEntityRelations`, void 0),
  M([z( () => YB, {
      index: `projectUpdateId`
  })], HM.prototype, `comments`, void 0),
  M([z( () => kM, {
      index: `projectUpdateId`
  })], HM.prototype, `draftComments`, void 0),
  M([z( () => oj, {
      index: `projectUpdateId`
  })], HM.prototype, `mediaMetadata`, void 0),
  M([L], HM.prototype, `previousUpdate`, null),
  M([R({
      persistence: `none`,
      serializer: Mh,
      default: []
  })], HM.prototype, `reactionData`, void 0),
  M([R({
      serializer: Mh,
      persistence: `none`
  })], HM.prototype, `infoSnapshot`, void 0),
  M([R({
      default: !1
  })], HM.prototype, `isDiffHidden`, void 0),
  M([L], HM.prototype, `snapshotDiff`, null),
  HM = M([mg(`ProjectUpdate`)], HM)
}
)), WM, GM, KM, qM, JM = t(( () => {
  zn(),
  ed(),
  WM = function(e) {
      return e.inbox = `inbox`,
      e.myIssues = `myIssues`,
      e.allIssues = `allIssues`,
      e.activeIssues = `activeIssues`,
      e.activeCycle = `activeCycle`,
      e.allProjects = `allProjects`,
      e.allInitiatives = `allInitiatives`,
      e.customView = `customView`,
      e.project = `project`,
      e.initiative = `initiative`,
      e
  }({}),
  GM = WM.activeIssues,
  KM = e => Qu(WM).filter(t => t === WM.allInitiatives || t === WM.initiative ? e.initiativesEnabled : !0),
  qM = e => {
      switch (e) {
      case WM.allIssues:
          return `All issues`;
      case WM.activeIssues:
          return `Active issues`;
      case WM.activeCycle:
          return `Current cycle`;
      case WM.customView:
          return `View`;
      case WM.project:
          return `Project`;
      case WM.initiative:
          return `Initiative`;
      case WM.inbox:
          return `Inbox`;
      case WM.myIssues:
          return `My issues`;
      case WM.allInitiatives:
          return `Initiatives`;
      case WM.allProjects:
          return `Projects`;
      default:
          return y(e),
          `ERROR - Unknown view`
      }
  }
}
)), YM, XM = t(( () => {
  zn(),
  ML(),
  YM = function(e) {
      return e.projects = `projects`,
      e.issues = `issues`,
      e.initiatives = `initiatives`,
      e.dashboards = `dashboards`,
      e
  }({}),
  (function(e) {
      function t(e) {
          switch (e) {
          case YM.projects:
              return `Projects`;
          case YM.issues:
              return `Issues`;
          case YM.initiatives:
              return `Initiatives`;
          case YM.dashboards:
              return `Dashboards`;
          default:
              throw y(e)
          }
      }
      e.labelForType = t;
      function n(e) {
          switch (e) {
          case YM.projects:
              return `project`;
          case YM.issues:
              return `issue`;
          case YM.initiatives:
              return `initiative`;
          case YM.dashboards:
              throw Error(`Dashboards are not supported as a model type`);
          default:
              throw y(e)
          }
      }
      e.modelForType = n;
      function r({urlParam: e, lastUsed: t, options: n}) {
          return a(e, n) ? e : e ? null : a(t, n) ? t : YM.issues
      }
      e.parseViewTypeParam = r;
      function i({showInitiativeViews: e, showDashboards: t}) {
          return [YM.issues, YM.projects, e ? YM.initiatives : void 0, t ? YM.dashboards : void 0].concrete()
      }
      e.getValidViewTypes = i;
      function a(e, t) {
          return !!e && i(t).includes(e)
      }
      e.isViewTypeValid = a;
      function o(e, t, n) {
          return n ? iN(n, e) : RF(t.organization, e)
      }
      e.path = o
  }
  )(YM ||= {})
}
));
function ile(e) {
  return e === OH ? Y : G
}
var ZM, QM, $M = t(( () => {
  kH(),
  Dk(),
  Lq(),
  iz(),
  ZM = e => e instanceof OH,
  QM = e => e instanceof Ek
}
));
function ale(e) {
  let t = {}
    , n = (e[0] === `?` ? e.substr(1) : e).replace(/\&amp;/g, `&`).split(`&`);
  for (let e = 0; e < n.length; e++) {
      let r = n[e].split(`=`)
        , i = decodeURIComponent(r[0].replace(/\+/g, ` `))
        , a = decodeURIComponent((r[1] || ``).replace(/\+/g, ` `));
      i.length && a.length && (t[i] = a)
  }
  return t
}
function eN(e) {
  let t = Object.keys(e).filter(t => e[t] !== void 0);
  if (t.length === 0)
      return ``;
  let n = `?`;
  for (let r of t) {
      let t = e[r];
      t !== void 0 && (n.length > 1 && (n += `&`),
      n += encodeURIComponent(r) + `=` + encodeURIComponent(t.toString()))
  }
  return n
}
var tN = t(( () => {}
));
function ole(e) {
  return dP(e.team) + eN({
      title: yl.fixupTitle(e.title),
      description: e.documentContent.value?.markdownContent || ``,
      assignee: e.assignee?.displayName,
      estimate: e.estimate,
      priority: e.priority.priority,
      status: e.state.name,
      cycle: e.cycle?.value?.displayName,
      project: e.project?.name,
      labels: e.labels.length ? e.labels.map(e => e.name).join(`,`) : void 0
  })
}
function sle(e) {
  if (e.type === yf.issue)
      return dP(e.team ?? e.organization) + eN({
          [fP]: e.id
      });
  if (e.type === yf.project)
      return XN(iI(e.organization, e.team?.key)) + eN({
          [fP]: e.id
      });
  throw Error(`Not implemented yet`)
}
function cle(e, t) {
  return `${EP(e)}/review/${t}`
}
function nN(e, t) {
  let n = rN(e);
  if (t instanceof J) {
      let r = t.settings.getInitiativeLastSeenTab(e)
        , i = r?.facetId && e.facets.findById(r?.facetId);
      if (i && i.isHydrated())
          return nL(i);
      if (r?.mainTab)
          return `${n}/${r.mainTab}`
  } else if (t)
      return `${n}/${t}`;
  return nN(e, pw.overview)
}
function rN(e) {
  return `${EP(e.organization)}/initiative/${e.slugId ? e.slug : e.id}`
}
function lle(e, t) {
  return `${EP(e)}/initiative/${t}`
}
function ule(e, t) {
  if (t != null)
      if (t instanceof J) {
          let n = t.settings.getTeamLastSeenMainTab(e.id);
          if (n)
              return k_(e.organization.urlKey, e.key, n)
      } else
          return k_(e.organization.urlKey, e.key, t);
  return k_(e.organization.urlKey, e.key, hw.resources)
}
function iN(e, t) {
  let n;
  n = t instanceof J ? t.settings.teamCustomViewsViewType : t;
  let r = lI(e, `views`);
  return n === `dashboards` && e.organization.dashboardsAvailable ? UF(e.organization, e) : n != null && YM.isViewTypeValid(n, {
      showInitiativeViews: e.organization.initiativeViewsAvailable,
      showDashboards: e.organization.dashboardsAvailable
  }) ? `${r}/${n}` : `${r}/${YM.issues}`
}
function aN(e, t) {
  let n = QI(e);
  if (t != null)
      if (t instanceof J) {
          let r = t.settings.getProjectLastSeenTab(e)
            , i = r?.facetId && e.facets.findById(r?.facetId);
          if (i && i.isHydrated())
              return nL(i);
          if (r?.mainTab)
              return `${n}/${r.mainTab}`
      } else
          return `${n}/${t}`;
  return n
}
function dle(e) {
  return `${EP(e)}/project/new`
}
function fle(e) {
  e.length > AL && w.warning(`URL is longer than ${AL} characters`, {
      url: e
  })
}
function ple(e) {
  try {
      return new URL(e).pathname
  } catch {
      return e
  }
}
var oN, sN, cN, lN, uN, dN, fN, pN, mN, hN, gN, _N, vN, yN, bN, xN, SN, CN, wN, TN, EN, DN, ON, kN, AN, jN, MN, NN, PN, FN, IN, LN, RN, zN, BN, VN, HN, UN, WN, GN, KN, qN, JN, YN, XN, ZN, QN, $N, eP, tP, nP, rP, iP, aP, oP, sP, cP, lP, uP, dP, fP, pP, mP, hP, gP, _P, vP, yP, bP, xP, SP, CP, wP, TP, EP, DP, OP, kP, AP, jP, MP, NP, PP, FP, IP, LP, RP, zP, BP, VP, HP, UP, WP, GP, KP, qP, JP, YP, XP, ZP, QP, $P, eF, tF, nF, rF, iF, aF, oF, sF, cF, lF, uF, dF, fF, pF, mF, hF, gF, _F, vF, yF, bF, xF, SF, CF, wF, TF, EF, DF, OF, kF, AF, jF, MF, NF, PF, FF, IF, LF, RF, zF, BF, VF, HF, UF, WF, GF, KF, qF, JF, YF, XF, ZF, QF, $F, eI, tI, nI, rI, iI, aI, oI, sI, cI, lI, uI, dI, fI, pI, mI, hI, gI, _I, vI, yI, bI, xI, SI, CI, wI, TI, EI, DI, OI, kI, AI, jI, MI, NI, PI, FI, II, LI, RI, zI, BI, VI, HI, UI, WI, GI, KI, qI, JI, YI, XI, ZI, QI, $I, eL, tL, nL, rL, iL, aL, oL, sL, cL, lL, uL, dL, fL, pL, mL, hL, gL, _L, vL, yL, bL, xL, SL, CL, wL, TL, EL, DL, OL, kL, AL, jL, ML = t(( () => {
  zn(),
  bl(),
  L_(),
  Yf(),
  gc(),
  fw(),
  mw(),
  gw(),
  iy(),
  Bu(),
  ed(),
  ww(),
  Ew(),
  Ow(),
  Xn(),
  ws(),
  XB(),
  Pz(),
  _H(),
  PR(),
  Lq(),
  kH(),
  iz(),
  hR(),
  UM(),
  mH(),
  GU(),
  JM(),
  XM(),
  HA(),
  DM(),
  FB(),
  QO(),
  TA(),
  Ij(),
  $M(),
  tN(),
  oN = `https://twitter.com/linear`,
  sN = `https://linear.app/docs`,
  cN = `https://linear.app/dpa`,
  lN = `https://linear.app/changelog`,
  uN = `https://developers.linear.app`,
  dN = `https://github.com/linear/linear/tree/master/packages/import`,
  fN = `https://developers.linear.app/docs/graphql/webhooks`,
  pN = `https://linear.app/developers/oauth-2-0-authentication#refresh-an-access-token`,
  mN = `https://linear.app/developers/oauth-2-0-authentication#client-credentials-tokens`,
  hN = `https://linear.app/developers/oauth-2-0-authentication#revoke-an-access-token`,
  gN = `https://linear.app/docs/audit-log`,
  _N = `https://linear.app/docs/import-issues`,
  vN = `https://linear.app/docs/triage`,
  yN = `https://linear.app/docs/triage#triage-responsibility`,
  bN = `https://linear.app/docs/default-team-pages#issues`,
  xN = `https://linear.app/docs/default-team-pages#backlog`,
  SN = `https://linear.app/docs/default-team-pages#active`,
  CN = `https://linear.app/docs/linear-asks`,
  wN = `https://linear.app/docs/linear-asks#using-linear-asks-with-email`,
  TN = `https://linear.app/docs/linear-asks#configure-email-forwarding-in-google-workspace`,
  EN = `https://linear.app/docs/team-issue-limit`,
  DN = `https://linear.app/docs/initiatives`,
  ON = `https://linear.app/docs/customer-requests`,
  kN = `https://linear.app/docs/projects`,
  AN = `https://linear.app/docs/initiative-and-project-updates`,
  jN = `https://linear.app/docs/use-cycles`,
  MN = `https://linear.app/docs/custom-views`,
  NN = `https://linear.app/docs/project-milestones`,
  PN = `https://linear.app/docs/members-roles`,
  FN = `https://linear.app/docs/members-roles#guest`,
  IN = `https://linear.app/docs/third-party-application-approvals`,
  LN = `https://linear.app/docs/pulse`,
  RN = `https://www.zendesk.com/apps/support/linear/`,
  zN = `https://app.frontapp.com/settings/apps/details/linear/overview`,
  BN = `https://www.figma.com/community/plugin/1221187540287746170`,
  VN = `https://appexchange.salesforce.com/appxListingDetail?listingId=8baa654b-55e3-43bd-8c24-1b556107a932`,
  HN = `https://linear.app/contact/sales`,
  UN = `https://linear.app/docs/github#configure`,
  WN = `https://linear.app/docs/delete-archive-issues#auto-close`,
  GN = `https://linear.app/docs/delete-archive-issues#auto-archive`,
  KN = `https://linear.app/docs/use-cycles#cycle-automations`,
  qN = `https://linear.app/developers/agents#actor-and-scopes`,
  JN = `https://linear.app/docs/product-intelligence`,
  YN = `https://linear.app/docs/agents-in-linear`,
  XN = (e, t=Jn.CLIENT_URL) => Ug(e, t),
  ZN = e => XN(`/connect/slack/post/${e}`),
  QN = () => XN(`/connect/slack`),
  $N = e => XN(`/connect/slack/customer/${e}`),
  eP = () => XN(`/auth/desktop-redirect`),
  tP = () => XN(`/connect/figma/desktop-redirect`),
  nP = () => XN(`/connect/sentry`),
  rP = () => XN(`/connect/intercom`),
  iP = e => XN($g(e), Jn.API_SERVER_URL).replace(`client-`, ``),
  aP = e => XN(t_(e), Jn.API_SERVER_URL).replace(`client-`, ``),
  oP = e => XN(CI(e)),
  sP = e => XN(HI(e)),
  cP = e => XN(lI(e)),
  lP = e => XN(qI(e)),
  uP = e => XN(BF(e)),
  dP = e => XN(e instanceof K ? xI(e) : SI(e)),
  fP = `template`,
  pP = e => XN(DI(e)),
  mP = e => XN(bL(e)),
  hP = e => XN(WF(e)),
  gP = (e, t) => XN(t ? eL(e, t) : aN(e)),
  _P = e => XN(lL(e)),
  vP = (e, t) => XN(nN(e, t)),
  yP = e => XN(XF(e)),
  bP = e => XN(pL(e)),
  xP = e => XN(mL(e)),
  SP = e => XN(_L(e)),
  CP = e => XN(QF(e)),
  wP = (e, t) => `${Jn.API_SERVER_URL}/ical/${e.organization.id}/${e.id}/cycles.ics?userId=${t.user.id}&token=${t.calendarHash}`,
  TP = e => Ug(`/connect/gitlab/${e.id}`, Jn.IS_PRODUCTION_ENV ? Jn.API_SERVER_URL : `https://linear-dev-gitlab.ngrok.io`),
  EP = e => `/${e.urlKey}`,
  DP = e => `${EP(e)}/welcome`,
  OP = e => iF(e),
  kP = e => `${EP(e)}/settings/workspace`,
  AP = e => `${EP(e)}/settings/billing/plans`,
  jP = e => `${EP(e)}/settings/security`,
  MP = e => `${EP(e)}/settings/authentication`,
  NP = (e, t) => `${EP(e)}/settings/identity-providers/${t}`,
  PP = e => `${EP(e)}/settings/members`,
  FP = e => `${EP(e)}/settings/teams`,
  IP = e => `${EP(e)}/settings/issue-labels`,
  LP = e => `${EP(e)}/settings/project-labels`,
  RP = e => `${EP(e)}/settings/issue-templates`,
  zP = e => `${EP(e)}/settings/project-statuses`,
  BP = e => `${EP(e)}/settings/project-updates`,
  VP = e => `${EP(e)}/settings/project-templates`,
  HP = e => `${EP(e.organization)}/settings/teams/${e.key}/issue-labels`,
  UP = e => `${EP(e)}/settings/projects`,
  WP = e => `${EP(e)}/settings/releases`,
  GP = (e, t) => {
      let n = e.slugId && e.slugId.trim() !== `` ? e.slugId : e.id;
      return `${WP(t)}/pipelines/${n}`
  }
  ,
  KP = (e, t) => {
      let n = e.slugId && e.slugId.trim() !== `` ? e.slugId : e.id;
      return `${EP(t)}/pipeline/${n}/releases`
  }
  ,
  qP = e => {
      let t = e.pipeline.value;
      if (!t)
          return ``;
      let n = t.slugId && t.slugId.trim() !== `` ? t.slugId : t.id;
      return `${EP(t.organization)}/pipeline/${n}/release/${e.id}`
  }
  ,
  JP = e => `${EP(e)}/settings/documents`,
  YP = (e, t) => `${EP(e)}/settings/sla${t ? `?slaRuleId=${t}` : ``}`,
  XP = (e, t) => `${EP(e.organization)}/settings/teams/${e.key}/triage${t ? `?triageRuleId=${t}` : ``}`,
  ZP = (e, t) => `${EP(e)}/settings/ai${t ? `/${t}` : ``}`,
  QP = e => `${EP(e)}/settings/agents`,
  $P = (e, t) => {
      let {duplicate: n, editTemplateId: r, isNewTemplateShared: i} = t ?? {}
        , a = `${EP(e)}/settings/prompt-template`;
      return r ? `${a}/${r}/${n ? `duplicate` : `edit`}` : `${a}/new${i ? `?shared=true` : ``}`
  }
  ,
  eF = e => `${EP(e)}/settings/prompt-templates`,
  tF = e => `${EP(e)}/settings/feature-flags`,
  nF = e => `${EP(e)}/settings/emojis`,
  rF = e => `${EP(e)}/settings/account/profile`,
  iF = e => `${EP(e)}/settings/account/preferences`,
  aF = e => `${EP(e)}/settings/account/notifications`,
  oF = (e, t) => `${EP(e)}/settings/account/notifications/${t}`,
  sF = e => `${EP(e)}/settings/account/shortcuts`,
  cF = e => `${EP(e)}/settings/account/security`,
  lF = (e, t) => `${cF(e)}/api-keys/${t.id}`,
  uF = e => `${cF(e)}/api-keys/new`,
  dF = (e, t) => `${lF(e, t)}/edit`,
  fF = e => `${EP(e)}/settings/account/connections`,
  pF = e => `${EP(e)}/settings/initiatives`,
  mF = e => `${EP(e)}/settings/pulse`,
  hF = (e, t) => `${EP(e)}/settings/customers-requests${t ? `#${t}` : ``}`,
  gF = (e, t) => `${EP(e)}/settings/applications${t ? `#${p_(t)}` : ``}`,
  _F = e => `${EP(e)}/settings/billing`,
  vF = e => `${EP(e)}/settings/billing/invoices`,
  yF = e => `${EP(e)}/settings/audit-log?notType=sessionCreated`,
  bF = e => `${EP(e)}/settings/import-export`,
  xF = (e, t, n) => `${EP(e)}/settings/integrations` + (t ? `/${t}` : ``) + (n ? `#${n}` : ``),
  SF = e => `${EP(e)}/settings/integrations/enabled`,
  CF = (e, t) => t ? `${EP(e)}/settings/import-export/migration-assistant/${t.id}` : `${EP(e)}/settings/import-export/migration-assistant`,
  wF = e => `${EP(e)}/settings/api`,
  TF = (e, t) => `${wF(e)}/applications/${t.id}`,
  EF = e => `${EP(e)}/settings/applications`,
  DF = (e, t) => `${EF(e)}/${t}`,
  OF = (e, t) => `${TF(e, t)}/edit`,
  kF = (e, t) => `${wF(e)}/webhooks/${t.id}`,
  AF = (e, t) => `${kF(e, t)}/edit`,
  jF = e => `${wF(e)}/applications/new`,
  MF = e => `${wF(e)}/webhooks/new`,
  NF = (e, t) => `${EP(e)}/search${eN({
      q: t
  })}`,
  PF = (e, t) => `${EP(e)}/inbox${t ? `/${t}` : ``}`,
  FF = (e, t={}) => eie(e.urlKey, t),
  IF = (e, t) => `${EP(e)}/my-issues/${t || ``}`,
  LF = e => `${EP(e)}/drafts`,
  RF = (e, t) => `${EP(e)}/views${t ? `/${t}` : ``}`,
  zF = e => `${EP(e)}/teams`,
  BF = e => `${EP(e.organization)}/view/${e.slug ?? e.id}`,
  VF = (e, t) => `${EP(t)}/view/${e}`,
  HF = e => `${BF(e)}/edit`,
  UF = (e, t) => `${EP(e)}${t ? `/team/${t.key}` : ``}/dashboards`,
  WF = e => e.persisted ? `${EP(e.organization)}/dashboard/${e.slug ?? e.id}` : qF(e.organization, e.team),
  GF = (e, t) => `${WF(e)}/widget/${t.id}`,
  KF = e => `${WF(e)}/widget/new`,
  qF = (e, t) => `${EP(e)}${t ? `/team/${t.key}` : ``}/dashboards/new`,
  JF = e => `${EP(e)}/members`,
  YF = e => `${EP(e)}/customers`,
  XF = e => `${EP(e.organization)}/customer/${e.slug ?? e.id}`,
  ZF = (e, t=Dw.me) => t === Dw.me ? `${EP(e)}/reviews` : `${EP(e)}/reviews/${t}`,
  QF = e => `${EP(e.organization)}/review/${e.slug}`,
  $F = (e, t) => t ? `${EP(e)}/agents/${t}` : `${EP(e)}/agents`,
  eI = e => T_({
      baseUrl: QF(e.pullRequest.value),
      commentId: e.id
  }),
  tI = async e => {
      let t = e.settings
        , n = e.store
        , {organization: r} = e
        , i = t.getDefaultView();
      if (i === WM.customView)
          try {
              let e = await t.getDefaultViewCustomView();
              if (e)
                  return BF(e)
          } catch {}
      let a = t.getDefaultViewProjectId();
      if (i === WM.project && a) {
          let e = n.findById(G, a);
          if (e)
              return aN(e)
      }
      let o = t.getDefaultViewInitiativeId();
      if (i === WM.initiative && o) {
          let e = n.findById(W, o);
          if (e)
              return nN(e)
      }
      let s = t.activeTeam, c;
      if (s)
          switch (i) {
          case WM.customView:
          case WM.project:
          case WM.initiative:
          case WM.activeIssues:
              c = lI(s, `active`);
              break;
          case WM.activeCycle:
              await e.settings.activeTeam?.cycles.hydrate(),
              c = s.activeCycle ? UI(s) : lI(s, `active`);
              break;
          case WM.inbox:
              c = PF(r);
              break;
          case WM.myIssues:
              c = IF(r, `assigned`);
              break;
          case WM.allInitiatives:
              c = oI(r);
              break;
          case WM.allProjects:
              c = iI(r);
              break;
          case WM.allIssues:
          case void 0:
              c = hI(s);
              break;
          default:
              y(i)
          }
      return c || (s ? hI(s) : bI(r))
  }
  ,
  nI = (e, t=`issue`) => e instanceof K ? `${EP(e.organization)}/team/${e.key}/views/${t}s/new` : `${EP(e)}/views/${t}s/new`,
  rI = (e, t) => t ? `${EP(e)}/team/${t}/projects` : `${EP(e)}/projects`,
  iI = (e, t) => `${rI(e, t)}/all`,
  aI = (e, t) => {
      let n = t ? e.settings.getTeamPageLastSeenTab(ry.projects, t.id) : e.settings.getWorkspacePageLastSeenTab(ry.projects);
      if (n && `facetId`in n) {
          let r = (t ?? e.organization).projectsPageFacets.findById(n.facetId);
          if (r?.targetCustomView?.id)
              return `${rI(e.organization, t?.key)}/view/${r?.targetCustomView?.id}`
      }
      return iI(e.organization, t?.key)
  }
  ,
  oI = (e, t) => `${EP(e)}/initiatives${t ? `/${t}` : ``}`,
  sI = e => lI(e, `view`),
  cI = (e, t) => {
      let n = e.settings.getTeamPageLastSeenTab(ry.teamIssues, t.id);
      if (n)
          if (`facetId`in n) {
              let e = t.issuesPageFacets.findById(n.facetId);
              if (e?.targetCustomView?.value?.id)
                  return `${sI(t)}/${e?.targetCustomView.value.slug ?? e?.targetCustomView.value.id}`
          } else
              switch (n.tab) {
              case k.backlog:
                  return pI(t);
              case k.activeIssues:
                  return mI(t);
              case k.allIssues:
                  return hI(t);
              default:
              }
      return hI(t)
  }
  ,
  lI = (e, t) => k_(e.organization.urlKey, e.key, t),
  uI = (e, t) => {
      switch (t) {
      case E.triage:
          return fI(e);
      case E.backlog:
          return pI(e);
      case E.unstarted:
          return mI(e);
      case E.started:
          return mI(e);
      case E.completed:
          return hI(e);
      case E.canceled:
          return hI(e);
      default:
          return y(t),
          ``
      }
  }
  ,
  dI = e => lI(e, `projects/all`),
  fI = e => lI(e, `triage`),
  pI = e => lI(e, `backlog`),
  mI = e => lI(e, `active`),
  hI = e => lI(e, `all`),
  gI = (e, t) => lI(e, `archive` + (t ? `/${t}` : ``)),
  _I = (e, t) => `${EP(e.organization)}/settings/teams/${e.key}${t ? `/` + t : ``}`,
  vI = (e, t) => `${EP(e.organization)}/settings/teams/${e.key}/ai/${t}`,
  yI = e => `${EP(e.organization)}/settings/teams/${e.key}/agents`,
  bI = (e, t) => `${EP(e)}/settings/new-team${t ? `?parentTeamId=${t.id}` : ``}`,
  xI = e => `${EP(e.organization)}/team/${e.key}/new`,
  SI = e => `${EP(e)}/new`,
  CI = e => e.persistedOnBackend ? j_({
      organizationUrlKey: e.team.organization.urlKey,
      teamKey: e.team.key,
      issueNumber: e.number,
      title: e.title,
      isTeamPrivate: e.team.private
  }) : TI(e),
  wI = (e, t) => `${EP(e)}/issue/${t}`,
  TI = e => `${EP(e.team.organization)}/issue/${e.id}`,
  EI = (e, t) => `${EP(e)}/issues/${t.join(`,`)}`,
  DI = e => {
      if (`pullRequest`in e)
          return eI(e);
      let t = e.issue?.value;
      if (t)
          return Jre({
              organizationUrlKey: t.team.organization.urlKey,
              teamKey: t.team.key,
              issueNumber: t.number,
              title: t.title,
              isTeamPrivate: t.team.private,
              commentId: e.id
          });
      if (e.documentContent?.value) {
          let t, n = e.documentContent.value;
          if (n.issue) {
              let e = n.issue.value;
              e && (t = CI(e))
          } else
              n.project ? t = aN(n.project) : n.document?.value ? (qO(n.document),
              t = bL(n.document.value)) : n.projectMilestone?.value ? t = aN(n.projectMilestone.value.project) : n.initiative && (t = nN(n.initiative));
          if (!t)
              throw Error(`Not able to generate inline comment url`);
          return T_({
              baseUrl: t,
              commentId: e.id
          })
      } else if (e.projectUpdate?.id) {
          let t = e.projectUpdate.value.project;
          return Xre({
              organizationUrlKey: t.accessibleTeams.first?.organization.urlKey ?? ``,
              projectUpdateId: e.projectUpdate.id,
              projectName: t.name,
              projectSlugId: t.slugId,
              commentId: e.id
          })
      } else if (e.initiativeUpdate?.id) {
          let t = e.initiativeUpdate
            , n = t.value.initiative;
          return Qre({
              organizationUrlKey: n.organization.urlKey,
              initiativeUpdateId: e.initiativeUpdate.id,
              initiativeUpdateSlugId: t.value.slugId,
              initiativeSlugId: n.slugId,
              initiativeName: n.name,
              commentId: e.id
          })
      } else if (e.post?.value)
          return ``;
      return w.error(`Not able to generate comment url`, void 0, {
          commentId: e.id,
          issueId: e.issueId,
          documentId: e.documentId,
          projectUpdateId: e.projectUpdateId
      }),
      ``
  }
  ,
  OI = e => jI(e) || FI(e) || ``,
  kI = e => XN(AI(e)),
  AI = e => {
      if (e.type !== yw.commentThread)
          return w.error(`Not able to generate agent session path: unsupported agent session type`, void 0, {
              agentSessionId: e.id
          }),
          ``;
      let t;
      if (e.issue && (t = CI(e.issue.value)),
      !t)
          throw Error(`Not able to generate inline agent session url`);
      return E_({
          baseUrl: t,
          agentSessionId: e.id
      })
  }
  ,
  jI = e => {
      let t = e.issue?.value;
      return t ? Kre({
          customerNeedId: e.id,
          organizationUrlKey: t.team.organization.urlKey,
          issueNumber: t.number,
          isTeamPrivate: t.team.private,
          teamKey: t.team.key,
          title: t.title
      }) : ``
  }
  ,
  MI = e => XN(jI(e)),
  NI = e => {
      let t = e.customer?.value;
      return t ? Gre({
          customerNeedId: e.id,
          customerName: t.name,
          customerSlugId: t.slugId,
          organizationUrlKey: t.organization.urlKey
      }) : ``
  }
  ,
  PI = e => XN(NI(e)),
  FI = e => {
      let t = e.project;
      return t ? qre({
          customerNeedId: e.id,
          projectName: t.name,
          projectSlugId: t.slugId,
          organizationUrlKey: t.organization.urlKey
      }) : ``
  }
  ,
  II = e => XN(FI(e)),
  LI = (e, t=Tw.assigned) => `${EP(e.organization)}/profiles/${encodeURIComponent(e.displayName)}${t && t !== Tw.assigned ? `/${t}` : ``}`,
  RI = (e, t=Tw.assigned) => XN(LI(e, t)),
  zI = e => lI(e, `cycles`),
  BI = e => lI(e, `updates`),
  VI = e => lI(e, `resources`),
  HI = e => A_(e.team.organization.urlKey, e.identifier, e.team.key),
  UI = e => A_(e.organization.urlKey, `active`, e.key),
  WI = e => A_(e.organization.urlKey, `upcoming`, e.key),
  GI = e => nie(e.urlKey),
  KI = (e, t) => rie(e.urlKey, t.date),
  qI = e => ZM(e) ? F_({
      labelName: e.name,
      organizationUrlKey: e.organization.urlKey,
      teamKey: e.team?.key
  }) : aie({
      labelName: e.name,
      organizationUrlKey: e.organization.urlKey
  }),
  JI = (e, t, n) => {
      switch (t) {
      case yf.recurringIssue:
          return Zu(n),
          `${EP(e)}/settings/teams/${n.key}/recurring-issues/new`;
      default:
          return n ? `${EP(e)}/settings/teams/${n.key}/templates/${t}/new` : `${EP(e)}/settings/templates/${t}/new`
      }
  }
  ,
  YI = (e, t, n) => {
      let r = n === `form` ? `/${n}` : ``;
      return t ? `${EP(e)}/settings/teams/${t.key}/templates/${yf.issue}/new${r}` : `${EP(e)}/settings/templates/${yf.issue}/new${r}`
  }
  ,
  XI = (e, t) => {
      switch (t.type) {
      case yf.recurringIssue:
          return Zu(t.team),
          `${EP(e)}/settings/teams/${t.team.key}/recurring-issues/${t.id}/edit`;
      default:
          return t.team ? `${EP(e)}/settings/teams/${t.team.key}/templates/${t.type}/${t.id}/edit` : `${EP(e)}/settings/templates/${t.type}/${t.id}/edit`
      }
  }
  ,
  ZI = e => lI(e, `projects`),
  QI = e => `${EP(e.organization)}/project/${e.slugId ? e.slug : e.id}`,
  $I = (e, t) => `${EP(e)}/project/${t}`,
  eL = (e, t) => `${aN(e)}/${t === dw.documents ? `overview` : t === dw.customers ? `requests` : t}`,
  tL = (e, t) => `${EP(e.organization)}/initiative/${e.slug}/${t}`,
  nL = e => {
      let[t,n] = zA(e);
      if (t === ny.Unknown)
          return `/`;
      let r = n.targetCustomView.value;
      if (!r)
          return w.warning(`Custom view is missing for facet`, {
              id: n.id,
              type: t,
              isHydrated: n.isHydrated()
          }),
          `/`;
      switch (t) {
      case ny.Project:
          let e = n.sourceProject;
          return `${aN(e)}/view/${r.slug ?? r.id}`;
      case ny.Initiative:
          let i = n.sourceInitiative;
          return `${rN(i)}/view/${r.slug ?? r.id}`;
      case ny.TeamPage:
          let a = n.sourceTeam
            , o = n.sourcePage;
          switch (o) {
          case ry.projects:
              return `${rI(a.organization, a.key)}/view/${r.slug ?? r.id}`;
          case ry.teamIssues:
              return k_(a.organization.urlKey, a.key, `view/${r.slug ?? r.id}`);
          case ry.feed:
              return FF(a.organization, {
                  customViewId: r?.slug ?? r.id
              });
          default:
              throw new Rn(o)
          }
      case ny.WorkspacePage:
          let s = n.sourceOrganization
            , c = n.sourcePage;
          switch (c) {
          case ry.projects:
              return `${rI(s)}/view/${r?.slug ?? r.id}`;
          case ry.teamIssues:
              throw Error(`Team key is required for team issues page`);
          case ry.feed:
              return FF(s, {
                  customViewId: r?.slug ?? r.id
              });
          default:
              throw new Rn(c)
          }
      case ny.Feed:
          let l = n.sourceFeedUser;
          return FF(l.organization, {
              customViewId: r?.slug ?? r.id
          });
      default:
          Ln(t)
      }
  }
  ,
  rL = e => `${nL(e)}/edit`,
  iL = e => `${aN(e)}/view/new`,
  aL = e => `${rN(e)}/view/new`,
  oL = e => `${EP(e)}/pulse/view/new`,
  sL = (e, t, n) => {
      switch (t) {
      case ry.projects:
          return `${rI(e, n)}/view/new`;
      case ry.teamIssues:
          if (!n)
              throw Error(`Team key is required for team issues page`);
          return k_(e.urlKey, n, `view/new`);
      case ry.feed:
          return FF(e, {
              customViewId: `new`
          });
      default:
          return y(t),
          ``
      }
  }
  ,
  cL = e => `${eL(e.project, dw.issues)}?projectMilestoneId=${e.id}`,
  lL = e => `${eL(e.project, dw.documents)}#milestone-${e.id}`,
  uL = e => `${aN(e)}/updates`,
  dL = e => `${aN(e)}/requests`,
  fL = (e, t) => {
      let n = t ? `&${g_(t.id)}` : ``;
      return e instanceof HM ? uL(e.project) + `#${b_({
          projectUpdateId: e.id
      })}${n}` : gL(e.initiative) + `#${x_({
          initiativeUpdateSlugId: e.slugId
      })}${n}`
  }
  ,
  pL = e => tie(e.organization.urlKey, e.slug, {
      teamKey: e.team?.key
  }),
  mL = e => {
      let t = e.project;
      return D_({
          projectUpdateId: e.id,
          organizationUrlKey: t.organization.urlKey,
          projectName: t.name,
          projectSlugId: t.slugId
      })
  }
  ,
  hL = e => {
      let t = e.project;
      return Zre({
          projectUpdateId: e.id,
          organizationUrlKey: t.organization.urlKey,
          projectName: t.name,
          projectSlugId: t.slugId,
          createdAt: e.createdAt,
          projectUpdateSlugId: e.slugId
      })
  }
  ,
  gL = e => `${rN(e)}/updates`,
  _L = e => {
      let t = e.initiative;
      return P_({
          initiativeSlugId: t.slugId,
          initiativeUpdateSlugId: e.slugId,
          organizationUrlKey: t.organization.urlKey,
          initiativeName: t.name,
          initiativeUpdateId: e.id
      })
  }
  ,
  vL = e => {
      let t = e.initiative;
      return $re({
          initiativeSlugId: t.slugId,
          initiativeUpdateSlugId: e.slugId,
          organizationUrlKey: t.organization.urlKey,
          initiativeName: t.name,
          initiativeUpdateId: e.id,
          createdAt: e.createdAt
      })
  }
  ,
  yL = e => `${EP(e.organization)}/folder/${e.slugId ? e.slug : e.id}`,
  bL = e => `${EP(e.organization)}/document/${e.slugId ? e.slug : e.id}`,
  xL = (e, t) => `${EP(e)}/document/${t}`,
  SL = e => {
      let t = e.parent;
      if (t instanceof G)
          return aN(t);
      if (t instanceof W)
          return nN(t);
      if (t instanceof K)
          return lI(t);
      if (t instanceof Y)
          return CI(t);
      if (t)
          throw new Rn(t);
      return `/`
  }
  ,
  CL = e => `${EP(e.organization)}/approval/${e.id}`,
  wL = e => {
      let t;
      return e instanceof G ? t = aN(e) : e instanceof gH ? t = HI(e) : e instanceof J ? t = LI(e) : e instanceof OH ? t = qI(e) : e instanceof Az ? t = BF(e) : e instanceof Fj ? t = WF(e) : e instanceof NR ? t = bL(e) : e instanceof W ? t = nN(e) : e instanceof YB && e.isHydrated() ? t = DI(e) : e instanceof Y ? t = CI(e) : e instanceof U ? t = QF(e) : e instanceof mR ? t = cL(e) : e instanceof K ? t = lI(e) : e instanceof MB && (t = XF(e)),
      t
  }
  ,
  TL = e => Jn.CLIENT_URL ? e.replace(Jn.CLIENT_URL + `/`, `linear://`) : e,
  EL = (e, t) => `${Jn.API_SERVER_URL}/oauth/authorize${eN({
      userAccountId: e,
      userId: t
  })}`,
  DL = (e, t, n) => `${Jn.API_SERVER_URL}/auth/mobile/authorize${eN({
      userAccountId: e,
      userId: t,
      redirectUri: n
  })}`,
  OL = function(e) {
      return e.filter = `filter`,
      e.layout = `layout`,
      e.grouping = `grouping`,
      e.subGrouping = `subGrouping`,
      e.ordering = `ordering`,
      e.orderingDirection = `orderingDirection`,
      e.zoom = `zoom`,
      e.zoomScale = `zoomScale`,
      e.showCompletedIssues = `showCompletedIssues`,
      e.showCompletedProjects = `showCompletedProjects`,
      e.showSubIssues = `showSubIssues`,
      e.insights = `insights`,
      e.insightsFilter = `insightsFilter`,
      e.drill = `drill`,
      e.display = `display`,
      e.teamKey = `teamKey`,
      e.projectId = `projectId`,
      e.sourcePage = `sourcePage`,
      e.sourceInitiativeId = `sourceInitiativeId`,
      e.showTriageIssues = `showTriageIssues`,
      e.fullscreen = `fullscreen`,
      e
  }({}),
  kL = `__private__`,
  AL = 2048,
  jL = (e, t) => {
      switch (t) {
      case yf.issue:
      case yf.recurringIssue:
          return RP(e);
      case yf.project:
          return VP(e);
      case yf.document:
          return JP(e);
      default:
          return RP(e)
      }
  }
}
));
function mle() {
  let {customersConfiguration: e} = pQ().organization;
  return !(e.attributesDataSourceConfiguration?.allowManualEdits ?? !0)
}
var NL, PL = t(( () => {
  hQ(),
  NL = e => {
      let t = pQ().organization?.isCustomersAccessible
        , n = !e.guest;
      return {
          base: t && n
      }
  }
}
)), FL, IL = t(( () => {
  Dl(),
  Tl(),
  zn(),
  Pz(),
  kH(),
  sR(),
  iz(),
  mH(),
  GU(),
  V(),
  F(),
  Nm(),
  ML(),
  Ry(),
  DM(),
  PL(),
  FB(),
  N(),
  FL = class extends qh {
      isCustomViewNotificationSubscription() {
          return !!this.customView?.id
      }
      isCustomerNotificationSubscription() {
          return !!this.customer?.id
      }
      isInitiativeNotificationSubscription() {
          return !!this.initiative?.id
      }
      isLabelNotificationSubscription() {
          return !!this.label?.id
      }
      isProjectNotificationSubscription() {
          return !!this.project?.id
      }
      isTeamNotificationSubscription() {
          return !!this.team?.id
      }
      isUserNotificationSubscription() {
          return !!this.user?.id
      }
      getModel() {
          let e = this.customView?.value ?? this.customer?.value ?? this.initiative ?? this.label ?? this.project ?? this.team ?? this.user;
          if (!e)
              throw Error(`Subscription does not have a targeted model`);
          return e
      }
      get hasAnyNotificationSubscriptionTypes() {
          let e = this.subscriptionTypes || [];
          return this.active ? e.length > 0 : !1
      }
      getTargetProps(e={}) {
          let t = this.getModel()
            , n = this.store.user;
          return t instanceof Az ? {
              target: `customView`,
              customView: t
          } : t instanceof MB ? {
              target: `customer`,
              customer: t
          } : t instanceof W ? {
              target: `initiative`,
              initiative: t
          } : t instanceof OH ? {
              target: `label`,
              label: t
          } : t instanceof G ? {
              target: `project`,
              project: t,
              currentUser: n,
              withSlackSection: e.withSlackSection
          } : t instanceof K ? {
              target: `team`,
              team: t,
              contextViewType: this.contextViewType
          } : {
              target: `user`,
              user: t,
              userContextViewType: this.userContextViewType
          }
      }
      getDisplayName(e={}) {
          let t = this.getTargetProps();
          switch (t.target) {
          case `customView`:
              return t.customView.name;
          case `customer`:
              return t.customer.name;
          case `initiative`:
              return t.initiative.name;
          case `label`:
              return t.label.name;
          case `project`:
              return t.project.name;
          case `team`:
              let n = t.contextViewType;
              switch (n) {
              case Cl.activeCycle:
                  return `${e.withBreadcrumb ? `${t.team.name}  ` : ``}Current cycle`;
              case Cl.activeIssues:
                  return `${e.withBreadcrumb ? `${t.team.name}  ` : ``}Active issues`;
              case Cl.backlog:
                  return `${e.withBreadcrumb ? `${t.team.name}  ` : ``}Backlog`;
              case Cl.triage:
                  return `${e.withBreadcrumb ? `${t.team.name}  ` : ``}Triage`;
              case Cl.upcomingCycle:
                  return `${e.withBreadcrumb ? `${t.team.name}  ` : ``}Upcoming cycle`;
              case void 0:
                  return t.team.name;
              default:
                  throw new Rn(n)
              }
          case `user`:
              return e.userSettings ? Ly.getUsername(e.userSettings, t.user) : t.user.name;
          default:
              throw new Rn(t)
          }
      }
      getModelPath() {
          let e = this.getTargetProps();
          switch (e.target) {
          case `customView`:
              return BF(e.customView);
          case `customer`:
              return XF(e.customer);
          case `initiative`:
              return nN(e.initiative);
          case `label`:
              return qI(e.label);
          case `project`:
              return aN(e.project);
          case `team`:
              let t = e.contextViewType;
              switch (t) {
              case Cl.activeCycle:
                  return UI(e.team);
              case Cl.activeIssues:
                  return mI(e.team);
              case Cl.backlog:
                  return pI(e.team);
              case Cl.triage:
                  return fI(e.team);
              case Cl.upcomingCycle:
                  return WI(e.team);
              case void 0:
                  return hI(e.team);
              default:
                  throw new Rn(t)
              }
          case `user`:
              return LI(e.user);
          default:
              throw new Rn(e)
          }
      }
      disable() {
          this.active = !1,
          this.save()
      }
      enable() {
          this.active = !0,
          this.save()
      }
      get subscriptionTypes() {
          return this.notificationSubscriptionTypes || []
      }
      set subscriptionTypes(e) {
          let t = El.allValues;
          this.notificationSubscriptionTypes = e.filter(e => t.includes(e)).distinct()
      }
      isSubscribedToNotificationType(e) {
          return this.subscriptionTypes.includes(e)
      }
      isValidSubscription() {
          return NL(this.subscriber).base ? this.hasAnyNotificationSubscriptionTypes : this.subscriptionTypes.length === 1 && this.isSubscribedToNotificationType(O.customerNeedCreated) ? !1 : this.hasAnyNotificationSubscriptionTypes
      }
      subscribeToNotificationType(e) {
          this.isSubscribedToNotificationType(e) || (this.notificationSubscriptionTypes || (this.subscriptionTypes = []),
          this.subscriptionTypes = [...this.subscriptionTypes, e].distinct())
      }
      unsubscribeFromNotificationType(e) {
          this.isSubscribedToNotificationType(e) && (this.subscriptionTypes = this.subscriptionTypes.filter(t => t !== e))
      }
  }
  ,
  M([B( () => J, `subscriptions`, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], FL.prototype, `subscriber`, void 0),
  M([dg( () => Az, `subscription`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], FL.prototype, `customView`, void 0),
  M([dg( () => MB, `subscription`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], FL.prototype, `customer`, void 0),
  M([ug( () => OH, `subscription`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], FL.prototype, `label`, void 0),
  M([ug( () => G, `subscription`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], FL.prototype, `project`, void 0),
  M([ug( () => K, `subscription`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], FL.prototype, `team`, void 0),
  M([ug( () => J, `subscription`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], FL.prototype, `user`, void 0),
  M([ug( () => W, `subscription`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], FL.prototype, `initiative`, void 0),
  M([R({
      enum: Cl,
      persistence: `createOnly`
  })], FL.prototype, `contextViewType`, void 0),
  M([R({
      enum: wl,
      persistence: `createOnly`
  })], FL.prototype, `userContextViewType`, void 0),
  M([R({
      default: []
  })], FL.prototype, `notificationSubscriptionTypes`, void 0),
  M([R({
      default: !0
  })], FL.prototype, `active`, void 0),
  M([z( () => XL, {
      index: `subscriptionIds`,
      order: new P(`createdAt`,`asc`)
  })], FL.prototype, `notifications`, void 0),
  M([I], FL.prototype, `disable`, null),
  M([I], FL.prototype, `enable`, null),
  M([I], FL.prototype, `subscribeToNotificationType`, null),
  M([I], FL.prototype, `unsubscribeFromNotificationType`, null),
  FL = M([mg(`NotificationSubscription`)], FL)
}
)), LL, hle = t(( () => {
  nt(),
  Dl(),
  LL = class e {
      static #e = this.PRIORITIZE_MENTION_NOTIFICATION_IN_LAST_HOURS = 72;
      static doesNotificationHaveIncreasedPriority(t) {
          if (!El.allMentionNotificationTypes.includes(t.type))
              return !1;
          let n = new Date;
          return t.createdAt > qe(n, e.PRIORITIZE_MENTION_NOTIFICATION_IN_LAST_HOURS)
      }
  }
}
));
function gle(e) {
  return e.length === 0 ? [] : e.some(e => !e.readAt) ? VL((0,
  zL.default)(e.filter(e => !e.readAt), e => -e.createdAt.getTime(), e => e.id)) : VL((0,
  zL.default)(e, e => e.readAt ? -e.readAt.getTime() : 0, e => -e.createdAt.getTime(), e => e.id))
}
var RL, zL, BL, VL, HL = t(( () => {
  RL = e(Ce(), 1),
  zL = e(_(), 1),
  Dl(),
  hle(),
  Nx(),
  zn(),
  cw(),
  FB(),
  PR(),
  Lq(),
  iz(),
  UM(),
  hR(),
  DM(),
  ws(),
  Xp(),
  TA(),
  lj(),
  Uj(),
  BL = class e {
      static handleNotification(e, t) {
          let n = sw[El.toNotificationPresenter(e.type)]
            , r = n ? n.getNotificationGrouping(e) : Mx.getNotificationGrouping(e, e.type);
          switch (r.type) {
          case `issue`:
          case `issue-reminder`:
              return t.issue(e.issue?.value);
          case `feed`:
          case `team-update`:
              return t.post(e.post?.value);
          case `initiative`:
          case `initiative-update-prompt`:
          case `initiative-description-change`:
          case `initiative-thread`:
          case `initiative-reminder`:
          case `initiative-moved`:
              return t.initiative(e.initiative);
          case `initiative-update`:
              return t.initiativeUpdate(e.initiativeUpdate?.value);
          case `project`:
          case `project-update-prompt`:
          case `project-description-change`:
          case `project-reminder`:
          case `project-moved`:
          case `project-thread`:
              return t.project(e.project);
          case `project-milestone`:
              return t.projectMilestone(e.projectMilestone?.value);
          case `project-update`:
              return t.projectUpdate(e.projectUpdate?.value);
          case `document`:
          case `document-moved`:
          case `document-reminder`:
          case `document-content-change`:
              return t.document(e.document?.value);
          case `oauth-client-approval`:
              return t.oauthClientApproval(e.oauthClientApproval?.value);
          case `document-thread`:
              return t.document(e.document?.value);
          case `project-milestone-thread`:
              return t.projectMilestone(e.projectMilestone?.value);
          case `pull-request`:
              return t.pullRequest(e.pullRequest?.value);
          case `customer`:
              return t.customer(e.customer?.value);
          case `system`:
          case `unknown`:
              return;
          default:
              throw w.warning(`Unknown notification type`, {
                  notificationType: e.type
              }),
              y(r.type)
          }
      }
      static entity(t) {
          return e.handleNotification(t, {
              issue: e => e,
              oauthClientApproval: e => e,
              project: e => e,
              initiative: e => e,
              initiativeUpdate: e => e,
              projectUpdate: e => e,
              projectMilestone: e => e,
              pullRequest: e => e,
              document: e => e,
              post: e => e,
              customer: e => e
          })
      }
      static fetchArchivedEntity(t, n) {
          return this.fetchArchiveCache[n.id] ||= new Jp(r => {
              async function i(e, i, a) {
                  return i ? r() : t.findArchivedByIdentifier(a, e).then( () => {
                      r()
                  }
                  ).catch( () => {
                      n.archive(),
                      r()
                  }
                  )
              }
              return e.handleNotification(n, {
                  issue: e => void i(n.issueId, e, Y),
                  oauthClientApproval: () => r(),
                  project: e => void i(n.projectId, e, G),
                  initiative: e => void i(n.initiativeId, e, W),
                  initiativeUpdate: e => void i(n.initiativeUpdateId, e, cj),
                  projectUpdate: e => void i(n.projectUpdateId, e, HM),
                  projectMilestone: e => void i(n.projectMilestoneId, e, mR),
                  pullRequest: e => void i(n.pullRequestId, e, U),
                  document: e => void i(n.documentId, e, NR),
                  post: e => void i(n.postId, e, Hj),
                  customer: e => void i(n.customerId, e, MB)
              })
          }
          ),
          this.fetchArchiveCache[n.id]
      }
      static #e = this.fetchArchiveCache = {};
      static getAllNotificationsFromTheSameGroup(e, t) {
          let n = e.groupingEntityId;
          return t.filter(e => e.groupingEntityId === n)
      }
      static groupNotificationsByGroupingEntityId(e) {
          return Object.values((0,
          RL.default)(e, e => e.groupingEntityId))
      }
      static getPrioritizedNotification(e) {
          let t = [];
          return this.groupNotificationsByGroupingEntityId(e).forEach(e => {
              let[n,...r] = gle(e);
              n && t.push({
                  mainNotification: n,
                  otherNotifications: r
              })
          }
          ),
          t
      }
      static findByHash(e, t) {
          return e.find(e => e.id.startsWith(t))
      }
  }
  ,
  VL = e => {
      let t = -1
        , n = e.findIndex(e => LL.doesNotificationHaveIncreasedPriority({
          createdAt: e.createdAt,
          type: e.type,
          readAt: e.readAt
      }));
      if (n !== -1 && (t = n),
      t === -1)
          return e;
      let r = [...e]
        , [i] = r.splice(t, 1);
      return r.unshift(i),
      r
  }
}
)), UL, WL, GL = t(( () => {
  UL = function(e) {
      return e.requested = `requested`,
      e.approved = `approved`,
      e.denied = `denied`,
      e
  }({}),
  WL = class e {
      static #e = this.minNoteLength = 2;
      static #t = this.maxNoteLength = 1e3;
      static #n = this.errorCodeAuthorize = `oauthAppApprovalError`;
      static #r = this.errorCodeDenied = `${e.errorCodeAuthorize}-Denied`;
      static #i = this.errorCodeGuestCantRequest = `${e.errorCodeAuthorize}-GuestCantRequest`;
      static #a = this.errorCodeNotRequested = `${e.errorCodeAuthorize}-NotRequested`;
      static #o = this.errorCodeUnanswered = `${e.errorCodeAuthorize}-Unanswered`;
      static #s = this.errorCodeAdditionalScopesRequested = `${e.errorCodeAuthorize}-AdditionalScopesRequested`;
      static #c = this.errorCodeAdditionalScopesRequestInFlight = `${e.errorCodeAuthorize}-AdditionalScopesRequestInFlight`
  }
}
));
function KL(e, t) {
  return t.length === 0 ? Promise.resolve({
      applicationInfoByIds: []
  }) : e.query(Ut`
    query ApplicationInfoByIdsQuery($ids: [String!]!) {
      applicationInfoByIds(ids: $ids) {
        id
        clientId
        name
        description
        developer
        developerUrl
        imageUrl
      }
    }
  `, {
      ids: t
  }, {
      cache: !0
  })
}
var qL = t(( () => {
  Wt()
}
)), JL, YL = t(( () => {
  zt(),
  GL(),
  iU(),
  GU(),
  F(),
  V(),
  sR(),
  qL(),
  om(),
  N(),
  JL = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.full;
      get isApproved() {
          return this.status === UL.approved
      }
      get isDenied() {
          return this.status === UL.denied
      }
      get isRequested() {
          return this.status === UL.requested
      }
      async hydrateOAuthApplicationInfo() {
          if (!this.oauthApplication)
              try {
                  let e = await KL(this.store.graphQLClient, [this.oauthClientId]);
                  Mt( () => {
                      this.oauthApplication = e.applicationInfoByIds.length > 0 ? e.applicationInfoByIds[0] : void 0
                  }
                  )
              } catch {
                  return
              }
      }
      markNotificationAsRead() {
          this.notifications.forEach(e => {
              e.readAt || (e.markAsRead(),
              e.save())
          }
          )
      }
  }
  ,
  M([B( () => q, `oauthClientApprovals`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], JL.prototype, `organization`, void 0),
  M([R({
      persistence: `none`,
      default: ``
  })], JL.prototype, `oauthClientId`, void 0),
  M([cg( () => J, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], JL.prototype, `requester`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `none`
  })], JL.prototype, `responder`, void 0),
  M([R({
      enum: UL,
      persistence: `updateOnly`,
      default: UL.requested
  })], JL.prototype, `status`, void 0),
  M([R({
      persistence: `createAndUpdate`,
      default: []
  })], JL.prototype, `scopes`, void 0),
  M([R({
      persistence: `createOnly`
  })], JL.prototype, `requestReason`, void 0),
  M([R({
      persistence: `updateOnly`
  })], JL.prototype, `denyReason`, void 0),
  M([R({
      persistence: `updateOnly`
  })], JL.prototype, `newlyRequestedScopes`, void 0),
  M([og( () => aR)], JL.prototype, `notifications`, void 0),
  M([I], JL.prototype, `markNotificationAsRead`, null),
  JL = M([mg(`OauthClientApproval`)], JL)
}
)), XL, ZL, QL, $L, eR, tR, nR, rR, iR, aR, oR, sR = t(( () => {
  Dl(),
  Nx(),
  gc(),
  L_(),
  cw(),
  fw(),
  eu(),
  XB(),
  Lq(),
  GU(),
  iz(),
  IL(),
  PR(),
  F(),
  V(),
  Ih(),
  ML(),
  hR(),
  HL(),
  qk(),
  Uj(),
  FB(),
  PL(),
  UM(),
  YL(),
  Iy(),
  dx(),
  DM(),
  TA(),
  lj(),
  WB(),
  N(),
  XL = class extends Jh {
      constructor(...e) {
          super(...e),
          this.markedUnreadAt = null
      }
      get issueId() {
          return this.issue?.id
      }
      get projectId() {
          return this.project?.id
      }
      get projectMilestoneId() {
          return this.projectMilestone?.id
      }
      get projectUpdateId() {
          return this.projectUpdate?.id
      }
      get initiativeId() {
          return this.initiative?.id
      }
      get initiativeUpdateId() {
          return this.initiative?.id
      }
      get documentId() {
          return this.document?.id
      }
      get pullRequestId() {
          return this.pullRequest?.id
      }
      get commentId() {
          return this.comment?.id
      }
      get parentCommentId() {
          return this.parentComment?.id
      }
      get oauthClientApprovalId() {
          return this.oauthClientApproval?.id
      }
      get postId() {
          return this.post?.id
      }
      get customerId() {
          return this.customer?.id
      }
      get shortLabel() {
          let e = this.getCommonPresenter();
          switch (this.type) {
          case O.issueStatusChangedDone:
          case O.issueStatusChangedAll:
              switch (this.issue?.value?.state.type) {
              case E.completed:
                  return `Completed`;
              case E.canceled:
                  return `Canceled`;
              default:
                  return `Status updated`
              }
          default:
              return e ? e.getShortLabel() : El.getShortLabel(this.type)
          }
      }
      get teams() {
          let e = this.isHydrated() ? this : void 0;
          return e && BL.handleNotification(e, {
              issue: e => {
                  let t = e?.team;
                  return t ? [t] : []
              }
              ,
              initiative: () => [],
              project: e => e?.accessibleTeams.elements ?? [],
              initiativeUpdate: e => e?.initiative.accessibleTeams.elements ?? [],
              projectUpdate: e => e?.project.accessibleTeams.elements ?? [],
              projectMilestone: e => e?.project.accessibleTeams.elements ?? [],
              document: e => e?.project ? e.project?.accessibleTeams.elements ?? [] : (e?.initiative,
              []),
              pullRequest: () => [],
              oauthClientApproval: () => [],
              post: e => e?.team ? [e.team] : [],
              customer: () => []
          }) || []
      }
      archive() {
          let e = super.archive();
          return this._locallyArchivedAt = this.archivedAt,
          e
      }
      unarchive() {
          let e = super.unarchive();
          return this._locallyArchivedAt = void 0,
          e
      }
      get wasArchivedLocally() {
          return this._locallyArchivedAt !== void 0 && this.archivedAt === this._locallyArchivedAt
      }
      markArchivedLocally() {
          this._locallyArchivedAt = this.archivedAt
      }
      get grouping() {
          let e = this.getCommonPresenter();
          return e ? e.getNotificationGrouping(this) : Mx.getNotificationGrouping(this, this.type)
      }
      get groupingEntityId() {
          let e = this.getCommonPresenter();
          return e ? e.getNotificationGroupingId(this) : Mx.getNotificationGroupingId(this, this.type)
      }
      get movedToInboxAt() {
          return this.unsnoozedAt ?? this.createdAt
      }
      get category() {
          let e = this.getCommonPresenter();
          return e ? e.getNotificationCategory() : El.categoryForType(this.type)
      }
      getActor() {
          return this.actor ?? this.externalUserActor?.value
      }
      markAsRead() {
          if (this.readAt === void 0) {
              if (this.markedUnreadAt && Date.now() - this.markedUnreadAt.getTime() < 500)
                  return;
              this.readAt = new Date
          }
      }
      markAsUnread() {
          this.readAt !== void 0 && (this.markedUnreadAt = new Date,
          this.readAt = void 0)
      }
      matchInlineFind(e) {
          let t = [this.shortLabel];
          this.isHydrated() && BL.handleNotification(this, {
              issue: e => {
                  e && (t.push(e.identifier),
                  t.push(e.title))
              }
              ,
              oauthClientApproval: e => {
                  e && (t.push(e.oauthApplication?.name),
                  t.push(`application approval`))
              }
              ,
              project: e => {
                  e && t.push(e.name)
              }
              ,
              projectUpdate: e => {
                  e && t.push(e.project.name)
              }
              ,
              projectMilestone: e => {
                  e && (t.push(e.project.name),
                  t.push(e.name))
              }
              ,
              initiative: e => {
                  e && t.push(e.name)
              }
              ,
              initiativeUpdate: e => {
                  e && t.push(e.initiative.name)
              }
              ,
              document: e => {
                  e && (t.push(e.displayTitle),
                  e.project && t.push(e.project.name),
                  e.initiative && t.push(e.initiative.name))
              }
              ,
              pullRequest: e => {
                  e && (t.push(e.title),
                  this.pullRequestComment?.value?.notificationText && t.push(this.pullRequestComment.value.notificationText))
              }
              ,
              post: e => {
                  e && t.push(e.title)
              }
              ,
              customer: e => {
                  e && t.push(e.name)
              }
          }),
          this.comment?.value?.notificationText && t.push(this.comment.value.notificationText),
          t.push(this.getActor()?.name || `Linear`);
          let n = $l(t.concrete().join(` `)).toLowerCase();
          return e.split(` `).reduce( (e, t) => e && n.indexOf(t) !== -1, !0)
      }
      inboxPath() {
          let e = {
              notificationStackId: this.groupingEntityId,
              issueOrigin: {
                  type: `inbox`
              }
          };
          this.isContentChangeNotification() && (e.contentChangesOpen = !0);
          let t = this.comment?.id
            , n = this;
          return this.isHydrated() === !1 ? {
              to: cie(this.user.organization.urlKey, this.id),
              state: e
          } : BL.handleNotification(n, {
              issue: r => {
                  if (!r)
                      return null;
                  let i = CI(r);
                  return t ? {
                      to: {
                          pathname: i,
                          hash: g_(t)
                      },
                      state: e
                  } : n.customerNeed?.id ? {
                      to: {
                          pathname: i,
                          hash: C_(n.customerNeed.id)
                      },
                      state: e
                  } : {
                      to: i,
                      state: e
                  }
              }
              ,
              document: n => {
                  if (!n)
                      return null;
                  let r = bL(n);
                  return t ? {
                      to: {
                          pathname: r,
                          hash: g_(t)
                      },
                      state: e
                  } : {
                      to: r,
                      state: e
                  }
              }
              ,
              oauthClientApproval: t => t ? {
                  to: CL(t),
                  state: e
              } : null,
              initiative: n => {
                  if (!n)
                      return null;
                  let r = rN(n);
                  return t ? {
                      to: {
                          pathname: r,
                          hash: g_(t)
                      },
                      state: e
                  } : {
                      to: r,
                      state: e
                  }
              }
              ,
              initiativeUpdate: t => t ? {
                  to: {
                      pathname: rN(t.initiative),
                      hash: this.getInitiativeUpdateHash()
                  },
                  state: e
              } : null,
              project: n => {
                  if (!n)
                      return null;
                  let r = eL(n, dw.documents);
                  return t ? {
                      to: {
                          pathname: r,
                          hash: g_(t)
                      },
                      state: e
                  } : this.customerNeed?.id ? NL(this.user).base ? {
                      to: {
                          pathname: dL(n),
                          hash: C_(this.customerNeed.id)
                      },
                      state: e
                  } : {
                      to: {
                          pathname: eL(n, dw.documents)
                      },
                      state: e
                  } : {
                      to: {
                          pathname: r,
                          hash: this.getProjectUpdateHash()
                      },
                      state: e
                  }
              }
              ,
              projectUpdate: t => t ? {
                  to: {
                      pathname: aN(t.project),
                      hash: this.getProjectUpdateHash()
                  },
                  state: e
              } : null,
              projectMilestone: n => {
                  if (!n || !n.project)
                      return null;
                  let r = aN(n.project);
                  return t ? {
                      to: {
                          pathname: r,
                          hash: g_(t)
                      },
                      state: e
                  } : {
                      to: r,
                      state: e
                  }
              }
              ,
              pullRequest: t => {
                  if (!t)
                      return null;
                  let n = QF(t)
                    , r = this.pullRequestComment?.id;
                  return r ? {
                      to: {
                          pathname: n,
                          hash: g_(r)
                      },
                      state: e
                  } : {
                      to: n,
                      state: e
                  }
              }
              ,
              post: t => t ? {
                  to: {
                      pathname: pL(t),
                      hash: this.getPostHash()
                  },
                  state: e
              } : null,
              customer: t => t ? this.customerNeed?.id ? {
                  to: {
                      pathname: XF(t),
                      hash: C_(this.customerNeed.id)
                  },
                  state: e
              } : {
                  to: {
                      pathname: XF(t)
                  },
                  state: e
              } : null
          }) ?? null
      }
      getProjectUpdateHash() {
          let e;
          return this.projectUpdate?.id && (e = this.comment?.id ? Vre({
              projectUpdateId: this.projectUpdate?.id,
              commentId: this.comment?.id
          }) : b_({
              projectUpdateId: this.projectUpdate?.id
          })),
          e
      }
      getInitiativeUpdateHash() {
          let e;
          return this.initiativeUpdate?.value?.slugId && (e = this.comment?.id ? Hre({
              initiativeUpdateSlugId: this.initiativeUpdate?.value?.slugId,
              commentId: this.comment?.id
          }) : x_({
              initiativeUpdateSlugId: this.initiativeUpdate?.value?.slugId
          })),
          e
      }
      getPostHash() {
          return this.comment?.id ? g_(this.comment.id) : void 0
      }
      getCommonPresenter() {
          return sw[El.toNotificationPresenter(this.type)]
      }
      isProjectDocumentNotification() {
          return [O.projectMention, O.projectNewComment, O.projectThreadResolved, O.projectCommentMention, O.projectCommentReaction, O.projectMilestoneMention, O.projectMilestoneNewComment, O.projectMilestoneThreadResolved, O.projectMilestoneCommentMention, O.projectMilestoneCommentReaction].includes(this.type)
      }
      isContentChangeNotification() {
          return [O.projectDescriptionContentChange, O.projectMilestoneDescriptionContentChange, O.documentContentChange, O.initiativeDescriptionContentChange].includes(this.type)
      }
      isCustomerNeedResolvedNotification() {
          return this.type === O.customerNeedResolved
      }
  }
  ,
  M([R({
      persistence: `createOnly`,
      default: O.issueSubscribed
  })], XL.prototype, `type`, void 0),
  M([cg( () => J, {
      optional: !0,
      nullable: !1,
      persistence: `createOnly`
  })], XL.prototype, `actor`, void 0),
  M([lg( () => Fy, {
      optional: !0,
      nullable: !1,
      persistence: `createOnly`
  })], XL.prototype, `externalUserActor`, void 0),
  M([R({
      persistence: `createOnly`
  })], XL.prototype, `sourceMetadata`, void 0),
  M([R({
      persistence: `createOnly`
  })], XL.prototype, `metadata`, void 0),
  M([B( () => J, `notifications`, {
      optional: !1,
      nullable: !1,
      persistence: `createOnly`
  })], XL.prototype, `user`, void 0),
  M([R({
      serializer: Ah
  })], XL.prototype, `readAt`, void 0),
  M([R({
      serializer: Ah
  })], XL.prototype, `snoozedUntilAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `createOnly`
  })], XL.prototype, `unsnoozedAt`, void 0),
  M([fg( () => FL, `notifications`, {
      persistence: `none`,
      indexed: !0
  })], XL.prototype, `subscriptions`, void 0),
  M([sg( () => Y, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `issue`, void 0),
  M([cg( () => ux, {
      optional: !0,
      nullable: !1,
      persistence: `none`,
      indexed: !0
  })], XL.prototype, `workflowState`, void 0),
  M([sg( () => YB, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `comment`, void 0),
  M([lg( () => YB, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `parentComment`, void 0),
  M([R({
      persistence: `createOnly`
  })], XL.prototype, `reactionEmoji`, void 0),
  M([sg( () => UB, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `customerNeed`, void 0),
  M([sg( () => MB, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `customer`, void 0),
  M([sg( () => NR, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `document`, void 0),
  M([B( () => G, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `project`, void 0),
  M([B( () => W, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `initiative`, void 0),
  M([sg( () => cj, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `initiativeUpdate`, void 0),
  M([sg( () => HM, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `projectUpdate`, void 0),
  M([sg( () => mR, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `projectMilestone`, void 0),
  M([sg( () => U, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `pullRequest`, void 0),
  M([sg( () => Kk, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `pullRequestComment`, void 0),
  M([sg( () => JL, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `oauthClientApproval`, void 0),
  M([sg( () => Hj, `notifications`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], XL.prototype, `post`, void 0),
  M([ag()], XL.prototype, `_locallyArchivedAt`, void 0),
  XL = M([mg(`Notification`)], XL),
  ZL = class extends XL {
  }
  ,
  QL = class extends XL {
  }
  ,
  $L = class extends XL {
  }
  ,
  eR = class extends XL {
  }
  ,
  tR = class extends XL {
  }
  ,
  nR = class extends XL {
  }
  ,
  rR = class extends XL {
  }
  ,
  iR = class extends XL {
  }
  ,
  aR = class extends XL {
  }
  ,
  oR = class extends XL {
  }
}
)), cR, lR = t(( () => {
  nt(),
  zn(),
  Db(),
  cR = class {
      static anchorComparisonDate(e, t, n) {
          switch (e) {
          case Tb.start:
              return t.startDate ?? t.targetDate;
          case Tb.milestone:
              return n?.targetDate ?? t.startDate ?? t.targetDate;
          case Tb.end:
              return t.targetDate ?? t.startDate;
          default:
              y(e);
              return
          }
      }
      static isRelationViolated(e) {
          let {relationDescription: t, aDate: n, bDate: r} = e;
          if (!n || !r)
              return !1;
          switch (t) {
          case Eb.blocking:
              return je(n.toLocalDate(), r.toLocalDate());
          case Eb.blockedBy:
              return je(r.toLocalDate(), n.toLocalDate());
          case Eb.endsWith:
          case Eb.startsWith:
          case ``:
              return !1;
          default:
              return y(t),
              !1
          }
      }
  }
}
)), uR, dR, fR = t(( () => {
  Db(),
  V(),
  F(),
  iz(),
  hR(),
  GU(),
  om(),
  lR(),
  N(),
  dR = class extends Yh {
      static #e = uR = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.full;
      get description() {
          return Goe({
              anchorType: this.anchorType,
              relatedAnchorType: this.relatedAnchorType
          }) || ``
      }
      get inverseDescription() {
          return Koe({
              anchorType: this.anchorType,
              relatedAnchorType: this.relatedAnchorType
          }) || ``
      }
      get isViolated() {
          let e = this.project
            , t = this.projectMilestone?.value
            , n = this.relatedProject
            , r = this.relatedProjectMilestone?.value;
          if (e.isDone || n.isDone)
              return !1;
          let i = cR.anchorComparisonDate(this.anchorType, e, t)
            , a = cR.anchorComparisonDate(this.relatedAnchorType, n, r);
          return cR.isRelationViolated({
              relationDescription: this.description,
              aDate: i,
              bDate: a
          })
      }
      get violationDescription() {
          if (this.isViolated)
              switch (this.description) {
              case Eb.blocking:
                  return `Ends after ${this.relatedProject.name} starts.`;
              case Eb.blockedBy:
                  return `Starts before ${this.relatedProject.name} ends.`;
              default:
                  return ``
              }
          return ``
      }
      get inverseViolationDescription() {
          if (this.isViolated)
              switch (this.inverseDescription) {
              case Eb.blocking:
                  return `Ends after ${this.project.name} starts.`;
              case Eb.blockedBy:
                  return `Starts before ${this.project.name} ends.`;
              default:
                  return ``
              }
          return ``
      }
      static preloadForProjects(e) {
          uR.preloadFor(`project`, {
              skipAddingToMemory: !0
          }).for(e.elements),
          uR.preloadFor(`relatedProject`, {
              skipAddingToMemory: !0
          }).for(e.elements)
      }
  }
  ,
  M([R({
      enum: wb,
      default: wb.dependency
  })], dR.prototype, `type`, void 0),
  M([B( () => G, `relations`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], dR.prototype, `project`, void 0),
  M([sg( () => mR, `relations`, {
      nullable: !0,
      indexed: !0
  })], dR.prototype, `projectMilestone`, void 0),
  M([R({
      enum: Tb,
      default: Tb.start
  })], dR.prototype, `anchorType`, void 0),
  M([B( () => G, `inverseRelations`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], dR.prototype, `relatedProject`, void 0),
  M([sg( () => mR, `inverseRelations`, {
      nullable: !0,
      indexed: !0
  })], dR.prototype, `relatedProjectMilestone`, void 0),
  M([R({
      enum: Tb,
      default: Tb.start
  })], dR.prototype, `relatedAnchorType`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `none`
  })], dR.prototype, `user`, void 0),
  M([L], dR.prototype, `isViolated`, null),
  M([L], dR.prototype, `violationDescription`, null),
  M([L], dR.prototype, `inverseViolationDescription`, null),
  dR = uR = M([mg(`ProjectRelation`)], dR)
}
)), pR, mR, hR = t(( () => {
  Cc(),
  Ax(),
  Joe(),
  cc(),
  Pv(),
  F(),
  V(),
  Ih(),
  Nm(),
  Lq(),
  iz(),
  sR(),
  fR(),
  Tm(),
  mH(),
  om(),
  nx(),
  ly(),
  N(),
  mR = class extends Yh {
      static #e = pR = this;
      constructor(...e) {
          super(...e),
          this.skipUpdatedAtKeys = new Set([`sortOrder`])
      }
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialPreloadForTeam = am.firstPriority;
      static #r = this.collectionsExcludedFromLocalTransaction = [`issues`];
      get issuesWithoutClones() {
          return this.issues.filter(e => !e.isClone)
      }
      get status() {
          return Ox.getStatus(this.id, this.progress, this.targetDate, this.project?.projectMilestones.map( ({id: e, progress: t}) => ({
              id: e,
              progress: t
          })) || [])
      }
      get progress() {
          return this.useIssueBasedProgress ? Sc.progress(this.issuesWithoutClones.elements) : Sc.completionProgress(this.currentProgress)
      }
      get progressPercent() {
          return Sc.progressToPercent(this.progress)
      }
      get progressText() {
          return this.progressPercent + `%`
      }
      get totalEstimatePoints() {
          let e = this.project.accessibleTeams.elements.every(e => e.estimationEnabled);
          return Sc.totalEstimatePoints(this.useIssueBasedProgress ? this.issuesWithoutClones.elements : this.currentProgress, {
              estimationEnabled: e
          })
      }
      get totalIssueCount() {
          return Sc.totalIssueCount(this.useIssueBasedProgress ? this.issuesWithoutClones.elements : this.currentProgress)
      }
      get inTriageEstimatePoints() {
          let e = this.project.accessibleTeams.elements.every(e => e.estimationEnabled);
          return Sc.inTriageEstimatePoints(this.useIssueBasedProgress ? this.issuesWithoutClones.elements : this.currentProgress, e)
      }
      get doneDate() {
          if (this.status === `done`)
              return this.issuesWithoutClones.reduce( (e, t) => {
                  let n = t.doneAt;
                  return e === void 0 || n && n.getTime() > e.getTime() ? n : e
              }
              , void 0)?.toTimelessDate()
      }
      get targetOrDoneDate() {
          return this.targetDate ?? this.doneDate
      }
      getTrait(e) {
          return sc(this.traits, e)
      }
      get useIssueBasedProgress() {
          return this.issues.isHydrated()
      }
      static validateMilestonePerProjectQuota(e) {
          return cy.validateQuotaOrToast(e.organization, jv.maxMilestonesPerProject, e.projectMilestones.filter(e => !e.isClone).length)
      }
      static create(e) {
          let t = pR.createEmpty();
          return t.project = e.project,
          t.name = e.name,
          t.sortOrder = tx.lastSortOrder(e.project.projectMilestones.filter(e => !e.isClone), `sortOrder`),
          e.targetDate && (t.targetDate = e.targetDate),
          t
      }
  }
  ,
  M([R({
      default: ``
  })], mR.prototype, `name`, void 0),
  M([dg({
      nullable: !0
  })], mR.prototype, `documentContent`, void 0),
  M([R({
      serializer: jh
  })], mR.prototype, `targetDate`, void 0),
  M([R({
      persistence: `none`,
      serializer: Fh,
      default: {}
  })], mR.prototype, `currentProgress`, void 0),
  M([R({
      default: 0
  })], mR.prototype, `sortOrder`, void 0),
  M([B( () => G, `projectMilestones`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      trait: `useForPartialIndex`
  })], mR.prototype, `project`, void 0),
  M([og( () => nR)], mR.prototype, `notifications`, void 0),
  M([z( () => Y, {
      index: `projectMilestoneId`,
      order: new P(`sortOrder`),
      customNetworkHydration: e => [{
          modelClass: Y,
          indexedKey: `projectId`,
          keyValue: e.project.id
      }],
      canSkipNetworkHydration: async e => await e.store.syncClient.hasModelsForPartialIndexes(Y.modelName, e.project.accessibleTeams.map(e => wm.createPartialIndex({
          modelClass: K,
          syncGroup: e.id
      })), {
          requireAll: !0
      })
  })], mR.prototype, `issues`, void 0),
  M([z( () => dR, {
      index: `projectId`,
      order: new P(`type`).and(`createdAt`, `desc`),
      canSkipHydration: e => !e.getTrait(jx.hasRelations)
  })], mR.prototype, `relations`, void 0),
  M([z( () => dR, {
      index: `relatedProjectId`,
      order: new P(`type`).and(`createdAt`, `desc`),
      canSkipHydration: e => !e.getTrait(jx.hasReverseRelations)
  })], mR.prototype, `inverseRelations`, void 0),
  M([R({
      persistence: `none`
  })], mR.prototype, `traits`, void 0),
  M([L], mR.prototype, `issuesWithoutClones`, null),
  M([L], mR.prototype, `status`, null),
  M([L], mR.prototype, `totalEstimatePoints`, null),
  M([L], mR.prototype, `doneDate`, null),
  M([I], mR, `create`, null),
  mR = pR = M([mg(`ProjectMilestone`)], mR)
}
)), gR, _R = t(( () => {
  F(),
  V(),
  om(),
  Ih(),
  AR(),
  GU(),
  N(),
  gR = class extends qh {
      static #e = this.loadStrategy = rm.explicitlyRequested
  }
  ,
  M([lg( () => kR, {
      nullable: !1,
      optional: !1,
      indexed: !0
  })], gR.prototype, `documentContent`, void 0),
  M([R({
      serializer: Mh,
      shallowObservation: !0
  })], gR.prototype, `contentData`, void 0),
  M([fg( () => J)], gR.prototype, `actors`, void 0),
  M([R({
      serializer: Ah,
      default: () => new Date
  })], gR.prototype, `contentDataSnapshotAt`, void 0),
  M([R({
      persistence: `none`
  })], gR.prototype, `metadata`, void 0),
  gR = M([mg(`DocumentContentHistory`)], gR)
}
)), vR, _le = t(( () => {
  Sx(),
  Ih(),
  vR = {
      optimizeUpdate: (e, t) => {
          let n = new xx;
          n.applyUpdate(Ph.deserialize(e));
          let r = n.encodeStateVector();
          return n.applyUpdate(Ph.deserialize(t)),
          Ph.serialize(n.encodeStateAsUpdate(r))
      }
  }
}
)), yR, bR = t(( () => {
  yR = function(e) {
      return e[e.noArchivedModels = 0] = `noArchivedModels`,
      e[e.noTempModels = 1] = `noTempModels`,
      e[e.onlyRegularModels = 2] = `onlyRegularModels`,
      e[e.onlyArchivedModels = 3] = `onlyArchivedModels`,
      e[e.allModels = 4] = `allModels`,
      e
  }({})
}
)), xR, vle = t(( () => {
  zt(),
  Xp(),
  ws(),
  Vm(),
  F(),
  om(),
  bR(),
  pm(),
  xR = class extends Bm {
      get elements() {
          return this.isHydrated() || this.hydrate(),
          super.elements
      }
      get length() {
          return this.isHydrated() || this.hydrate(),
          super.length
      }
      constructor(e, t, n, r) {
          if (super(e, [], r),
          this.parent = t,
          this.index = n,
          e.loadStrategy !== rm.explicitlyRequested)
              throw Error(`RequestCollection can only be used with models that have loadStrategy explicitlyRequested`)
      }
      isHydrated() {
          return !!(this.hydrationPromise && !this.hydrationPromise.isPending)
      }
      hydrate() {
          return this.hydrationPromise && this.hydrationPromiseParentUpdatedAt && this.hydrationPromiseParentUpdatedAt >= this.parent.updatedAt ? this.hydrationPromise : (this.hydrationPromise = new Jp(async (e, t) => {
              try {
                  await qh.store.batchModelLoader.addRequest({
                      modelClass: this.modelClass,
                      indexedKey: this.index,
                      keyValue: this.parent.id,
                      skipSavingModelsInDatabase: !0
                  });
                  let t = qh.store.syncClient.allModelsOfType(this.modelClass, yR.onlyRegularModels).filter(e => e[this.index] === this.parent.id);
                  this.updateRawModels(t),
                  e()
              } catch (e) {
                  w.error(`Hydration failed`, e, {
                      modelClass: this.modelClass.modelName,
                      key: this.index,
                      keyValue: this.parent?.id
                  }),
                  this.invalidateRejectedWhenRequested(),
                  t(new dm(this.modelClass,e))
              }
          }
          ),
          this.hydrationPromise.catch(e => {
              w.info(`Error while hydrating request collection`, {
                  modelName: this.modelClass.modelName,
                  parent: this.parent?.modelName,
                  index: this.index,
                  error: e
              })
          }
          ),
          this.hydrationPromiseParentUpdatedAt = this.parent.updatedAt,
          this.hydrationPromise)
      }
      invalidateRejectedHydrationPromises() {
          this.hydrationPromise?.error && (this.hydrationPromise = void 0,
          this.hydrationPromiseParentUpdatedAt = void 0),
          super.invalidateRejectedHydrationPromises()
      }
      updateRawModels(e) {
          Mt( () => {
              this.setElementIds(e.map(e => e.id)),
              this._rootRawElements = e,
              this.idLookup = {};
              for (let t of e)
                  this.idLookup[t.id] = t,
                  this.elementsObserved && t.observePropertyChanges()
          }
          )
      }
  }
}
)), SR, CR, wR = t(( () => {
  Ng(),
  V(),
  F(),
  om(),
  iU(),
  mH(),
  GU(),
  N(),
  CR = class extends Yh {
      static #e = SR = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static create(e) {
          let {id: t, team: n, type: r} = e
            , i = SR.createEmpty();
          return t && (i.id = t),
          i.organization = i.store.organization,
          i.team = n,
          i.type = r,
          i
      }
  }
  ,
  M([B( () => q, `aiPromptRules`, {
      indexed: !0,
      nullable: !1,
      optional: !1,
      persistence: `none`
  })], CR.prototype, `organization`, void 0),
  M([B( () => K, `aiPromptRules`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], CR.prototype, `team`, void 0),
  M([R({
      persistence: `createOnly`,
      default: Ag.productIntelligence
  })], CR.prototype, `type`, void 0),
  M([dg({
      nullable: !0
  })], CR.prototype, `documentContent`, void 0),
  M([R()], CR.prototype, `settings`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `none`
  })], CR.prototype, `updatedBy`, void 0),
  M([I], CR, `create`, null),
  CR = SR = M([mg(`AiPromptRules`)], CR)
}
));
function TR(e) {
  if (!(0,
  ER.default)(e, pl())) {
      if (Array.isArray(e))
          e.forEach(TR);
      else if (typeof e == `object` && e)
          for (let t in e.attrs && (e.attrs.language === null && delete e.attrs.language,
          e.attrs.uploadState !== void 0 && delete e.attrs.uploadState,
          Object.keys(e.attrs).length === 0 && delete e.attrs),
          e)
              e[t] === void 0 || e[t] === null ? delete e[t] : TR(e[t]);
      return e
  }
}
var ER, DR, OR, kR, AR = t(( () => {
  ER = e(ne(), 1),
  DR = e(nn(), 1),
  zt(),
  ml(),
  Sy(),
  Sx(),
  wx(),
  zn(),
  qoe(),
  cc(),
  Dx(),
  V(),
  om(),
  F(),
  Ih(),
  ws(),
  Lq(),
  iz(),
  hR(),
  PR(),
  XB(),
  _R(),
  _le(),
  vle(),
  Nm(),
  Sm(),
  wR(),
  DM(),
  sj(),
  N(),
  kR = class extends qh {
      static #e = OR = this;
      constructor(...e) {
          super(...e),
          this.history = new xR(gR,this,`documentContentId`,{
              order: new P(`createdAt`,`desc`)
          })
      }
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static #r = this.partialPreloadForTeam = am.secondPriority;
      get contentData() {
          if (this.contentState)
              return this.createYjsDocument().asProsemirrorData()
      }
      get activeCommentThreadCount() {
          return this.contentData ? this.activeCommentsForContent(this.contentData.content).distinct().length : 0
      }
      get resolvedCommentThreadCount() {
          return this.contentData ? this.resolvedCommentsForContent(this.contentData.content).distinct().length : 0
      }
      get removedCommentThreadCount() {
          return this.comments.length - this.activeCommentThreadCount - this.resolvedCommentThreadCount
      }
      get markdownContent() {
          return this.contentData ? Hp.serialize(this.contentData) : ``
      }
      get hasContent() {
          let e = this.contentData;
          return !e || !e.content?.length ? !1 : !(e.content.length === 1 && e.content[0].type === `paragraph` && (!e.content[0].content || e.content[0].content.length === 0 || e.content[0].content.length === 1 && e.content[0].content[0].type === `text` && e.content[0].content[0].text === ``))
      }
      checkSize(e) {
          if (this.hasContent && this.contentState != null && this.contentState.length > Ex.maxContentStateLength)
              return Ex.maxContentStateLengthErrorMessage(e)
      }
      get documentVersion() {
          return this.createYjsDocument().documentVersion
      }
      getParent() {
          return this.isHydrated() ? this.unsafeGetParent() : Promise.all([this.issue?.resolve(), this.document?.resolve()]).then( () => this.unsafeGetParent())
      }
      unsafeGetParent() {
          return this.issue?.value || this.project || this.projectMilestone?.value || this.document?.value || this.initiative || this.aiPromptRules?.value
      }
      setParent(e) {
          if (e instanceof Y)
              this.issue = vm.wrap(e);
          else if (e instanceof G)
              this.project = e;
          else if (e instanceof mR)
              this.projectMilestone = vm.wrap(e);
          else if (e instanceof NR)
              this.document = vm.wrap(e);
          else if (e instanceof W)
              this.initiative = e;
          else if (e instanceof CR)
              this.aiPromptRules = vm.wrap(e);
          else
              throw y(e)
      }
      get parentType() {
          if (this.issue)
              return `issue`;
          if (this.project)
              return `project`;
          if (this.projectMilestone)
              return `projectMilestone`;
          if (this.document)
              return `document`;
          if (this.initiative)
              return `initiative`;
          if (this.aiPromptRules)
              return `aiPromptRules`
      }
      hasContentEqualTo(e) {
          return (0,
          ER.default)(TR((0,
          DR.default)(this.contentData)), TR((0,
          DR.default)(e)))
      }
      isParentPersisted() {
          return this.isHydrated() ? this.getParent()?.persisted ?? !1 : this.getParent().then(e => e?.persisted ?? !1)
      }
      createYjsDocument() {
          try {
              let e = new xx;
              if (this.contentState) {
                  let t = Ph.deserialize(this.contentState);
                  e.applyUpdate(t)
              } else
                  e.updateToProsemirrorData(pl());
              return e
          } catch (e) {
              return w.error(`Error converting contentState to Yjs doc`, e),
              new xx
          }
      }
      replaceWithContent(e) {
          let t = this.createYjsDocument();
          this.persisted ? (t.updateToProsemirrorData(e),
          this.contentState = Ph.serialize(t.encodeStateAsUpdate())) : (t.updateToProsemirrorData(e),
          this.contentState = Ph.serialize(t.getFlattenedState({
              dontBumpVersion: !0
          })))
      }
      appendContent(e) {
          let t = this.createYjsDocument()
            , n = this.hasContent ? {
              type: `doc`,
              content: [...t.asProsemirrorData().content || [], ...e.content || []]
          } : e;
          this.replaceWithContent(n)
      }
      prependContent(e) {
          let t = this.createYjsDocument()
            , n = this.hasContent ? {
              type: `doc`,
              content: [...e.content || [], ...t.asProsemirrorData().content || []]
          } : e;
          this.replaceWithContent(n)
      }
      applyState(e) {
          let t = this.createYjsDocument();
          t.applyUpdate(Ph.deserialize(e)),
          this.contentState = Ph.serialize(t.encodeStateAsUpdate())
      }
      get textContent() {
          if (!this.contentData)
              return ``;
          let e = dl.nodeFromJSON(this.contentData);
          return Cx(e, 0, e.content.size, {})
      }
      getTrait(e) {
          return sc(this.traits, e)
      }
      includeInLocalTransactionVia() {
          return [this.unsafeGetParent()].concrete()
      }
      static getOrCreateFrom(e, t=`attach`) {
          let n = Ft(e => {
              if (e.documentContent.value)
                  return e.documentContent.value;
              let n = new OR;
              return n.setParent(e),
              t === `attach` && (e.documentContent = ym.wrap(n)),
              n
          }
          );
          if (e.isHydrated()) {
              let t = n(e);
              return e.documentContent.value,
              t
          } else
              return e.hydrate().then(e => n(e))
      }
      activeCommentsForContent(e) {
          let t = [];
          for (let n of e)
              t.push(...this.activeCommentsForNode(n));
          return t
      }
      activeCommentsForNode(e) {
          let t = [];
          return e.content && t.push(...this.activeCommentsForContent(e.content)),
          e.marks && t.push(...e.marks.filter(e => e.type === `inlineComment` && !e.attrs?.createdBy && e.attrs?.resolved !== !0 && e.attrs?.resolved !== `true` && e.attrs?.commentId).map(e => e.attrs?.commentId)),
          t
      }
      resolvedCommentsForContent(e) {
          let t = [];
          for (let n of e)
              t.push(...this.resolvedCommentsForNode(n));
          return t
      }
      resolvedCommentsForNode(e) {
          let t = [];
          return e.content && t.push(...this.resolvedCommentsForContent(e.content)),
          e.marks && t.push(...e.marks.filter(e => e.type === `inlineComment` && (e.attrs?.resolved === !0 || e.attrs?.resolved === `true`) && e.attrs?.commentId).map(e => e.attrs?.commentId)),
          t
      }
  }
  ,
  M([R({
      optimizer: vR
  })], kR.prototype, `contentState`, void 0),
  M([R({
      persistence: `updateOnly`
  })], kR.prototype, `restoredAt`, void 0),
  M([R({
      persistence: `none`
  })], kR.prototype, `traits`, void 0),
  M([dg( () => Y, `documentContent`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`,
      trait: `useForPartialIndex`
  })], kR.prototype, `issue`, void 0),
  M([ug( () => G, `documentContent`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`,
      trait: `useForPartialIndex`
  })], kR.prototype, `project`, void 0),
  M([dg( () => mR, `documentContent`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], kR.prototype, `projectMilestone`, void 0),
  M([dg( () => NR, `documentContent`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], kR.prototype, `document`, void 0),
  M([ug( () => W, `documentContent`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], kR.prototype, `initiative`, void 0),
  M([dg( () => CR, `documentContent`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], kR.prototype, `aiPromptRules`, void 0),
  M([z( () => YB, {
      index: `documentContentId`,
      canSkipHydration: e => !e.getTrait(Tx.hasComments)
  })], kR.prototype, `comments`, void 0),
  M([z( () => oj, {
      index: `documentContentId`
  })], kR.prototype, `mediaMetadata`, void 0),
  M([Mre()], kR.prototype, `viewers`, void 0),
  M([L], kR.prototype, `contentData`, null),
  M([L], kR.prototype, `activeCommentThreadCount`, null),
  M([L], kR.prototype, `resolvedCommentThreadCount`, null),
  M([L], kR.prototype, `removedCommentThreadCount`, null),
  M([L], kR.prototype, `markdownContent`, null),
  M([L], kR.prototype, `hasContent`, null),
  M([L], kR.prototype, `documentVersion`, null),
  M([I], kR.prototype, `replaceWithContent`, null),
  M([I], kR.prototype, `appendContent`, null),
  M([I], kR.prototype, `prependContent`, null),
  M([I], kR.prototype, `applyState`, null),
  kR = OR = M([mg(`DocumentContent`)], kR)
}
)), jR, MR, NR, PR = t(( () => {
  pn(),
  ln(),
  jR = e(nn(), 1),
  Mu(),
  ml(),
  bx(),
  V(),
  Ih(),
  F(),
  Vm(),
  Nm(),
  gx(),
  iz(),
  GU(),
  bH(),
  AR(),
  sR(),
  DM(),
  lM(),
  Sm(),
  om(),
  eu(),
  mH(),
  xM(),
  Lq(),
  N(),
  NR = class extends Xh {
      static #e = MR = this;
      constructor(...e) {
          super(...e),
          this.skipUpdatedAtKeys = new Set([`subscriberIds`])
      }
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      get reminder() {
          return this.reminders.elements[0]
      }
      get slug() {
          return `${ju(this.title || `untitled`)}-${this.slugId}`
      }
      get displayTitle() {
          return this.title || yx.defaultDocumentTitle
      }
      isUntouched() {
          return !this.title && !this.icon && !this.color && !this.favorite && !this.isTemplate && !this.lastAppliedTemplate && this.isEmptyContent()
      }
      isEmptyContent() {
          let e = this.documentContent.value;
          return e == null || !e.hasContent
      }
      static create(e) {
          let t = MR.createEmpty();
          t.title = e.title;
          let n, r, i, a, o = e.folder;
          return o ? (n = o.sourceProject,
          r = o.sourceInitiative,
          i = o.sourceTeam,
          t.resourceFolder = vm.wrap(o)) : (n = e.project,
          r = e.initiative,
          i = e.team,
          a = e.issue),
          n ? t.project = n : r ? t.initiative = r : i ? t.team = i : a && (t.issue = vm.wrap(a)),
          t.creator = e.creator,
          t.updatedBy = e.updatedBy ?? e.creator,
          e.creator && t.subscribers.add(e.creator),
          t
      }
      duplicate(e) {
          let t = MR.createEmpty();
          t.project = this.project,
          t.initiative = this.initiative,
          t.team = this.team,
          this.issue?.value && (t.issue = vm.wrap(this.issue.value)),
          t.creator = e,
          t.updatedBy = e,
          t.title = `${this.title} (copy)`,
          t.icon = this.icon,
          t.color = this.color;
          let n = this.documentContent.value?.contentData;
          if (n) {
              let e = an.fromJSON(dl, n)
                , r = dl.marks.inlineComment
                , i = (0,
              jR.default)(n);
              if (r) {
                  let t = new dn(e);
                  t.removeMark(0, t.doc.content.size, r),
                  t.docChanged && (i = t.doc.toJSON())
              }
              kR.getOrCreateFrom(t).replaceWithContent(i)
          }
          return t
      }
      markNotificationAsRead(e) {
          let t = this.notifications.find(t => t.id === e);
          if (!t)
              return;
          let n = t?.groupingEntityId;
          this.notifications.forEach(e => {
              e.readAt === void 0 && e.groupingEntityId === n && (e.markAsRead(),
              e.save())
          }
          )
      }
      toggleFavorite() {
          if (this.favorite)
              return this.favorite.delete(),
              !1;
          let e = yH.create({
              reference: this
          });
          return e.save(!0),
          e
      }
      beforeSave(e) {
          super.beforeSave(e),
          this.title ||= ``,
          this.title = this.title.trim()
      }
      applyTemplate(e) {
          let t = e.templateData;
          if (!t)
              return;
          let n = kR.getOrCreateFrom(this);
          if (t.descriptionData && n && n.replaceWithContent(t.descriptionData),
          n.hasContent || n.replaceWithContent(pl()),
          this.icon = t.icon,
          this.color = t.color,
          t.title && (this.title = t.title),
          t.projectId) {
              let e = this.store.findById(G, t.projectId);
              e && (this.project = e)
          }
          return this.lastAppliedTemplate = vm.wrap(e),
          this
      }
      get parent() {
          return this.project || this.initiative || this.team || this.issue?.value
      }
      get organization() {
          return this.store.organization
      }
      get parentId() {
          return this.project?.id ?? this.initiative?.id ?? this.team?.id ?? this.issue?.id
      }
      get parentName() {
          if (this.project)
              return this.project.name;
          if (this.initiative)
              return this.initiative.name;
          if (this.team)
              return this.team.name;
          let e = this.issue?.value;
          return e ? e.title : ``
      }
      get parentLabel() {
          return this.project ? `Project` : this.initiative ? `Initiative` : this.team ? `Team` : `Issue`
      }
      get accessibleTeams() {
          if (this.team)
              return Bm.of(K, [this.team]);
          if (this.project)
              return this.project.accessibleTeams;
          if (this.initiative)
              return this.initiative.accessibleTeams;
          let e = this.issue?.value;
          return e ? Bm.of(K, [e.team]) : new Bm(K)
      }
      matchInlineFind(e) {
          return $l(this.title).toLowerCase().indexOf(e) !== -1
      }
  }
  ,
  M([R({
      default: ``
  })], NR.prototype, `title`, void 0),
  M([R({
      persistence: `none`,
      indexed: !0,
      default: ``
  })], NR.prototype, `slugId`, void 0),
  M([R()], NR.prototype, `icon`, void 0),
  M([R()], NR.prototype, `color`, void 0),
  M([R({
      default: 0
  })], NR.prototype, `sortOrder`, void 0),
  M([R({
      persistence: `updateOnly`
  })], NR.prototype, `trashed`, void 0),
  M([dg({
      nullable: !0
  })], NR.prototype, `documentContent`, void 0),
  M([B( () => G, `documents`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], NR.prototype, `project`, void 0),
  M([B( () => W, `documents`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], NR.prototype, `initiative`, void 0),
  M([B( () => K, `documents`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], NR.prototype, `team`, void 0),
  M([sg( () => Y, `documents`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], NR.prototype, `issue`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `none`
  })], NR.prototype, `creator`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `none`
  })], NR.prototype, `updatedBy`, void 0),
  M([lg( () => hx, {
      nullable: !0,
      indexed: !0
  })], NR.prototype, `lastAppliedTemplate`, void 0),
  M([R({
      serializer: Ah,
      persistence: `updateOnly`
  })], NR.prototype, `hiddenAt`, void 0),
  M([fg( () => J, `subscribedDocuments`, {
      indexed: !0
  })], NR.prototype, `subscribers`, void 0),
  M([ug({
      nullable: !0
  })], NR.prototype, `favorite`, void 0),
  M([og( () => rR)], NR.prototype, `notifications`, void 0),
  M([R({
      persistence: `none`,
      default: !1
  })], NR.prototype, `isTemplate`, void 0),
  M([z( () => bM, {
      index: `documentId`,
      order: new P(e => e.createdAt.valueOf(),`desc`)
  })], NR.prototype, `reminders`, void 0),
  M([L], NR.prototype, `reminder`, null),
  M([I], NR.prototype, `markNotificationAsRead`, null),
  M([I], NR.prototype, `toggleFavorite`, null),
  M([I], NR.prototype, `applyTemplate`, null),
  M([L], NR.prototype, `parent`, null),
  M([sg( () => cM, `documents`, {
      nullable: !0,
      indexed: !0
  })], NR.prototype, `resourceFolder`, void 0),
  NR = MR = M([mg(`Document`)], NR)
}
)), FR, IR = t(( () => {
  FR = function(e) {
      return e.new = `new`,
      e.active = `active`,
      e.inactive = `inactive`,
      e.launched = `launched`,
      e
  }({})
}
)), LR, RR, zR = t(( () => {
  V(),
  F(),
  VR(),
  rB(),
  iU(),
  N(),
  RR = LR = class extends Yh {
      static create(e) {
          let t = new LR;
          return t.name = e.name,
          t.description = e.description,
          t.segmentKeys = e.segmentKeys,
          t.type = e.type,
          t.organization = e.organization,
          t
      }
      isAheadOf(e) {
          let t = this.organization.orderedRolloutStages;
          return t.indexOf(this) > t.indexOf(e)
      }
  }
  ,
  M([R({
      default: ``
  })], RR.prototype, `name`, void 0),
  M([R()], RR.prototype, `description`, void 0),
  M([R({
      default: []
  })], RR.prototype, `segmentKeys`, void 0),
  M([R({
      default: `dev`
  })], RR.prototype, `type`, void 0),
  M([R({
      default: 0
  })], RR.prototype, `sortOrder`, void 0),
  M([og( () => BR)], RR.prototype, `featureFlags`, void 0),
  M([B( () => q, `rolloutStages`, {
      persistence: `none`,
      optional: !1,
      nullable: !1,
      indexed: !0
  })], RR.prototype, `organization`, void 0),
  M([B( () => nB, `rolloutStages`, {
      persistence: `none`,
      optional: !1,
      nullable: !1,
      indexed: !0
  })], RR.prototype, `integration`, void 0),
  RR = LR = M([mg(`FeatureFlagRolloutStage`)], RR)
}
)), BR, VR = t(( () => {
  IR(),
  V(),
  F(),
  zR(),
  rB(),
  iU(),
  iz(),
  Ih(),
  GU(),
  Lq(),
  N(),
  BR = class extends Yh {
      get entityName() {
          return this.project?.name ?? this.issue?.value?.identifier ?? ``
      }
      get displayedKey() {
          return this.key ?? this.defaultKey
      }
  }
  ,
  M([B( () => G, `featureFlags`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], BR.prototype, `project`, void 0),
  M([dg( () => Y, `featureFlag`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], BR.prototype, `issue`, void 0),
  M([B( () => RR, `featureFlags`, {
      optional: !0,
      nullable: !1
  })], BR.prototype, `rolloutStage`, void 0),
  M([R({
      persistence: `createOnly`
  })], BR.prototype, `key`, void 0),
  M([R({
      persistence: `createOnly`,
      isVirtual: !0
  })], BR.prototype, `defaultKey`, void 0),
  M([R({
      persistence: `none`,
      default: ``
  })], BR.prototype, `externalUrl`, void 0),
  M([R({
      persistence: `none`,
      default: FR.active
  })], BR.prototype, `status`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], BR.prototype, `lastStageUpdatedAt`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0
  })], BR.prototype, `lastStageUpdatedBy`, void 0),
  M([B( () => q, `featureFlags`, {
      persistence: `none`,
      optional: !1,
      nullable: !1,
      indexed: !0
  })], BR.prototype, `organization`, void 0),
  M([B( () => nB, `featureFlags`, {
      persistence: `none`,
      optional: !1,
      nullable: !1,
      indexed: !0
  })], BR.prototype, `integration`, void 0),
  M([L], BR.prototype, `displayedKey`, null),
  BR = M([mg(`FeatureFlag`)], BR)
}
)), HR, UR, WR = t(( () => {
  Bl(),
  qb(),
  HR = {
      serialize: e => e.priority,
      deserialize: e => zl.createFromPriority(e)
  },
  UR = {
      serialize: e => e.priority,
      deserialize: e => Kb.createFromPriority(e)
  }
}
)), GR, KR, qR, JR = t(( () => {
  zn(),
  GR = e => {
      let t = new Map;
      return e.forEach(e => {
          let n = qR(e, {
              groupType: `feature`
          });
          t.has(n) ? t.get(n)?.additionalNeeds.push(e) : t.set(n, {
              primaryNeed: e,
              additionalNeeds: [],
              type: e.issue ? `issue` : `project`,
              groupId: n
          })
      }
      ),
      t
  }
  ,
  KR = (e, t={}) => {
      let {withinFeatureGroup: n} = t
        , r = new Map;
      return e.forEach(e => {
          let t = qR(e, {
              groupType: `customer`,
              withinFeatureGroup: n
          });
          r.has(t) ? r.get(t)?.additionalNeeds.push(e) : r.set(t, {
              primaryNeed: e,
              additionalNeeds: [],
              groupId: t
          })
      }
      ),
      r
  }
  ,
  qR = (e, t) => {
      let {groupType: n} = t;
      switch (n) {
      case `customer`:
          return `${t.withinFeatureGroup ? `${e.issue?.id || e.project?.id}-` : ``}${e.customer?.id || e.id}`;
      case `feature`:
          return e.issue?.id || e.project?.id || e.id;
      default:
          throw new Rn(n)
      }
  }
}
)), YR, yle = t(( () => {
  YR = function(e) {
      return e.summary = `summary`,
      e
  }({})
}
)), XR, ZR = t(( () => {
  yle(),
  iz(),
  GU(),
  iU(),
  V(),
  om(),
  F(),
  Ih(),
  N(),
  XR = class extends Jh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular
  }
  ,
  M([R({
      default: YR.summary
  })], XR.prototype, `type`, void 0),
  M([cg( () => q, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], XR.prototype, `organization`, void 0),
  M([cg( () => J, {
      nullable: !0
  })], XR.prototype, `creator`, void 0),
  M([B( () => G, `customerGeneratedContents`, {
      nullable: !1,
      optional: !0,
      indexed: !0
  })], XR.prototype, `project`, void 0),
  M([R({
      serializer: Mh,
      shallowObservation: !0
  })], XR.prototype, `bodyData`, void 0),
  M([R({
      persistence: `none`,
      default: ``
  })], XR.prototype, `evalLogId`, void 0),
  XR = M([mg(`CustomerGeneratedContent`)], XR)
}
)), QR, $R = t(( () => {
  Nm(),
  Vm(),
  FB(),
  JR(),
  QR = e => {
      let t = KR(e)
        , n = new Set(e.map(e => e.customer?.value).filter(Boolean));
      return Bm.of(MB, Array.from(n), {
          order: new P(e => {
              let n = t.get(e.id);
              return n ? [n.primaryNeed, ...n.additionalNeeds].some(e => e.priority.isImportant) : !1
          }
          ,`desc`).and(e => e.displayRevenue ?? 0, `desc`).and(e => {
              let n = t.get(e.id);
              return n ? [n.primaryNeed, ...n.additionalNeeds].length : 0
          }
          , `desc`)
      }).elements
  }
}
)), ez, tz, nz, rz, G, iz = t(( () => {
  ez = e(fe(), 1),
  tz = e(ne(), 1),
  nz = e(l(), 1),
  nt(),
  _n(),
  Woe(),
  Kd(),
  Mu(),
  Cc(),
  ml(),
  Db(),
  Ev(),
  Jl(),
  kb(),
  cc(),
  Bu(),
  Yr(),
  Un(),
  jb(),
  Hb(),
  Gb(),
  Pv(),
  qb(),
  zn(),
  eu(),
  Lq(),
  iU(),
  gx(),
  vx(),
  mH(),
  GU(),
  PR(),
  bH(),
  AR(),
  V(),
  F(),
  Vm(),
  Nm(),
  Ih(),
  UM(),
  sR(),
  hR(),
  nx(),
  ws(),
  tj(),
  HA(),
  Pz(),
  fR(),
  Sm(),
  Tm(),
  _M(),
  AM(),
  WB(),
  QO(),
  VR(),
  DM(),
  xM(),
  WR(),
  RA(),
  FA(),
  JR(),
  ZR(),
  lM(),
  ly(),
  $R(),
  KA(),
  Dk(),
  N(),
  G = class extends Xh {
      static #e = rz = this;
      constructor(...e) {
          super(...e),
          this.toggleFavorite = (e={}) => {
              let {projectTab: t} = e
                , n = t ? this.favorites.filter(e => e.projectTab === t) : this.favorites.filter(e => e.projectTab == null);
              if (n.length > 0)
                  return n.forEach(e => e.delete()),
                  !1;
              {
                  let e = yH.create({
                      reference: this,
                      projectTab: t
                  });
                  return e.save(!0),
                  e
              }
          }
      }
      get effectiveUpdateReminderFrequency() {
          return this.updateReminderFrequency ?? this.organization.projectUpdateReminderFrequencyInWeeks ?? 0
      }
      get effectiveUpdateReminderFrequencyResolution() {
          return this.updateReminderFrequency == null ? Ab.weekly : this.frequencyResolution
      }
      get effectiveUpdateReminderDay() {
          return this.updateReminderFrequency != null && this.updateRemindersDay != null ? this.updateRemindersDay : this.organization.projectUpdateRemindersDay
      }
      get effectiveUpdateReminderHour() {
          return this.updateReminderFrequency != null && this.updateRemindersHour != null ? this.updateRemindersHour : this.organization.projectUpdateRemindersHour
      }
      get progressHistoryEntries() {
          let e = this.progressHistory.map(bb.serialize).filter(e => e.date);
          if (e.length > 0) {
              let t = e[e.length - 1].date
                , n = new Date().toTimelessDate();
              t !== n && e.push({
                  createdAt: new Date,
                  date: n,
                  backlogEstimate: this.currentProgress.backlogEstimate ?? 0,
                  unstartedEstimate: this.currentProgress.unstartedEstimate ?? 0,
                  startedEstimate: this.currentProgress.startedEstimate ?? 0,
                  completedEstimate: this.currentProgress.completedEstimate ?? 0,
                  scopeEstimate: this.currentProgress.scopeEstimate ?? 0
              })
          }
          return e
      }
      get reminder() {
          return this.reminders.elements[0]
      }
      get dependedOnByRelations() {
          return this.relations.filter(this.checkForErroneousProjectRelation).filter(e => e.description === Eb.blocking)
      }
      get dependsOnRelations() {
          return this.inverseRelations.filter(this.checkForErroneousProjectRelation).filter(e => e.inverseDescription === Eb.blockedBy)
      }
      get blockingRelations() {
          return this.relations.filter(this.checkForErroneousProjectRelation).filter(e => e.description === Eb.blocking)
      }
      get blockedByRelations() {
          return this.inverseRelations.filter(this.checkForErroneousProjectRelation).filter(e => e.inverseDescription === Eb.blockedBy)
      }
      get violatedRelations() {
          return Bm.of(dR, this.allRelations.map( ({relation: e}) => e).filter(this.checkForErroneousProjectRelation).filter(e => e.isViolated))
      }
      get allNeeds() {
          return this.needs
      }
      get hasDependedOnByRelations() {
          return this.dependedOnByRelations.length > 0
      }
      get hasDependsOnRelations() {
          return this.dependsOnRelations.length > 0
      }
      get hasBlockingRelations() {
          return this.blockingRelations.length > 0
      }
      get hasBlockedByRelations() {
          return this.blockedByRelations.length > 0
      }
      get hasViolatedRelations() {
          return this.violatedRelations.length > 0
      }
      get hasRelatedRelations() {
          return this.relations.length > 0 || this.inverseRelations.length > 0
      }
      relationsOfType(e) {
          return [...this.relations.filter(t => t.description === e).map(e => ({
              relation: e,
              relatedEntity: e.relatedProject,
              inverse: !1
          })), ...this.inverseRelations.filter(t => t.inverseDescription === e).map(e => ({
              relation: e,
              relatedEntity: e.project,
              inverse: !0
          }))]
      }
      get allRelations() {
          return [...this.relations.map(e => ({
              relation: e,
              relatedEntity: e.relatedProject,
              inverse: !1
          })), ...this.inverseRelations.map(e => ({
              relation: e,
              relatedEntity: e.project,
              inverse: !0
          }))]
      }
      get allRelatedProjects() {
          return [...this.relations.map(e => e.relatedProject), ...this.inverseRelations.map(e => e.project)]
      }
      get initiatives() {
          return Bm.of(W, this.initiativeToProjects.map(e => e.initiative), {
              order: new P(`statusSortOrder`).and(`sortOrder`)
          })
      }
      get initiativesAndAncestors() {
          return Bm.of(W, this.initiativeToProjects.flatMap(e => [...e.initiative.ancestors, e.initiative]), {
              order: new P(`statusSortOrder`).and(`sortOrder`)
          })
      }
      get teamsAndAncestors() {
          return Bm.of(K, this.teams.flatMap(e => e.withAncestors), {
              order: new P(`name`)
          })
      }
      isPartOfInitiative(e) {
          return this.initiatives.some(t => t === e)
      }
      get nextProjectMilestone() {
          return this.projectMilestones.find(e => e.status !== `done`)
      }
      get completedProjectMilestones() {
          return this.projectMilestones.filter(e => e.status === `done`)
      }
      get activeMilestone() {
          let e = this.nextProjectMilestone ?? this.projectMilestones.first;
          return e?.status === `done` ? void 0 : e
      }
      get accessibleTeams() {
          return this.teams.filter(e => e.userCanAccessTeam(q.store.user))
      }
      get administrableTeams() {
          return this.teams
      }
      get nonCloneIssues() {
          return this.issues.filter(e => !e.isClone)
      }
      get progress() {
          if (!this.useIssueBasedProgress)
              return Sc.completionProgress(this.currentProgress);
          let e = this.nonCloneIssues.elements
            , t = e.filter(e => !e.state);
          return t.length > 0 && w.error(`Project issues without state`, void 0, {
              project: {
                  id: this.id
              },
              projectMilestone: {
                  id: this.id
              },
              lastSyncId: this.store.syncClient.getLastSyncId(),
              firstSyncId: this.store.syncClient.getFirstSyncId(),
              issues: t.slice(0, 10).map(e => ({
                  id: e.id,
                  teamId: e.teamId,
                  stateId: e.stateId
              }))
          }),
          Sc.progress(e)
      }
      get estimationEnabled() {
          return this.accessibleTeams.elements.some(e => e.estimationEnabled)
      }
      get progressEstimatePoints() {
          return Sc.progressEstimatePoints(this.useIssueBasedProgress ? this.nonCloneIssues.elements : this.currentProgress, this.estimationEnabled)
      }
      get currentWeekEstimatePoints() {
          return Sc.progressEstimatePoints(this.nonCloneIssues.filter(e => Date.now() - (e.completedAt?.valueOf() ?? e.startedAt?.valueOf() ?? e.createdAt.valueOf()) < b.WEEK).elements, !0)
      }
      get inProgressEstimatePoints() {
          return Sc.inProgressEstimatePoints(this.useIssueBasedProgress ? this.nonCloneIssues.elements : this.currentProgress, this.estimationEnabled)
      }
      get completedEstimatePoints() {
          return Sc.completedEstimatePoints(this.useIssueBasedProgress ? this.nonCloneIssues.elements : this.currentProgress, this.estimationEnabled)
      }
      get totalEstimatePoints() {
          return Sc.totalEstimatePoints(this.useIssueBasedProgress ? this.nonCloneIssues.elements : this.currentProgress, {
              estimationEnabled: this.estimationEnabled
          })
      }
      get lastIssueUpdate() {
          let e = this.nonCloneIssues.elements.sortBy(e => e.updatedAt.valueOf())[0];
          return e ? e.updatedAt.valueOf() || e.createdAt.valueOf() : 0
      }
      getViewPreferences(e) {
          return e === k.projectDocuments ? this._viewPreferencesOverview : this._viewPreferences
      }
      get _viewPreferences() {
          return NA.getOrCreateFrom(this.viewPreferences, k.project, {
              project: this
          })
      }
      get _viewPreferencesOverview() {
          return NA.getOrCreateFrom(this.viewPreferences, k.projectDocuments, {
              project: this
          })
      }
      get customerCount() {
          return new Set(this.needs.map(e => e.customer?.id ?? e.id).filter(Boolean)).size
      }
      get customerImportantCount() {
          let e = KR(this.needs.elements);
          return Array.from(e.values()).filter(e => e.primaryNeed.priority.isImportant || e.additionalNeeds.some(e => e.priority.isImportant)).length
      }
      get aggregatedCustomersRevenue() {
          let e = new Set(this.needs.map(e => e.customer?.value).filter(Boolean));
          return Array.from(e).reduce( (e, t) => e + (t.displayRevenue ?? 0), 0)
      }
      get sortedCustomerByImpact() {
          return QR(this.needs.elements)
      }
      get lastPostedUpdate() {
          return this.lastUpdate?.value ?? this.projectUpdates.first
      }
      get hasUpdateDrafts() {
          return this.draftProjectUpdates.length > 0
      }
      get lastDraft() {
          return this.draftProjectUpdates.first
      }
      get isPrivate() {
          return this.teams.every(e => e.private)
      }
      get progressPercent() {
          return Sc.progressToPercent(this.progress)
      }
      get progressText() {
          return this.progressPercent + `%`
      }
      get isActive() {
          return Wd.started === this.status.type
      }
      get isBacklog() {
          return Wd.backlog === this.status.type
      }
      get isPlanned() {
          return Wd.planned === this.status.type
      }
      get isDone() {
          return [Wd.completed, Wd.canceled].includes(this.status.type)
      }
      get doneAt() {
          return this.isCompleted ? this.completedAt : this.canceledAt
      }
      get isCompleted() {
          return Wd.completed === this.status.type
      }
      get isCanceled() {
          return Wd.canceled === this.status.type
      }
      get slug() {
          return `${ju(this.name)}-${this.slugId}`
      }
      get searchableContent() {
          return `${this.name} ${this.description ?? ``}`
      }
      static get defaultColor() {
          return Tv.colors.lightGrey.color
      }
      get allDocumentTemplates() {
          return new Bm(hx,[],{
              order: new P(e => !e.isTeamTemplate).and(e => e.name.toLowerCase())
          }).concat(this.accessibleTeams.reduce( (e, t) => e.concat(t.documentTemplates.elements), [])).concat(this.organization.documentTemplates.elements)
      }
      get predictedCompletionDates() {
          if (!this.startedAt)
              return {
                  type: `notStarted`
              };
          if (this.completedAt)
              return {
                  type: `completed`
              };
          if (this.issueCountHistory.length === 0 || this.issues.length === 0)
              return {
                  type: `tooEarly`
              };
          if (this.progressVelocity === 0)
              return {
                  type: `stale`
              };
          if (this.completedScopeHistory.length >= 3) {
              let e = this.completedScopeHistory.length;
              if (this.completedScopeHistory[e - 1] <= this.completedScopeHistory[e - 3] && this.progressEstimatePoints <= this.completedScopeHistory[e - 1])
                  return {
                      type: `stale`
                  }
          }
          let e = Math.max(this.progressVelocity, 2)
            , t = this.totalEstimatePoints - this.progressEstimatePoints;
          if (t <= 0)
              return {
                  type: `completed`
              };
          let n = new Date().offsetByDays(7 * t / e)
            , r = new Date().daysTo(n);
          return {
              type: `prediction`,
              optimisticCompletion: n.offsetByDays(-r / 2.5),
              predictedCompletion: n,
              pessimisticCompletion: n.offsetByDays(r / 2.5)
          }
      }
      get isWayBehind() {
          if (!this.targetDate)
              return !1;
          let e = this.predictedCompletionDates;
          return e.type === `prediction` ? Ne(We(this.targetDate.toLocalDate()), e.optimisticCompletion) : !1
      }
      get isSlightlyBehind() {
          if (!this.targetDate)
              return !1;
          let e = this.predictedCompletionDates;
          return e.type === `prediction` ? Ne(We(this.targetDate.toLocalDate()), e.predictedCompletion) : !1
      }
      get isOverdue() {
          return ql.qualifierForDueDate(this.targetDate) === Kl.overdue
      }
      get isBehind() {
          return this.isSlightlyBehind || this.isWayBehind || this.isOverdue
      }
      get isEndingToday() {
          let e = We(new Date)
            , t = this.isCompleted && this.completedAt
            , n = this.isCanceled && this.canceledAt
            , r = this.startDate && Ne(We(this.startDate.toLocalDate()), e);
          return !!(this.isActive && !this.targetDate && !n && !t && r)
      }
      get isStale() {
          return this.predictedCompletionDates.type === `stale`
      }
      get healthAgeInDays() {
          return Vb.getHealthAgeInDays(this)
      }
      get orgReminderFrequency() {
          return this.organization.projectUpdateReminderFrequencyInWeeks
      }
      get healthWithAge() {
          return Vb.getHealthWithAge(this)
      }
      isUserExpectedToWriteUpdate(e) {
          return this.isActive && e.memberOf(this)
      }
      get progressVelocity() {
          if (this.completedScopeHistory.length === 0 && !this.completedAt)
              return this.progressEstimatePoints;
          let e = this.completedScopeHistory.length;
          if (this.completedScopeHistory.length === 1)
              return Math.round(Math.max(this.completedScopeHistory[0], this.progressEstimatePoints - this.completedScopeHistory[0]));
          let t = this.completedScopeHistory.map( (e, t) => t === 0 ? this.completedScopeHistory[0] : this.completedScopeHistory[t] - this.completedScopeHistory[t - 1])
            , n = this.progressEstimatePoints - this.completedScopeHistory[e - 1];
          t[t.length - 1] <= n && t.push(n);
          let r = 0
            , i = 0;
          return t.forEach( (e, t) => {
              let n = Math.max(0, t + 6 - this.completedScopeHistory.length);
              r += e * n,
              i += n
          }
          ),
          Math.max(Math.round(r / i), 0)
      }
      get currentVelocity() {
          return rz.periodVelocity(this.progressHistoryEntries.filter(e => e.date.toLocalDate().valueOf() >= gn(b.HOUR) - b.WEEK)) + rz.periodVelocity(this.progressHistoryEntries.filter(e => e.date.toLocalDate().valueOf() >= gn(b.HOUR) - b.WEEK * 2 && e.date.toLocalDate().valueOf() < gn(b.HOUR) - b.WEEK)) * .25
      }
      get currentVelocityIssueCount() {
          return rz.periodVelocityIssueCount(this.progressHistoryEntries.filter(e => e.date.toLocalDate().valueOf() >= gn(b.HOUR) - b.WEEK * 2))
      }
      get activity() {
          let e = this.currentVelocity
            , t = this.organization.projectVelocityDeciles;
          if (t.length <= 8)
              return 0;
          for (let n = 0; n < t.length; n++)
              if (e <= t[n])
                  return n;
          return 9
      }
      get activityType() {
          return Wb.getActivityType(this.activity)
      }
      get nonLeadMembers() {
          return this.members.filter(e => e !== this.lead)
      }
      issuesForTeam(e, t=!0) {
          return this.issues.filter(n => n.team === e || t && n.team.parent === e)
      }
      getTrait(e) {
          return sc(this.traits, e)
      }
      getCustomViewByFacetId(e) {
          return this.customViews.find(t => t.facet?.id === e)
      }
      isUnchangedTemplate() {
          let e = this.lastAppliedTemplate?.value;
          if (!e)
              return !1;
          let t = q.store.user
            , n = e.templateData
            , r = this.getDataForTemplate();
          function i(e, n) {
              let r = e
                , i = e.initialIssues?.map( (e, t) => {
                  if (n.initialIssues?.[t]?.teamId === null) {
                      let {stateId: t, projectId: n, projectMilestoneId: r, teamId: i, ...a} = e;
                      return {
                          ...a,
                          teamId: null
                      }
                  }
                  return e
              }
              );
              return r = (0,
              nz.default)(r, `teamIds`),
              !n.color && e.color === rz.defaultColor && (r = (0,
              nz.default)(r, `color`)),
              !n.leadId && e.leadId === t.id && (r = (0,
              nz.default)(r, `leadId`)),
              (0,
              ez.default)({
                  ...r,
                  initialIssues: i
              }, e => e !== void 0)
          }
          return (0,
          tz.default)((0,
          nz.default)(n, `teamIds`), i(r, n))
      }
      get isRootFavorited() {
          return this.favorites.some(e => e.projectTab == null)
      }
      applyTemplate(e, t={}) {
          let n = e.templateData;
          if (!n)
              return;
          let r = this.lastAppliedTemplate?.value;
          if (r && this.isClone && this.clearTemplate(r),
          n.description && (this.description = n.description),
          n.title && (this.name = n.title),
          n.icon && (this.icon = n.icon),
          n.color && (this.color = n.color),
          n.statusId) {
              let e = this.store.findById(ej, n.statusId);
              if (!e)
                  throw Error(`Could not find a project status to use`);
              this.status = e
          }
          if (n.priority !== void 0 && (this.priority = Kb.createFromPriority(n.priority)),
          n.leadId) {
              let e = this.store.findById(J, n.leadId);
              e && (this.lead = e)
          }
          if (n.descriptionData?.content) {
              let e = kR.getOrCreateFrom(this);
              !e.contentData || !e.hasContent || t.overwrite ? e.replaceWithContent(n.descriptionData) : e.replaceWithContent({
                  ...e.contentData,
                  content: [...e.contentData.content, ...n.descriptionData.content]
              })
          }
          let i = q.store.user
            , a = n.teamIds?.map(e => this.store.findById(K, e)).filter(Boolean);
          if (a?.length) {
              this.administrableTeams.forEach(e => {
                  this.issues.some(t => t.team === e) || this.administrableTeams.remove(e)
              }
              );
              for (let e of a)
                  i.canAccessTeam(e) && this.administrableTeams.add(e)
          }
          this.administrableTeams.length === 0 && t.teamFromContext && i.canAccessTeam(t.teamFromContext) && this.administrableTeams.add(t.teamFromContext);
          let o = n.memberIds?.map(e => this.store.findById(J, e)).filter(Boolean);
          if (o?.length)
              for (let e of o)
                  this.members.add(e);
          let s = (n.initiativeIds ?? []).filter(e => !this.initiatives.some(t => t.id === e)).map(e => this.store.findById(W, e)).filter(Boolean)
            , c = [...new Set([...s])];
          for (let e of c)
              LA.create({
                  initiative: e,
                  project: this
              }).save(!0);
          if (n.projectMilestones?.length && mR.validateMilestonePerProjectQuota(this))
              for (let e of n.projectMilestones) {
                  let t = mR.create({
                      name: e.name,
                      project: this
                  });
                  if (e.descriptionData?.content) {
                      let n = kR.getOrCreateFrom(t);
                      n.replaceWithContent(e.descriptionData),
                      n.save(!0)
                  }
                  t.save(!0)
              }
          if (n.initialIssues?.length)
              for (let r of n.initialIssues)
                  this.createInitialIssueFromTemplate({
                      issueData: r,
                      templateTeam: e.team,
                      options: t
                  });
          let l = n.labelIds?.map(e => this.store.findById(Ek, e)).filter(Boolean);
          if (l?.length)
              for (let e of l)
                  e.parent && this.labels.filter(t => t.parent === e.parent).forEach(e => {
                      this.labels.remove(e)
                  }
                  ),
                  !(t.editingContext !== `template` && e.isRetired) && this.labels.add(e);
          return this.lastAppliedTemplate = vm.wrap(e),
          this
      }
      clearTemplate(e) {
          let t = e.templateData;
          t && (t.title === this.name && (this.name = ``),
          t.description === this.description && (this.description = ``),
          this.documentContent.value?.hasContentEqualTo(t.descriptionData) && this.documentContent.value.replaceWithContent(pl()),
          t.icon === this.icon && t.color === this.color && (this.icon = void 0,
          this.color = void 0),
          t.statusId === this.status.id && (this.status = this.organization.projectStatuses.find(e => e.type === Wd.backlog)),
          t.leadId === this.lead?.id && (this.lead = void 0),
          t.teamIds?.forEach(e => {
              let t = this.store.findById(K, e);
              t && this.administrableTeams.remove(t)
          }
          ),
          t.memberIds?.forEach(e => {
              let t = this.store.findById(J, e);
              t && this.members.remove(t)
          }
          ),
          t.labelIds && t.labelIds.length > 0 && t.labelIds.forEach(e => {
              let t = this.store.findById(Ek, e);
              t && this.labels.remove(t)
          }
          ),
          t.projectMilestones?.map(e => {
              let t = this.projectMilestones.find(t => t.name === e.name);
              t && (this.projectMilestones.remove(t),
              t.delete())
          }
          ),
          t.initiativeIds && t.initiativeIds.length > 0 && t.initiativeIds.forEach(e => {
              let t = this.initiativeToProjects.find(t => t.initiative.id === e);
              t && t.delete()
          }
          ),
          t.initialIssues?.forEach(e => {
              let t = this.issues.find(t => {
                  let n = t.title === e.title
                    , r = !e.descriptionData && !t.documentContent.value?.hasContent
                    , i = !!t.documentContent.value?.hasContentEqualTo(e.descriptionData);
                  return n && (r || i)
              }
              );
              t && t.trash()
          }
          ),
          this.lastAppliedTemplate = void 0)
      }
      getDataForTemplate() {
          qO(this.projectMilestones.elements);
          let e = this.projectMilestones.map(e => ({
              name: e.name,
              descriptionData: e.documentContent.value?.contentData
          }));
          return (0,
          ez.default)({
              icon: this.icon,
              color: this.color,
              description: this.description,
              descriptionData: this.documentContent.value?.contentData,
              title: this.name,
              leadId: this.lead?.id,
              statusId: this.status.id,
              priority: this.priority.priority,
              initiativeIds: this.initiatives.map(e => e.id),
              memberIds: this.members.map(e => e.id),
              teamIds: this.administrableTeams.map(e => e.id),
              projectMilestones: e.map(e => ({
                  name: e.name,
                  descriptionData: e.descriptionData
              })),
              initialIssues: this.issues.filter(e => !e.parent).map(t => this.transformIssueForTemplate(t, e)),
              labelIds: this.labels.map(e => e.id)
          }, e => e !== void 0)
      }
      matchInlineFind(e) {
          let t = $l([this.name].concat(this.members.map(e => e.name + ` ` + e.displayName), [this.lead?.name, this.lead?.displayName].concrete()).join(` `)).toLowerCase();
          return e.split(` `).reduce( (e, n) => e && t.indexOf(n) !== -1, !0)
      }
      markNotificationAsRead(e) {
          let t = this.notifications.find(t => t.id === e);
          if (!t)
              return;
          let n = t?.groupingEntityId;
          this.notifications.forEach(e => {
              e.readAt === void 0 && e.groupingEntityId === n && (e.markAsRead(),
              e.save())
          }
          );
          let r = t.metadata?.issueIdForGrouping;
          if (r) {
              let e = `issue#${r}`;
              q.store.user.notifications.forEach(t => {
                  t.readAt === void 0 && t.groupingEntityId === e && (t.markAsRead(),
                  t.save())
              }
              )
          }
      }
      getAllDocumentContents() {
          let e = this.documentContent.value
            , t = [{
              title: this.name,
              documentContent: e
          }];
          return this.projectMilestones.forEach(e => {
              t.push({
                  title: e.name,
                  documentContent: e.documentContent.value
              })
          }
          ),
          {
              documentContent: e,
              allDocumentContents: t
          }
      }
      static #t = this.collectionsIncludedInLocalTransaction = [`issues`, `projectMilestones`];
      save(e=!1, t) {
          return super.save(e, t)
      }
      findProjectMilestone(e) {
          return this.projectMilestones.find(t => t.id === e || t.name.toLowerCase() === e.toLowerCase())
      }
      static validateProjectPerTeamQuota(e) {
          return e.every(e => cy.validateQuotaOrToast(e.organization, jv.maxProjectsPerTeam, e.projects.length))
      }
      getIntegration(e) {
          return this.organization.getIntegration(e, e => e.project?.id === this.id)
      }
      get shouldUseDailyVelocityData() {
          let e = this.progressHistoryEntries.slice().sort( (e, t) => e.date.toLocalDate().valueOf() - t.date.toLocalDate().valueOf());
          if (e.length < 2)
              return !0;
          let t = e.filter(e => (e.scopeCount ?? 0) > 0 || (e.completedIssueCount ?? 0) > 0 || (e.startedIssueCount ?? 0) > 0 || (e.scopeEstimate ?? 0) > 0 || (e.completedEstimate ?? 0) > 0 || (e.startedEstimate ?? 0) > 0 || (e.completedEstimateToday ?? 0) > 0 || (e.completedIssueCountToday ?? 0) > 0 || (e.addedEstimateToday ?? 0) > 0 || (e.addedIssueCountToday ?? 0) > 0);
          if (t.length < 2)
              return !0;
          for (let e = 1; e < t.length; e++)
              if (lt(t[e].date.toLocalDate(), t[e - 1].date.toLocalDate()) > 1.5)
                  return !1;
          return !0
      }
      static periodVelocity(e) {
          if (e.length < 2)
              return 0;
          let t = e[0]
            , n = e[e.length - 1]
            , r = (n.completedEstimate ?? 0) + (n.startedEstimate ?? 0) * .25 - ((t.completedEstimate ?? 0) + (t.startedEstimate ?? 0) * .25) + Math.max(0, ((n.scopeEstimate ?? 0) - (t.scopeEstimate ?? 0)) * .0625);
          return Math.max(r, 0)
      }
      static periodVelocityIssueCount(e) {
          if (e.length < 2)
              return 0;
          let t = e[0]
            , n = e[e.length - 1]
            , r = (n.completedIssueCount ?? 0) - (t.completedIssueCount ?? 0)
            , i = (n.startedIssueCount ?? 0) - (t.startedIssueCount ?? 0);
          return Math.abs(r + i)
      }
      combineIssuesProgressHistoryEntriesToWeekly(e) {
          let t = e.slice().sort( (e, t) => e.date.toLocalDate().valueOf() - t.date.toLocalDate().valueOf());
          if (t.length === 0)
              return t;
          function n(e, t) {
              let n = {
                  ...t,
                  startDate: t.startDate || t.date
              };
              return Object.keys(n).forEach(r => {
                  switch (r) {
                  case `addedIssueCountToday`:
                  case `addedEstimateToday`:
                  case `completedEstimateToday`:
                  case `completedIssueCountToday`:
                      n[r] = (e[r] ?? 0) + (t[r] ?? 0);
                      break;
                  case `scopeEstimate`:
                  case `triageEstimate`:
                  case `backlogEstimate`:
                  case `unstartedEstimate`:
                  case `startedEstimate`:
                  case `completedEstimate`:
                  case `cancelledEstimate`:
                  case `scopeCount`:
                  case `triageIssueCount`:
                  case `backlogIssueCount`:
                  case `unstartedIssueCount`:
                  case `startedIssueCount`:
                  case `completedIssueCount`:
                  case `cancelledIssueCount`:
                      n[r] = t[r] ?? e[r];
                      break;
                  case `createdAt`:
                  case `date`:
                      break;
                  default:
                      y(r);
                      break
                  }
              }
              ),
              n
          }
          let r = [];
          for (let e = t.length - 1; e > -1; e--) {
              let i = t[e]
                , a = r[0]
                , o = a && (a.startDate || a.date).toLocalDate().valueOf();
              if (o && o - i.date.toLocalDate().valueOf() < b.WEEK - b.DAY / 2) {
                  r[0] = n(i, a);
                  continue
              } else {
                  r.unshift(i);
                  continue
              }
          }
          return r
      }
      createInitialIssueFromTemplate(e) {
          let {issueData: t, templateTeam: n, options: r, parentIssue: i} = e
            , a = Y.createEmpty()
            , o = t.teamId ? this.store.findById(K, t.teamId) : null
            , s = r.teamFromContext && this.accessibleTeams.contains(r.teamFromContext) ? r.teamFromContext : void 0
            , c = o ?? s ?? this.accessibleTeams.first ?? n ?? this.organization.accessibleTeams.first;
          if (!c)
              throw Error(`Could not find a team to use`);
          a.team = c,
          a.isTemplateWithNoDefaultTeam = r.editingContext === `template` ? !o : !1,
          i && (a.parent = vm.wrap(i));
          let l = new hx;
          if (l.templateData = {
              ...t,
              projectId: this.id,
              children: []
          },
          a.applyTemplate(l, r),
          t.lastAppliedTemplateId) {
              let e = this.store.findById(hx, t.lastAppliedTemplateId);
              e ? a.lastAppliedTemplate = vm.wrap(e) : a.lastAppliedTemplate = void 0
          } else
              a.lastAppliedTemplate = void 0;
          a.lastAppliedIssueTemplateData = t,
          t.projectMilestoneIndex !== void 0 && (a.projectMilestone = vm.wrap(this.projectMilestones.elements[t.projectMilestoneIndex])),
          a.project = this,
          a.sortOrder = tx.lastSortOrder(this.issues, `sortOrder`),
          i && (a.subIssueSortOrder = tx.lastSortOrder(i.children, `subIssueSortOrder`)),
          a.prioritySortOrder = a.sortOrder,
          a.preserveSortOrderOnCreate = !0,
          a.save(!0),
          kR.getOrCreateFrom(a).save(!0),
          t.children?.forEach(e => {
              this.createInitialIssueFromTemplate({
                  issueData: e,
                  templateTeam: c,
                  options: r,
                  parentIssue: a
              })
          }
          )
      }
      transformIssueForTemplate(e, t) {
          let n = e => {
              let r = {
                  ...this.transformIssueWithMilestone(e, t),
                  projectId: void 0
              }
                , i = e.children?.map(e => n(e));
              return i?.length && (r.children = i),
              (0,
              ez.default)(r, e => e !== void 0)
          }
          ;
          return n(e)
      }
      transformIssueWithMilestone(e, t) {
          let n = e.getDataForTemplate();
          if (e.projectMilestone?.id) {
              qO(e.projectMilestone);
              let r = t.findIndex(t => t.name === e.projectMilestone?.value?.name);
              n = {
                  ...n,
                  projectMilestoneIndex: r === -1 ? void 0 : r,
                  projectMilestoneId: void 0
              }
          }
          return n
      }
      checkForErroneousProjectRelation(e) {
          return !e.project || !e.relatedProject ? (w.error(`Project relation without a related project`, void 0, {
              relation: {
                  id: e.id,
                  ProjectIsUnresolved: !e.project,
                  relatedProjectIsUnresolved: !e.relatedProject
              }
          }),
          !1) : !0
      }
      get useIssueBasedProgress() {
          return this.issues.isHydrated()
      }
  }
  ,
  M([R({
      default: ``
  })], G.prototype, `name`, void 0),
  M([R({
      default: ``
  })], G.prototype, `description`, void 0),
  M([R({
      persistence: `none`,
      default: ``
  })], G.prototype, `slugId`, void 0),
  M([R()], G.prototype, `icon`, void 0),
  M([R()], G.prototype, `color`, void 0),
  M([B( () => ej, `projects`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], G.prototype, `status`, void 0),
  M([z( () => gM, {
      index: `projectId`,
      order: new P(`createdAt`,`desc`),
      canSkipHydration: e => !e.getTrait(Ob.hasEntityExternalLinks)
  })], G.prototype, `links`, void 0),
  M([z( () => bM, {
      index: `projectId`,
      order: new P(`createdAt`,`desc`)
  })], G.prototype, `reminders`, void 0),
  M([z( () => NR, {
      index: `projectId`,
      order: new P(`createdAt`,`desc`),
      canSkipHydration: e => !e.getTrait(Ob.hasDocuments)
  })], G.prototype, `documents`, void 0),
  M([z( () => mR, {
      index: `projectId`,
      order: new P(`sortOrder`),
      canSkipHydration: e => !e.getTrait(Ob.hasProjectMilestones)
  })], G.prototype, `projectMilestones`, void 0),
  M([og( () => QL)], G.prototype, `notifications`, void 0),
  M([z( () => HM, {
      index: `projectId`,
      order: new P(`createdAt`,`desc`)
  })], G.prototype, `projectUpdates`, void 0),
  M([fg( () => Ek, `projects`, {
      indexed: !0,
      order: new P(e => `${e.parent ? `0${e.parent.name}` : 1}${e.name}`)
  })], G.prototype, `labels`, void 0),
  M([lg( () => HM, {
      nullable: !0,
      indexed: !0,
      onDelete: `SET NULL`,
      persistence: `none`
  })], G.prototype, `lastUpdate`, void 0),
  M([og( () => kM, {
      order: new P(`createdAt`,`desc`)
  })], G.prototype, `draftProjectUpdates`, void 0),
  M([og( () => yH)], G.prototype, `favorites`, void 0),
  M([ug({
      nullable: !0
  })], G.prototype, `subscription`, void 0),
  M([dg({
      nullable: !0
  })], G.prototype, `integrationsSettings`, void 0),
  M([og( () => BR)], G.prototype, `featureFlags`, void 0),
  M([z( () => cM, {
      index: `sourceProjectId`,
      order: new P(`sortOrder`),
      canSkipHydration: () => !0
  })], G.prototype, `resourceFolders`, void 0),
  M([z( () => Y, {
      index: `projectId`,
      order: new P(`sortOrder`),
      canSkipNetworkHydration: e => e.store.syncClient.hasModelsForPartialIndexes(Y.modelName, e.accessibleTeams.map(e => wm.createPartialIndex({
          modelClass: K,
          syncGroup: e.id
      })), {
          requireAll: !0
      })
  })], G.prototype, `issues`, void 0),
  M([z( () => _x, {
      index: `projectId`
  })], G.prototype, `history`, void 0),
  M([z( () => VA, {
      index: `sourceProjectId`,
      order: new P(`sortOrder`)
  })], G.prototype, `facets`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0
  })], G.prototype, `creator`, void 0),
  M([cg( () => J, {
      nullable: !0
  })], G.prototype, `lead`, void 0),
  M([fg( () => J)], G.prototype, `members`, void 0),
  M([B( () => q, `projects`, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], G.prototype, `organization`, void 0),
  M([R({
      serializer: jh
  })], G.prototype, `startDate`, void 0),
  M([R({
      persistence: `none`
  })], G.prototype, `health`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], G.prototype, `healthUpdatedAt`, void 0),
  M([R({
      persistence: `updateOnly`
  })], G.prototype, `updateReminderFrequency`, void 0),
  M([R({
      persistence: `updateOnly`
  })], G.prototype, `frequencyResolution`, void 0),
  M([R({
      enum: Vn,
      persistence: `updateOnly`
  })], G.prototype, `updateRemindersDay`, void 0),
  M([R({
      persistence: `updateOnly`
  })], G.prototype, `updateRemindersHour`, void 0),
  M([R({
      persistence: `none`
  })], G.prototype, `sourceMetadata`, void 0),
  M([R()], G.prototype, `startDateResolution`, void 0),
  M([R({
      serializer: jh
  })], G.prototype, `targetDate`, void 0),
  M([R()], G.prototype, `targetDateResolution`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], G.prototype, `startedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `updateOnly`
  })], G.prototype, `completedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `updateOnly`
  })], G.prototype, `canceledAt`, void 0),
  M([R({
      default: 0
  })], G.prototype, `sortOrder`, void 0),
  M([R({
      default: 0
  })], G.prototype, `prioritySortOrder`, void 0),
  M([R({
      serializer: UR,
      default: () => Kb.createFromPriority(0)
  })], G.prototype, `priority`, void 0),
  M([R({
      persistence: `updateOnly`
  })], G.prototype, `trashed`, void 0),
  M([lg( () => Y, {
      nullable: !0,
      indexed: !0
  })], G.prototype, `convertedFromIssue`, void 0),
  M([lg( () => hx, {
      nullable: !0,
      indexed: !0
  })], G.prototype, `lastAppliedTemplate`, void 0),
  M([R({
      persistence: `none`,
      serializer: Mh,
      default: {}
  })], G.prototype, `currentProgress`, void 0),
  M([R({
      persistence: `none`,
      default: []
  })], G.prototype, `issueCountHistory`, void 0),
  M([R({
      persistence: `none`,
      default: []
  })], G.prototype, `completedIssueCountHistory`, void 0),
  M([R({
      persistence: `none`,
      default: []
  })], G.prototype, `scopeHistory`, void 0),
  M([R({
      persistence: `none`,
      default: []
  })], G.prototype, `completedScopeHistory`, void 0),
  M([R({
      persistence: `none`,
      default: []
  })], G.prototype, `inProgressScopeHistory`, void 0),
  M([R({
      persistence: `none`
  })], G.prototype, `traits`, void 0),
  M([R({
      persistence: `none`,
      default: []
  })], G.prototype, `progressHistory`, void 0),
  M([L], G.prototype, `progressHistoryEntries`, null),
  M([L], G.prototype, `reminder`, null),
  M([fg( () => K, `projects`, {
      onDelete: `REMOVE AND CASCADE WHEN EMPTY`,
      updateOnSyncGroupChange: !0,
      indexed: !0,
      private: !0
  })], G.prototype, `teams`, void 0),
  M([og( () => LA, {
      order: new P(`createdAt`,`desc`)
  })], G.prototype, `initiativeToProjects`, void 0),
  M([dg({
      nullable: !0,
      cascadeHydration: !0
  })], G.prototype, `documentContent`, void 0),
  M([z( () => Az, {
      index: `projectId`,
      order: new P(`name`)
  })], G.prototype, `customViews`, void 0),
  M([z( () => dR, {
      index: `projectId`,
      order: new P(`type`).and(`createdAt`, `desc`),
      canSkipHydration: e => !e.getTrait(Ob.hasRelations)
  })], G.prototype, `relations`, void 0),
  M([z( () => dR, {
      index: `relatedProjectId`,
      order: new P(`type`).and(`createdAt`, `desc`),
      canSkipHydration: e => !e.getTrait(Ob.hasReverseRelations)
  })], G.prototype, `inverseRelations`, void 0),
  M([z( () => UB, {
      index: `projectId`,
      canSkipHydration: e => !e.getTrait(Ob.hasCustomerNeeds)
  })], G.prototype, `needs`, void 0),
  M([z( () => XR, {
      index: `projectId`
  })], G.prototype, `customerGeneratedContents`, void 0),
  M([z( () => NA, {
      index: `projectId`,
      canSkipHydration: e => e.organization.viewPreferences.isHydrated()
  })], G.prototype, `viewPreferences`, void 0),
  M([z( () => GA, {
      index: `projectId`,
      canSkipHydration: e => !e.getTrait(Ob.hasExternalEntityRelations)
  })], G.prototype, `externalEntityRelations`, void 0),
  M([L], G.prototype, `dependedOnByRelations`, null),
  M([L], G.prototype, `dependsOnRelations`, null),
  M([L], G.prototype, `blockingRelations`, null),
  M([L], G.prototype, `blockedByRelations`, null),
  M([L], G.prototype, `violatedRelations`, null),
  M([L], G.prototype, `allNeeds`, null),
  M([L], G.prototype, `allRelations`, null),
  M([L], G.prototype, `allRelatedProjects`, null),
  M([L], G.prototype, `initiatives`, null),
  M([L], G.prototype, `initiativesAndAncestors`, null),
  M([L], G.prototype, `teamsAndAncestors`, null),
  M([L], G.prototype, `nextProjectMilestone`, null),
  M([L], G.prototype, `completedProjectMilestones`, null),
  M([L], G.prototype, `activeMilestone`, null),
  M([L], G.prototype, `accessibleTeams`, null),
  M([L], G.prototype, `nonCloneIssues`, null),
  M([L], G.prototype, `progress`, null),
  M([L], G.prototype, `estimationEnabled`, null),
  M([L], G.prototype, `progressEstimatePoints`, null),
  M([L], G.prototype, `currentWeekEstimatePoints`, null),
  M([L], G.prototype, `inProgressEstimatePoints`, null),
  M([L], G.prototype, `completedEstimatePoints`, null),
  M([L], G.prototype, `totalEstimatePoints`, null),
  M([L], G.prototype, `lastIssueUpdate`, null),
  M([L], G.prototype, `_viewPreferences`, null),
  M([L], G.prototype, `_viewPreferencesOverview`, null),
  M([L], G.prototype, `customerCount`, null),
  M([L], G.prototype, `customerImportantCount`, null),
  M([L], G.prototype, `aggregatedCustomersRevenue`, null),
  M([L], G.prototype, `sortedCustomerByImpact`, null),
  M([L], G.prototype, `slug`, null),
  M([L], G.prototype, `searchableContent`, null),
  M([L], G.prototype, `allDocumentTemplates`, null),
  M([L], G.prototype, `predictedCompletionDates`, null),
  M([L], G.prototype, `progressVelocity`, null),
  M([L], G.prototype, `currentVelocity`, null),
  M([L], G.prototype, `currentVelocityIssueCount`, null),
  M([L], G.prototype, `activity`, null),
  M([L], G.prototype, `activityType`, null),
  M([L], G.prototype, `nonLeadMembers`, null),
  M([L], G.prototype, `isRootFavorited`, null),
  M([I], G.prototype, `applyTemplate`, null),
  M([I], G.prototype, `clearTemplate`, null),
  M([I], G.prototype, `markNotificationAsRead`, null),
  M([L], G.prototype, `shouldUseDailyVelocityData`, null),
  G = rz = M([mg(`Project`)], G)
}
));
function ble(e) {
  if (`length`in e && e.length?.eq === 0)
      return e;
  if (`every`in e && e.every?.id?.nin) {
      let t = e.every.id.nin;
      return {
          every: {
              and: [{
                  id: {
                      nin: t
                  }
              }, {
                  ancestors: {
                      or: [{
                          every: {
                              id: {
                                  nin: t
                              }
                          }
                      }, {
                          length: {
                              eq: 0
                          }
                      }]
                  }
              }]
          }
      }
  }
  if (`id`in e && e.id && `eq`in e.id)
      return {
          or: [{
              id: {
                  eq: e.id.eq
              }
          }, {
              ancestors: {
                  some: {
                      id: {
                          eq: e.id.eq
                      }
                  }
              }
          }]
      };
  if (e.and)
      return {
          and: e.and.map(e => e?.id?.eq ? {
              or: [{
                  id: {
                      eq: e.id.eq
                  }
              }, {
                  ancestors: {
                      some: {
                          id: {
                              eq: e.id.eq
                          }
                      }
                  }
              }]
          } : e)
      };
  if (`or`in e && Array.isArray(e.or))
      if (e.or[0]?.every?.id?.nin) {
          let t = e.or[0].every.id.nin;
          return {
              or: [{
                  every: {
                      and: [{
                          id: {
                              nin: t
                          }
                      }, {
                          ancestors: {
                              or: [{
                                  every: {
                                      id: {
                                          nin: t
                                      }
                                  }
                              }, {
                                  length: {
                                      eq: 0
                                  }
                              }]
                          }
                      }]
                  }
              }, e.or[1]]
          }
      } else if (e.or[0]?.every?.id?.neq) {
          let t = e.or[0].every.id.neq;
          return {
              or: [{
                  every: {
                      and: [{
                          id: {
                              neq: t
                          }
                      }, {
                          ancestors: {
                              or: [{
                                  every: {
                                      id: {
                                          neq: t
                                      }
                                  }
                              }, {
                                  length: {
                                      eq: 0
                                  }
                              }]
                          }
                      }]
                  }
              }, e.or[1]]
          }
      } else
          return {
              or: e.or.reduce( (e, t) => t?.id?.eq ? [...e, {
                  id: {
                      eq: t.id.eq
                  }
              }, {
                  ancestors: {
                      some: {
                          id: {
                              eq: t.id.eq
                          }
                      }
                  }
              }] : [...e, t], [])
          };
  return e
}
var xle = t(( () => {}
)), az, oz, Sle = t(( () => {
  az = e(nn(), 1),
  xle(),
  (function(e) {
      e.teamComparatorOverride = function(e, n, i) {
          let a = i;
          a = r(a, e => t(e));
          let o = n?.[e];
          return this.matchElement(a, o)
      }
      ,
      e.initiativeAncestorsComparatorOverride = function(e, t, n) {
          let i = n;
          i = r(i, e => ble(e));
          let a = t?.[e];
          return this.matchElement(i, a)
      }
      ,
      e.inheritedModelComparatorOverride = e => function(t, i, a) {
          let o = a;
          o = r(o, t => n(t, e));
          let s = i?.[t];
          return this.matchElement(o, s)
      }
      ;
      function t(e) {
          if (e.id) {
              let t = (0,
              az.default)(e)
                , n = {
                  id: t.id
              }
                , r = {
                  parent: n
              }
                , i = `nin`in e.id || `neq`in e.id ? `and` : `or`;
              return t[i] = [n, r],
              delete t.id,
              t
          }
          return e
      }
      function n(e, t) {
          if (e.id)
              if (t) {
                  let n = [];
                  `in`in e.id || `nin`in e.id ? n = e.id.in ?? e.id.nin ?? [] : (`eq`in e.id || `neq`in e.id) && (n = [e.id.eq ?? e.id.neq].concrete());
                  let r = n.flatMap(e => t(e)).distinct();
                  if (r.length === 1 && (`eq`in e.id || `neq`in e.id))
                      return e;
                  let i = (0,
                  az.default)(e);
                  return i.id = {},
                  `in`in e.id || `eq`in e.id ? i.id.in = r : (`nin`in e.id || `neq`in e.id) && (i.id.nin = r),
                  i
              } else {
                  let t = (0,
                  az.default)(e)
                    , n = {
                      id: t.id
                  }
                    , r = {
                      inheritedFrom: n
                  }
                    , i = `nin`in e.id || `neq`in e.id ? `and` : `or`;
                  return t[i] = [n, r],
                  delete t.id,
                  t
              }
          return e
      }
      function r(e, t) {
          let n = t(e);
          if (n !== e)
              return n;
          let i = {
              ...n
          };
          return `some`in i && i.some && (i.some = r(i.some, t)),
          `every`in i && i.every && (i.every = r(i.every, t)),
          `and`in i && Array.isArray(i.and) && (i.and = i.and.map(e => r(e, t))),
          `or`in i && Array.isArray(i.or) && (i.or = i.or.map(e => r(e, t))),
          i
      }
  }
  )(oz ||= {})
}
));
function Cle(e) {
  return t => e.reduce( (e, t) => t(e), t)
}
var sz, cz = t(( () => {
  sz = Symbol(`isCustomerTransformer`)
}
)), lz, uz, dz, fz = t(( () => {
  lz = e(re(), 1),
  zt(),
  MD(),
  Sle(),
  gO(),
  hQ(),
  ws(),
  ni(),
  Am(),
  gx(),
  cz(),
  _H(),
  uz = 2,
  dz = class e extends km {
      constructor(e) {
          super(),
          this._filter = {};
          let {filter: t, persistenceKey: n, storage: r=`local`, filterTransformers: i} = e;
          this._storage = r,
          this._filterTransformer = Cle(i ?? []),
          n && (this._persistenceKey = `filter_${uz}_${n}`,
          this.filter = this._storage === `local` ? ei.get(this._persistenceKey, {
              logError: !1
          }) || {} : ei.getSession(this._persistenceKey) || {}),
          t && (this.filter = t),
          At(this, {
              _filter: Vt,
              simplifiedFilter: Bt
          })
      }
      set filter(e) {
          Mt( () => {
              this._filter = e
          }
          ),
          this._persistenceKey && (Object.keys(e).length === 0 ? (ei.remove(this._persistenceKey),
          ei.removeSession(this._persistenceKey)) : this._storage === `local` ? ei.set(this._persistenceKey, e) : ei.setSession(this._persistenceKey, e))
      }
      get filter() {
          return this._filter
      }
      get persistenceKey() {
          return this._persistenceKey
      }
      get storage() {
          return this._storage
      }
      get isFiltering() {
          return this.filterCount > 0
      }
      get filterCount() {
          return hO.getBlocksCount(this._filter)
      }
      reset() {
          this.filter = {}
      }
      matchingFilterForKey(e, t=`all`) {
          let n = this.filter.or || []
            , r = this.filter.and || [];
          if (t === `all`) {
              if (this.filter[e])
                  return this.filter[e];
              let t;
              return r.length > 0 && (t = r.find(t => t[e])?.[e] || void 0),
              !t && n.length === 1 && (t = n[0][e]),
              t
          } else
              return this.filter[e] ? this.filter[e] : [...n, ...r].find(t => t[e])?.[e] || void 0
      }
      get isMatchingAllFilters() {
          return `and`in this.filter
      }
      get isMatchingAnyFilters() {
          return `or`in this.filter
      }
      hasFilterOnlyForKey(t) {
          let n = e.filterKeys(this.filter);
          return !(`or`in this.filter) && n.length === 1 && n.indexOf(t) === 0
      }
      static filterElement(e, t) {
          return this.modelMatcher.matchElement(e, t)
      }
      filterElement(t) {
          return e.modelMatcher.matchElement(this.simplifiedFilter, t)
      }
      filterElements(e) {
          try {
              return super.filterElements(e)
          } catch (t) {
              return w.warning(`Invalid filter `, {
                  filter: JSON.parse(JSON.stringify(this.simplifiedFilter)),
                  originalFilter: JSON.parse(JSON.stringify(this.filter)),
                  error: t
              }),
              e
          }
      }
      filterNotElements(e) {
          try {
              return super.filterNotElements(e)
          } catch (t) {
              return w.warning(`Invalid filter `, {
                  filter: JSON.parse(JSON.stringify(this.simplifiedFilter)),
                  originalFilter: JSON.parse(JSON.stringify(this.filter)),
                  error: t
              }),
              e
          }
      }
      get simplifiedFilter() {
          try {
              return hO.simplifyFilter(this._filterTransformer?.(this._filter) || this._filter)
          } catch (e) {
              return w.error(`Error simplifying filter`, e, {
                  filter: this._filter
              }),
              this._filter
          }
      }
      static #e = this.modelMatcher = new AD({
          priority: function(e, t, n) {
              return this.matchElement(n, t?.priority.priority)
          },
          team: oz.teamComparatorOverride,
          teams: oz.teamComparatorOverride,
          relatedTeams: oz.teamComparatorOverride,
          accessibleTeams: oz.teamComparatorOverride,
          initiatives: oz.initiativeAncestorsComparatorOverride,
          lastAppliedTemplate: oz.inheritedModelComparatorOverride(t => e.getInheritedModelIds(hx, t)),
          cycle: oz.inheritedModelComparatorOverride(t => e.getInheritedModelIds(gH, t))
      });
      static filterKeys(t) {
          let n = [`and`, `or`]
            , r = [...(0,
          lz.default)(t.and?.map(t => e.filterKeys(t)) || []), ...(0,
          lz.default)(t.or?.map(t => e.filterKeys(t)) || [])];
          return [...Object.keys(t).filter(e => n.indexOf(e) === -1), ...r].distinct()
      }
      static getInheritedModelIds(e, t) {
          let n = pQ().findById(e, t)
            , r = [t];
          return n && (n.inheritedFrom?.id && r.push(n.inheritedFrom.id),
          r.push(...n.inheritedBy.map(e => e.id))),
          r
      }
  }
}
));
function pz(e, t) {
  if (e[t])
      return !0;
  if (`some`in e || `every`in e) {
      let n = e;
      if (n.some && pz(n.some, t) || n.every && pz(n.every, t))
          return !0
  }
  return e.and?.some(e => pz(e, t)) || e.or?.some(e => pz(e, t)) || !1
}
var mz = t(( () => {}
));
function wle(e) {
  if (!e || !e.and || !Array.isArray(e.and))
      return e;
  let t = []
    , n = [];
  if (e.and.forEach(e => {
      `needs`in e && e.needs ? t.push(e) : n.push(e)
  }
  ),
  t.length <= 1)
      return e;
  let r = [];
  return t.forEach(e => {
      let t = e.needs;
      if (t?.and)
          t.and.forEach(e => {
              e.some && e.some.customer ? r.push(e.some.customer) : e.every && e.every.customer && r.push(e.every.customer)
          }
          );
      else if (t?.or) {
          let e = [];
          t.or.forEach(t => {
              t.some && t.some.customer ? e.push(t.some.customer) : t.every && t.every.customer && e.push(t.every.customer)
          }
          ),
          e.length > 0 && r.push({
              or: e
          })
      }
  }
  ),
  {
      and: [{
          needs: {
              and: [{
                  some: {
                      customer: {
                          and: r
                      }
                  }
              }]
          }
      }, ...n]
  }
}
function Tle(e, t) {
  if (!e || (0,
  gz.default)(e) || !t || (0,
  gz.default)(t))
      return e;
  let n = !1;
  if (e.and && Array.isArray(e.and) ? n = e.and.some(e => `needs`in e && e.needs) : e.or && Array.isArray(e.or) && (n = e.or.some(e => `needs`in e && e.needs)),
  !n)
      return e;
  let r = [];
  return t.and && Array.isArray(t.and) ? t.and.forEach(e => {
      `needs`in e && e.needs && r.push(e)
  }
  ) : t.or && Array.isArray(t.or) && t.or.forEach(e => {
      `needs`in e && e.needs && r.push(e)
  }
  ),
  r.length === 0 ? e : e.and && Array.isArray(e.and) ? {
      and: [...e.and, ...r]
  } : {
      and: [e, ...r]
  }
}
function hz(e) {
  let t = t => {
      let n = t;
      return e && (n = Tle(t, e)),
      wle(n)
  }
  ;
  return t[sz] = !0,
  t
}
function Ele(e) {
  return typeof e == `function` && e[sz] === !0
}
var gz, _z = t(( () => {
  gz = e(ue(), 1),
  cz()
}
)), vz, Dle = t(( () => {
  qa(),
  vz = class {
      static #e = this.maxPageSize = 250;
      static #t = this.defaultPageSize = 50
  }
  ,
  (function(e) {
      e.Direction = function(e) {
          return e[e.forward = 0] = `forward`,
          e[e.backward = 1] = `backward`,
          e
      }({}),
      e.Order = function(e) {
          return e.createdAt = `createdAt`,
          e.updatedAt = `updatedAt`,
          e
      }({}),
      e.Nulls = function(e) {
          return e.first = `first`,
          e.last = `last`,
          e
      }({});
      let t = function(e) {
          return e.Ascending = `ASC`,
          e.Descending = `DESC`,
          e
      }({});
      e.SortOrder = t;
      function n(e) {
          return e === t.Ascending ? t.Descending : t.Ascending
      }
      e.reverse = n;
      function r(e) {
          return JSON.parse(Buffer.from(e, `base64`).toString())
      }
      e.decodeCursor = r;
      function i(e) {
          return Buffer.from(JSON.stringify(e)).toString(`base64`)
      }
      e.encodeCursor = i;
      function a(e) {
          return Ka(e) ? e : r(e)?.key
      }
      e.getCursorId = a
  }
  )(vz ||= {})
}
)), yz, Ole = t(( () => {
  zn(),
  Dle(),
  FA(),
  yz = class {
      static getAdditionalServerBackedViewSettings(e, t, n) {
          if (n && e instanceof NA && e.getPreference(`layout`) === `list`) {
              let t = this.convertViewOrderingToSort(e);
              return {
                  errorOnLimitExceeded: !1,
                  sorts: [this.convertGroupingToSort(e, `issueGrouping`, t), this.convertGroupingToSort(e, `issueSubGrouping`, t), t].concrete(),
                  displayOptions: {
                      showTriageIssues: e.getPreference(`showTriageIssues`) ?? !0,
                      showSubIssues: e.getPreference(`showSubIssues`) ?? !0,
                      showCompletedIssues: e.getPreference(`showCompletedIssues`) ?? `all`
                  },
                  limit: 2e3
              }
          }
          return {
              errorOnLimitExceeded: !0,
              limit: t
          }
      }
      static convertGroupingToSort(e, t, n) {
          let r = e.getPreference(t);
          if (r)
              switch (r) {
              case `sla`:
                  return {
                      slaStatus: {}
                  };
              case `assignee`:
                  return {
                      assignee: {}
                  };
              case `delegate`:
                  return {
                      delegate: {}
                  };
              case `workflowState`:
                  return {
                      workflowState: {}
                  };
              case `priority`:
                  return {
                      priority: {}
                  };
              case `project`:
                  return {
                      project: {}
                  };
              case `projectMilestone`:
                  return {
                      milestone: {}
                  };
              case `cycle`:
                  return {
                      cycle: {
                          currentCycleFirst: !0
                      }
                  };
              case `team`:
                  return {
                      team: {}
                  };
              case `label`:
                  return {
                      label: {}
                  };
              case `none`:
                  return;
              case `customer`:
                  return {
                      customer: {}
                  };
              case `labelGroup`:
                  let i = e.getPreference(t === `issueGrouping` ? `issueGroupingLabelGroupId` : `issueSubGroupingLabelGroupId`);
                  return i ? {
                      labelGroup: {
                          labelGroupId: i
                      }
                  } : void 0;
              case `rootIssue`:
                  return n ? {
                      rootIssue: {
                          sort: n
                      }
                  } : void 0;
              case `activityDate`:
              case `focus`:
                  return;
              default:
                  Ln(r)
              }
      }
      static convertViewOrderingToSort(e) {
          let t = e.getPreference(`viewOrdering`)
            , n = e.getPreference(`viewOrderingDirection`)
            , r = n === void 0 ? {} : {
              order: n === `asc` ? vz.SortOrder.Ascending : vz.SortOrder.Descending
          };
          switch (t) {
          case void 0:
          case `manual`:
              return {
                  manual: r
              };
          case `title`:
              return {
                  title: r
              };
          case `priority`:
              return {
                  priority: r
              };
          case `dateCreated`:
              return {
                  createdAt: r
              };
          case `dateUpdated`:
              return {
                  updatedAt: r
              };
          case `dueDate`:
              return {
                  dueDate: r
              };
          case `assignee`:
              return {
                  assignee: r
              };
          case `delegate`:
              return {
                  delegate: r
              };
          case `estimate`:
              return {
                  estimate: r
              };
          case `workflowState`:
              return {
                  workflowState: {
                      ...r,
                      closedIssuesOrderedByRecency: !!e.getPreference(`closedIssuesOrderedByRecency`)
                  }
              };
          case `customerCount`:
              return {
                  customerCount: r
              };
          case `customerImportantCount`:
              return {
                  customerImportantCount: r
              };
          case `customerRevenue`:
              return {
                  customerRevenue: r
              };
          case `linkCount`:
              return {
                  linkCount: r
              };
          case `dateMyActivity`:
              return;
          case `accumulatedStateUpdatedAt`:
              return {
                  accumulatedStateUpdatedAt: r
              };
          default:
              Ln(t)
          }
      }
  }
}
)), bz, kle = t(( () => {
  bz = class {
      constructor(e) {
          this.maxSize = e,
          this.map = new Map
      }
      get(e) {
          if (this.map.has(e)) {
              let t = this.map.get(e);
              return this.map.delete(e),
              this.map.set(e, t),
              t
          }
      }
      has(e) {
          return this.map.has(e)
      }
      set(e, t) {
          this.maxSize <= 0 || (this.map.size >= this.maxSize && this.map.delete(this.map.keys().next().value),
          this.map.set(e, t))
      }
      get size() {
          return this.map.size
      }
  }
}
)), xz, Sz, Cz, wz, Tz = t(( () => {
  zt(),
  gO(),
  Yr(),
  hQ(),
  ws(),
  V(),
  Vm(),
  Ole(),
  Xp(),
  Lq(),
  kle(),
  es(),
  Ck(),
  ai(),
  N(),
  xz = class {
      get models() {
          return this.filter == null ? this.unfilteredModels : this.unfilteredModels.filter(this.filter)
      }
      get filter() {}
      get identifier() {}
  }
  ,
  M([L], xz.prototype, `models`, null),
  Sz = class extends xz {
      hydrateModels() {
          return [new Jp(async (e, t) => {
              let n = this.parents;
              if (n.every(e => e.issues.isHydrated()))
                  return e();
              try {
                  await Jp.allResolved(n.map(e => e.issues.hydrate())),
                  e()
              } catch (e) {
                  t(e)
              }
          }
          )]
      }
      get countOverrides() {}
      get hasTooManyModels() {
          return !1
      }
      get hasAllModels() {
          return !0
      }
      get totalModelsCount() {
          return this.models.length
      }
      get loadedModelsCount() {
          return this.models.length
      }
      get hydrationStatus() {
          return `success`
      }
  }
  ,
  Cz = class extends xz {
      get limit() {
          return 1e3
      }
      constructor() {
          super(),
          this.hasTooManyModels = !1,
          this.countOverrides = void 0,
          this.collectionIsComplete = !1,
          this.perFilterCache = new bz(4),
          this.serverHydrationStatus = void 0,
          this.lastServerIssueCount = -1,
          At(this, {
              hasTooManyModels: Vt,
              lastServerIssueCount: Vt,
              serverHydrationStatus: Vt,
              collectionIsComplete: Vt,
              countOverrides: Vt
          })
      }
      get unfilteredModels() {
          return this.modelCollection
      }
      get totalModelsCount() {
          return this.lastServerIssueCount
      }
      get loadedModelsCount() {
          return this.models.length
      }
      get hasAllModels() {
          return this.collectionIsComplete
      }
      hydrateModels(e, t) {
          let n = this.latestUpdatedAt
            , r = this.computeParams(e)
            , i = JSON.stringify(r);
          return (t?.forceServerRehydration || !this.latestHydrationPromise || this.previousServerHydrationState?.serializedParams !== i || (this.previousServerHydrationState?.when ?? 0) < Date.now() - 15 * b.MINUTE || n && (this.previousServerHydrationState?.when ?? 0) < (n.getTime() ?? 0)) && (this.previousServerHydrationState = {
              when: Date.now(),
              serializedParams: i
          },
          this.latestHydrationAbortController?.abort(),
          this.latestHydrationAbortController = new AbortController,
          this.latestHydrationPromise = this.hydrateFromServer(this.latestHydrationAbortController.signal, i, r)),
          [this.latestHydrationPromise]
      }
      get hydrationStatus() {
          return this.serverHydrationStatus
      }
      hydrateFromServer(e, t, n) {
          let r = pQ()
            , i = !1;
          this.perFilterCache.has(t) && (this.modelCollection.setElementIds(this.perFilterCache.get(t)),
          i = !0);
          let a = new Jp(async o => {
              let s;
              if (i ? o() : Mt( () => {
                  this.serverHydrationStatus = `hydrating`
              }
              ),
              await ri(10),
              e.aborted)
                  w.info(`Hydration request aborted before sending to server`);
              else
                  try {
                      let t = this.path
                        , i = {
                          ...n,
                          lastSyncId: r.getLastSyncId()
                      };
                      s = await r.graphQLClient.restModelsStream(t, {
                          method: `POST`,
                          body: JSON.stringify(i),
                          abortSignal: e
                      })
                  } catch (e) {
                      Ko(e) ? w.info(`Hydration request aborted`) : w.error(`Error hydrating from server`, e, {
                          params: JSON.stringify(n),
                          identifier: this.identifier
                      })
                  }
              this.latestHydrationPromise === a && (this.latestHydrationAbortController = void 0,
              Mt( () => {
                  if (!s) {
                      this.serverHydrationStatus = `error`,
                      this.lastServerIssueCount = -1,
                      i || this.modelCollection.setElementIds([]);
                      return
                  }
                  if (this.serverHydrationStatus = `success`,
                  s.metadata.error === `Too many results`)
                      this.hasTooManyModels = !0,
                      this.collectionIsComplete = !1,
                      this.lastServerIssueCount = s.metadata.count ?? -1,
                      i || this.modelCollection.setElementIds([]);
                  else {
                      let e = []
                        , i = new Set;
                      for (let t of s.models)
                          i.has(t.id) || (i.add(t.id),
                          e.push(t));
                      this.hasTooManyModels = !1,
                      this.lastServerIssueCount = s.metadata.count ?? e.length,
                      this.collectionIsComplete = s.models.length < n.limit,
                      this.countOverrides = this.computeCountOverrides(s.metadata, i.size),
                      e.length > 0 && r.applyModelData(e);
                      let a = [...i];
                      this.modelCollection.setElementIds(a),
                      this.perFilterCache.set(t, a)
                  }
              }
              )),
              o()
          }
          );
          return a
      }
      computeCountOverrides(e, t) {}
  }
  ,
  M([I], Cz.prototype, `hydrateModels`, null),
  M([I], Cz.prototype, `hydrateFromServer`, null),
  wz = class extends Cz {
      constructor() {
          super(),
          this.path = `/models/issues`,
          this.modelCollection = new Bm(Y)
      }
      computeParams(e) {
          let {baseFilter: t, overlayFilters: n} = this.computeFilters(e)
            , r = n ? {
              universal: n.universal && !hO.isEmpty(n.universal) ? n.universal : void 0,
              insights: n.insights && !hO.isEmpty(n.insights) ? n.insights : void 0,
              quick: n.quick && !hO.isEmpty(n.quick) ? n.quick : void 0
          } : {}
            , i = yz.getAdditionalServerBackedViewSettings(this.viewPreferences, this.limit, this.serverBackendEnabled);
          return i.errorOnLimitExceeded ? {
              errorOnLimitExceeded: !0,
              limit: this.limit,
              filter: Sk.combineModelFilters(`and`, [t, ...Object.values(r)])
          } : {
              errorOnLimitExceeded: !1,
              limit: i.limit,
              filter: t,
              overlayFilters: r,
              displayOptions: i.displayOptions,
              sorts: i.sorts
          }
      }
      computeCountOverrides(e, t) {
          if (!(!e.countOverrides || e.count === void 0))
              return {
                  ...e.countOverrides,
                  hiddenByLimit: Math.max(0, e.count - (e.countOverrides.hiddenByFilters + e.countOverrides.hiddenByDisplayOptions) - t)
              }
      }
  }
}
));
function Ale(e) {
  let t = e instanceof dz ? e.filter : e.universal.filter;
  return jz.some(e => pz(t, e))
}
function Ez(e) {
  return `customView ${e.id}`
}
var Dz, Oz, kz, Az, jz, Mz, Nz, Pz = t(( () => {
  zt(),
  vb(),
  Mu(),
  iy(),
  Bu(),
  pi(),
  hQ(),
  GU(),
  iU(),
  mH(),
  Lq(),
  bH(),
  iz(),
  V(),
  F(),
  Ih(),
  FA(),
  Vm(),
  Nm(),
  fz(),
  DM(),
  OA(),
  om(),
  QO(),
  eu(),
  Ck(),
  mz(),
  _z(),
  Tz(),
  N(),
  Oz = 5e3,
  kz = 1e4,
  Az = class extends Yh {
      static #e = Dz = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      constructor(e) {
          super(e),
          jt( () => Lt(this.filterData), () => {
              this._issueHydrator &&= void 0
          }
          )
      }
      static create(e) {
          let t = Dz.createEmpty();
          return t.creator = e.creator,
          t.team = e.team,
          t.shared = e.shared,
          t.owner = e.creator,
          t.name = e.name ?? ``,
          t.description = e.description,
          t.icon = e.icon,
          t.color = e.color,
          e.issueFilterData ? t.filterData = e.issueFilterData : e.projectFilterData ? t.projectFilterData = e.projectFilterData : e.initiativeFilterData ? t.initiativeFilterData = e.initiativeFilterData : e.feedItemFilterData && (t.feedItemFilterData = e.feedItemFilterData,
          t.shared = !1),
          t.organization = e.creator.organization,
          t
      }
      get slug() {
          return this.slugId ? `${ju(this.name)}-${this.slugId}` : void 0
      }
      get shareType() {
          return this.shared ? this.team ? `team` : `workspace` : `personal`
      }
      get modelType() {
          return this.projectFilterData === void 0 ? this.initiativeFilterData === void 0 ? this.feedItemFilterData ? `feedItem` : `issue` : `initiative` : `project`
      }
      getViewPreferences() {
          return this.viewPreferences.isHydrated() ? this._viewPreferences : this.viewPreferences.hydrate().then(e => NA.getOrCreateFrom(e, k.customView, {
              customView: this
          }))
      }
      get _viewPreferences() {
          return NA.getOrCreateFrom(this.viewPreferences, k.customView, {
              customView: this
          })
      }
      get unfilteredProjects() {
          if (this.facet && qO(this.facet)) {
              let e = this.facet.getProjects();
              if (e)
                  return e
          }
          return this.team ? this.team.projectsInherited : this.initiative ? this.initiative.projectsInherited : this.organization.projects
      }
      get unfilteredFeedItems() {
          if (this.facet && qO(this.facet)) {
              let e = this.facet.getFeedItems();
              if (e)
                  return e
          }
          return this.organization.feed
      }
      matchInlineFind(e) {
          return $l(this.name + ` ` + this.description).toLowerCase().indexOf(e) !== -1
      }
      get projects() {
          return this.unfilteredProjects.filter(this.projectFilter)
      }
      get initiatives() {
          return this.organization.initiatives.filter(this.initiativeFilter)
      }
      get unfilteredIssues() {
          return this.issueHydrator.unfilteredModels
      }
      get issues() {
          return this.issueHydrator.models
      }
      get filter() {
          return this.issueUniversalCollectionFilter === void 0 && (this.issueUniversalCollectionFilter = new dz({
              filter: this.filterData,
              filterTransformers: [hz()]
          })),
          this.issueUniversalCollectionFilter.filter = this.filterData,
          this.issueUniversalCollectionFilter
      }
      get projectFilter() {
          return this.projectUniversalCollectionFilter === void 0 && (this.projectUniversalCollectionFilter = new dz({
              filter: this.projectFilterData,
              filterTransformers: [hz()]
          })),
          this.projectFilterData && (this.projectUniversalCollectionFilter.filter = this.projectFilterData),
          this.projectUniversalCollectionFilter
      }
      get initiativeFilter() {
          return this.initiativeUniversalCollectionFilter === void 0 && (this.initiativeUniversalCollectionFilter = new dz({
              filter: this.initiativeFilterData,
              filterTransformers: [hz()]
          })),
          this.initiativeFilterData && (this.initiativeUniversalCollectionFilter.filter = this.initiativeFilterData),
          this.initiativeUniversalCollectionFilter
      }
      get feedItemFilter() {
          return this.feedItemUniversalCollectionFilter === void 0 && (this.feedItemUniversalCollectionFilter = new dz({
              filter: this.feedItemFilterData,
              filterTransformers: [hz()]
          })),
          this.feedItemFilterData && (this.feedItemUniversalCollectionFilter.filter = this.feedItemFilterData),
          this.feedItemUniversalCollectionFilter
      }
      get stateFilter() {
          let e = `and`in this.filterData && this.filter.matchingFilterForKey(`state`);
          return e ? t => dz.filterElement(e, t) : void 0
      }
      get teams() {
          if (this.team)
              return this.team.withAccessibleDescendants;
          if (this.project)
              return this.project.accessibleTeams.elements;
          if (this.initiative)
              return this.initiative.accessibleTeams.elements;
          {
              let e = this.modelType === `issue` ? this.issueFilterValueForKey(`team`) : this.projectFilterValueForKey(`accessibleTeams`)
                , t = this.organization.accessibleTeams;
              e && e.length > 0 && (t = Bm.of(K, DA.withDescendants(t.filter(t => e.indexOf(t.id) > -1).elements)));
              let n = this.store.user;
              return t.orderBy(new P(e => n.memberOf(e) ? 0 : -1,`desc`).and(`name`, `asc`)).elements
          }
      }
      get preFilteredTeams() {
          if (this.team)
              return this.team.withAccessibleDescendants;
          if (this.project)
              return this.project.accessibleTeams.elements;
          {
              let e = this.organization.accessibleTeams
                , t = this.store.user;
              return e.orderBy(new P(e => t.memberOf(e) ? 0 : -1,`desc`).and(`name`, `asc`)).elements
          }
      }
      get initiativeFromFilter() {
          let e = this.projectFilterValueForKey(`initiatives`) ?? [];
          return e.length === 1 ? this.organization.initiatives.findById(e[0]) : void 0
      }
      get assignees() {
          let e = this.modelType === `issue` ? this.issueFilterValueForKey(`assignee`) : void 0;
          return e && e.length > 0 ? e.map(e => e === `__isMe__` ? this.store.user : this.organization.allUsers.findById(e)).concrete() : void 0
      }
      get projectsFromFilter() {
          let e = this.modelType === `issue` ? this.issueFilterValueForKey(`project`) : void 0;
          return e && e.length > 0 ? e.map(e => this.organization.projects.findById(e)).concrete() : void 0
      }
      get hasNoAssigneeOption() {
          let e = this.modelType === `issue` && this.issueFilterValueForKey(`assignee`);
          return e && e.includes(`____null____`) || !1
      }
      get hydratedFacet() {
          if (this.facet && qO(this.facet))
              return this.facet
      }
      toggleFavorite() {
          if (this.favorite)
              return this.favorite.delete(),
              !1;
          {
              let e = yH.create({
                  reference: this
              });
              return e.save(!0),
              e
          }
      }
      projectFilterValueForKey(e) {
          return Sk.projectFilterValueForKey(e, this.projectFilter.filter)
      }
      initiativeFilterValueForKey(e) {
          return Sk.initiativeFilterValueForKey(e, this.initiativeFilter.filter)
      }
      hydrateIssues(e, t) {
          return this.issueHydrator.hydrateModels(e, t)
      }
      get hasTooManyIssues() {
          return this.issueHydrator.hasTooManyModels
      }
      get issueCount() {
          return this.issueHydrator.totalModelsCount
      }
      get countOverrides() {
          if (this.modelType === `issue`)
              return this.issueHydrator.countOverrides
      }
      get serverHydrationStatus() {
          return this.modelType === `issue` ? this.issueHydrator.hydrationStatus : void 0
      }
      get loadedIssueCount() {
          return this.modelType === `issue` ? this.issueHydrator.loadedModelsCount : 0
      }
      get hasAllModels() {
          return this.modelType === `issue` ? this.issueHydrator.hasAllModels : !0
      }
      get isServerBacked() {
          if (this.facet?.type === ny.TeamPage && this.team)
              return !1;
          let e = this.teams, t, n = () => (t ??= It( () => e.every(e => e.issues.isHydrated() && e.issues.every(e => e.isHydrated()))),
          t);
          return Ale(this.filter) && !n() ? !0 : It( () => this.organization.approximateIssueCount < kz && !this.organization.isSuperuserWorkspace) ? !1 : !(this.project || e.length <= 1) && !n()
      }
      issueFilterValueForKey(e) {
          return Sk.issueFilterValueForKey(e, this.filter.filter)
      }
      get issueHydrator() {
          return this.isServerBacked ? this._issueHydrator instanceof Nz || (this._issueHydrator = new Nz(this)) : this._issueHydrator instanceof Nz || (this._issueHydrator = new Mz(this)),
          this._issueHydrator
      }
      static isProjectView(e) {
          return e.modelType === `project`
      }
      static isInitiativeView(e) {
          return e.modelType === `initiative`
      }
      static isIssueView(e) {
          return e.modelType === `issue`
      }
      static isFeedView(e) {
          return e.modelType === `feedItem`
      }
      getIntegration(e) {
          return this.organization.getIntegration(e, e => e.customView?.id === this.id)
      }
  }
  ,
  M([R({
      default: ``
  })], Az.prototype, `name`, void 0),
  M([R()], Az.prototype, `description`, void 0),
  M([R()], Az.prototype, `icon`, void 0),
  M([R()], Az.prototype, `color`, void 0),
  M([B( () => q, `allCustomViews`, {
      persistence: `none`,
      optional: !1,
      nullable: !1,
      indexed: !0
  })], Az.prototype, `organization`, void 0),
  M([B( () => K, `allCustomViews`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], Az.prototype, `team`, void 0),
  M([cg( () => J, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], Az.prototype, `creator`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `none`
  })], Az.prototype, `updatedBy`, void 0),
  M([B( () => J, `customViews`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], Az.prototype, `owner`, void 0),
  M([R({
      serializer: Fh,
      default: {}
  })], Az.prototype, `filterData`, void 0),
  M([R({
      serializer: Fh
  })], Az.prototype, `projectFilterData`, void 0),
  M([R({
      serializer: Fh
  })], Az.prototype, `initiativeFilterData`, void 0),
  M([R({
      serializer: Fh
  })], Az.prototype, `feedItemFilterData`, void 0),
  M([R({
      default: !1
  })], Az.prototype, `shared`, void 0),
  M([ug({
      nullable: !0
  })], Az.prototype, `favorite`, void 0),
  M([ug({
      nullable: !0
  })], Az.prototype, `subscription`, void 0),
  M([dg({
      nullable: !0
  })], Az.prototype, `integrationsSettings`, void 0),
  M([z( () => NA, {
      index: `customViewId`,
      canSkipHydration: e => e.organization.viewPreferences.isHydrated()
  })], Az.prototype, `viewPreferences`, void 0),
  M([B( () => G, `customViews`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createAndUpdate`
  })], Az.prototype, `project`, void 0),
  M([B( () => W, `customViews`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createAndUpdate`
  })], Az.prototype, `initiative`, void 0),
  M([ug({
      nullable: !0
  })], Az.prototype, `facet`, void 0),
  M([R({
      persistence: `none`,
      indexed: !0,
      default: ``
  })], Az.prototype, `slugId`, void 0),
  M([R({
      persistence: `none`
  })], Az.prototype, `traits`, void 0),
  M([L], Az.prototype, `slug`, null),
  M([L], Az.prototype, `shareType`, null),
  M([L], Az.prototype, `modelType`, null),
  M([L], Az.prototype, `_viewPreferences`, null),
  M([L], Az.prototype, `unfilteredProjects`, null),
  M([L], Az.prototype, `unfilteredFeedItems`, null),
  M([L], Az.prototype, `projects`, null),
  M([L], Az.prototype, `initiatives`, null),
  M([L], Az.prototype, `unfilteredIssues`, null),
  M([L], Az.prototype, `filter`, null),
  M([L], Az.prototype, `projectFilter`, null),
  M([L], Az.prototype, `initiativeFilter`, null),
  M([L], Az.prototype, `feedItemFilter`, null),
  M([L], Az.prototype, `stateFilter`, null),
  M([L], Az.prototype, `teams`, null),
  M([L], Az.prototype, `preFilteredTeams`, null),
  M([L], Az.prototype, `initiativeFromFilter`, null),
  M([L], Az.prototype, `assignees`, null),
  M([L], Az.prototype, `projectsFromFilter`, null),
  M([L], Az.prototype, `hasNoAssigneeOption`, null),
  M([L], Az.prototype, `hydratedFacet`, null),
  M([I], Az.prototype, `toggleFavorite`, null),
  M([I], Az.prototype, `hydrateIssues`, null),
  M([L], Az.prototype, `isServerBacked`, null),
  M([L], Az.prototype, `issueHydrator`, null),
  Az = Dz = M([mg(`CustomView`)], Az),
  jz = [`searchableContent`, `attachments`, `needs`, `customerCount`, `customerImportantCount`],
  Mz = class extends Sz {
      constructor(e) {
          super(),
          this.customView = e
      }
      get filter() {
          return this.customView.filter
      }
      get identifier() {
          return Ez(this.customView)
      }
      get parents() {
          return this.customView.project ? [this.customView.project] : this.customView.teams
      }
      get unfilteredModels() {
          let e = this.customView;
          if (e.facet && qO(e.facet)) {
              let t = e.facet.getIssues();
              if (t)
                  return t
          }
          return e.team ? e.team.issuesInherited : new Bm(Y,e.teams.flatMap(e => e.issues.localElements))
      }
  }
  ,
  M([L], Mz.prototype, `unfilteredModels`, null),
  Nz = class extends wz {
      constructor(e) {
          super(),
          this.customView = e
      }
      get filter() {
          return this.customView.filter
      }
      get identifier() {
          return Ez(this.customView)
      }
      get viewPreferences() {
          return this.customView.getViewPreferences()
      }
      get latestUpdatedAt() {
          let e = this.customView
            , t = pQ().user.subscriptions.find(t => t.customView?.id === e.id);
          return (t?.notifications?.length ?? 0) > 0 ? t?.notifications.elements.at(-1)?.updatedAt : void 0
      }
      computeFilters(e) {
          let t = this.customView
            , n = t.project ? {
              project: {
                  id: {
                      eq: t.project.id
                  }
              }
          } : t.team ? {
              team: {
                  id: {
                      in: t.team.withAccessibleDescendants.map(e => e.id)
                  }
              }
          } : void 0;
          return {
              baseFilter: Sk.combineModelFilters(`and`, [n, t.filter.filter]),
              overlayFilters: {
                  universal: e.universal.filter,
                  insights: this.serverBackendEnabled ? e.insights.filter : void 0,
                  quick: this.serverBackendEnabled ? Object.values(e.quick).find(e => e.isFiltering)?.filter : void 0
              }
          }
      }
      get serverBackendEnabled() {
          return ui.isEnabled(ui.serverBackedCustomViews)
      }
      get limit() {
          return Oz
      }
  }
}
)), Fz, Iz = t(( () => {
  nt(),
  Fz = class {
      static getCurrentAndNextScheduleEntry(e=[]) {
          let t = new Date, n, r = e => e instanceof Date ? e : Xe(e);
          for (let i of e) {
              let e = r(i.startsAt)
                , a = i.endsAt ? r(i.endsAt) : void 0;
              if (e <= t && (!a || t < a) && (n = i),
              e > t)
                  return [n, i]
          }
          return [n, void 0]
      }
      static getScheduleEntriesWithIndex(e) {
          if (e === void 0)
              return [];
          let[t,n] = this.getCurrentAndNextScheduleEntry(e)
            , r = e.findIndex(e => e === t)
            , i = e.findIndex(e => e === n);
          if (r === -1 && i === -1)
              return [];
          let a = r === -1 ? i : r;
          return e.map( (e, t) => {
              let n = t - a;
              return n >= 0 && r === -1 && n++,
              [e, n]
          }
          )
      }
  }
}
));
function Lz(e, t) {
  return e ? `${e} added an issue to ${t} triage` : `Issue added to ${t} triage`
}
var Rz, zz, Bz = t(( () => {
  gc(),
  Iz(),
  Rz = function(e) {
      return e.assign = `assign`,
      e.notify = `notify`,
      e
  }({}),
  zz = class {
      static getCurrentUserId(e) {
          let {manualSelection: t, timeSchedule: n} = e;
          if (t) {
              let {assignmentIndex: e, userIds: n} = t;
              return n.length === 1 ? n[0] : e === void 0 ? void 0 : n[e]
          } else if (n) {
              let[e] = Fz.getCurrentAndNextScheduleEntry(n.entries || []);
              return e?.userId
          }
      }
      static getUserIds(e) {
          let {manualSelection: t, timeSchedule: n} = e;
          return t ? t.userIds : n && n.entries?.map(e => e.userId).filter(e => e !== void 0) || []
      }
      static getTriageNotificationText(e) {
          let {triageResponsibilityTeam: t, triageIssue: n} = e
            , r = n.team.id === t?.id ? n.creatorName : void 0;
          return t ? t.id === n.team.id ? t.id === n.team.id && n.triagedAt ? `Issue ${(n.canonicalIssue?.stateType ?? n.stateType) === E.canceled ? `declined` : `accepted`}${n.canonicalIssue ? ` as duplicate` : ``} from ${t.name} triage` : Lz(r, t.name) : `Triage issue moved to ${n.team.name} from ${t.name}` : Lz(r, n.team.name)
      }
  }
}
)), Vz, Hz = t(( () => {
  Bz(),
  mH(),
  Wz(),
  GU(),
  V(),
  F(),
  Ih(),
  om(),
  N(),
  Vz = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular;
      get configType() {
          return this.manualSelection ? `manualSelection` : this.timeSchedule ? `schedule` : void 0
      }
      get manualSelectionUserIds() {
          return this.timeSchedule ? [] : zz.getUserIds({
              manualSelection: this.manualSelection
          })
      }
      get manualSelectionUsers() {
          return this.manualSelectionUserIds.map(e => this.store.findById(J, e)).concrete()
      }
      addUser(e) {
          let {manualSelection: t, timeSchedule: n} = this;
          if (!t && !n)
              this.manualSelection = {
                  userIds: [e.id]
              };
          else if (t)
              this.manualSelection = {
                  ...t,
                  userIds: [...t.userIds, e.id]
              };
          else
              throw Error(`Cannot manipulate schedule`)
      }
      removeUser(e) {
          let {manualSelection: t, timeSchedule: n} = this;
          if (!(!t && !n))
              if (t) {
                  let n = t.userIds.filter(t => t !== e.id);
                  this.manualSelection = {
                      ...t,
                      userIds: n
                  }
              } else
                  throw Error(`Cannot manipulate schedule`)
      }
  }
  ,
  M([ug( () => K, `triageResponsibility`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], Vz.prototype, `team`, void 0),
  M([R()], Vz.prototype, `action`, void 0),
  M([R({
      serializer: Fh
  })], Vz.prototype, `manualSelection`, void 0),
  M([sg( () => Uz, `triageResponsibilities`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      cascadeHydration: !0
  })], Vz.prototype, `timeSchedule`, void 0),
  Vz = M([mg(`TriageResponsibility`)], Vz)
}
)), Uz, Wz = t(( () => {
  nt(),
  zt(),
  zn(),
  Xs(),
  Iz(),
  L_(),
  rB(),
  iU(),
  Hz(),
  GU(),
  V(),
  F(),
  om(),
  qL(),
  Ih(),
  N(),
  Uz = class extends qh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular;
      get originName() {
          return this.integration ? this.integration.name : this.oauthApplication ? this.oauthApplication.name : this.oauthClientId ? (this.hydrateOAuthApplicationInfo(),
          `OAuth app`) : `API`
      }
      get currentAndNextScheduleEntries() {
          let[e,t] = Fz.getCurrentAndNextScheduleEntry(this.entries);
          return [this.mapEntry(e, 0), this.mapEntry(t, 1)]
      }
      getRecentScheduleEntries(e) {
          let {entries: t} = this;
          if (!t)
              return [];
          let n = Fz.getScheduleEntriesWithIndex(t).map( ([e,t]) => this.mapEntry(e, t)).concrete()
            , r = n.findIndex(e => e.position === `current` || e.position === `next`);
          if (r === -1)
              return [];
          let i = Math.max(r - e.before, 0);
          return n.slice(i).slice(0, e.after + e.before + 1)
      }
      getFutureShiftForUser(e) {
          let {entries: t} = this;
          if (t)
              return Fz.getScheduleEntriesWithIndex(t).map( ([t,n]) => t.userId === e.id && n > 1 ? this.mapEntry(t, n) : void 0).concrete()[0]
      }
      getRequiredIntegrationAction() {
          let {integration: e} = this;
          if (!e)
              return;
          let t = e.service;
          if (!Hs(t))
              throw Error(`Invariant: Unexpected integration service ${t}`);
          if (!e.settings?.[t]?.apiFailedWithUnauthorizedErrorAt)
              return;
          let n = ``;
          if (t === T.pagerDuty || t === T.opsgenie)
              n = c_(t, this.organization);
          else
              throw new Rn(t);
          return {
              url: n,
              title: `Reconnect ${e.name} to synchronize triage responsibility`,
              subtitle: `Reconnect integration`
          }
      }
      async hydrateOAuthApplicationInfo() {
          if (!(!this.oauthClientId || this.oauthApplication))
              try {
                  let e = await KL(this.store.graphQLClient, [this.oauthClientId]);
                  Mt( () => {
                      this.oauthApplication = e.applicationInfoByIds.length > 0 ? e.applicationInfoByIds[0] : void 0
                  }
                  )
              } catch {
                  return
              }
      }
      mapEntry(e, t) {
          if (!e)
              return;
          let n = null;
          return t === -1 ? n = `previous` : t === 0 ? n = `current` : t === 1 && (n = `next`),
          {
              startsAt: typeof e.startsAt == `string` ? Xe(e.startsAt) : e.startsAt,
              endsAt: typeof e.endsAt == `string` ? Xe(e.endsAt) : e.endsAt,
              user: e?.userId ? this.store.findById(J, e.userId) : void 0,
              externalUserEmail: e.userEmail,
              position: n
          }
      }
  }
  ,
  M([R({
      default: ``
  })], Uz.prototype, `name`, void 0),
  M([R({
      serializer: Fh
  })], Uz.prototype, `entries`, void 0),
  M([B( () => nB, `timeSchedules`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], Uz.prototype, `integration`, void 0),
  M([R({
      persistence: `none`
  })], Uz.prototype, `oauthClientId`, void 0),
  M([B( () => q, `timeSchedules`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], Uz.prototype, `organization`, void 0),
  M([R()], Uz.prototype, `externalId`, void 0),
  M([R()], Uz.prototype, `externalUrl`, void 0),
  M([z( () => Vz, {
      index: `timeScheduleId`
  })], Uz.prototype, `triageResponsibilities`, void 0),
  Uz = M([mg(`TimeSchedule`)], Uz)
}
)), Gz, Kz, qz, Jz, Yz, Xz, Zz, Qz = t(( () => {
  Xs(),
  ed(),
  Xn(),
  pi(),
  ML(),
  Gz = e => {
      let {botScopes: t, userScopes: n, slackApp: r, callbackUrl: i=QN(), teamId: a} = e
        , o = {
          client_id: r === Ws.Linear ? ui.isEnabled(ui.slackStagingApp) ? Jn.SLACK_STAGING_CLIENT_ID : Jn.SLACK_CLIENT_ID : Jn.SLACK_INTAKE_APP_CLIENT_ID,
          scope: t ? t.join(`,`) : ``,
          user_scope: n ? n.join(`,`) : ``,
          install_redirect: `update-to-granular-scopes`,
          redirect_uri: i,
          team: a
      };
      return `https://slack.com/oauth/v2/authorize?${Qu(o).map(e => {
          let t = o[e];
          if (t !== void 0)
              return `${e}=${encodeURIComponent(t)}`
      }
      ).concrete().join(`&`)}`
  }
  ,
  Kz = `links.embed:write`,
  qz = `channels:join`,
  Jz = [`chat:write`, `chat:write.customize`],
  Yz = [`channels:history`, `groups:history`, `mpim:history`, `im:history`],
  Xz = [...Jz, ...Yz, `commands`, `links:read`, `links:write`, `users:read`, `users:read.email`, `channels:read`, `groups:read`, `im:read`, `mpim:read`, `reactions:read`, `reactions:write`, `files:read`, `files:write`, `app_mentions:read`, qz],
  Zz = () => {
      let e = !ui.isEnabled(ui.previewVideosInSlack)
        , t = ui.isEnabled(ui.slackIntegrationOptOutOfAutojoiningChannel)
        , n = ui.isEnabled(ui.slackIntegrationOptOutOfReadingMessageHistory)
        , r = (r, i=!1) => (t && (r = r.filter(e => e !== qz)),
      e && (r = r.filter(e => e !== Kz)),
      n && !i && (r = r.filter(e => !Yz.includes(e))),
      i && (r = r.filter(e => e !== `mpim:history`)),
      r);
      return {
          Linear: r([...Xz, `im:write`, Kz]),
          LinearStaging: r([...Xz, `im:write`, `channels:manage`, `bookmarks:write`, `links.embed:write`]),
          Asks: r([...Xz, `app_mentions:read`], !0),
          Post: r([`incoming-webhook`, Kz]),
          Personal: r([`chat:write`, `im:write`, `im:history`, `reactions:read`, Kz]),
          EmojiImport: r([`emoji:read`]),
          ChannelPicker: r([`incoming-webhook`])
      }
  }
}
));
function jle(e, t) {
  return e.query(Ut`
    query CheckScopes($integrationId: String!, $scopes: [String!]!) {
      integrationHasScopes(integrationId: $integrationId, scopes: $scopes) {
        hasAllScopes
        missingScopes
      }
    }
  `, t)
}
var $z, eB, tB, nB, rB = t(( () => {
  Wt(),
  $z = e(pe(), 1),
  eB = e(nn(), 1),
  tB = e(Se(), 1),
  zt(),
  Xs(),
  ab(),
  Yf(),
  vd(),
  Od(),
  pi(),
  Pz(),
  VR(),
  zR(),
  Xb(),
  iU(),
  iz(),
  mH(),
  Wz(),
  GU(),
  V(),
  F(),
  Nm(),
  Ih(),
  Qz(),
  DM(),
  N(),
  nB = class extends Yh {
      constructor(...e) {
          super(...e),
          this.shouldReinstall = () => this.service === T.slack ? ui.isEnabled(ui.forceSlackUpdate) ? Promise.resolve(!0) : jle(this.store.graphQLClient, {
              scopes: ui.isEnabled(ui.slackStagingApp) ? Zz().LinearStaging : Zz().Linear,
              integrationId: this.id
          }).then(e => !e.integrationHasScopes.hasAllScopes) : Promise.resolve(!1),
          this.userCanManageAsksSettings = (e, t) => {
              if (t.service !== T.slackAsks || !t.settings?.slackAsks)
                  throw Error(`Integration is not a Slack Asks integration`);
              return e.hasPermission(Cd.integrations, {
                  [Cd.integrations]: t.settings.slackAsks.canAdministrate
              })
          }
          ,
          this.setSettings = async e => {
              if (![T.front, T.intercom, T.jira, T.sentry, T.slack, T.slackAsks, T.zendesk, T.github, T.googleSheets, T.salesforce].includes(this.service))
                  return;
              let t = (0,
              eB.default)(this.settings)
                , n = this.service === T.github ? `gitHub` : this.service;
              t = {
                  [n]: (0,
                  $z.default)(t[n], e)
              },
              Mt( () => {
                  this.settings = t,
                  this.save()
              }
              )
          }
      }
      get name() {
          return Ys.getDisplayName(this.service)
      }
      get isPullRequestIntegration() {
          return this.service === T.github || this.service === T.githubEnterpriseServer || this.service === T.gitlab
      }
      get isLegacyZendeskIntegration() {
          return this.service === T.zendesk ? !this.settings?.zendesk?.supportsOAuthRefresh : !1
      }
      get isTemplateEnabledIntegration() {
          return rb.isTemplateEnabledIntegration(this.service)
      }
      sortedTemplates() {
          return (0,
          tB.default)(this.integrationTemplates.map(e => e.template.value).concrete(), [e => e.team?.name, `sortOrder`, `createdAt`], [`asc`, `asc`, `asc`])
      }
      isAvailableForTemplate(e) {
          let t = this.service === T.slackAsks ? this.organization.canAccessSome([gd.asksLimited, gd.asks]) : !0
            , n = this.service === T.slackAsks ? !!this.settings?.slackAsks?.slackChannelMapping?.length : this.isTemplateEnabledIntegration
            , r = rb.isWorkspaceTemplatesEnabledIntegration(this.service)
            , i = rb.isPrivateTemplateEnabledIntegration(this.service);
          return e.type === yf.issue && t && n && (e.team || r) && (!e.team?.private || i)
      }
      userHasMatchingPersonalIntegration(e) {
          let t = e.organization.integrations.filter(t => t.creator.id === e.id);
          switch (this.service) {
          case T.github:
              let e = this.settings.gitHub?.codeAccess ? T.githubCodeAccessPersonal : T.githubPersonal;
              return t.some(t => t.service === e && !t.authError);
          case T.jira:
              return t.some(e => e.service === T.jiraPersonal && !e.authError);
          default:
              return !1
          }
      }
      isSlackAgentEnabled() {
          return this.settings.slack?.enableAgent ?? !0
      }
  }
  ,
  M([R({
      default: `email`,
      persistence: `none`
  })], nB.prototype, `service`, void 0),
  M([R({
      default: ``,
      persistence: `none`
  })], nB.prototype, `serviceId`, void 0),
  M([cg( () => K, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], nB.prototype, `team`, void 0),
  M([cg( () => G, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], nB.prototype, `project`, void 0),
  M([cg( () => W, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], nB.prototype, `initiative`, void 0),
  M([lg( () => Az, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], nB.prototype, `customView`, void 0),
  M([cg( () => J, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], nB.prototype, `creator`, void 0),
  M([B( () => q, `integrations`, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], nB.prototype, `organization`, void 0),
  M([R({
      default: {},
      persistence: `updateOnly`
  })], nB.prototype, `settings`, void 0),
  M([og( () => BR)], nB.prototype, `featureFlags`, void 0),
  M([og( () => RR)], nB.prototype, `rolloutStages`, void 0),
  M([og( () => Yb)], nB.prototype, `integrationTemplates`, void 0),
  M([z( () => Uz, {
      index: `integrationId`,
      order: new P(`name`)
  })], nB.prototype, `timeSchedules`, void 0),
  M([R({
      serializer: Mh,
      persistence: `none`
  })], nB.prototype, `authError`, void 0),
  M([R({
      serializer: Mh,
      persistence: `none`
  })], nB.prototype, `metadata`, void 0),
  nB = M([mg(`Integration`)], nB)
}
)), iB, aB = t(( () => {
  V(),
  F(),
  om(),
  rB(),
  sB(),
  N(),
  iB = class extends Jh {
      static #e = this.loadStrategy = rm.instant
  }
  ,
  M([R({
      default: ``
  })], iB.prototype, `displayName`, void 0),
  M([cg( () => nB, {
      nullable: !0,
      persistence: `none`,
      indexed: !0
  })], iB.prototype, `integration`, void 0),
  M([og( () => oB)], iB.prototype, `fields`, void 0),
  iB = M([mg(`CustomerSchema`)], iB)
}
)), oB, sB = t(( () => {
  nb(),
  V(),
  F(),
  om(),
  aB(),
  N(),
  oB = class extends Jh {
      static #e = this.loadStrategy = rm.instant
  }
  ,
  M([R({
      persistence: `none`,
      default: ``
  })], oB.prototype, `name`, void 0),
  M([R({
      persistence: `none`,
      default: tb.stringType
  })], oB.prototype, `type`, void 0),
  M([R({
      default: !0
  })], oB.prototype, `enabled`, void 0),
  M([B( () => iB, `fields`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], oB.prototype, `schema`, void 0),
  oB = M([mg(`CustomerSchemaField`)], oB)
}
)), cB, lB = t(( () => {
  nb(),
  V(),
  F(),
  om(),
  Ih(),
  sB(),
  FB(),
  N(),
  cB = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular
  }
  ,
  M([R({
      serializer: Mh,
      persistence: `none`,
      default: ``
  })], cB.prototype, `value`, void 0),
  M([R({
      persistence: `none`,
      default: tb.stringType
  })], cB.prototype, `type`, void 0),
  M([cg( () => oB, {
      nullable: !0,
      persistence: `none`,
      indexed: !0
  })], cB.prototype, `field`, void 0),
  M([sg( () => MB, `attributes`, {
      nullable: !1,
      optional: !1,
      indexed: !0,
      persistence: `none`
  })], cB.prototype, `customer`, void 0),
  cB = M([mg(`CustomAttribute`)], cB)
}
)), uB, dB = t(( () => {
  V(),
  F(),
  iU(),
  N(),
  uB = class extends Yh {
      get name() {
          return this.displayName
      }
      set name(e) {
          this.displayName = e
      }
  }
  ,
  M([R({
      default: ``
  })], uB.prototype, `displayName`, void 0),
  M([R({
      default: `#f00`
  })], uB.prototype, `color`, void 0),
  M([R()], uB.prototype, `description`, void 0),
  M([R({
      default: 0
  })], uB.prototype, `position`, void 0),
  M([B( () => q, `customerStatuses`, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], uB.prototype, `organization`, void 0),
  uB = M([mg(`CustomerStatus`)], uB)
}
));
function Mle(e) {
  return fB === void 0 && (fB = new Intl.NumberFormat),
  fB.format(e)
}
function Nle(e) {
  return Math.round(1e3 * e) / 10
}
function Ple(e) {
  let t = pB(e);
  return new Intl.NumberFormat(`en-US`,{
      ...t
  }).format(e)
}
var fB, pB, mB, hB = t(( () => {
  pB = e => e >= 1e3 ? {
      notation: `compact`,
      compactDisplay: `short`,
      minimumFractionDigits: 1,
      maximumFractionDigits: 1
  } : {
      notation: `compact`,
      compactDisplay: `short`,
      maximumFractionDigits: 0
  },
  mB = 2147483647
}
));
function Fle(e) {
  return gB(e / 100)
}
function gB(e, t) {
  let n = t?.compact ? pB(e) : {}
    , r = t?.currencyCode ?? `USD`
    , i = t?.useUserLocale ? void 0 : `en-US`;
  return new Intl.NumberFormat(i,{
      style: `currency`,
      currency: r,
      currencyDisplay: `narrowSymbol`,
      ...n,
      ...t?.maximumFractionDigits !== void 0 && {
          maximumFractionDigits: t.maximumFractionDigits
      }
  }).format(e)
}
var _B, vB = t(( () => {
  hB(),
  _B = e => {
      try {
          let t = new Intl.NumberFormat(`en-US`,{
              style: `currency`,
              currency: e ?? `USD`,
              currencyDisplay: `narrowSymbol`
          }).formatToParts(0).find(e => e.type === `currency`);
          return t ? t.value : `$`
      } catch {
          return `$`
      }
  }
}
)), yB, bB = t(( () => {
  V(),
  F(),
  iU(),
  N(),
  yB = class extends Yh {
      get name() {
          return this.displayName
      }
      set name(e) {
          this.displayName = e
      }
  }
  ,
  M([R({
      default: ``
  })], yB.prototype, `displayName`, void 0),
  M([R({
      default: `#f00`
  })], yB.prototype, `color`, void 0),
  M([R()], yB.prototype, `description`, void 0),
  M([R({
      default: 0
  })], yB.prototype, `position`, void 0),
  M([B( () => q, `customerTiers`, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], yB.prototype, `organization`, void 0),
  yB = M([mg(`CustomerTier`)], yB)
}
));
function xB(e, t, n={}) {
  let r = t != null && Number.isFinite(t) ? Math.max(t, 0) : 0, i = n.getNextArgs || ( (e, t) => t), a, o, s, c;
  function l() {
      let t = a;
      if (!t)
          return Promise.reject(Error(`unexpected error: nextArgs is null`));
      c = void 0,
      a = void 0;
      let n = Promise.resolve(e(...t));
      return o = n.catch( () => {}
      ).then( () => {
          o = void 0
      }
      ),
      s = new CB(o,r),
      n
  }
  function u(e) {
      if (a = a ? i(a, e) : e,
      !a)
          throw Error(`unexpected error: nextArgs is null`)
  }
  function d() {
      return c = (s || Promise.resolve()).then(l)
  }
  function f(...e) {
      try {
          u(e)
      } catch (e) {
          return Promise.reject(e)
      }
      return c || d()
  }
  return f.invokeIgnoreResult = (...e) => {
      u(e),
      c || d().catch(e => {
          if (!(e instanceof SB))
              throw e
      }
      )
  }
  ,
  f.cancel = async () => {
      var e, t;
      let n = o;
      (e = s) == null || (t = e.cancel) == null || t.call(e),
      c = void 0,
      a = void 0,
      o = void 0,
      s = void 0,
      await n
  }
  ,
  f.flush = async () => {
      var e, t;
      (e = s) == null || (t = e.flush) == null || t.call(e),
      await o
  }
  ,
  f
}
var SB, CB, wB, TB = t(( () => {
  SB = class extends Error {
      constructor() {
          super(`throttled invocation was canceled`),
          this.name = `CanceledError`
      }
  }
  ,
  CB = class {
      ready;
      canceled = !1;
      constructor(e, t) {
          let n = new Promise(e => {
              this.timeout = setTimeout(e, t),
              this.resolve = e
          }
          );
          this.ready = e.then( () => n, () => n).then( () => {
              this.ready = void 0
          }
          )
      }
      flush() {
          clearTimeout(this.timeout),
          this.resolve()
      }
      cancel() {
          this.canceled = !0,
          clearTimeout(this.timeout),
          this.resolve()
      }
      get[Symbol.toStringTag]() {
          return `Delay`
      }
      then(e, t) {
          return (this.ready || Promise.resolve()).then( () => {
              if (this.canceled)
                  throw new SB
          }
          ).then(e, t)
      }
      catch(e) {
          return this.then(void 0, e)
      }
      finally(e) {
          return this.then().finally(e)
      }
  }
  ,
  xB.CanceledError = SB,
  wB = xB
}
));
async function EB(e, t) {
  let n = Ut`
  query CustomersQuery($first: Int, $after: String, $filter: CustomerFilter, $sorts: [CustomerSortInput!]) {
    customers(first: $first, after: $after, filter: $filter, sorts: $sorts) {
      nodes {
        id
      }
      pageInfo {
        endCursor
        hasNextPage
        hasPreviousPage
        startCursor
      }
    }
  }
`;
  return (await e.query(n, t)).customers
}
var DB, OB = t(( () => {
  TB(),
  Wt(),
  DB = wB( (e, t) => EB(e, t), 200)
}
)), kB, AB = t(( () => {
  hQ(),
  FB(),
  OB(),
  kB = async (e, t) => {
      let {direction: n, filter: r, ordering: i} = t
        , a = n ? n === `asc` ? `Ascending` : `Descending` : void 0
        , o = i ? [{
          [i]: {
              order: a
          }
      }] : void 0
        , s = await EB(pQ().graphQLClient, {
          after: e || void 0,
          first: 50,
          filter: r,
          sorts: o
      });
      return {
          models: (await Promise.all(s.nodes.map(e => pQ().hydrateModel(MB, e.id)))).concrete(),
          pageInfo: s.pageInfo
      }
  }
}
)), jB, MB, NB, PB, FB = t(( () => {
  $y(),
  Bu(),
  Mu(),
  Uoe(),
  cc(),
  hQ(),
  GU(),
  V(),
  F(),
  om(),
  WB(),
  lB(),
  dB(),
  iU(),
  bH(),
  ML(),
  PL(),
  vB(),
  JR(),
  sR(),
  bB(),
  mx(),
  fz(),
  AB(),
  N(),
  Ot(),
  MB = class extends Yh {
      static #e = jB = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      markNotificationAsRead(e) {
          let t = this.notifications.find(t => t.id === e);
          if (!t)
              return;
          let n = t?.groupingEntityId;
          this.notifications.forEach(e => {
              e.readAt === void 0 && e.groupingEntityId === n && (e.markAsRead(),
              e.save())
          }
          )
      }
      toggleFavorite() {
          if (this.favorite)
              return this.favorite.delete(),
              !1;
          let e = yH.create({
              reference: this
          });
          return e.save(!0),
          e
      }
      get displayRevenue() {
          return this.organization?.customersConfiguration && this.organization.customersConfiguration.revenueDisplay === `monthly` ? this.revenue ? Math.round(this.revenue / 12) : null : this.revenue
      }
      get hasArchivedCustomerNeeds() {
          return sc(this.traits, eb.hasArchivedCustomerNeeds)
      }
      static create(e) {
          let t = jB.createEmpty();
          return t.name = e.name,
          t.organization = e.organization,
          t
      }
      matchInlineFind() {
          return !0
      }
      get slug() {
          return `${ju(this.name)}-${this.slugId}`
      }
      get managedIntegration() {
          return this.sourceMetadata?.find(e => NB(this.organization, e))
      }
      get isManagedByDataSource() {
          let e = this.organization.customersConfiguration?.attributesDataSourceConfiguration?.integration?.service;
          if (!e)
              return !1;
          let t = this.organization.getIntegration(e);
          return t ? this.sourceMetadata?.some(e => e.type === `integration` && e.integrationId === t.id) ?? !1 : !1
      }
      get hasAlternativeSources() {
          let e = this.managedIntegration?.subType;
          return (this.sourceMetadata?.filter(t => !!t.externalName && t.subType === e)?.length ?? 0) > 1
      }
      get formattedSourceName() {
          return this.managedIntegration?.displayName ? this.managedIntegration.displayName : this.sourceMetadata?.some(e => e.type === `api`) ? `API` : ``
      }
      get isConnectedToSlackChannel() {
          return !!this.slackChannelId && !!this.slackChannelMetadata
      }
      get slackChannelMetadata() {
          return this.sourceMetadata?.find(e => e.type === `manual` && e.slackSourceMetadata)?.slackSourceMetadata
      }
      get formattedRevenue() {
          return gB(this.displayRevenue ?? 0, {
              compact: !0,
              currencyCode: this.organization.customersConfiguration?.revenueCurrencyCode,
              useUserLocale: !0
          })
      }
      get exactFormattedRevenue() {
          return gB(this.displayRevenue ?? 0, {
              compact: !1,
              currencyCode: this.organization.customersConfiguration?.revenueCurrencyCode,
              useUserLocale: !0
          })
      }
      get requestCount() {
          return GR(this.needs.elements).size
      }
      static #r = this.collectionsExcludedFromLocalTransaction = [`needs`];
      static #i = this.hydrateAfterStartupConfig = {
          priority: px.low,
          execute: async e => {
              if (!(NL(pQ().user).base && e.approximateCustomerCount > 0))
                  return;
              await e.viewPreferences.hydrate();
              let t = e.getViewPreferences.bind(e)(k.customers).getPreference(`customersViewOrdering`) ?? `createdAt`
                , n = new dz({
                  persistenceKey: YF(e)
              })
                , r = {
                  and: []
              };
              n.isFiltering && r.and.push(n.filter),
              await (await PB()).prefetchInfiniteQuery({
                  queryKey: [`customers`, r, t],
                  queryFn: ({pageParam: e}) => kB(e, {
                      filter: r,
                      ordering: t
                  }),
                  initialPageParam: ``,
                  getNextPageParam: e => e.pageInfo.endCursor,
                  pages: 2
              })
          }
      }
  }
  ,
  M([R({
      default: ``
  })], MB.prototype, `name`, void 0),
  M([R()], MB.prototype, `logoUrl`, void 0),
  M([R({
      default: []
  })], MB.prototype, `domains`, void 0),
  M([R({
      persistence: `none`,
      default: []
  })], MB.prototype, `externalIds`, void 0),
  M([R()], MB.prototype, `slackChannelId`, void 0),
  M([cg( () => J, {
      nullable: !0
  })], MB.prototype, `owner`, void 0),
  M([R({
      persistence: `none`
  })], MB.prototype, `sourceMetadata`, void 0),
  M([R({
      persistence: `none`
  })], MB.prototype, `metadata`, void 0),
  M([R()], MB.prototype, `revenue`, void 0),
  M([R()], MB.prototype, `size`, void 0),
  M([R({
      persistence: `none`,
      default: 0
  })], MB.prototype, `approximateNeedCount`, void 0),
  M([R({
      persistence: `none`
  })], MB.prototype, `traits`, void 0),
  M([R({
      persistence: `none`,
      default: ``,
      indexed: !0
  })], MB.prototype, `slugId`, void 0),
  M([cg( () => uB, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], MB.prototype, `status`, void 0),
  M([cg( () => yB, {
      nullable: !0,
      indexed: !0
  })], MB.prototype, `tier`, void 0),
  M([B( () => q, `customers`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], MB.prototype, `organization`, void 0),
  M([R()], MB.prototype, `mainSourceId`, void 0),
  M([z( () => UB, {
      index: `customerId`
  })], MB.prototype, `needs`, void 0),
  M([z( () => cB, {
      index: `customerId`
  })], MB.prototype, `attributes`, void 0),
  M([ug({
      nullable: !0
  })], MB.prototype, `favorite`, void 0),
  M([og( () => XL)], MB.prototype, `notifications`, void 0),
  M([ug({
      nullable: !0
  })], MB.prototype, `subscription`, void 0),
  M([I], MB.prototype, `markNotificationAsRead`, null),
  M([I], MB.prototype, `toggleFavorite`, null),
  M([L], MB.prototype, `displayRevenue`, null),
  M([L], MB.prototype, `hasArchivedCustomerNeeds`, null),
  M([L], MB.prototype, `requestCount`, null),
  MB = jB = M([mg(`Customer`)], MB),
  NB = (e, t) => {
      let n = e.customersConfiguration?.attributesDataSourceConfiguration?.integration?.service;
      if (!n)
          return !1;
      let r = e.integrations.filter(e => Jy.includes(e.service)).find(e => e.service === n);
      return r ? t.type === `integration` && t.integrationId === r.id : !1
  }
  ,
  PB = () => kt( () => import(`./queryClient.aZi-y_WY.js`), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6]), import.meta.url).then(e => e.queryClient)
}
)), IB, LB, RB, zB, BB = t(( () => {
  IB = class {
      constructor(e, t) {
          this.name = e,
          this.priority = t
      }
      get filterValue() {
          return this.priority
      }
      get isNoPriority() {
          return this.priority === 0
      }
      get isImportant() {
          return this.priority >= 1
      }
      static createFromPriority(e) {
          return e >= 1 ? zB : RB
      }
      static get allPriorities() {
          return [RB, zB]
      }
  }
  ,
  LB = {
      serialize: e => e.priority,
      deserialize: e => IB.createFromPriority(e)
  },
  RB = new IB(`Important`,0),
  zB = new IB(`Important`,1)
}
)), VB, Ile = t(( () => {
  Fc(),
  GU(),
  iz(),
  rB(),
  V(),
  F(),
  Ih(),
  N(),
  VB = class extends Yh {
      get sourceType() {
          return Pc.getSourceType(this)
      }
      get strippedFirstAttachmentMessageBody() {
          return Pc.getStrippedFirstAttachmentMessageBody(this)
      }
  }
  ,
  M([R({
      default: ``
  })], VB.prototype, `title`, void 0),
  M([R()], VB.prototype, `subtitle`, void 0),
  M([R({
      persistence: `createOnly`,
      default: ``
  })], VB.prototype, `url`, void 0),
  M([R({
      serializer: Mh,
      default: {}
  })], VB.prototype, `metadata`, void 0),
  M([R({
      persistence: `none`
  })], VB.prototype, `source`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0
  })], VB.prototype, `creator`, void 0),
  M([cg( () => G, {
      persistence: `none`,
      optional: !1,
      nullable: !1,
      indexed: !0
  })], VB.prototype, `project`, void 0),
  M([cg( () => nB, {
      persistence: `none`,
      nullable: !0
  })], VB.prototype, `integration`, void 0),
  M([dg({
      nullable: !0
  })], VB.prototype, `need`, void 0),
  M([R({
      persistence: `none`
  })], VB.prototype, `sourceMetadata`, void 0),
  VB = M([mg(`ProjectAttachment`)], VB)
}
)), HB, UB, WB = t(( () => {
  Xt(),
  Sy(),
  Uy(),
  xy(),
  Vg(),
  Gy(),
  XB(),
  Lq(),
  V(),
  F(),
  om(),
  Sm(),
  FB(),
  iz(),
  AV(),
  iU(),
  GU(),
  BB(),
  Ih(),
  Ile(),
  eu(),
  sR(),
  N(),
  UB = class extends Yh {
      static #e = HB = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static create(e) {
          let t = HB.createEmpty();
          return t.organization = e.organization,
          t.creator = e.creator,
          t.priority = IB.createFromPriority(0),
          e.customer && (t.customer = vm.wrap(e.customer)),
          e.issue && (t.issue = vm.wrap(e.issue)),
          e.project && (t.project = e.project),
          e.attachment && (t.attachment = vm.wrap(e.attachment)),
          e.attachmentUrl && (t.attachmentUrl = e.attachmentUrl),
          e.bodyData && (t.bodyData = e.bodyData),
          t
      }
      get effectiveAttachment() {
          return this.attachment?.value ?? this.projectAttachment?.value
      }
      get effectiveUrl() {
          return this.effectiveAttachment?.url
      }
      isEmpty() {
          return this.priority.isNoPriority && !this.effectiveUrl && (!this.bodyData || zy(this.bodyData))
      }
      get linkedToProjectOnly() {
          return !!this.project?.id && !this.issue
      }
      get hasManualBodyContent() {
          return !!this.bodyData && !zy(this.bodyData)
      }
      get bodyContent() {
          return this.hasManualBodyContent ? this.bodyData : this.attachmentBodyContent
      }
      get attachmentBodyContent() {
          let e = this.effectiveAttachment?.strippedFirstAttachmentMessageBody
            , t = Hp.parseToProsemirrorData(e || ``);
          if (t && !zy(t))
              return t
      }
      get hasBothManualAndAttachmentContent() {
          return this.hasManualBodyContent && this.attachmentBodyContent !== void 0
      }
      subtitle(e=100) {
          if (this.bodyData)
              return vy(Hp.serialize(this.bodyData), {
                  truncateLength: e,
                  preserveCodeMarks: !0
              });
          let t = this.effectiveAttachment?.strippedFirstAttachmentMessageBody;
          return t ? vy(t, {
              truncateLength: e,
              preserveCodeMarks: !0
          }) : ``
      }
      get sourceUserEmail() {
          return this.sourceMetadata?.userMetadata?.email ?? this.effectiveAttachment?.metadata?.attributes?.find(e => e.name === `User email`)?.value?.toString()
      }
      get externalSourceMetadata() {
          let e = this.sourceMetadata?.type;
          if (e)
              return {
                  ...this.sourceMetadata,
                  type: e
              }
      }
      get baseSearchableText() {
          return `${this.issue?.value?.title || ``} ${this.issue?.value?.identifier || ``} ${this.bodyContent ? Hp.serialize(this.bodyContent) : ``}`
      }
      get customerPageSearchableText() {
          return $l(`${this.project?.name || ``} ${this.baseSearchableText}`).toLowerCase()
      }
      get projectPageSearchableText() {
          return $l(`${this.customer?.value?.name || ``} ${this.baseSearchableText}`).toLowerCase()
      }
      matchInlineFind(e) {
          let t = Wy.location.pathname;
          return Yt({
              path: Rg.customer
          }, t) ? this.customerPageSearchableText.includes(e) : this.projectPageSearchableText.includes(e)
      }
      beforeSave(e) {
          super.beforeSave(e),
          e && (this.issue?.value?.needs?.some(e => e.priority.isImportant && !!this.customer?.id && e.customer?.id === this.customer?.id) || this.project?.needs?.some(e => e.priority.isImportant && !!this.customer?.id && e.customer?.id === this.customer?.id)) && (this.priority = IB.createFromPriority(1))
      }
      createMutation(e) {
          let t;
          function n(e, t) {
              return `${e}(input: {${Object.entries(t).map( ([e,t]) => `${e}: ${JSON.stringify(t)}`).join(`, `)}}) { lastSyncId }`
          }
          if (this.attachment?.id)
              t = n(`customerNeedCreateFromAttachment`, {
                  attachmentId: this.attachment.id
              });
          else
              return super.createMutation(e);
          return this.observePropertyChanges(),
          t
      }
  }
  ,
  M([R({
      serializer: LB,
      default: IB.createFromPriority(0)
  })], UB.prototype, `priority`, void 0),
  M([R({
      isVirtual: !0
  })], UB.prototype, `attachmentUrl`, void 0),
  M([R({
      serializer: Mh,
      shallowObservation: !0
  })], UB.prototype, `bodyData`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0
  })], UB.prototype, `creator`, void 0),
  M([sg( () => MB, `needs`, {
      nullable: !1,
      optional: !0,
      indexed: !0
  })], UB.prototype, `customer`, void 0),
  M([sg( () => Y, `needs`, {
      nullable: !1,
      optional: !0,
      indexed: !0,
      trait: `useForPartialIndex`
  })], UB.prototype, `issue`, void 0),
  M([sg( () => YB, `needs`, {
      nullable: !1,
      optional: !0,
      indexed: !0,
      persistence: `createOnly`
  })], UB.prototype, `comment`, void 0),
  M([B( () => G, `needs`, {
      nullable: !1,
      optional: !0,
      indexed: !0,
      trait: `useForPartialIndex`
  })], UB.prototype, `project`, void 0),
  M([dg( () => kV, `need`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], UB.prototype, `attachment`, void 0),
  M([dg( () => VB, `need`, {
      nullable: !0,
      indexed: !0,
      persistence: `none`
  })], UB.prototype, `projectAttachment`, void 0),
  M([R({
      persistence: `none`
  })], UB.prototype, `sourceMetadata`, void 0),
  M([sg( () => Y, `formerNeeds`, {
      nullable: !1,
      optional: !0,
      indexed: !0,
      persistence: `none`
  })], UB.prototype, `originalIssue`, void 0),
  M([og( () => XL)], UB.prototype, `notifications`, void 0),
  M([cg( () => q, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], UB.prototype, `organization`, void 0),
  M([L], UB.prototype, `effectiveAttachment`, null),
  M([L], UB.prototype, `baseSearchableText`, null),
  M([L], UB.prototype, `customerPageSearchableText`, null),
  M([L], UB.prototype, `projectPageSearchableText`, null),
  UB = HB = M([mg(`CustomerNeed`)], UB)
}
)), GB, KB = t(( () => {
  Ng(),
  V(),
  F(),
  om(),
  Nm(),
  Lq(),
  XB(),
  N(),
  GB = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      get isActive() {
          return this.status === jg.created || this.status === jg.inProgress
      }
      get isFinished() {
          return this.status === jg.finished
      }
      get isFailed() {
          return this.status === jg.failed
      }
      get isCanceled() {
          return this.status === jg.canceled
      }
  }
  ,
  M([sg( () => Y, `aiPromptProgresses`, {
      nullable: !1,
      optional: !0,
      indexed: !0,
      trait: `useForPartialIndex`,
      persistence: `none`
  })], GB.prototype, `issue`, void 0),
  M([sg( () => YB, `aiPromptProgresses`, {
      nullable: !1,
      optional: !0,
      indexed: !0,
      persistence: `none`
  })], GB.prototype, `comment`, void 0),
  M([sg( () => GB, `children`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      cascadeHydration: !0,
      persistence: `createOnly`
  })], GB.prototype, `parent`, void 0),
  M([z( () => GB, {
      index: `parentId`,
      order: new P(`createdAt`)
  })], GB.prototype, `children`, void 0),
  M([R({
      persistence: `none`,
      default: Ag.productIntelligence
  })], GB.prototype, `type`, void 0),
  M([R({
      persistence: `none`,
      default: jg.created
  })], GB.prototype, `status`, void 0),
  M([R({
      persistence: `none`,
      default: {}
  })], GB.prototype, `metadata`, void 0),
  GB = M([mg(`AiPromptProgress`)], GB)
}
)), qB, JB, YB, XB = t(( () => {
  fy(),
  hy(),
  Ul(),
  Pv(),
  cc(),
  Gp(),
  ml(),
  _y(),
  Oy(),
  zn(),
  Xs(),
  to(),
  Od(),
  ly(),
  Ry(),
  AV(),
  V(),
  F(),
  om(),
  Vm(),
  Nm(),
  WB(),
  AR(),
  AM(),
  KA(),
  Iy(),
  Sm(),
  lj(),
  Lq(),
  sR(),
  UM(),
  Ih(),
  GU(),
  Bk(),
  Oj(),
  KB(),
  Uj(),
  hR(),
  sj(),
  Sj(),
  N(),
  JB = new P(`createdAt`),
  YB = class extends Yh {
      static #e = qB = this;
      constructor(...e) {
          super(...e),
          this.skipUpdatedAtKeys = new Set([`subscriberIds`])
      }
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static #r = this.partialPreloadForTeam = am.secondPriority;
      get author() {
          return this.user ?? this.externalUser?.value
      }
      get threadComments() {
          if (this.root)
              return Bm.of(qB, [...new Set([this.root, ...this.root.children])])
      }
      get root() {
          return this.parent?.id ? this.parent.value : this
      }
      get threadNotifications() {
          if (this.threadComments)
              return Bm.of(XL, this.threadComments.flatMap(e => e.notifications.elements))
      }
      get parentModel() {
          if (this.issue)
              return this.issue.value;
          if (this.projectUpdate)
              return this.projectUpdate.value;
          if (this.initiativeUpdate)
              return this.initiativeUpdate.value;
          if (this.documentContent)
              return this.documentContent.value;
          if (this.post)
              return this.post.value;
          throw Error(`Comment does not belong to any related model`)
      }
      allowEdit(e) {
          if (this.user !== e || this.sourceMetadata?.slackSyncMetadata?.commentSource === py.Slack || this.isEmailIntakeComment || this.getTrait(dy.hasAgentSession))
              return !1;
          let t = this.root;
          return !(t && t !== this && t.getTrait(dy.hasAgentSession))
      }
      allowDelete(e) {
          let t = this.user === e
            , n = e.organization.activeSubscription !== void 0 && e.hasPermission(Cd.entityManagement)
            , r = this.sourceMetadata?.slackSyncMetadata?.commentSource === py.Slack ? this.isRootUnsyncedSlackComment : !0
            , i = this.isEmailIntakeComment ? n : !0;
          return (t || n) && r && i
      }
      get hasEmojiOnlyBody() {
          return zk.hasEmojiOnlyBody(this)
      }
      get canResolve() {
          return this.parent === void 0 && !this.isSlackSynced
      }
      get hasPendingUploads() {
          return !!this.pendingUploads && this.pendingUploads.size > 0
      }
      get isResolved() {
          return !!this.resolvedAt
      }
      async markNotificationsAsRead() {
          let e = this.id
            , t = this.parent?.id
            , n = n => {
              n.forEach(n => {
                  n.comment?.id && (n.comment?.id === e || n.comment?.id === t) && (n.markAsRead(),
                  n.save())
              }
              )
          }
          ;
          if (this.issue?.value) {
              n(this.issue.value.notifications.elements);
              return
          }
          if (this.projectUpdate?.value) {
              n(this.projectUpdate.value.notifications.elements);
              return
          }
          if (this.initiativeUpdate?.value) {
              n(this.initiativeUpdate.value.notifications.elements);
              return
          }
          if (this.documentContent?.value) {
              let e = await this.documentContent.value.hydrate()
                , t = e.parentType;
              if (!t)
                  return;
              switch (t) {
              case `issue`:
                  return;
              case `document`:
                  n(e.document?.value.notifications.elements || []);
                  return;
              case `initiative`:
                  n(e.initiative?.notifications.elements || []);
                  return;
              case `project`:
                  n(e.project?.notifications.elements || []);
                  return;
              case `projectMilestone`:
                  n(e.projectMilestone?.value?.notifications.elements || []);
                  return;
              case `aiPromptRules`:
                  return;
              default:
                  y(t);
                  return
              }
          }
      }
      resolve(e, t) {
          this.resolvingUser = e,
          this.resolvingComment = t ? vm.wrap(t) : void 0,
          this.save()
      }
      unresolve() {
          this.resolvedAt = null,
          this.resolvingUser = null,
          this.resolvingComment = null,
          this.save()
      }
      get bodyMarkdown() {
          return this.bodyData ? Hp.serialize(this.bodyData) : ``
      }
      get bodyTextContent() {
          return this.bodyData ? gy(dl.nodeFromJSON(this.bodyData)) : ``
      }
      get notificationText() {
          let e = this.store;
          if (this.bodyData)
              return Ty(this.bodyData, {
                  getDisplayUserLabel(t, n) {
                      let r = e.findById(J, t);
                      return r ? Ly.getUsername(e.user.settings, r) : n
                  }
              })
      }
      get isThread() {
          return !!this.parent || this.children.length > 0
      }
      get isSlackSynced() {
          return this.parent?.value?.isSlackSynced ? !0 : this.sourceMetadata?.slackSyncMetadata !== void 0
      }
      get isRootSlackSyncedComment() {
          return this.isSlackSynced && this.isSyncedExternalThreadRoot
      }
      get isRootUnsyncedSlackComment() {
          return this.isRootSlackSyncedComment && this.sourceMetadata?.slackSyncMetadata?.unsynced === !0
      }
      get isRootEmailIntakeComment() {
          return this.parent?.value === void 0 && this.sourceMetadata?.emailIntakeMetadata !== void 0
      }
      get isEmailIntakeComment() {
          return this.isRootEmailIntakeComment ? !0 : this.parent?.value?.isRootEmailIntakeComment
      }
      getEmailIntakeMessageMetadata() {
          return this.externalEntityRelations?.find(e => e.externalEntityType === Vl.emailMessage)?.metadata?.emailMessageMetadata
      }
      get isSyncedExternalThreadRoot() {
          return !!this.sourceMetadata?.externalSyncRoot
      }
      get threadSubscribers() {
          return this.root?.subscribers
      }
      userIsSubscribedToThread(e) {
          return this.threadSubscribers?.contains(e)
      }
      get isAsksThread() {
          return this.sourceMetadata?.subType === T.slackAsks
      }
      async unsyncSlack() {
          if (!this.isRootSlackSyncedComment)
              throw new eo(`Attachment is not a synced Slack thread`);
          if (this.isAsksThread)
              throw new eo(`Asks threads cannot be un-synced`);
          return await this.store.mutate(qB, `rootCommentUnsyncSlack`, {
              id: this.id
          })
      }
      getTrait(e) {
          return sc(this.traits, e)
      }
      static validateCommentQuota(e) {
          if (e instanceof Y)
              return cy.validateQuotaOrToast(e.team.organization, jv.maxCommentsPerIssue, e.comments.length);
          if (e instanceof kR) {
              if (!e.isHydrated())
                  return !0;
              let t = e.getParent();
              if (!t || t instanceof Y)
                  return !0;
              let n;
              return n = t instanceof mR ? t.project.organization : t.organization,
              cy.validateQuotaOrToast(n, jv.maxCommentsPerDocumentContent, e.comments.length)
          } else if (e instanceof HM)
              return cy.validateQuotaOrToast(e.project.organization, jv.maxCommentsPerUpdate, e.comments.length);
          else if (e instanceof cj)
              return cy.validateQuotaOrToast(e.organization, jv.maxCommentsPerUpdate, e.comments.length);
          else if (e instanceof Hj)
              return cy.validateQuotaOrToast(e.organization, jv.maxCommentsPerPost, e.comments.length);
          return !1
      }
      static create(e) {
          let {parentModel: t, user: n, bodyData: r, parent: i, quotedText: a} = e
            , o = qB.createEmpty();
          return o.user = n,
          this.setCommentParent(o, t),
          i && (o.parent = vm.wrap(i)),
          o.bodyData = r || pl(),
          o.quotedText = a,
          o
      }
      static setCommentParent(e, t) {
          if (t instanceof Y)
              e.issue = vm.wrap(t);
          else if (t instanceof HM)
              e.projectUpdate = vm.wrap(t);
          else if (t instanceof cj)
              e.initiativeUpdate = vm.wrap(t);
          else if (t instanceof kR)
              e.documentContent = vm.wrap(t);
          else if (t instanceof Hj)
              e.post = vm.wrap(t);
          else
              throw Error(`Invalid entity model`)
      }
  }
  ,
  M([R({
      serializer: Mh,
      shallowObservation: !0,
      default: {}
  })], YB.prototype, `bodyData`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], YB.prototype, `editedAt`, void 0),
  M([R({
      persistence: `none`,
      serializer: Mh,
      default: []
  })], YB.prototype, `reactionData`, void 0),
  M([sg( () => Y, `comments`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`,
      trait: `useForPartialIndex`
  })], YB.prototype, `issue`, void 0),
  M([sg( () => kR, `comments`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], YB.prototype, `documentContent`, void 0),
  M([sg( () => HM, `comments`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], YB.prototype, `projectUpdate`, void 0),
  M([sg( () => cj, `comments`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], YB.prototype, `initiativeUpdate`, void 0),
  M([sg( () => Hj, `comments`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], YB.prototype, `post`, void 0),
  M([z( () => oj, {
      index: `commentId`
  })], YB.prototype, `mediaMetadata`, void 0),
  M([sg( () => YB, `children`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      cascadeHydration: !0,
      persistence: `createOnly`,
      trait: `sameAsSelfPartial`
  })], YB.prototype, `parent`, void 0),
  M([z( () => YB, {
      index: `parentId`,
      order: JB,
      canSkipHydration: e => !e.getTrait(dy.hasChildren)
  })], YB.prototype, `children`, void 0),
  M([og( () => kM)], YB.prototype, `draftReplies`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `updateOnly`
  })], YB.prototype, `resolvingUser`, void 0),
  M([lg( () => YB, {
      nullable: !0,
      indexed: !0,
      cascadeHydration: !0,
      persistence: `updateOnly`
  })], YB.prototype, `resolvingComment`, void 0),
  M([R()], YB.prototype, `quotedText`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], YB.prototype, `resolvedAt`, void 0),
  M([dg( () => kV, `comment`, {
      persistence: `none`,
      optional: !0,
      nullable: !1,
      indexed: !0
  })], YB.prototype, `attachment`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !0,
      nullable: !1
  })], YB.prototype, `user`, void 0),
  M([z( () => GA, {
      index: `commentId`,
      canSkipHydration: e => !e.getTrait(dy.hasExternalEntityRelations)
  })], YB.prototype, `externalEntityRelations`, void 0),
  M([lg( () => Fy, {
      nullable: !0,
      indexed: !0,
      persistence: `none`
  })], YB.prototype, `externalUser`, void 0),
  M([z( () => Y, {
      index: `sourceCommentId`,
      canSkipHydration: e => !e.getTrait(dy.hasCreatedIssues)
  })], YB.prototype, `createdIssues`, void 0),
  M([R({
      persistence: `none`
  })], YB.prototype, `sourceMetadata`, void 0),
  M([R({
      persistence: `none`
  })], YB.prototype, `threadSummary`, void 0),
  M([R({
      isVirtual: !0
  })], YB.prototype, `doNotSubscribeToIssue`, void 0),
  M([R({
      persistence: `none`
  })], YB.prototype, `pendingUploads`, void 0),
  M([og( () => XL)], YB.prototype, `notifications`, void 0),
  M([fg( () => J)], YB.prototype, `subscribers`, void 0),
  M([z( () => UB, {
      index: `commentId`,
      canSkipHydration: e => !e.getTrait(dy.hasCustomerNeeds)
  })], YB.prototype, `needs`, void 0),
  M([z( () => xj, {
      index: `sourceCommentId`
  })], YB.prototype, `createdAgentActivities`, void 0),
  M([R({
      persistence: `none`
  })], YB.prototype, `traits`, void 0),
  M([z( () => Dj, {
      index: `commentId`,
      canSkipHydration: e => !e.getTrait(dy.hasAgentSession)
  })], YB.prototype, `agentSessions`, void 0),
  M([z( () => Dj, {
      index: `sourceCommentId`,
      canSkipHydration: e => !e.getTrait(dy.hasSpawnedAgentSessions)
  })], YB.prototype, `spawnedAgentSessions`, void 0),
  M([z( () => GB, {
      index: `commentId`,
      canSkipHydration: e => !e.getTrait(dy.hasAiPromptProgresses)
  })], YB.prototype, `aiPromptProgresses`, void 0),
  M([L], YB.prototype, `threadComments`, null),
  M([L], YB.prototype, `root`, null),
  M([L], YB.prototype, `threadNotifications`, null),
  M([L], YB.prototype, `hasEmojiOnlyBody`, null),
  M([I], YB.prototype, `markNotificationsAsRead`, null),
  M([I], YB.prototype, `resolve`, null),
  M([I], YB.prototype, `unresolve`, null),
  M([L], YB.prototype, `bodyMarkdown`, null),
  M([L], YB.prototype, `bodyTextContent`, null),
  M([L], YB.prototype, `notificationText`, null),
  M([I], YB, `create`, null),
  YB = qB = M([mg(`Comment`)], YB)
}
));
function Lle(e, t) {
  return gn(3e4),
  Tr(e, {
      short: !0,
      ...t
  })
}
function ZB(e, t) {
  return gn(3e4),
  Tr(e, {
      short: !1,
      ...t
  })
}
function QB(e) {
  let t = e instanceof Date ? e : e.toLocalDate();
  return hV ??= new Intl.DateTimeFormat(`en-US`,{
      day: `numeric`,
      month: `short`,
      year: `numeric`
  }),
  hV.format(t)
}
function $B(e) {
  let t = e instanceof Date ? e : e.toLocalDate();
  return gV ??= new Intl.DateTimeFormat(`en-US`,{
      day: `numeric`,
      month: `short`
  }),
  gV.format(t)
}
function Rle(e) {
  return _V ??= new Intl.DateTimeFormat(void 0,{
      day: `numeric`,
      month: `numeric`,
      year: `numeric`
  }),
  _V.format(e)
}
function eV(e, t) {
  let n = t?.alwaysYear === !0 ? QB(e) : mV(e)
    , r = t?.omitSeconds === !0 ? SV(e) : bV(e);
  return `${t?.includeDayOfWeek ? `${TV(e, {
      short: !0
  })} ` : ``}${n}, ${r}`
}
function zle(e) {
  let {min: t=1, max: n} = e;
  return Math.floor(Math.random() * (n - t + 1) + t)
}
function Ble(e=navigator.language) {
  let t = new Intl.Locale(e);
  if (`hourCycles`in t) {
      let e = t.hourCycles;
      return e ? e.some(e => e === `h23` || e === `h24`) : !1
  }
  let n = new Intl.DateTimeFormat(e,{
      hour: `numeric`
  }).format();
  return Number.isInteger(Number(n))
}
function tV(e) {
  return e.getFullYear() === new Date().getFullYear()
}
var nV, rV, iV, aV, oV, sV, cV, lV, uV, dV, fV, pV, mV, hV, gV, _V, vV, yV, bV, xV, SV, CV, wV, TV, EV, DV = t(( () => {
  nt(),
  Pe(),
  _n(),
  Yr(),
  nV = Ble(),
  rV = nV ? `H:mm` : `h:mm a`,
  oV = (e, t) => {
      gn(3e4);
      let n = new Date;
      if (Math.abs($e(We(n), e)) > 6)
          if (t?.withWeekday) {
              let t = SV(e)
                , n = ``;
              return tV(e) ? (aV ??= new Intl.DateTimeFormat(`en-US`,{
                  month: `long`,
                  weekday: `long`,
                  day: `numeric`
              }),
              n = aV.format(e)) : (iV ??= new Intl.DateTimeFormat(`en-US`,{
                  year: `numeric`,
                  month: `long`,
                  weekday: `long`,
                  day: `numeric`
              }),
              n = iV.format(e)),
              `${n}, ${t}`
          } else
              return eV(e, {
                  omitSeconds: !0
              });
      else
          return Ie(e, n, {
              locale: cV
          })
  }
  ,
  sV = {
      lastWeek: `'last' eeee 'at' ${rV}`,
      yesterday: `'yesterday at' ${rV}`,
      today: `'today at' ${rV}`,
      tomorrow: `'tomorrow at' ${rV}`,
      nextWeek: `eeee 'at' ${rV}`,
      other: `P`
  },
  cV = {
      ...Ke,
      formatRelative: e => sV[e]
  },
  lV = e => {
      gn(3e4);
      let t = new Date;
      return Math.abs($e(We(t), e)) > 6 ? mV(e) : Ie(e, t, {
          locale: dV
      })
  }
  ,
  uV = {
      lastWeek: `'last' eeee`,
      yesterday: `'yesterday'`,
      today: `'today'`,
      tomorrow: `'tomorrow'`,
      nextWeek: `eeee`,
      other: `P`
  },
  dV = {
      ...Ke,
      formatRelative: e => uV[e]
  },
  pV = e => {
      let t = e instanceof Date ? e : e.toLocalDate()
        , n = Ne(t, it(ot(new Date), {
          years: 1
      }))
        , r = je(t, tt(new Date, {
          years: 1
      }));
      return n || r ? (fV ??= new Intl.DateTimeFormat(`en-US`,{
          month: `short`,
          year: `numeric`
      }),
      fV.format(t)) : $B(t)
  }
  ,
  mV = xr,
  vV = (e, t) => eV(e, {
      omitSeconds: t?.omitSeconds,
      alwaysYear: !0,
      includeDayOfWeek: t?.includeDayOfWeek
  }),
  bV = e => (yV ??= new Intl.DateTimeFormat(void 0,{
      hour: `numeric`,
      minute: `numeric`,
      second: `numeric`
  }),
  yV.format(e)),
  SV = e => (xV ??= new Intl.DateTimeFormat(void 0,{
      hour: `numeric`,
      minute: `numeric`
  }),
  xV.format(e)),
  wV = e => (CV ??= new Intl.DateTimeFormat(void 0,{
      day: `numeric`
  }),
  CV.format(e)),
  TV = (e, t) => Ge(e, t?.short ? `EEE` : `EEEE`),
  EV = e => Ge(e, `MMMM`)
}
)), OV, kV, AV = t(( () => {
  Fc(),
  Xs(),
  Wv(),
  Ul(),
  zoe(),
  cc(),
  pi(),
  Lq(),
  XB(),
  GU(),
  V(),
  F(),
  om(),
  DV(),
  Sm(),
  ws(),
  Zk(),
  N(),
  kV = class extends Yh {
      static #e = OV = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static #r = this.partialPreloadForTeam = am.firstPriority;
      static createFromDraftAttachment(e, t) {
          let n = OV.create({
              url: e.url,
              title: e.title,
              issue: t
          });
          return n.save(),
          n
      }
      get sourceType() {
          return Pc.getSourceType(this)
      }
      get isPullRequest() {
          return (this.sourceType === T.gitlab || this.sourceType === T.github) && !!this.source && `pullRequestId`in this.source
      }
      get isSentryIssue() {
          return this.sourceType === T.sentry
      }
      get isJiraIssue() {
          return this.sourceType === T.jira
      }
      get isAsksThread() {
          if (this.source?.type !== T.slack)
              return !1;
          let e = this.source?.syncedCommentId;
          return !!e && !!this.store.findById(YB, e)?.isAsksThread
      }
      get syncErrorCommentId() {
          if (this?.source?.type === T.jira)
              return this.source?.syncErrorCommentId
      }
      get isSynced() {
          return this.isSyncedGithubIssue || this.isSyncedJiraIssue || this.isSyncedSlackThread
      }
      get isSyncedJiraIssue() {
          let e = this.issue.value?.team.organization.integrations.find(e => e.service === T.jira);
          return !!(this.isJiraIssue && this.issue.value?.externalEntityRelations.find(t => t.externalEntityType === Vl.jiraIssue && !!e?.settings.jira?.projectMapping?.some(e => e.jiraProjectId === t.metadata?.jiraIssueMetadata?.projectId)))
      }
      get isSyncedGithubIssue() {
          let e = Uv.GitHub.parseIssueUrl(this.url);
          if (!e)
              return !1;
          let {owner: t, repo: n, number: r} = e;
          return !!(this.isGithubIssue && this.issue.value?.externalEntityRelations.find(e => e.externalEntityType === Vl.githubIssue && e.metadata?.githubIssueMetadata?.number === r && e.metadata?.githubIssueMetadata?.owner === t && e.metadata?.githubIssueMetadata?.repo === n))
      }
      get isGithubIssue() {
          return this.sourceType === T.github && !this.isPullRequest
      }
      get isGithubCommit() {
          return this.sourceType === T.githubCommit
      }
      get isEmailIntake() {
          return this.sourceType === T.email
      }
      get pullRequestAdapter() {
          return new Xk(this)
      }
      get pullRequestAttachment() {
          if (this?.isPullRequest)
              return this.metadata
      }
      get pullRequestEntity() {
          let e = this.store.user.settings
            , t = this.pullRequestAttachment;
          if (!(!t || !e.showReviewsInbox))
              return this.issue.value?.linkedPullRequests.find(e => e.repository.owner === t.repoLogin && e.repository.name === t.repoName && e.number === t.number)
      }
      static create(e) {
          let {url: t, title: n, issue: r} = e
            , i = OV.createEmpty();
          i.issue = vm.wrap(r),
          i.url = t,
          i.title = n,
          i.metadata = {
              title: n,
              messages: []
          };
          let a = r.team.organization.integrations.filter(e => Uv.AttachmentLinkIntegrations.find(t => t === e.service) !== void 0)
            , o = a.reduce( (e, t) => (t.service === T.gitlab && (e[t.service] = t.settings?.gitLab?.url),
          e), {})
            , s = Uv.findIntegrationMatches(t, a.map(e => e.service), o);
          if (s?.match) {
              let {match: e, integrationType: t} = s;
              switch (t) {
              case T.discord:
                  let[n,r] = e;
                  i.source = {
                      type: T.discord,
                      channelId: n,
                      messageId: r
                  };
                  break;
              case T.front:
                  i.source = {
                      type: T.front,
                      conversationId: e
                  };
                  break;
              case T.intercom:
                  i.source = {
                      type: T.intercom
                  };
                  break;
              case T.zendesk:
                  i.source = {
                      type: T.zendesk
                  };
                  break;
              case T.gitlab:
                  i.source = {
                      type: t,
                      pullRequestId: String(e.number)
                  };
                  break;
              case T.github:
                  s.type === `pr` ? i.source = {
                      type: t,
                      pullRequestId: String(e.number)
                  } : i.source = {
                      type: t
                  };
                  break;
              case T.jira:
                  i.source = {
                      type: T.jira
                  };
                  break;
              default:
                  break
              }
          }
          return i
      }
      get strippedFirstAttachmentMessageBody() {
          return Pc.getStrippedFirstAttachmentMessageBody(this)
      }
      createMutation(e) {
          let t;
          function n(e, t) {
              return `${e}(${Object.entries(t).map( ([e,t]) => `${e}: ${JSON.stringify(t)}`).join(`, `)}) { lastSyncId }`
          }
          let r = this.issue.id;
          switch (this.source?.type) {
          case T.discord:
              t = n(`attachmentLinkDiscord`, {
                  id: this.id,
                  messageId: this.source.messageId,
                  channelId: this.source.channelId,
                  url: this.url,
                  issueId: r,
                  title: this.title
              });
              break;
          case T.front:
              {
                  let e = this.source.conversationId;
                  if (!e)
                      throw Error(`invariant: expected conversationId for front`);
                  t = n(`attachmentLinkFront`, {
                      id: this.id,
                      issueId: r,
                      conversationId: e,
                      title: this.title
                  });
                  break
              }
          case T.zendesk:
              {
                  let e = Uv.Zendesk.parseTicketUrl(this.url);
                  if (!e)
                      throw Error(`invariant: expected ticketId for Zendesk`);
                  t = n(`attachmentLinkZendesk`, {
                      id: this.id,
                      ticketId: e,
                      issueId: r,
                      title: this.title
                  });
                  break
              }
          case T.intercom:
              {
                  let {conversationId: e, partId: i} = Uv.Intercom.parseConversationUrl(this.url) ?? {};
                  if (!e)
                      throw Error(`invariant: expected conversationId for Intercom`);
                  let a = {
                      id: this.id,
                      conversationId: e,
                      partId: i ?? ``,
                      issueId: r,
                      title: this.title
                  };
                  t = n(`attachmentLinkIntercom`, i ? {
                      ...a,
                      partId: i
                  } : a);
                  break
              }
          case T.github:
              if (Uv.GitHub.parsePullRequestUrl(this.url)) {
                  t = n(`attachmentLinkGitHubPR`, {
                      id: this.id,
                      issueId: r,
                      title: this.title,
                      url: this.url
                  });
                  break
              }
              if (Uv.GitHub.parseIssueUrl(this.url)) {
                  t = n(`attachmentLinkGitHubIssue`, {
                      id: this.id,
                      issueId: r,
                      url: this.url
                  });
                  break
              }
              throw Error(`invariant: expected owner, repo and number for GitHub`);
          case T.jira:
              {
                  let e = Uv.jira.parseIssueUrl(this.url);
                  if (!e)
                      throw Error(`invariant: expected issue key for Jira`);
                  t = n(`attachmentLinkJiraIssue`, {
                      id: this.id,
                      jiraIssueId: e,
                      issueId: r,
                      url: this.url
                  });
                  break
              }
          default:
              t = n(`attachmentLinkURL`, {
                  url: this.url,
                  title: this.title,
                  issueId: r,
                  id: this.id
              });
              break
          }
          return this.observePropertyChanges(),
          t
      }
      get isSyncedSlackThread() {
          return !!this.syncedSlackComment()
      }
      syncedSlackComment() {
          if (!ui.isEnabled(ui.slackIntegrationOptOutOfReadingMessageHistory)) {
              if (!this.issue.value) {
                  w.warning(`Attachment has no issue`, {
                      attachmentId: this.id
                  });
                  return
              }
              return this.issue.value.comments.transientlyHydratedElements.find(e => e.isRootSlackSyncedComment && e.sourceMetadata?.slackSyncMetadata?.messageUrl === this.url && !e.isRootUnsyncedSlackComment)
          }
      }
      get subtitleWithMessage() {
          return this.sourceType === T.slack || !this.subtitle ? this.strippedFirstAttachmentMessageBody : this.subtitle
      }
      formatSubtitle() {
          let e = this.subtitleWithMessage;
          if (!e)
              return e;
          let t = (e, t, n) => {
              let r = this.metadata[t];
              return r ? n(new Date(r)) ?? e : e
          }
          ;
          return e.replace(/{(\w+?)__since}/gm, (e, n) => t(e, n, ZB)).replace(/{(\w+?)__relativeTimestamp}/gm, (e, n) => t(e, n, oV))
      }
      getTrait(e) {
          return sc(this.traits, e)
      }
  }
  ,
  M([R({
      default: ``
  })], kV.prototype, `title`, void 0),
  M([R()], kV.prototype, `subtitle`, void 0),
  M([R({
      persistence: `createOnly`,
      default: ``
  })], kV.prototype, `url`, void 0),
  M([R({
      default: {}
  })], kV.prototype, `metadata`, void 0),
  M([R({
      persistence: `none`
  })], kV.prototype, `source`, void 0),
  M([R({
      persistence: `createOnly`,
      default: !1
  })], kV.prototype, `groupBySource`, void 0),
  M([sg( () => Y, `attachments`, {
      persistence: `none`,
      optional: !1,
      nullable: !1,
      indexed: !0,
      trait: `useForPartialIndex`
  })], kV.prototype, `issue`, void 0),
  M([dg({
      nullable: !0
  })], kV.prototype, `comment`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0
  })], kV.prototype, `creator`, void 0),
  M([dg({
      nullable: !0,
      canSkipHydration: e => e.getTrait(uy.hasCustomerNeed) === !1
  })], kV.prototype, `need`, void 0),
  M([R({
      persistence: `none`
  })], kV.prototype, `sourceMetadata`, void 0),
  M([sg( () => Y, `formerAttachments`, {
      nullable: !0,
      indexed: !0,
      persistence: `none`
  })], kV.prototype, `originalIssue`, void 0),
  M([R({
      persistence: `none`
  })], kV.prototype, `traits`, void 0),
  M([L], kV.prototype, `pullRequestEntity`, null),
  M([L], kV.prototype, `subtitleWithMessage`, null),
  kV = OV = M([mg(`Attachment`)], kV)
}
)), jV, MV = t(( () => {
  Bj(),
  pk(),
  iU(),
  UM(),
  V(),
  F(),
  om(),
  lj(),
  mH(),
  eu(),
  Uj(),
  N(),
  jV = class extends qh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular;
      get popularity() {
          let e = (this.projectUpdate || this.initiativeUpdate || this.post)?.value;
          return uk.getPopularityScore({
              createdAt: this.createdAt,
              commentsCount: e?.numberOfComments ?? 0,
              reactionData: e?.reactionData ?? []
          })
      }
      get updateType() {
          if (this.projectUpdate)
              return fk.project;
          if (this.initiativeUpdate)
              return fk.initiative;
          if (this.post?.value)
              return {
                  [zj.summary]: fk.summary,
                  [zj.update]: fk.team
              }[this.post.value.postType]
      }
      get author() {
          return this.post?.value?.creator ?? this.initiativeUpdate?.value?.user ?? this.projectUpdate?.value?.user
      }
      get relatedInitiatives() {
          let e = [this.initiativeUpdate?.value?.initiative, ...this.projectUpdate?.value?.project.initiatives ?? []].concrete()
            , t = new Set;
          for (let n of e) {
              t.add(n);
              for (let e of n.ancestors)
                  t.add(e)
          }
          return Array.from(t)
      }
      get relatedTeams() {
          return [this.post?.value?.team, ...this.projectUpdate?.value?.project.accessibleTeams.elements ?? []].concrete()
      }
      get updateHealth() {
          return this.initiativeUpdate?.value?.health ?? this.projectUpdate?.value?.health
      }
      matchInlineFind(e) {
          let t = []
            , n = this.projectUpdate?.value || this.initiativeUpdate?.value || this.post?.value;
          return n instanceof HM && (t = [n.project.name, n.bodyMarkdown, n.user?.displayName]),
          n instanceof cj && (t = [n.initiative.name, n.bodyMarkdown, n.user?.name, n.user?.displayName]),
          n instanceof Hj && (t = [n.title, n.body, n.creator?.name, n.creator?.displayName]),
          $l(t.concrete().join(` `)).toLowerCase().indexOf(e.toLowerCase()) !== -1
      }
  }
  ,
  M([lg( () => HM, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], jV.prototype, `projectUpdate`, void 0),
  M([lg( () => cj, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], jV.prototype, `initiativeUpdate`, void 0),
  M([lg( () => Hj, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], jV.prototype, `post`, void 0),
  M([B( () => q, `feed`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], jV.prototype, `organization`, void 0),
  M([B( () => K, `feed`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], jV.prototype, `team`, void 0),
  M([L], jV.prototype, `popularity`, null),
  M([L], jV.prototype, `updateType`, null),
  M([L], jV.prototype, `author`, null),
  M([L], jV.prototype, `relatedInitiatives`, null),
  M([L], jV.prototype, `relatedTeams`, null),
  M([L], jV.prototype, `updateHealth`, null),
  jV = M([mg(`FeedItem`)], jV)
}
));
function NV(e) {
  return !e.isClone
}
var PV, FV = t(( () => {
  _H(),
  bH(),
  Lq(),
  kH(),
  iU(),
  iz(),
  oM(),
  mH(),
  GU(),
  F(),
  Vm(),
  fz(),
  Dk(),
  sk(),
  V(),
  Xp(),
  N(),
  PV = class extends qh {
      static get modelName() {
          return `PredefinedView`
      }
      constructor(e=!0) {
          super(e),
          this.modelName = `PredefinedView`
      }
      get issues() {
          return this.unfilteredIssues.filter([NV, this.filter])
      }
      get unfilteredIssues() {
          let e = this.group;
          return e instanceof J ? e.assignedIssues : e instanceof OH ? e.allIssuesInherited : e instanceof K || e instanceof gH ? e.issuesInherited : e instanceof aM || e instanceof G ? e.issues : `type`in e && e.type === `state` ? new ok(Y,e.states.map(e => e.issues)) : Bm.of(Y, [])
      }
      get projects() {
          return this.unfilteredProjects.filter([NV, this.projectFilter])
      }
      get unfilteredProjects() {
          let e = this.group;
          return e instanceof G ? Bm.of(G, [e]) : e instanceof K ? e.projects : e instanceof Ek ? e.allProjects : Bm.of(G, [])
      }
      get teams() {
          let e = this.group;
          return e instanceof J ? e.organization.accessibleTeams.elements : e instanceof q ? e.accessibleTeams.elements : e instanceof G ? this.team ? [this.team] : e.accessibleTeams.elements : e instanceof K ? e.withAccessibleDescendants : e instanceof gH ? e.team.withAccessibleDescendants : e instanceof aM ? e.pipeline.value?.organization.accessibleTeams.elements ?? [] : `type`in e && e.type === `state` ? e.team.withAccessibleDescendants : e instanceof OH ? e.team ? [e.team] : e.organization ? e.organization.accessibleTeams.elements : [] : this.group instanceof Ek ? this.group.organization.accessibleTeams.elements : []
      }
      get cycles() {
          if (this.group instanceof gH)
              return [this.group]
      }
      get stateFilter() {
          if (`type`in this.group && this.group.type === `state`) {
              let e = this.group.states;
              return t => e.includes(t)
          }
          let e = this.rawFilter.and
            , t = this.rawFilter.state || e?.find(e => e.state)?.state || void 0;
          if (t !== void 0)
              return e => dz.filterElement(t, e)
      }
      canBeFavorited() {
          return this.team != null && this.favoriteViewType != null
      }
      toggleFavorite() {
          let e = this.favorite;
          if (e)
              return e.delete(),
              !1;
          {
              let e = yH.create({
                  predefinedViewTeam: this.team,
                  predefinedViewType: this.favoriteViewType
              });
              return e.save(!0),
              e
          }
      }
      hydrateIssues() {
          let e = this.group, t;
          if (e instanceof J)
              t = e.assignedIssues.hydrate();
          else if (e instanceof G)
              t = e.issues.hydrate();
          else if (e instanceof K)
              return e.withAccessibleDescendants.map(e => e.issues.hydrate());
          else if (e instanceof OH) {
              if (e.children.length)
                  return [e, ...e.children.elements].map(e => e.issues.hydrate());
              t = e.issues.hydrate()
          } else if (e instanceof gH)
              t = e.issuesInherited.hydrate();
          else if (e instanceof aM)
              t = e.issueToReleases.hydrate();
          else if (`type`in e && e.type === `state`)
              return e.states.map(e => e.issues.hydrate());
          return [t ?? Yp]
      }
      hydrateProjects() {
          let e = this.group, t;
          return e instanceof G ? t = e.hydrate() : e instanceof Ek && (t = e.projects.hydrate()),
          [t ?? Yp]
      }
      get favorite() {
          return this.team && this.favoriteViewType && this.store.user.favorites.find(e => e.predefinedViewTeam === this.team && this.favoriteViewType === e.predefinedViewType)
      }
      get organization() {
          let e = this.group;
          return e instanceof q ? e : e instanceof gH ? e.team.organization : e instanceof aM ? e.pipeline.value.organization : `type`in e && e.type === `state` ? e.team.organization : e.organization
      }
      get rawFilter() {
          return this.filter?.filter
      }
      get rawProjectFilter() {
          return this.projectFilter?.filter
      }
      initialize({filter: e={}, projectFilter: t={}, group: n, team: r, favoriteViewType: i}) {
          this.group = n,
          this.team = r,
          this.favoriteViewType = i,
          this.filter = new dz({
              filter: e
          }),
          this.projectFilter = new dz({
              filter: t
          }),
          this.observePropertyChanges()
      }
  }
  ,
  M([L], PV.prototype, `issues`, null),
  M([L], PV.prototype, `unfilteredIssues`, null),
  M([L], PV.prototype, `projects`, null),
  M([L], PV.prototype, `unfilteredProjects`, null)
}
)), IV, LV, RV, zV, BV, VV, HV, UV, WV, GV, KV, qV, JV, YV, XV, ZV, QV = t(( () => {
  Hv(),
  gc(),
  Bu(),
  Lq(),
  GU(),
  Vm(),
  V(),
  rk(),
  FV(),
  N(),
  IV = class e extends PV {
      static create({team: t}) {
          let n = e.createEmpty();
          return n.initialize({
              favoriteViewType: Vv.allIssues,
              team: t,
              group: t
          }),
          n
      }
  }
  ,
  LV = class e extends PV {
      static create({team: t}) {
          let n = e.createEmpty();
          return n.initialize({
              favoriteViewType: Vv.activeIssues,
              team: t,
              group: {
                  type: `state`,
                  team: t,
                  states: t.withAccessibleDescendants.flatMap(e => e.activeStates.elements)
              }
          }),
          n
      }
  }
  ,
  RV = class e extends PV {
      static create({team: t}) {
          let n = e.createEmpty();
          return n.initialize({
              favoriteViewType: Vv.backlog,
              team: t,
              group: {
                  type: `state`,
                  team: t,
                  states: t.withAccessibleDescendants.flatMap(e => e.backlogStates.elements)
              }
          }),
          n
      }
  }
  ,
  zV = class e extends PV {
      static create({team: t}) {
          let n = e.createEmpty();
          return n.initialize({
              favoriteViewType: Vv.triage,
              team: t,
              group: {
                  type: `state`,
                  team: t,
                  states: t.triageIssueState ? [t.triageIssueState] : []
              }
          }),
          n
      }
      hydrateIssues() {
          let e = super.hydrateIssues();
          if (`type`in this.group && this.group.type === `state`) {
              let t = this.group.states[0];
              if (t)
                  return [...e, t.issues.hydrate(), ...t.issues.map(e => e.relations.hydrate()), ...t.issues.map(e => e.inverseRelations.hydrate())]
          }
          return e
      }
  }
  ,
  BV = class e extends PV {
      static create({cycle: t}) {
          let n = e.createEmpty();
          return n.initialize({
              filter: {
                  state: {
                      type: {
                          in: [E.unstarted, E.started, E.completed, E.canceled]
                      }
                  }
              },
              group: t,
              team: t.team
          }),
          n
      }
  }
  ,
  VV = class e extends PV {
      static create({release: t}) {
          let n = e.createEmpty();
          return n.initialize({
              group: t
          }),
          n
      }
  }
  ,
  HV = class e extends PV {
      static create({cycle: t}) {
          let n = e.createEmpty();
          return n.cycle = t,
          n.initialize({
              group: t,
              team: t.team
          }),
          n
      }
      get issues() {
          return new nk(Y,[this.cycle.issuesInherited, this.cycle.allUncompletedIssuesUponClose],{
              dedupe: !0
          })
      }
      get teams() {
          let e = super.teams
            , t = new Set(e);
          for (let e of this.cycle.allUncompletedIssuesUponClose)
              t.has(e.team) || t.add(e.team);
          return Array.from(t)
      }
  }
  ,
  M([L], HV.prototype, `issues`, null),
  M([L], HV.prototype, `teams`, null),
  UV = class e extends PV {
      static create({label: t}) {
          let n = e.createEmpty();
          return n.initialize({
              group: t
          }),
          n
      }
  }
  ,
  WV = class e extends PV {
      static create({label: t}) {
          let n = e.createEmpty();
          return n.initialize({
              group: t
          }),
          n
      }
  }
  ,
  GV = class e extends PV {
      static create(t) {
          let n = new e;
          return n.initialize({
              group: t
          }),
          n
      }
  }
  ,
  KV = class e extends PV {
      static create({user: t, viewType: n}) {
          let r = e.createEmpty();
          return r.initialize({
              group: t
          }),
          r.viewType = n,
          r
      }
      get unfilteredIssues() {
          if (!(this.group instanceof J))
              throw Error(`group should be User model`);
          return this.viewType === k.userProfileCreatedByUser ? this.group.createdIssues : new nk(Y,[this.group.assignedIssues, this.group.delegatedIssues],{
              dedupe: !0
          })
      }
      hydrateIssues() {
          if (!(this.group instanceof J))
              throw Error(`group should be User model`);
          return this.viewType === k.userProfileCreatedByUser ? [this.group.createdIssues.hydrate()] : [this.group.assignedIssues.hydrate(), this.group.delegatedIssues.hydrate()]
      }
  }
  ,
  M([L], KV.prototype, `unfilteredIssues`, null),
  qV = class e extends PV {
      static create({user: t}) {
          let n = e.createEmpty();
          return n.initialize({
              group: t
          }),
          n
      }
      get issues() {
          if (!(this.group instanceof J))
              throw Error(`group should be User model`);
          return this.group.subscribedIssues.filter(this.filter)
      }
      hydrateIssues() {
          if (!(this.group instanceof J))
              throw Error(`group should be User model`);
          return [this.group.subscribedIssues.hydrate()]
      }
  }
  ,
  JV = class e extends PV {
      static create({user: t}) {
          let n = e.createEmpty();
          return n.initialize({
              group: t
          }),
          n
      }
      get issues() {
          return Bm.of(Y, this.group.activities.groupBy(`issueId`).groups.map(e => e.collection.first?.issue?.value).concrete())
      }
      hydrateIssues() {
          return this.hydrateIssuesPromises ||= this.group.activities.map(e => e.hydrate()),
          this.hydrateIssuesPromises
      }
  }
  ,
  M([L], JV.prototype, `issues`, null),
  YV = class e extends PV {
      static create({user: t}) {
          let n = e.createEmpty();
          return n.initialize({
              group: t
          }),
          n
      }
      get issues() {
          return this.group.createdIssues.filter(this.filter)
      }
      hydrateIssues() {
          return [this.group.createdIssues.hydrate()]
      }
  }
  ,
  XV = class e extends PV {
      static create({user: t}) {
          let n = e.createEmpty();
          return n.initialize({
              group: t
          }),
          n
      }
  }
  ,
  ZV = class e extends PV {
      static create({team: t}) {
          let n = e.createEmpty();
          return n.initialize({
              favoriteViewType: Vv.projects,
              team: t,
              group: t
          }),
          n
      }
  }
}
));
async function $V(e, t, n=!0) {
  let r = Ut`
  query ($teamId: String!) {
    team(id: $teamId) {
      issueCount(includeArchived: ${n})
    }
  }
`;
  return e.query(r, {
      teamId: t
  })
}
var Vle = t(( () => {
  Wt()
}
)), eH, tH = t(( () => {
  V(),
  F(),
  mH(),
  N(),
  eH = class extends Yh {
  }
  ,
  M([R({
      default: ``
  })], eH.prototype, `name`, void 0),
  M([B( () => K, `keys`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], eH.prototype, `team`, void 0),
  eH = M([mg(`TeamKey`)], eH)
}
)), nH, rH = t(( () => {
  mH(),
  GU(),
  V(),
  F(),
  N(),
  nH = class extends Yh {
  }
  ,
  M([B( () => K, `memberships`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], nH.prototype, `team`, void 0),
  M([B( () => J, `teamMemberships`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], nH.prototype, `user`, void 0),
  M([R({
      default: !1
  })], nH.prototype, `owner`, void 0),
  M([R({
      default: 0
  })], nH.prototype, `sortOrder`, void 0),
  nH = M([mg(`TeamMembership`)], nH)
}
)), iH, aH = t(( () => {
  zn(),
  (function(e) {
      e.maxLabelLength = 64,
      e.signatureKeyLength = 44,
      e.signatureKeyPrefix = `lin_wh_`,
      e.maxUrlLength = 1e3,
      e.maxSecretLength = 256,
      e.disallowedHosts = /((^127|^10)(\.[0-9]{1,3}){3})|(^((172\.1[6-9])|(172\.2[0-9])|(172\.3[0-1]))(\.[0-9]{1,3}){2})|(^192\.168(\.[0-9]{1,3}){2})|(^(.*\.)?linear\.app)/i;
      let t = function(e) {
          return e.Attachment = `Attachment`,
          e.AuditEntry = `AuditEntry`,
          e.Comment = `Comment`,
          e.Customer = `Customer`,
          e.CustomerNeed = `CustomerNeed`,
          e.Cycle = `Cycle`,
          e.Document = `Document`,
          e.Initiative = `Initiative`,
          e.InitiativeUpdate = `InitiativeUpdate`,
          e.Issue = `Issue`,
          e.IssueLabel = `IssueLabel`,
          e.ProjectLabel = `ProjectLabel`,
          e.Project = `Project`,
          e.ProjectUpdate = `ProjectUpdate`,
          e.Reaction = `Reaction`,
          e.User = `User`,
          e
      }({});
      e.EntityResourceType = t;
      let n = function(e) {
          return e.IssueSLA = `IssueSLA`,
          e
      }({});
      e.CustomResourceType = n;
      let r = function(e) {
          return e.AgentSessionEvent = `AgentSessionEvent`,
          e.AppUserNotification = `AppUserNotification`,
          e.PermissionChange = `PermissionChange`,
          e.OAuthAuthorization = `OAuthAuthorization`,
          e
      }({});
      e.CustomOauthAppResourceType = r;
      let i = e.labelForResourceType = e => {
          switch (e) {
          case t.Issue:
              return `Issues`;
          case t.Comment:
              return `Comments`;
          case t.Document:
              return `Documents`;
          case t.Attachment:
              return `Issue attachments`;
          case t.Reaction:
              return `Emoji reactions`;
          case t.IssueLabel:
              return `Issue Labels`;
          case t.ProjectLabel:
              return `Project Labels`;
          case t.Project:
              return `Projects`;
          case t.ProjectUpdate:
              return `Project updates`;
          case t.Cycle:
              return `Cycles`;
          case t.User:
              return `Users`;
          case n.IssueSLA:
              return `Issue SLA`;
          case t.Customer:
              return `Customers`;
          case t.CustomerNeed:
              return `Customer requests`;
          case t.Initiative:
              return `Initiatives`;
          case t.InitiativeUpdate:
              return `Initiative updates`;
          case t.AuditEntry:
              return `Audit logs`;
          case r.AppUserNotification:
              return `Inbox notifications`;
          case r.PermissionChange:
              return `Permission changes`;
          case r.AgentSessionEvent:
              return `Agent session events`;
          case r.OAuthAuthorization:
              return `OAuth authorization events`;
          default:
              throw new Rn(e)
          }
      }
        , a = (e, t) => i(e) < i(t) ? -1 : 1
        , o = e.entityResourceTypes = Object.values(t).sort(a)
        , s = e.customResourceTypes = Object.values(n).sort(a)
        , c = e.customOauthAppResourceTypes = Object.values(r).sort(a);
      e.specialWebhookTypes = [t.AuditEntry],
      e.resourceTypes = [...o, ...s, ...c].sort(a),
      e.nonOAuthResourceTypes = [...o, ...s].sort(a)
  }
  )(iH ||= {})
}
)), oH, sH = t(( () => {
  aH(),
  iU(),
  mH(),
  GU(),
  V(),
  F(),
  om(),
  N(),
  oH = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.full;
      get isAuditLogWebhook() {
          return this.resourceTypes.length === 1 && this.resourceTypes[0] === iH.EntityResourceType.AuditEntry
      }
  }
  ,
  M([R()], oH.prototype, `label`, void 0),
  M([R({
      default: ``
  })], oH.prototype, `url`, void 0),
  M([R({
      default: !0
  })], oH.prototype, `enabled`, void 0),
  M([R({
      isVirtual: !0
  })], oH.prototype, `secret`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], oH.prototype, `creator`, void 0),
  M([R({
      default: [iH.EntityResourceType.Issue]
  })], oH.prototype, `resourceTypes`, void 0),
  M([B( () => q, `webhooks`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], oH.prototype, `organization`, void 0),
  M([R({
      persistence: `createOnly`,
      default: !1
  })], oH.prototype, `allPublicTeams`, void 0),
  M([B( () => K, `webhooks`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], oH.prototype, `team`, void 0),
  oH = M([mg(`Webhook`)], oH)
}
)), cH, lH = t(( () => {
  mH(),
  GU(),
  F(),
  V(),
  Ih(),
  N(),
  cH = class extends Yh {
      get isTeamWorkflow() {
          return !!this.team
      }
  }
  ,
  M([R({
      default: ``
  })], cH.prototype, `name`, void 0),
  M([R()], cH.prototype, `description`, void 0),
  M([R({
      default: !1
  })], cH.prototype, `enabled`, void 0),
  M([R({
      serializer: Fh,
      default: []
  })], cH.prototype, `activities`, void 0),
  M([R({
      serializer: Mh
  })], cH.prototype, `schedule`, void 0),
  M([B( () => K, `workflowCronJobDefinitions`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], cH.prototype, `team`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], cH.prototype, `creator`, void 0),
  M([R({
      default: 0
  })], cH.prototype, `sortOrder`, void 0),
  cH = M([mg(`WorkflowCronJobDefinition`)], cH)
}
)), uH, dH = t(( () => {
  up(),
  mH(),
  GU(),
  F(),
  V(),
  Ih(),
  iU(),
  N(),
  uH = class extends Yh {
      get isTeamWorkflow() {
          return !!this.team
      }
  }
  ,
  M([R({
      default: ``
  })], uH.prototype, `name`, void 0),
  M([R()], uH.prototype, `groupName`, void 0),
  M([R()], uH.prototype, `description`, void 0),
  M([R({
      enum: op,
      persistence: `createOnly`,
      default: op.custom
  })], uH.prototype, `type`, void 0),
  M([R({
      enum: sp,
      persistence: `createOnly`,
      default: sp.entityCreated
  })], uH.prototype, `trigger`, void 0),
  M([R({
      enum: cp,
      persistence: `createOnly`,
      default: cp.issue
  })], uH.prototype, `triggerType`, void 0),
  M([R({
      serializer: Fh
  })], uH.prototype, `conditions`, void 0),
  M([R({
      default: !0
  })], uH.prototype, `enabled`, void 0),
  M([R({
      serializer: Fh,
      default: []
  })], uH.prototype, `activities`, void 0),
  M([R({
      serializer: Mh,
      persistence: `none`
  })], uH.prototype, `schedule`, void 0),
  M([B( () => q, `allWorkflowDefinitions`, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], uH.prototype, `organization`, void 0),
  M([B( () => K, `workflowDefinitions`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], uH.prototype, `team`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], uH.prototype, `creator`, void 0),
  M([R({
      default: 0
  })], uH.prototype, `sortOrder`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0,
      indexed: !0
  })], uH.prototype, `lastUpdatedBy`, void 0),
  M([R({
      persistence: `none`
  })], uH.prototype, `lastExecutedAt`, void 0),
  uH = M([mg(`WorkflowDefinition`)], uH)
}
)), fH, pH, K, mH = t(( () => {
  fH = e(Gt(), 1),
  Un(),
  zd(),
  Vd(),
  xc(),
  vc(),
  Wv(),
  Kv(),
  mc(),
  Jv(),
  Zv(),
  $v(),
  ty(),
  Ld(),
  Md(),
  Yf(),
  Iv(),
  gc(),
  Pv(),
  vd(),
  iy(),
  Ru(),
  cc(),
  Od(),
  du(),
  pi(),
  hQ(),
  ly(),
  ws(),
  AV(),
  V(),
  F(),
  Vm(),
  Nm(),
  rk(),
  sk(),
  Pz(),
  _H(),
  Ij(),
  PR(),
  ex(),
  _M(),
  HA(),
  MV(),
  cx(),
  ox(),
  OA(),
  QO(),
  Lq(),
  Rj(),
  kH(),
  iU(),
  Uj(),
  QV(),
  AM(),
  iz(),
  Dk(),
  Vle(),
  lM(),
  tH(),
  rH(),
  gx(),
  GU(),
  FA(),
  sH(),
  wR(),
  jH(),
  lH(),
  dH(),
  dx(),
  eu(),
  ML(),
  N(),
  K = class extends Yh {
      static #e = pH = this;
      static #t = this.syncGroupRoot = !0;
      get teamEmailIntakeAddresses() {
          return this.emailIntakeAddresses.filter(e => e.type !== Pu.asks && !e.template?.value)
      }
      get hasUpdateDrafts() {
          return this.draftPosts.length > 0
      }
      get lastDraft() {
          return this.draftPosts.first
      }
      get issueTemplates() {
          return this.templates.filter(e => e.type === yf.issue && e.isClone === !1)
      }
      get recurringIssueTemplates() {
          return this.templates.filter(e => e.type === yf.recurringIssue && e.isClone === !1)
      }
      get documentTemplates() {
          return this.templates.filter(e => e.type === yf.document && e.isClone === !1)
      }
      get projectTemplates() {
          return this.templates.filter(e => e.type === yf.project && e.isClone === !1)
      }
      get allIssueTemplates() {
          return new ok(hx,[this.issueTemplates, this.organization.issueTemplates],{
              order: new P(e => !e.isTeamTemplate).and(e => e.inheritedFrom == null, `desc`).and(`sortOrder`).and(e => e.name.toLowerCase())
          })
      }
      get allDocumentTemplates() {
          return new ok(hx,[this.documentTemplates, this.organization.documentTemplates],{
              order: new P(e => !e.isTeamTemplate).and(`sortOrder`).and(e => e.name.toLowerCase())
          })
      }
      get allProjectTemplates() {
          return new ok(hx,[this.projectTemplates, this.organization.projectTemplates],{
              order: new P(e => !e.isTeamTemplate).and(`sortOrder`).and(e => e.name.toLowerCase())
          })
      }
      get relatedDocuments() {
          let e = this.projects.flatMap(e => e.documents.elements)
            , t = this.initiatives.flatMap(e => e.documents.elements);
          return [...this.documents.elements, ...e, ...t]
      }
      get initiatives() {
          return this.organization.initiatives.filter(e => e.accessibleTeams.contains(this))
      }
      get safeMemberships() {
          return this.memberships.filter(e => e.user ? e.team ? !0 : (w.warning(`TeamMembership without team`, {
              teamMembershipId: e.id,
              teamId: e.teamId
          }),
          !1) : (w.warning(`TeamMembership without user`, {
              teamMembershipId: e.id,
              userId: e.userId
          }),
          !1))
      }
      get activeMemberships() {
          return this.safeMemberships.filter(e => e.user.isActive)
      }
      get projectsPageFacets() {
          return this.facets.filter(e => e.sourcePage === ry.projects)
      }
      get issuesPageFacets() {
          return this.facets.filter(e => e.sourcePage === ry.teamIssues)
      }
      get allIssueLabels() {
          return this.issueLabels.concat(this.organization.issueLabels.elements).orderBy(new P(`name`))
      }
      static createArchivedTeam(e, t) {
          let n = new pH;
          return n.id = e.id,
          n.name = e.name,
          n.icon = e.icon,
          n.createdAt = e.createdAt,
          n.archivedAt = e.archivedAt,
          n.color = e.color,
          n.key = e.key,
          n.private = e.private,
          n.timezone = e.timezone,
          n.organization = t,
          n
      }
      static get isUpdatesFeedEnabled() {
          return ui.isEnabled(ui.teamUpdatesFeed) && ui.isEnabled(ui.feedPostUpdate)
      }
      get frequentIssueLabels() {
          if (!this._frequentIssueLabels || !this.issues.isHydrated()) {
              let e = this.issues.elements
                , t = new Map;
              for (let n of e)
                  for (let e of n.labels.elements)
                      e.isRetired || (t.has(e) ? t.set(e, t.get(e) + 1) : t.set(e, 1));
              this._frequentIssueLabels = Bm.of(OH, Array.from(t.entries()).sort( (e, t) => t[1] - e[1]).slice(0, 3).map(e => e[0]))
          }
          return this._frequentIssueLabels
      }
      get statesWithoutTriage() {
          return this.triageEnabled ? this.states.filter(e => !e.isTriage) : this.states
      }
      get customViews() {
          return this.allCustomViews.filter(e => !sc(e.traits, Rd.hasFacet))
      }
      get isScimManaged() {
          return this.scimManaged && this.organization.isScimEnabled
      }
      get usersCount() {
          return this.safeMemberships.length
      }
      get users() {
          return Bm.of(J, this.safeMemberships.map(e => e.user))
      }
      get activeUsers() {
          return this.users.filter(e => e.isActive)
      }
      get activeAndInvitedUsers() {
          return this.users.filter(e => e.isActive || e.isInvited)
      }
      get activeProjects() {
          return this.projects.filter(e => e.isActive)
      }
      get owners() {
          return Bm.of(J, this.safeMemberships.filter(e => e.user.isActive && e.owner).map(e => e.user))
      }
      get sortOrder() {
          return pQ().user.getMembershipForTeam(this)?.sortOrder ?? 1 / 0
      }
      get administrableDescendants() {
          return this.children.reduce( (e, t) => (e.push(t, ...t.administrableDescendants),
          e), [])
      }
      get withAccessibleDescendants() {
          return [this, ...this.accessibleDescendants]
      }
      get ancestors() {
          let e = []
            , t = this.parent;
          for (; t; )
              e.unshift(t),
              t = t.parent;
          return e
      }
      get withAncestors() {
          return [...this.ancestors, this]
      }
      get hasSubTeams() {
          return this.children.length > 0
      }
      isLastSubTeamForUser(e) {
          return this.parent?.children.filter(t => t.userIsMember(e)).length === 1
      }
      get canAddAsSubTeam() {
          let e = (t, n=0) => Math.max(...t.map(t => e(t.children, n + 1)), n)
            , t = e(this.children);
          return !!this.parent || t < DA.maxNestingDepth(this.organization)
      }
      get canSetAsParent() {
          let e = 0
            , t = this.parent;
          for (; t; )
              e++,
              t = t.parent;
          return this.hasSubTeams || e < DA.maxNestingDepth(this.organization)
      }
      get displayName() {
          return this.withAncestors.map(e => e.name).join(`  `)
      }
      get allIssuesView() {
          return IV.create({
              team: this
          })
      }
      get activeIssuesView() {
          return LV.create({
              team: this
          })
      }
      get backlogIssuesView() {
          return RV.create({
              team: this
          })
      }
      get triageIssuesView() {
          return zV.create({
              team: this
          })
      }
      get hasViolatingTeamHierarchy() {
          return !this.organization.canAccess(gd.subTeams) && (this.parent !== void 0 || this.children.length > 0)
      }
      get isTriageSuggestionsEnabled() {
          return this.organization.isTriageSuggestionsAccessible && this.productIntelligenceScope !== qv.none
      }
      get isIssueSummariesEnabled() {
          return this.aiDiscussionSummariesEnabled && this.organization.aiDiscussionSummariesEnabled
      }
      get isThreadSummariesEnabled() {
          return this.aiThreadSummariesEnabled && this.organization.aiThreadSummariesEnabled
      }
      get isSettingsLocked() {
          return this.hasViolatingTeamHierarchy
      }
      getLabels(e, t={
          includeInherited: !1
      }) {
          return e === Ek ? [] : t.includeInherited ? this.issueLabels : this.issueLabels.filter(e => e.inheritedFrom === void 0)
      }
      userCanChangeIssueStatus(e) {
          return !this.triageEnabled || this.userIsMember(e)
      }
      userCanAccessTeam(e) {
          let t = e.app ? e.appBaseSyncGroups?.some(e => H.isPublicTeamsAccess(e)) : !e.guest;
          return !this.private && t || this.userIsMember(e)
      }
      hasPermission(e, t) {
          let n = this.getUserRoleOnTeam(t);
          return n ? Id.hasPermission(e, n, this.organization.featureTier, ui.isEnabled(ui.teamOwners), this) : !1
      }
      canJoin(e) {
          return !!(this.getUserRoleOnTeam(e) || !this.private && this.allMembersCanJoin)
      }
      canAdd(e, t) {
          return this.canJoin(e) ? t === su.guest ? this.hasPermission(Nd.guestManagement, e) : this.private || !this.allMembersCanJoin ? this.hasPermission(Nd.memberManagement, e) : !0 : !1
      }
      canViewSettings(e) {
          return this.getUserRoleOnTeam(e) !== void 0
      }
      get slaEnabled() {
          return this.organization.isSlaAccessible ?? !1
      }
      userIsMember(e) {
          return e.memberOf(this)
      }
      get activeStates() {
          return this.states.filter(e => e.isActive)
      }
      get backlogStates() {
          return this.states.filter(e => e.isBacklog)
      }
      get startedStates() {
          return this.states.filter(e => e.isStarted)
      }
      get issuesInherited() {
          return new ok(Y,[this.issues, ...this.accessibleChildren.map(e => e.issuesInherited)])
      }
      get projectsInherited() {
          return new nk(G,[this.projects, ...this.accessibleChildren.map(e => e.projectsInherited)],{
              dedupe: !0
          })
      }
      get activeIssues() {
          return this.issues.filter(e => e.state.isActive)
      }
      get unsnoozedTriageIssues() {
          return this.triageIssueState?.issues.filter(e => !e.snoozedUntilAt)
      }
      get autoCloseEnabled() {
          return this.autoClosePeriod !== void 0 && this.autoClosePeriod > 0
      }
      get autoArchiveEnabled() {
          return this.autoArchivePeriod !== void 0 && this.autoArchivePeriod > 0
      }
      get url() {
          return lI(this)
      }
      get colorForIcon() {
          return this.icon && Bd.isEmojiCode(this.icon) ? void 0 : this.color
      }
      matches(e) {
          return this.name.match(e) !== null
      }
      get identifier() {
          return `${this.key}`
      }
      get nextIssueNumber() {
          return 1 + this.issues.reduce( (e, t) => t.number ? Math.max(e, t.number) : e, 0)
      }
      get searchKeywords() {
          return [this.displayName, this.withAncestors.map(e => e.identifier).join(`  `)].join(` `)
      }
      defaultState(e, t={}) {
          let n = this.states.find(e => e.type === E.triage)
            , r = t.preferredState;
          if (!r && n && (e === void 0 || !this.userCanChangeIssueStatus(e)))
              return n;
          if (r) {
              if (r.team?.id === this.id)
                  return r;
              {
                  let e = this.states.find(e => e.type === r.type && e.name.toLowerCase() === r.name.toLowerCase());
                  if (e ||= this.states.find(e => e.type === r.type),
                  e)
                      return e;
                  w.error(`Team.defaultState: invalid preferred state, it belongs to another team`, void 0, {
                      teamId: this.id,
                      preferredStateId: r.id,
                      preferredStateTeamId: r.team.id
                  })
              }
          }
          return this.defaultIssueState || this.defaultStateForType(E.backlog) || this.defaultStateForType(E.unstarted)
      }
      get defaultActiveState() {
          return this.defaultStateForType(E.unstarted)
      }
      get defaultBacklogState() {
          return this.defaultStateForType(E.backlog)
      }
      get defaultCanceledState() {
          return this.defaultStateForType(E.canceled)
      }
      defaultStateForType(e) {
          if (e === E.triage)
              return this.triageIssueState || this.defaultStateForType(E.backlog);
          let t = this.defaultIssueState;
          return t && t.type === e ? t : this.states.find(t => t.type === e)
      }
      statesOfType(e) {
          return this.states.filter(t => t.type === e)
      }
      getViewPreferences(e) {
          return NA.getOrCreateFrom(this.viewPreferences, e, {
              team: this
          })
      }
      get activeCycle() {
          if (this.cyclesEnabled === !1)
              return;
          qO(this.cycles);
          let e = new Date;
          return this.cycles.elements.find(t => t.completedAt === void 0 && t.startsAt <= e && e < t.endsAt)
      }
      get previousCycle() {
          if (this.cyclesEnabled !== !1)
              return this.cycles.filter(e => e.isCompleted).orderBy(`completedAt`, `desc`).first
      }
      inCycleCooldown() {
          if (!this.cyclesEnabled || this.activeCycle)
              return !1;
          let e = this.previousCycle
            , t = this.upcomingCycle(0);
          if (!e?.completedAt || !t)
              return !1;
          let n = new Date;
          return e.completedAt < n && n < t.startsAt
      }
      get cycleDescription() {
          if (!this.cyclesEnabled)
              return `Off`;
          let e = `Every ${this.cycleDuration} ${(0,
          fH.default)(`week`, this.cycleDuration)}`;
          return this.cycleCooldownTime && (e += `, ${this.cycleCooldownTime} week cooldown`),
          e
      }
      get cycleVelocity() {
          let e = []
            , t = this.previousCycle;
          for (; t && e.length < 3; )
              t.isCompleted && t.allIssueCountHistory.some(e => e > 0) && e.push(t),
              t = t.previousCycle;
          if (e.length === 0) {
              let e = this.estimationEnabled ? 15 : 5;
              return {
                  velocity: Math.max(1, e * this.cycleDuration * this.memberships.length),
                  type: `estimate`
              }
          } else {
              let t = e.reduce( (e, t) => e + t.completedEstimatePoints, 0) / e.length;
              return {
                  velocity: Math.max(1, Math.floor(t)),
                  type: `historic`
              }
          }
      }
      get estimationEnabled() {
          return this.issueEstimationType !== yc.notUsed
      }
      upcomingCycle(e) {
          let t = new Date;
          return this.cycles.orderBy(`endsAt`, `asc`).filter(e => e.completedAt === void 0 && t < e.startsAt).elements[e]
      }
      async totalIssueCount() {
          try {
              return (await $V(this.store.graphQLClient, this.id)).team.issueCount
          } catch (e) {
              w.error(`Fetching issues count failed`, e, {
                  teamId: this.id
              });
              return
          }
      }
      async issueCounts() {
          try {
              let[e,t] = await Promise.all([$V(this.store.graphQLClient, this.id), $V(this.store.graphQLClient, this.id, !1)]);
              return {
                  total: e.team.issueCount,
                  active: t.team.issueCount,
                  archived: e.team.issueCount - t.team.issueCount
              }
          } catch (e) {
              w.error(`Fetching issues count failed`, e, {
                  teamId: this.id
              });
              return
          }
      }
      get usedByTriageRuleCount() {
          return this.associatedTriageRules.length
      }
      get associatedTriageRules() {
          return this.organization.triageWorkflowDefinitions.filter(e => !!(e.enabled && e.activities.find(e => e.updateIssue?.property === Fv.team && e.updateIssue?.value === this.id)))
      }
      findWorkflowState(e, t) {
          return this.states.find(n => (n.id === e || n.name.toLowerCase() === e.toLowerCase()) && (!t || n.type === t))
      }
      findEstimate(e) {
          if (!this.estimationEnabled)
              return;
          let t = bc.valuesForType(this.issueEstimationType, this.issueEstimationAllowZero, this.issueEstimationExtended)
            , n = bc.labelsForType(this.issueEstimationType, this.issueEstimationAllowZero, this.issueEstimationExtended).map(e => e.toLowerCase()).indexOf(e.toLowerCase());
          return n === -1 ? t.find(t => t === Number(e)) : t[n]
      }
      findLabel(e) {
          return this.allIssueLabels.find(t => t.id === e || Gv.labelNamesMatch(t.name, e))
      }
      findCycle(e) {
          return this.cycles.find(t => t.id === e || t.number + `` === e || t.displayName.toLowerCase() === e.toLocaleLowerCase())
      }
      findProject(e) {
          return this.projects.find(t => t.id === e || t.name.toLowerCase() === e.toLowerCase())
      }
      isDefaultTeamForAsksSlackChannel(e) {
          return e.id !== Uv.Asks.APP_HOME_ID && (e.autoCreateTemplateId ? !!this.templates.findById(e.autoCreateTemplateId) || Uv.Asks.generateGeneralAskTemplateIdForTeamId(this.id) === e.autoCreateTemplateId : e.teams.length > 0 && this.id === e.teams[0].id)
      }
      validateParentTeam(e) {
          if (this.administrableDescendants.includes(e))
              return `${e.name} is already a sub-team of ${this.name}`;
          if (e.private && !this.private)
              return `A public team cannot be a sub-team of a private team`;
          if (e.ancestors.length > Qv.maxNestingDepth - 1)
              return `Only ${Qv.maxNestingDepth} ${(0,
              fH.default)(`level`, Qv.maxNestingDepth)} of nesting is allowed`;
          if (e.children.length >= cy.getLimit(this.organization, jv.maxSubTeamsPerParentTeam))
              return `A parent team cannot have more than ${cy.getLimit(this.organization, jv.maxSubTeamsPerParentTeam)} sub-teams.`
      }
      getIntegration(e) {
          return this.organization.integrations.find(t => t.team === this && t.service === e)
      }
      save(e=!1, t) {
          return super.save(e, t)
      }
      matchInlineFind(e) {
          return $l([this.name, this.identifier, ...this.ancestors.flatMap(e => [e.name, e.identifier])].join(`  `)).toLowerCase().indexOf(e) !== -1
      }
      getTrait(e) {
          return sc(this.traits, e)
      }
      getUserRoleOnTeam(e) {
          e || w.error(`User param not set in getUserRoleOnTeam`, {
              teamId: this.id
          });
          let t = e ? this.safeMemberships.find(t => t.user ? t.user === e : (w.error(`Membership user not set in getUserRoleOnTeam`, {
              teamId: this.id,
              userId: t.userId,
              teamMembershipId: t.id
          }),
          !1)) : void 0
            , n = e.hasPermission(Cd.teamManagement)
            , r = jd.getUserRoleOnTeam(e, t, n);
          return r === kd.owner ? r : this.parent && this.parent.getUserRoleOnTeam(e) === kd.owner ? kd.owner : r
      }
      get accessibleChildren() {
          return this.children.filter(e => e.userCanAccessTeam(q.store.user))
      }
      get accessibleDescendants() {
          return this.accessibleChildren.reduce( (e, t) => (e.push(t, ...t.accessibleDescendants),
          e), [])
      }
  }
  ,
  M([R({
      default: ``
  })], K.prototype, `name`, void 0),
  M([R()], K.prototype, `description`, void 0),
  M([R()], K.prototype, `icon`, void 0),
  M([R()], K.prototype, `color`, void 0),
  M([og( () => eH)], K.prototype, `keys`, void 0),
  M([z( () => Y, {
      index: `teamId`,
      customNetworkHydration: e => [{
          modelClass: Y,
          syncGroup: e.id
      }, {
          modelClass: kV,
          syncGroup: e.id
      }],
      observeAccess: !0
  })], K.prototype, `issues`, void 0),
  M([z( () => NA, {
      index: `teamId`,
      canSkipHydration: e => e.organization.viewPreferences.isHydrated()
  })], K.prototype, `viewPreferences`, void 0),
  M([og( () => $b, {
      order: new P(`address`)
  })], K.prototype, `emailIntakeAddresses`, void 0),
  M([L], K.prototype, `teamEmailIntakeAddresses`, null),
  M([z( () => hx, {
      index: `teamId`,
      order: new P(`sortOrder`).and(`name`)
  })], K.prototype, `templates`, void 0),
  M([z( () => jV, {
      order: new P(`createdAt`,`desc`)
  })], K.prototype, `feed`, void 0),
  M([og( () => kM, {
      order: new P(`createdAt`,`desc`)
  })], K.prototype, `draftPosts`, void 0),
  M([L], K.prototype, `issueTemplates`, null),
  M([L], K.prototype, `recurringIssueTemplates`, null),
  M([L], K.prototype, `documentTemplates`, null),
  M([L], K.prototype, `projectTemplates`, null),
  M([L], K.prototype, `allIssueTemplates`, null),
  M([L], K.prototype, `allDocumentTemplates`, null),
  M([L], K.prototype, `allProjectTemplates`, null),
  M([z( () => NR, {
      index: `teamId`,
      order: new P(`sortOrder`),
      canSkipHydration: () => !ui.isEnabled(ui.teamResourceFolders)
  })], K.prototype, `documents`, void 0),
  M([z( () => gM, {
      index: `teamId`,
      order: new P(`sortOrder`),
      canSkipHydration: () => !ui.isEnabled(ui.teamResourceFolders)
  })], K.prototype, `links`, void 0),
  M([L], K.prototype, `relatedDocuments`, null),
  M([L], K.prototype, `initiatives`, null),
  M([z( () => oH, {
      index: `teamId`
  })], K.prototype, `webhooks`, void 0),
  M([z( () => CR, {
      index: `teamId`
  })], K.prototype, `aiPromptRules`, void 0),
  M([z( () => AH, {
      index: `teamId`
  })], K.prototype, `aiPromptMemories`, void 0),
  M([z( () => gH, {
      index: `teamId`,
      order: new P(`number`,`desc`)
  })], K.prototype, `cycles`, void 0),
  M([og( () => G, {
      order: new P(e => e.isActive,`desc`).and(e => e.isDone, `asc`).and(e => !e.targetDate, `asc`).and(e => e.targetDate ? e.targetDate : 0, `asc`).and(`createdAt`, `desc`)
  })], K.prototype, `projects`, void 0),
  M([og( () => nH, {
      order: new P(e => {
          let t = e.user;
          return t === void 0 ? (w.error(`Membership didn't have a user`, void 0, {
              id: e.id
          }),
          `~`) : t.name
      }
      ,`asc`)
  })], K.prototype, `memberships`, void 0),
  M([L], K.prototype, `safeMemberships`, null),
  M([L], K.prototype, `activeMemberships`, null),
  M([z( () => VA, {
      index: `sourceTeamId`,
      order: new P(`sortOrder`)
  })], K.prototype, `facets`, void 0),
  M([z( () => cM, {
      index: `sourceTeamId`,
      order: new P(`sortOrder`),
      canSkipHydration: () => !ui.isEnabled(ui.teamResourceFolders)
  })], K.prototype, `resourceFolders`, void 0),
  M([L], K.prototype, `projectsPageFacets`, null),
  M([L], K.prototype, `issuesPageFacets`, null),
  M([og( () => OH, {
      order: new P(`sortName`)
  })], K.prototype, `issueLabels`, void 0),
  M([L], K.prototype, `allIssueLabels`, null),
  M([og( () => ux, {
      order: new P(e => _c.getStateTypeOrder(e.type)).and(`position`)
  })], K.prototype, `states`, void 0),
  M([L({
      keepAlive: !0
  })], K.prototype, `statesWithoutTriage`, null),
  M([z( () => ax, {
      index: `teamId`
  })], K.prototype, `gitAutomationTargetBranches`, void 0),
  M([z( () => sx, {
      index: `teamId`
  })], K.prototype, `gitAutomationStates`, void 0),
  M([og( () => uH, {
      order: new P(`sortOrder`).and(`createdAt`, `asc`)
  })], K.prototype, `workflowDefinitions`, void 0),
  M([og( () => cH, {
      order: new P(e => e.createdAt,`asc`)
  })], K.prototype, `workflowCronJobDefinitions`, void 0),
  M([z( () => Az, {
      index: `teamId`,
      order: new P(`name`)
  })], K.prototype, `allCustomViews`, void 0),
  M([L], K.prototype, `customViews`, null),
  M([z( () => Fj, {
      index: `teamId`,
      order: new P(`name`),
      canSkipHydration: e => !e.getTrait(ey.hasDashboards)
  })], K.prototype, `dashboards`, void 0),
  M([z( () => Lj, {
      index: `teamId`
  })], K.prototype, `issueImports`, void 0),
  M([B( () => q, `teams`, {
      optional: !1,
      nullable: !1,
      persistence: `createOnly`
  })], K.prototype, `organization`, void 0),
  M([R({
      default: ``
  })], K.prototype, `key`, void 0),
  M([R({
      default: !1
  })], K.prototype, `cyclesEnabled`, void 0),
  M([R({
      default: Vn.Monday
  })], K.prototype, `cycleStartDay`, void 0),
  M([R({
      default: 2
  })], K.prototype, `cycleDuration`, void 0),
  M([R({
      default: 2
  })], K.prototype, `cycleCooldownTime`, void 0),
  M([R({
      default: !0
  })], K.prototype, `cycleIssueAutoAssignStarted`, void 0),
  M([R({
      default: !0
  })], K.prototype, `cycleIssueAutoAssignCompleted`, void 0),
  M([R({
      default: !1
  })], K.prototype, `cycleLockToActive`, void 0),
  M([R({
      persistence: `updateOnly`,
      isVirtual: !0
  })], K.prototype, `cycleEnabledStartDate`, void 0),
  M([R({
      default: 2
  })], K.prototype, `upcomingCycleCount`, void 0),
  M([R({
      default: `utc`
  })], K.prototype, `timezone`, void 0),
  M([R({
      default: !1
  })], K.prototype, `inheritIssueEstimation`, void 0),
  M([R({
      default: !0
  })], K.prototype, `inheritWorkflowStatuses`, void 0),
  M([R({
      default: yc.notUsed
  })], K.prototype, `issueEstimationType`, void 0),
  M([R({
      default: !1
  })], K.prototype, `issueEstimationAllowZero`, void 0),
  M([R({
      default: !1
  })], K.prototype, `issueEstimationExtended`, void 0),
  M([R({
      default: dc.first
  })], K.prototype, `setIssueSortOrderOnStateChange`, void 0),
  M([R({
      default: 1
  })], K.prototype, `defaultIssueEstimate`, void 0),
  M([ug({
      nullable: !0
  })], K.prototype, `subscription`, void 0),
  M([dg({
      nullable: !0
  })], K.prototype, `integrationsSettings`, void 0),
  M([R({
      default: !1
  })], K.prototype, `triageEnabled`, void 0),
  M([dg({
      nullable: !0
  })], K.prototype, `triageResponsibility`, void 0),
  M([R({
      default: !1
  })], K.prototype, `requirePriorityToLeaveTriage`, void 0),
  M([cg( () => ux, {
      nullable: !0,
      indexed: !0,
      persistence: `none`
  })], K.prototype, `triageIssueState`, void 0),
  M([cg( () => ux, {
      nullable: !0,
      indexed: !0,
      persistence: `updateOnly`
  })], K.prototype, `defaultIssueState`, void 0),
  M([lg( () => hx, {
      nullable: !0,
      indexed: !0
  })], K.prototype, `defaultTemplateForMembers`, void 0),
  M([lg( () => hx, {
      nullable: !0,
      indexed: !0
  })], K.prototype, `defaultTemplateForNonMembers`, void 0),
  M([lg( () => hx, {
      nullable: !0,
      indexed: !0
  })], K.prototype, `defaultProjectTemplate`, void 0),
  M([R({
      default: !1
  })], K.prototype, `private`, void 0),
  M([R({
      persistence: `updateOnly`
  })], K.prototype, `allMembersCanJoin`, void 0),
  M([R({
      default: {},
      persistence: `updateOnly`
  })], K.prototype, `securitySettings`, void 0),
  M([R({
      persistence: `updateOnly`,
      default: !1
  })], K.prototype, `scimManaged`, void 0),
  M([R({
      persistence: `none`
  })], K.prototype, `scimGroupName`, void 0),
  M([R({
      default: !0
  })], K.prototype, `groupIssueHistory`, void 0),
  M([R({
      default: !0,
      persistence: `updateOnly`
  })], K.prototype, `aiThreadSummariesEnabled`, void 0),
  M([R({
      default: !0,
      persistence: `updateOnly`
  })], K.prototype, `aiDiscussionSummariesEnabled`, void 0),
  M([R({
      default: !0
  })], K.prototype, `inheritProductIntelligenceScope`, void 0),
  M([R({
      default: qv.workspace
  })], K.prototype, `productIntelligenceScope`, void 0),
  M([R()], K.prototype, `autoClosePeriod`, void 0),
  M([R()], K.prototype, `autoArchivePeriod`, void 0),
  M([R({
      persistence: `updateOnly`
  })], K.prototype, `autoCloseParentIssues`, void 0),
  M([R({
      persistence: `updateOnly`
  })], K.prototype, `autoCloseChildIssues`, void 0),
  M([cg( () => ux, {
      nullable: !0,
      indexed: !0
  })], K.prototype, `autoCloseState`, void 0),
  M([cg( () => ux, {
      nullable: !0,
      indexed: !0
  })], K.prototype, `markedAsDuplicateWorkflowState`, void 0),
  M([R({
      persistence: `none`,
      default: 0
  })], K.prototype, `approximateIssueCount`, void 0),
  M([R({
      persistence: `updateOnly`
  })], K.prototype, `joinByDefault`, void 0),
  M([B( () => K, `children`, {
      nullable: !0,
      indexed: !0
  })], K.prototype, `parent`, void 0),
  M([og( () => K, {
      order: new P(`name`)
  })], K.prototype, `children`, void 0),
  M([R({
      persistence: `none`
  })], K.prototype, `traits`, void 0),
  M([z( () => Hj, {
      index: `teamId`
  })], K.prototype, `posts`, void 0),
  M([L], K.prototype, `isScimManaged`, null),
  M([L], K.prototype, `users`, null),
  M([L], K.prototype, `activeUsers`, null),
  M([L], K.prototype, `activeAndInvitedUsers`, null),
  M([L], K.prototype, `activeProjects`, null),
  M([L], K.prototype, `owners`, null),
  M([L], K.prototype, `sortOrder`, null),
  M([L], K.prototype, `administrableDescendants`, null),
  M([L], K.prototype, `withAccessibleDescendants`, null),
  M([L], K.prototype, `ancestors`, null),
  M([L], K.prototype, `withAncestors`, null),
  M([L], K.prototype, `hasSubTeams`, null),
  M([L], K.prototype, `canAddAsSubTeam`, null),
  M([L], K.prototype, `canSetAsParent`, null),
  M([L], K.prototype, `displayName`, null),
  M([L], K.prototype, `allIssuesView`, null),
  M([L], K.prototype, `activeIssuesView`, null),
  M([L], K.prototype, `backlogIssuesView`, null),
  M([L], K.prototype, `triageIssuesView`, null),
  M([L], K.prototype, `hasViolatingTeamHierarchy`, null),
  M([L], K.prototype, `isTriageSuggestionsEnabled`, null),
  M([L], K.prototype, `isIssueSummariesEnabled`, null),
  M([L], K.prototype, `isThreadSummariesEnabled`, null),
  M([L], K.prototype, `isSettingsLocked`, null),
  M([L], K.prototype, `activeStates`, null),
  M([L], K.prototype, `backlogStates`, null),
  M([L], K.prototype, `startedStates`, null),
  M([L], K.prototype, `issuesInherited`, null),
  M([L], K.prototype, `projectsInherited`, null),
  M([L], K.prototype, `activeIssues`, null),
  M([L], K.prototype, `unsnoozedTriageIssues`, null),
  M([L], K.prototype, `searchKeywords`, null),
  M([L], K.prototype, `defaultActiveState`, null),
  M([L], K.prototype, `defaultBacklogState`, null),
  M([L], K.prototype, `defaultCanceledState`, null),
  M([L], K.prototype, `activeCycle`, null),
  M([L], K.prototype, `previousCycle`, null),
  M([L], K.prototype, `cycleDescription`, null),
  M([L], K.prototype, `usedByTriageRuleCount`, null),
  M([L], K.prototype, `associatedTriageRules`, null),
  M([L], K.prototype, `accessibleChildren`, null),
  M([L], K.prototype, `accessibleDescendants`, null),
  K = pH = M([mg(`Team`)], K)
}
));
function hH(e, t) {
  return e.inheritedBy.reduce( (e, n) => {
      let r = n[t];
      return Hle(e, r)
  }
  , e[t])
}
function Hle(e, t) {
  let[n,r] = e.length < t.length ? [e, t] : [t, e]
    , i = r.length - n.length;
  return r.map( (e, t) => {
      let r = t - i;
      return e + (r >= 0 ? n[r] : 0)
  }
  )
}
var gH, _H = t(( () => {
  _n(),
  Hv(),
  gc(),
  Ml(),
  Cc(),
  Yr(),
  bH(),
  Lq(),
  mH(),
  V(),
  F(),
  Nm(),
  Ih(),
  om(),
  eu(),
  ak(),
  sk(),
  N(),
  gH = class extends qh {
      constructor(...e) {
          super(...e),
          this.toggleFavorite = () => {
              let e = this.getFavorite();
              if (e)
                  return e.delete(),
                  !1;
              {
                  let e = yH.create(this.favoriteViewType ? {
                      predefinedViewTeam: this.team,
                      predefinedViewType: this.favoriteViewType
                  } : {
                      reference: this
                  });
                  return e.save(!0),
                  e
              }
          }
          ,
          this.lazyInheritedIssueCollections = new ik(async () => {
              await Promise.all(this.team.children.map(e => e.cycles.hydrate()));
              let e = this.team.children.map(e => e.cycles.find(e => e.inheritedFrom?.id === this.id)).concrete();
              return [this.issues, ...e.map(e => e.issues)]
          }
          )
      }
      static #e = this.loadStrategy = rm.lazy;
      getFavorite() {
          return this.favorite ?? this.store.user.favorites.find(e => e.predefinedViewTeam === this.team && this.favoriteViewType === e.predefinedViewType)
      }
      get issuesInherited() {
          return new ok(Y,this.lazyInheritedIssueCollections)
      }
      get allUncompletedIssuesUponClose() {
          return new ok(Y,[this.uncompletedIssuesUponClose, ...this.inheritedBy.map(e => e.uncompletedIssuesUponClose)])
      }
      get allIssueCountHistory() {
          return hH(this, `issueCountHistory`)
      }
      get allCompletedIssueCountHistory() {
          return hH(this, `completedIssueCountHistory`)
      }
      get allScopeHistory() {
          return hH(this, `scopeHistory`)
      }
      get allCompletedScopeHistory() {
          return hH(this, `completedScopeHistory`)
      }
      get allInProgressScopeHistory() {
          return hH(this, `inProgressScopeHistory`)
      }
      get allCurrentProgress() {
          return this.inheritedBy.map(e => e.currentProgress).reduce( (e, t) => {
              for (let n in t) {
                  let r = t[n]
                    , i = e[n] ?? 0;
                  typeof r == `number` && (e[n] = i + r)
              }
              return e
          }
          , {
              ...this.currentProgress
          })
      }
      get numberName() {
          return `Cycle ${this.displayNumber}`
      }
      get displayName() {
          return this.name ? this.name : this.numberName
      }
      get displayNumber() {
          if (!this.name)
              return this.number;
          let e = Al.parseCycleNameAndNumber(this.name);
          if (!e)
              return this.number;
          let t = new Date().getFullYear();
          return e.number > t - 5 && e.number < t + 5 ? this.number : e.number
      }
      get shortCycleName() {
          return this.inheritedFrom?.value ? this.inheritedFrom.value.shortCycleName : this.displayNumber === this.number && this.name && this.name !== `Cycle ${this.displayNumber}` ? this.displayName : `${this.displayNumber}`
      }
      get identifier() {
          return `${this.number}`
      }
      get statusTitle() {
          return this.isActive ? `Current` : this.isNext ? `Upcoming` : this.isPlanned ? `Planned` : `Completed`
      }
      get weekDaysLeft() {
          let e = gn(b.MINUTE)
            , t = this.calendarDaysLeft
            , n = Math.floor(t / 7);
          t -= n * 7;
          let r = n * 5;
          for (let n = 0; n < t; n++) {
              let t = new Date(e + n * b.DAY).getDay();
              t !== 0 && t !== 6 && (r += 1)
          }
          return r
      }
      get calendarDaysLeft() {
          if (this.isCompleted || this.isPlanned)
              return 0;
          let e = Math.ceil((this.endsAt.getTime() - gn(b.MINUTE)) / b.DAY);
          return e <= 0 ? 0 : e
      }
      get progress() {
          return Sc.completionProgress(this.allCurrentProgress)
      }
      get capacityFilled() {
          let e = this.team.cycleVelocity;
          if (e)
              return this.totalEstimatePoints / e.velocity
      }
      get inProgressEstimatePoints() {
          return Sc.inProgressEstimatePoints(this.allCurrentProgress, this.team.estimationEnabled)
      }
      get completedEstimatePoints() {
          return Sc.completedEstimatePoints(this.allCurrentProgress, this.team.estimationEnabled)
      }
      get progressEstimatePoints() {
          return Sc.progressEstimatePoints(this.allCurrentProgress, this.team.estimationEnabled)
      }
      get totalEstimatePoints() {
          return Sc.totalEstimatePoints(this.allCurrentProgress, {
              estimationEnabled: this.team.estimationEnabled
          })
      }
      get hasStartedLine() {
          return this.allInProgressScopeHistory.length > 0 || this.startsAt > new Date(`2022-08-18`)
      }
      get openIssues() {
          return this.issuesInherited.filter(e => e.state.type === E.backlog || e.state.type === E.unstarted || e.state.type === E.started)
      }
      get completedIssues() {
          return this.issuesInherited.filter(e => e.state.type === E.completed)
      }
      get canceledIssues() {
          return this.issuesInherited.filter(e => e.state.type === E.canceled)
      }
      get progressPercent() {
          return Sc.progressToPercent(this.progress)
      }
      get progressText() {
          return this.progressPercent + `%`
      }
      get isPlanned() {
          return new Date(gn(b.MINUTE)) < this.startsAt && !this.completedAt
      }
      get isNext() {
          return this.team.upcomingCycle(0) === this
      }
      get isPrevious() {
          return this.team.previousCycle === this
      }
      get isPast() {
          return this.completedAt !== void 0
      }
      get isFuture() {
          return this.startsAt >= new Date(gn(b.MINUTE))
      }
      get isActive() {
          let e = new Date().getTime();
          return this.completedAt === void 0 && this.startsAt.getTime() <= e && e < this.endsAt.getTime()
      }
      get isCompleted() {
          return this.completedAt !== void 0
      }
      get isInCooldown() {
          if (!this.isCompleted)
              return !1;
          let e = this.nextCycle;
          if (!e)
              return !1;
          let t = new Date;
          return t > this.endsAt && t < e.startsAt
      }
      get hasCooldown() {
          let e = this.nextCycle;
          return e ? this.endsAt < e.startsAt : this.team.cycleCooldownTime > 0
      }
      get previousCycle() {
          let e = this.team.cycles.indexOf(this);
          return e >= 0 ? this.team.cycles.elements[e + 1] : void 0
      }
      get nextCycle() {
          let e = this.team.cycles.indexOf(this);
          return e >= 0 ? this.team.cycles.elements[e - 1] : void 0
      }
      matchInlineFind(e) {
          return $l(this.name + ` ` + this.description + ` ` + this.number).toLowerCase().indexOf(e) !== -1
      }
      get favoriteViewType() {
          return this.isActive ? Vv.activeCycle : this.isNext ? Vv.upcomingCycle : void 0
      }
  }
  ,
  M([R({
      persistence: `none`,
      default: 1
  })], gH.prototype, `number`, void 0),
  M([R()], gH.prototype, `name`, void 0),
  M([R()], gH.prototype, `description`, void 0),
  M([R({
      serializer: Ah,
      default: () => new Date
  })], gH.prototype, `startsAt`, void 0),
  M([R({
      serializer: Ah,
      default: () => new Date
  })], gH.prototype, `endsAt`, void 0),
  M([R({
      serializer: Ah
  })], gH.prototype, `completedAt`, void 0),
  M([B( () => K, `cycles`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], gH.prototype, `team`, void 0),
  M([ug({
      nullable: !0
  })], gH.prototype, `favorite`, void 0),
  M([z( () => Y, {
      index: `cycleId`,
      order: new P(`sortOrder`),
      canSkipHydration: e => e.team.issues.isHydrated()
  })], gH.prototype, `issues`, void 0),
  M([pg( () => Y, void 0, {
      persistence: `none`,
      onDelete: `NO ACTION`,
      indexed: !0
  })], gH.prototype, `uncompletedIssuesUponClose`, void 0),
  M([R({
      persistence: `none`,
      default: []
  })], gH.prototype, `issueCountHistory`, void 0),
  M([L], gH.prototype, `allIssueCountHistory`, null),
  M([R({
      persistence: `none`,
      default: []
  })], gH.prototype, `completedIssueCountHistory`, void 0),
  M([L], gH.prototype, `allCompletedIssueCountHistory`, null),
  M([R({
      persistence: `none`,
      default: []
  })], gH.prototype, `scopeHistory`, void 0),
  M([L], gH.prototype, `allScopeHistory`, null),
  M([R({
      persistence: `none`,
      default: []
  })], gH.prototype, `completedScopeHistory`, void 0),
  M([L], gH.prototype, `allCompletedScopeHistory`, null),
  M([R({
      persistence: `none`,
      default: []
  })], gH.prototype, `inProgressScopeHistory`, void 0),
  M([L], gH.prototype, `allInProgressScopeHistory`, null),
  M([R({
      persistence: `none`,
      serializer: Mh,
      default: []
  })], gH.prototype, `currentProgress`, void 0),
  M([L], gH.prototype, `allCurrentProgress`, null),
  M([sg( () => gH, `inheritedBy`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], gH.prototype, `inheritedFrom`, void 0),
  M([z( () => gH, {
      index: `inheritedFromId`
  })], gH.prototype, `inheritedBy`, void 0),
  M([L], gH.prototype, `numberName`, null),
  M([L], gH.prototype, `displayName`, null),
  M([L], gH.prototype, `displayNumber`, null),
  M([L], gH.prototype, `statusTitle`, null),
  M([L], gH.prototype, `weekDaysLeft`, null),
  M([L], gH.prototype, `calendarDaysLeft`, null),
  M([L], gH.prototype, `progress`, null),
  M([L], gH.prototype, `capacityFilled`, null),
  M([L], gH.prototype, `inProgressEstimatePoints`, null),
  M([L], gH.prototype, `completedEstimatePoints`, null),
  M([L], gH.prototype, `progressEstimatePoints`, null),
  M([L], gH.prototype, `totalEstimatePoints`, null),
  M([L], gH.prototype, `hasStartedLine`, null),
  M([L], gH.prototype, `openIssues`, null),
  M([L], gH.prototype, `completedIssues`, null),
  M([L], gH.prototype, `canceledIssues`, null),
  M([L], gH.prototype, `isPlanned`, null),
  M([L], gH.prototype, `isInCooldown`, null),
  M([L], gH.prototype, `hasCooldown`, null),
  M([L], gH.prototype, `previousCycle`, null),
  M([L], gH.prototype, `nextCycle`, null),
  gH = M([mg(`Cycle`)], gH)
}
)), vH, yH, bH = t(( () => {
  ku(),
  zn(),
  Vd(),
  hQ(),
  _H(),
  Lq(),
  kH(),
  iz(),
  mH(),
  GU(),
  Pz(),
  PR(),
  DM(),
  V(),
  F(),
  nx(),
  HA(),
  Sm(),
  FB(),
  Ij(),
  Dk(),
  TA(),
  N(),
  yH = vH = class extends Yh {
      get isActive() {
          let e = this.targetModel
            , t = e instanceof qh && e.isClone
            , n = e instanceof vm ? e.value !== void 0 : !0;
          return e !== void 0 && n && !t
      }
      async hydrateEmojiIcon() {
          if ([Ou.customView, Ou.project, Ou.document, Ou.initiative].includes(this.type)) {
              let e = this.targetModel?.icon;
              if (e && Bd.isEmojiCode(e))
                  return this.owner.organization.getEmojiByName(e)
          }
      }
      moveFromFolder() {
          this.parent = void 0
      }
      moveToFolder(e) {
          if (e.type !== `folder`)
              throw Error(`Favorite item as a folder should have type=folder`);
          this.parent = e
      }
      get naturalIdentity() {
          let e = typeof this.targetModel == `string` ? this.targetModel : this.targetModel?.id;
          return [this.type, this.owner.id, e]
      }
      static createFolder(e) {
          let t = new vH
            , n = pQ().user;
          return t.owner = n,
          t.sortOrder = tx.firstSortOrder(n.activeFavorites, `sortOrder`),
          t.folderName = e.folderName,
          t.type = Ou.folder,
          t
      }
      static create(e) {
          let t = vH.createEmpty()
            , n = pQ().user;
          return t.owner = n,
          t.sortOrder = tx.firstSortOrder(n.activeFavorites, `sortOrder`),
          e.predefinedViewTeam && e.predefinedViewType ? (t.type = Ou.predefinedView,
          t.predefinedViewTeam = e.predefinedViewTeam,
          t.predefinedViewType = e.predefinedViewType) : e.reference instanceof gH ? (t.type = Ou.cycle,
          t.cycle = vm.wrap(e.reference)) : e.reference instanceof OH ? (t.type = Ou.label,
          t.label = e.reference) : e.reference instanceof Ek ? (t.type = Ou.projectLabel,
          t.projectLabel = e.reference) : e.reference instanceof Y ? (t.type = Ou.issue,
          t.issue = vm.wrap(e.reference)) : e.reference instanceof G ? (t.type = Ou.project,
          t.project = e.reference,
          t.projectTab = e.projectTab) : e.reference instanceof W ? (t.type = Ou.initiative,
          t.initiative = e.reference,
          t.initiativeTab = e.initiativeTab) : e.reference instanceof Az ? (t.type = Ou.customView,
          t.customView = vm.wrap(e.reference)) : e.reference instanceof NR ? (t.type = Ou.document,
          t.document = vm.wrap(e.reference)) : e.reference instanceof J ? (t.type = Ou.user,
          t.user = e.reference) : e.reference instanceof VA ? (t.type = Ou.facet,
          t.facet = e.reference) : e.reference instanceof MB ? (t.type = Ou.customer,
          t.customer = vm.wrap(e.reference)) : e.reference instanceof Fj ? (t.type = Ou.dashboard,
          t.dashboard = vm.wrap(e.reference)) : e.reference instanceof U ? (t.type = Ou.pullRequest,
          t.pullRequest = vm.wrap(e.reference)) : e.reference !== void 0 && y(e.reference),
          e.parent && (t.parent = e.parent),
          t
      }
      get targetModel() {
          return this.initiative || this.customView || this.document || this.issue || this.project || this.facet || this.cycle || this.label || this.projectLabel || this.user || this.customer || this.dashboard || this.pullRequest || this.folderName || this.predefinedViewTeam && this.predefinedViewType
      }
  }
  ,
  M([R({
      persistence: `none`,
      default: Ou.folder
  })], yH.prototype, `type`, void 0),
  M([B( () => yH, `children`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], yH.prototype, `parent`, void 0),
  M([og( () => yH)], yH.prototype, `children`, void 0),
  M([R()], yH.prototype, `folderName`, void 0),
  M([R({
      default: 0
  })], yH.prototype, `sortOrder`, void 0),
  M([dg( () => Y, `favorite`, {
      optional: !0,
      nullable: !1,
      cascadeHydration: !0,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `issue`, void 0),
  M([cg( () => K, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `predefinedViewTeam`, void 0),
  M([R({
      persistence: `createOnly`
  })], yH.prototype, `predefinedViewType`, void 0),
  M([B( () => G, `favorites`, {
      optional: !0,
      nullable: !1,
      cascadeHydration: !0,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `project`, void 0),
  M([R({
      persistence: `createOnly`
  })], yH.prototype, `projectTab`, void 0),
  M([ug( () => VA, `favorite`, {
      optional: !0,
      nullable: !1,
      cascadeHydration: !0,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `facet`, void 0),
  M([dg( () => gH, `favorite`, {
      optional: !0,
      nullable: !1,
      cascadeHydration: !0,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `cycle`, void 0),
  M([dg( () => Az, `favorite`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      cascadeHydration: !0,
      persistence: `createOnly`
  })], yH.prototype, `customView`, void 0),
  M([dg( () => NR, `favorite`, {
      optional: !0,
      nullable: !1,
      cascadeHydration: !0,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `document`, void 0),
  M([B( () => W, `favorites`, {
      optional: !0,
      nullable: !1,
      cascadeHydration: !0,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `initiative`, void 0),
  M([R({
      persistence: `createOnly`
  })], yH.prototype, `initiativeTab`, void 0),
  M([ug( () => OH, `favorite`, {
      optional: !0,
      nullable: !1,
      cascadeHydration: !0,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `label`, void 0),
  M([ug( () => Ek, `favorite`, {
      optional: !0,
      nullable: !1,
      cascadeHydration: !0,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `projectLabel`, void 0),
  M([ug( () => J, `favorite`, {
      optional: !0,
      nullable: !1,
      persistence: `createOnly`
  })], yH.prototype, `user`, void 0),
  M([dg( () => MB, `favorite`, {
      optional: !0,
      nullable: !1,
      cascadeHydration: !0,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `customer`, void 0),
  M([dg( () => Fj, `favorite`, {
      optional: !0,
      nullable: !1,
      cascadeHydration: !0,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `dashboard`, void 0),
  M([dg( () => U, `favorite`, {
      optional: !0,
      nullable: !1,
      cascadeHydration: !0,
      indexed: !0,
      persistence: `createOnly`
  })], yH.prototype, `pullRequest`, void 0),
  M([B( () => J, `favorites`, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], yH.prototype, `owner`, void 0),
  M([L], yH.prototype, `isActive`, null),
  M([L], yH.prototype, `targetModel`, null),
  yH = vH = M([mg(`Favorite`)], yH)
}
)), xH, SH, CH, wH, TH = t(( () => {
  zt(),
  xH = e(ne(), 1),
  SH = e(l(), 1),
  Sy(),
  Bl(),
  kH(),
  mH(),
  GU(),
  Lq(),
  V(),
  F(),
  Nm(),
  Ih(),
  dx(),
  Sm(),
  WR(),
  N(),
  wH = CH = class extends Yh {
      get markdownDescription() {
          return this.descriptionData ? Hp.serialize(this.descriptionData) : ``
      }
      isIssueEquivalent(e) {
          let t = new Y;
          if (t.applyDraftValues(this, {
              skipChildren: !0,
              skipNeedsCreation: !0
          }),
          !this.issueHaveSameDraftValues(t, e) || e.children.length !== this.children.length)
              return !1;
          for (let n = 0; n < e.children.length; n++) {
              let r = e.children.elements[n]
                , i = this.children.elements[n]
                , a = new Y;
              if (a.applyDraftValues(i, {
                  parentDraftAsIssue: t
              }),
              !this.issueHaveSameDraftValues(a, r, [`parentId`]))
                  return !1
          }
          return !0
      }
      static createOrUpdateFromIssue(e, t, n, r) {
          return this.createOrUpdate(e, t, {
              title: n.title,
              descriptionData: n.documentContent.value?.contentData,
              priority: n.priority,
              assignee: n.assignee,
              delegate: n.delegate,
              estimate: n.estimate,
              parentIssue: r ? void 0 : n.parent?.value,
              project: n.project,
              projectMilestone: n.projectMilestone?.value,
              cycle: n.cycle?.value,
              state: n.state,
              labels: n.labels.elements,
              dueDate: n.dueDate,
              attachments: n.allAttachments.elements,
              draftId: n.createdFromDraftId,
              lastAppliedTemplate: n.lastAppliedTemplate?.value,
              sourceCommentId: n.sourceComment?.id,
              sourcePullRequestCommentId: n.sourcePullRequestComment?.id,
              needs: n.needs.elements,
              schedule: n.schedule
          }, r)
      }
      static createOrUpdate(e, t, n, r) {
          let {title: i, descriptionData: a, priority: o, assignee: s, delegate: c, estimate: l, parentIssue: u, project: d, projectMilestone: f, cycle: p, state: m, labels: h, dueDate: g, attachments: _, draftId: ee, lastAppliedTemplate: te, sourceCommentId: ne, sourcePullRequestCommentId: re, needs: ie, schedule: ae} = n
            , oe = (ee ? this.store.findById(CH, ee) : void 0) ?? new CH;
          return Mt( () => {
              oe.creator = t,
              oe.teamId = e.id,
              oe.title = i || ``,
              oe.descriptionData = a,
              oe.stateId = m && e === m.team && e.userCanChangeIssueStatus(t) ? m.id : m ? e.defaultStateForType(m.type).id : e.defaultState(t).id,
              oe.priority = o || zl.NoPriority,
              oe.assigneeId = s?.id,
              oe.delegateId = c?.id,
              oe.cycleId = p && e.cycles.map(e => e.id).includes(p.id) ? p.id : void 0,
              oe.estimate = l,
              oe.projectId = d && d.accessibleTeams.contains(e) ? d.id : void 0,
              oe.lastAppliedTemplate = te ? vm.wrap(te) : void 0,
              oe.projectMilestoneId = oe.projectId && f && f.project.id === oe.projectId ? f.id : void 0,
              oe.dueDate = g,
              oe.sourceCommentId = ne,
              oe.sourcePullRequestCommentId = re,
              r ? oe.parent = r : oe.parentIssue = u ? vm.wrap(u) : void 0,
              oe.labels.clear(),
              h && h.filter(t => !t.team || t.team === e).forEach(e => oe.labels.add(e)),
              oe.attachments = _ ? _.map(e => ({
                  title: e.title,
                  url: e.url
              })) : [],
              oe.needs = ie ? ie.map(e => ({
                  customerId: e.customer?.id,
                  bodyData: e.bodyData,
                  priority: e.priority.priority,
                  attachmentUrl: e.attachmentUrl
              })).filter(e => e.customerId !== void 0) : [],
              oe.schedule = ae
          }
          ),
          oe
      }
      issueHaveSameDraftValues(e, t, n=[]) {
          let r = [`updatedAt`, `createdAt`, `isTemplateWithNoDefaultTeam`, `sortOrder`, `subIssueSortOrder`, `id`, ...n]
            , i = (0,
          xH.default)((0,
          SH.default)(t.serialize(), r), (0,
          SH.default)(e.serialize(), r))
            , a = !t.documentContent.value?.hasContent && !e.documentContent.value?.hasContent || (0,
          xH.default)(t.documentContent.value?.contentData, e.documentContent.value?.contentData)
            , o = (0,
          xH.default)(e.allAttachments.map(e => e.id), t.allAttachments.map(e => e.id));
          return a && i && o
      }
  }
  ,
  M([R({
      default: ``
  })], wH.prototype, `title`, void 0),
  M([R({
      default: ``
  })], wH.prototype, `teamId`, void 0),
  M([cg( () => K, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], wH.prototype, `team`, void 0),
  M([R({
      indexed: !0
  })], wH.prototype, `cycleId`, void 0),
  M([R({
      indexed: !0
  })], wH.prototype, `projectId`, void 0),
  M([R({
      indexed: !0
  })], wH.prototype, `projectMilestoneId`, void 0),
  M([R({
      serializer: Mh,
      shallowObservation: !0
  })], wH.prototype, `descriptionData`, void 0),
  M([B( () => wH, `children`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], wH.prototype, `parent`, void 0),
  M([sg( () => Y, `draftChildren`, {
      nullable: !0,
      indexed: !0
  })], wH.prototype, `parentIssue`, void 0),
  M([R({
      persistence: `createOnly`
  })], wH.prototype, `sourceCommentId`, void 0),
  M([R({
      persistence: `createOnly`
  })], wH.prototype, `sourcePullRequestCommentId`, void 0),
  M([og( () => wH, {
      order: new P(`subIssueSortOrder`).and(`createdAt`)
  })], wH.prototype, `children`, void 0),
  M([R({
      serializer: HR,
      default: zl.createFromPriority
  })], wH.prototype, `priority`, void 0),
  M([R()], wH.prototype, `estimate`, void 0),
  M([B( () => J, `issueDrafts`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], wH.prototype, `creator`, void 0),
  M([R()], wH.prototype, `assigneeId`, void 0),
  M([R()], wH.prototype, `delegateId`, void 0),
  M([cg( () => ux, {
      persistence: `none`,
      nullable: !0,
      indexed: !0
  })], wH.prototype, `state`, void 0),
  M([R()], wH.prototype, `stateId`, void 0),
  M([R()], wH.prototype, `subIssueSortOrder`, void 0),
  M([fg( () => OH, `issueDrafts`, {
      indexed: !0,
      order: new P(`name`)
  })], wH.prototype, `labels`, void 0),
  M([R({
      serializer: jh
  })], wH.prototype, `dueDate`, void 0),
  M([R({
      serializer: Mh,
      shallowObservation: !0,
      default: []
  })], wH.prototype, `attachments`, void 0),
  M([R({
      serializer: Mh,
      shallowObservation: !0,
      default: []
  })], wH.prototype, `needs`, void 0),
  M([R({
      serializer: Mh,
      shallowObservation: !0,
      persistence: `createAndUpdate`
  })], wH.prototype, `schedule`, void 0),
  M([L], wH.prototype, `markdownDescription`, null),
  M([I], wH, `createOrUpdateFromIssue`, null),
  M([I], wH, `createOrUpdate`, null),
  wH = CH = M([mg(`IssueDraft`)], wH)
}
)), EH, DH, OH, kH = t(( () => {
  EH = e(Ee(), 1),
  Bu(),
  wv(),
  Ev(),
  Av(),
  Pv(),
  Iv(),
  up(),
  Bv(),
  bH(),
  Lq(),
  TH(),
  iU(),
  mH(),
  GU(),
  V(),
  F(),
  Nm(),
  KA(),
  FA(),
  eu(),
  sk(),
  Ih(),
  Ck(),
  N(),
  OH = DH = class extends Yh {
      constructor(...e) {
          super(...e),
          this.toggleFavorite = () => {
              if (this.favorite)
                  return this.favorite.delete(),
                  !1;
              {
                  let e = yH.create({
                      reference: this
                  });
                  return e.save(!0),
                  e
              }
          }
      }
      get issuesInherited() {
          return new ok(Y,[this.issues, ...this.inheritedBy.map(e => e.issues)])
      }
      get identifier() {
          return this.name.toLowerCase().replace(/[^\w]/g, `_`)
      }
      get isTeamLabel() {
          return !!this.team?.id
      }
      getActualLabel() {
          return this.inheritedFrom ?? this
      }
      getOwner() {
          return this.team ?? this.organization
      }
      getUsedByCount() {
          return this.allIssuesInherited.length
      }
      get usedByTriageRuleCount() {
          return this.associatedTriageRules.length
      }
      get associatedTriageRules() {
          let e = new Set([this.id, ...this.children.elements.map(e => e.id)])
            , t = new Set([this.name, ...this.children.elements.map(e => e.name)]);
          return this.organization.triageWorkflowDefinitions.filter(n => {
              if (!n.enabled)
                  return !1;
              let r = n.activities.some(t => t.updateIssue?.property === Fv.labels && t.updateIssue?.value && JSON.parse(t.updateIssue.value).some(t => e.has(t)))
                , i = n.conditions?.some(e => e?.issueFilter && Sk.getIssueLabelsFromFilter(e.issueFilter).some(e => typeof e == `string` && t.has(e))) ?? !1;
              return r || i
          }
          )
      }
      get usedBySLARuleCount() {
          return this.associatedSLARules.length
      }
      get associatedSLARules() {
          let e = new Set([this.name, ...this.children.elements.map(e => e.name)]);
          return this.organization.workflowDefinitions.filter(t => !!(t.type === op.sla && t.enabled && t.conditions?.some(t => t?.issueFilter && Sk.getIssueLabelsFromFilter(t.issueFilter).some(t => typeof t == `string` && e.has(t)))))
      }
      get isInBatchOperation() {
          if (this.parent?.isInBatchOperation)
              return !0;
          let e = [Rv.LabelMove, Rv.LabelMerge];
          return !!this.organization.batchOperations.filter(t => t.status !== Lv.finished && e.includes(t.type)).find(e => {
              if (e.type === Rv.LabelMove) {
                  let {labelIds: t=[]} = e.parameters?.labelMoveParameters || {};
                  return t.includes(this.id)
              }
              if (e.type === Rv.LabelMerge) {
                  let {toLabelId: t, fromLabelIds: n=[]} = e.parameters?.labelMergeParameters || {};
                  return t === this.id || n.includes(this.id)
              }
              return !1
          }
          )
      }
      getAssociatedModels() {
          return this.issues.elements
      }
      getIsExternal() {
          return this.isExternal
      }
      getMaxLabelsPerGroupQuota() {
          return jv.maxIssueLabelsPerGroup
      }
      get sortName() {
          return Cv.normalizeString(this.name)
      }
      get allIssues() {
          return new ok(Y,[this.issues, ...this.children.map(e => e.issues)])
      }
      get allIssuesInherited() {
          return new ok(Y,[this.issuesInherited, ...this.children.map(e => e.issuesInherited)])
      }
      getViewPreferences() {
          return this._viewPreferences
      }
      get _viewPreferences() {
          return NA.getOrCreateFrom(this.viewPreferences, k.label, {
              label: this,
              team: this.team
          })
      }
      get type() {
          return this.isGroup ? kv.Group : this.parent ? kv.Child : kv.Root
      }
      get isRetired() {
          return !!this.retiredAt || !!this.parent?.isRetired
      }
      get isExternal() {
          return this.externalEntityRelations.length > 0
      }
      static create({parent: e, owner: t, isGroup: n}) {
          let r = DH.createEmpty();
          return r.parent = e,
          r.name = ``,
          r.team = t instanceof K ? t : void 0,
          r.organization = t instanceof q ? t : t.organization,
          r.color = e?.color ?? (0,
          EH.default)(Tv.colorsList) ?? Tv.defaultTeamIconBackground,
          r.isGroup = n ?? !1,
          r
      }
      matchesLabelName(e) {
          return this.name.toLowerCase().trim() === e.name.toLowerCase().trim()
      }
      save(e=!1, t) {
          return super.save(e, t)
      }
      matchInlineFind(e) {
          return $l([this.name, this.parent?.name].concrete().join(`   `)).toLowerCase().indexOf(e) !== -1
      }
  }
  ,
  M([R({
      default: ``
  })], OH.prototype, `name`, void 0),
  M([R()], OH.prototype, `description`, void 0),
  M([R({
      default: `#f00`
  })], OH.prototype, `color`, void 0),
  M([R({
      default: !1
  })], OH.prototype, `isGroup`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], OH.prototype, `lastAppliedAt`, void 0),
  M([R({
      serializer: Ah
  })], OH.prototype, `retiredAt`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !0,
      nullable: !1
  })], OH.prototype, `retiredBy`, void 0),
  M([B( () => q, `allIssueLabels`, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], OH.prototype, `organization`, void 0),
  M([B( () => K, `issueLabels`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], OH.prototype, `team`, void 0),
  M([ug({
      nullable: !0
  })], OH.prototype, `favorite`, void 0),
  M([ug({
      nullable: !0
  })], OH.prototype, `subscription`, void 0),
  M([z( () => Y, {
      index: `labelIds`
  })], OH.prototype, `issues`, void 0),
  M([z( () => wH, {
      index: `labelIds`
  })], OH.prototype, `issueDrafts`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !0,
      nullable: !1
  })], OH.prototype, `creator`, void 0),
  M([B( () => OH, `children`, {
      optional: !0,
      nullable: !1,
      indexed: !0
  })], OH.prototype, `parent`, void 0),
  M([B( () => OH, `inheritedBy`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], OH.prototype, `inheritedFrom`, void 0),
  M([og( () => OH)], OH.prototype, `inheritedBy`, void 0),
  M([z( () => OH, {
      index: `parentId`,
      order: new P(`name`)
  })], OH.prototype, `children`, void 0),
  M([z( () => GA, {
      index: `labelId`
  })], OH.prototype, `externalEntityRelations`, void 0),
  M([z( () => NA, {
      index: `labelId`,
      canSkipHydration: e => e.organization.viewPreferences.isHydrated()
  })], OH.prototype, `viewPreferences`, void 0),
  M([L], OH.prototype, `usedByTriageRuleCount`, null),
  M([L], OH.prototype, `associatedTriageRules`, null),
  M([L], OH.prototype, `usedBySLARuleCount`, null),
  M([L], OH.prototype, `associatedSLARules`, null),
  M([L], OH.prototype, `isInBatchOperation`, null),
  M([L], OH.prototype, `sortName`, null),
  M([L], OH.prototype, `allIssues`, null),
  M([L], OH.prototype, `allIssuesInherited`, null),
  M([L], OH.prototype, `_viewPreferences`, null),
  M([L], OH.prototype, `type`, null),
  M([L], OH.prototype, `isRetired`, null),
  OH = DH = M([mg(`IssueLabel`)], OH)
}
));
function Ule() {
  return new P(e => e.subjectTeam ? 0 : e.subjectUser ? 1 : e.subjectProject ? 2 : e.subjectLabel ? 3 : 999).and(`createdAt`, `desc`)
}
var AH, jH = t(( () => {
  Ng(),
  ml(),
  bv(),
  V(),
  F(),
  om(),
  Nm(),
  kH(),
  iU(),
  iz(),
  mH(),
  GU(),
  N(),
  AH = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      get asMarkdown() {
          return _v(this.bodyData).trim()
      }
  }
  ,
  M([B( () => q, `aiPromptMemories`, {
      indexed: !0,
      nullable: !1,
      optional: !1,
      persistence: `none`
  })], AH.prototype, `organization`, void 0),
  M([B( () => K, `aiPromptMemories`, {
      indexed: !0,
      nullable: !1,
      optional: !1,
      persistence: `none`
  })], AH.prototype, `team`, void 0),
  M([R({
      enum: Ag,
      persistence: `none`,
      default: Ag.productIntelligence
  })], AH.prototype, `type`, void 0),
  M([R({
      persistence: `none`,
      default: () => pl()
  })], AH.prototype, `bodyData`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `none`
  })], AH.prototype, `subjectUser`, void 0),
  M([cg( () => K, {
      nullable: !0,
      persistence: `none`
  })], AH.prototype, `subjectTeam`, void 0),
  M([cg( () => G, {
      nullable: !0,
      persistence: `none`
  })], AH.prototype, `subjectProject`, void 0),
  M([cg( () => OH, {
      nullable: !0,
      persistence: `none`
  })], AH.prototype, `subjectLabel`, void 0),
  M([L], AH.prototype, `asMarkdown`, null),
  AH = M([mg(`AiPromptMemory`)], AH)
}
)), MH, NH = t(( () => {
  iU(),
  GU(),
  V(),
  F(),
  om(),
  mx(),
  eu(),
  N(),
  MH = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular;
      matchInlineFind(e) {
          return $l([this.name, this.creator?.name, this.creator?.displayName].concrete().join(` `)).toLowerCase().indexOf(e) !== -1
      }
      static #n = this.hydrateAfterStartupConfig = {
          priority: px.low,
          execute: async e => {
              await e.emojis.hydrate()
          }
      }
  }
  ,
  M([R({
      indexed: !0,
      default: ``
  })], MH.prototype, `name`, void 0),
  M([R({
      default: ``
  })], MH.prototype, `url`, void 0),
  M([R({
      persistence: `none`
  })], MH.prototype, `color`, void 0),
  M([R({
      persistence: `none`,
      default: `user`
  })], MH.prototype, `source`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0
  })], MH.prototype, `creator`, void 0),
  M([B( () => q, `emojis`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], MH.prototype, `organization`, void 0),
  MH = M([mg(`Emoji`)], MH)
}
));
async function Wle(e, t) {
  let n = Ut`
  mutation OauthClientRotateSecret($id: String!) {
    oauthClientRotateSecret(id: $id) {
      success
    }
  }
`;
  return e.mutate(n, t)
}
var Gle = t(( () => {
  Wt()
}
)), PH, FH = t(( () => {
  F(),
  V(),
  iU(),
  Gle(),
  om(),
  GU(),
  N(),
  PH = class extends Jh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.full;
      get mustUseRefreshTokens() {
          return this.createdAt >= new Date(`2025-10-01T00:00:00Z`)
      }
      rotateSecret() {
          if (this.store)
              return Wle(this.store.graphQLClient, {
                  id: this.id
              })
      }
  }
  ,
  M([R({
      persistence: `none`,
      default: ``
  })], PH.prototype, `clientId`, void 0),
  M([R({
      persistence: `none`,
      default: ``
  })], PH.prototype, `clientSecret`, void 0),
  M([R({
      default: ``
  })], PH.prototype, `name`, void 0),
  M([R()], PH.prototype, `externalUserMapping`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], PH.prototype, `creator`, void 0),
  M([R()], PH.prototype, `description`, void 0),
  M([R({
      default: ``
  })], PH.prototype, `developer`, void 0),
  M([R({
      default: ``
  })], PH.prototype, `developerUrl`, void 0),
  M([R()], PH.prototype, `imageUrl`, void 0),
  M([R({
      default: []
  })], PH.prototype, `redirectUris`, void 0),
  M([R({
      default: !1
  })], PH.prototype, `publicEnabled`, void 0),
  M([B( () => q, `oauthClients`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], PH.prototype, `organization`, void 0),
  M([R({
      default: []
  })], PH.prototype, `webhookResourceTypes`, void 0),
  M([R()], PH.prototype, `webhookUrl`, void 0),
  M([R({
      default: !0
  })], PH.prototype, `webhookEnabled`, void 0),
  M([R({
      isVirtual: !0
  })], PH.prototype, `webhookSecret`, void 0),
  M([R({
      default: !0
  })], PH.prototype, `useRefreshTokens`, void 0),
  M([R({
      default: !1
  })], PH.prototype, `supportsClientCredentials`, void 0),
  PH = M([mg(`OauthClient`)], PH)
}
)), IH, LH = t(( () => {
  IH = function(e) {
      return e.saml = `saml`,
      e.general = `general`,
      e
  }({})
}
)), RH, zH = t(( () => {
  RH = function(e) {
      return e.general = `general`,
      e.webForms = `webForms`,
      e
  }({})
}
)), BH, VH, HH = t(( () => {
  zH(),
  V(),
  F(),
  Nm(),
  iU(),
  WH(),
  Ih(),
  GU(),
  N(),
  BH = class extends Yh {
      get urlId() {
          return this.defaultMigrated ? this.organization.id : this.id
      }
      get samlConfig() {
          return {
              ssoEndpoint: this.ssoEndpoint,
              ssoBinding: this.ssoBinding,
              ssoSignAlgo: this.ssoSignAlgo,
              ssoSigningCert: this.ssoSigningCert,
              issuerEntityId: this.issuerEntityId
          }
      }
      get samlMetadata() {
          let e = this.ssoEndpoint ? new URL(this.ssoEndpoint).hostname : void 0
            , t = t => e === t || e?.endsWith(`.${t}`);
          return t(`okta.com`) ? {
              type: VH.okta,
              name: `Okta`
          } : t(`onelogin.com`) ? {
              type: VH.onelogin,
              name: `OneLogin`
          } : t(`google.com`) ? {
              type: VH.google,
              name: `Google`
          } : t(`login.microsoftonline.com`) ? {
              type: VH.entra,
              name: `Microsoft Entra`
          } : t(`jumpcloud.com`) ? {
              type: VH.jumpcloud,
              name: `JumpCloud`
          } : t(`rippling.com`) ? {
              type: VH.rippling,
              name: `Rippling`
          } : t(`cloudflareaccess.com`) ? {
              type: VH.cloudflareaccess,
              name: `Cloudflare Access`
          } : {
              type: VH.generic,
              name: `IdP${e ? ` (` + e + `)` : ``}`
          }
      }
      get scimSettings() {
          return {
              ownersGroupPush: this.ownersGroupPush,
              adminsGroupPush: this.adminsGroupPush,
              guestsGroupPush: this.guestsGroupPush,
              allowNameChange: this.allowNameChange
          }
      }
      get isSamlConfigured() {
          return !!this.ssoEndpoint
      }
      get claimedDomains() {
          return this.domains.filter(e => e.claimed)
      }
  }
  ,
  M([B( () => q, `identityProviders`, {
      optional: !1,
      nullable: !1
  })], BH.prototype, `organization`, void 0),
  M([R({
      default: !1,
      persistence: `none`
  })], BH.prototype, `defaultMigrated`, void 0),
  M([R({
      persistence: `createOnly`,
      default: RH.general
  })], BH.prototype, `type`, void 0),
  M([z( () => UH, {
      index: `identityProviderId`,
      order: new P(`name`)
  })], BH.prototype, `domains`, void 0),
  M([R({
      default: !1,
      persistence: `updateOnly`
  })], BH.prototype, `samlEnabled`, void 0),
  M([R({
      persistence: `none`
  })], BH.prototype, `ssoEndpoint`, void 0),
  M([R({
      persistence: `none`
  })], BH.prototype, `ssoBinding`, void 0),
  M([R({
      persistence: `none`
  })], BH.prototype, `ssoSignAlgo`, void 0),
  M([R({
      persistence: `none`
  })], BH.prototype, `ssoSigningCert`, void 0),
  M([R({
      persistence: `none`
  })], BH.prototype, `issuerEntityId`, void 0),
  M([R({
      persistence: `createOnly`
  })], BH.prototype, `spEntityId`, void 0),
  M([R({
      persistence: `updateOnly`
  })], BH.prototype, `priority`, void 0),
  M([R({
      default: !1,
      persistence: `updateOnly`
  })], BH.prototype, `scimEnabled`, void 0),
  M([R({
      serializer: Mh,
      persistence: `updateOnly`
  })], BH.prototype, `ownersGroupPush`, void 0),
  M([R({
      serializer: Mh,
      persistence: `updateOnly`
  })], BH.prototype, `adminsGroupPush`, void 0),
  M([R({
      serializer: Mh,
      persistence: `updateOnly`
  })], BH.prototype, `guestsGroupPush`, void 0),
  M([R({
      default: !1,
      persistence: `updateOnly`
  })], BH.prototype, `allowNameChange`, void 0),
  M([z( () => J, {
      index: `identityProviderId`,
      order: new P(`name`)
  })], BH.prototype, `users`, void 0),
  M([L], BH.prototype, `urlId`, null),
  M([L], BH.prototype, `samlConfig`, null),
  M([L], BH.prototype, `samlMetadata`, null),
  M([L], BH.prototype, `scimSettings`, null),
  M([L], BH.prototype, `isSamlConfigured`, null),
  M([L], BH.prototype, `claimedDomains`, null),
  BH = M([mg(`IdentityProvider`)], BH),
  VH = function(e) {
      return e.okta = `okta`,
      e.onelogin = `onelogin`,
      e.google = `google`,
      e.entra = `entra`,
      e.jumpcloud = `jumpcloud`,
      e.rippling = `rippling`,
      e.cloudflareaccess = `cloudflareaccess`,
      e.generic = `generic`,
      e
  }(VH || {})
}
)), UH, WH = t(( () => {
  LH(),
  iU(),
  HH(),
  GU(),
  V(),
  F(),
  om(),
  N(),
  UH = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.full;
      save(e=!1, t) {
          return super.save(e, t)
      }
  }
  ,
  M([R({
      persistence: `createOnly`,
      default: ``
  })], UH.prototype, `name`, void 0),
  M([R({
      persistence: `none`,
      default: !1
  })], UH.prototype, `verified`, void 0),
  M([R({
      persistence: `none`,
      default: !1
  })], UH.prototype, `claimed`, void 0),
  M([R({
      persistence: `updateOnly`
  })], UH.prototype, `disableOrganizationCreation`, void 0),
  M([B( () => q, `domains`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], UH.prototype, `organization`, void 0),
  M([B( () => BH, `domains`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], UH.prototype, `identityProvider`, void 0),
  M([cg( () => J, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], UH.prototype, `creator`, void 0),
  M([R({
      persistence: `createOnly`
  })], UH.prototype, `verificationEmail`, void 0),
  M([R({
      persistence: `createOnly`,
      default: IH.general
  })], UH.prototype, `authType`, void 0),
  UH = M([mg(`OrganizationDomain`)], UH)
}
)), GH, KH = t(( () => {
  zn(),
  du(),
  iU(),
  mH(),
  GU(),
  V(),
  F(),
  Ih(),
  om(),
  N(),
  GH = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.full;
      delete() {
          return super.delete()
      }
      get roleLabel() {
          switch (this.role) {
          case su.owner:
              return `Owner`;
          case su.admin:
              return `Admin`;
          case su.guest:
              return `Guest`;
          case su.user:
              return `Member`;
          case su.app:
              return `App`;
          default:
              throw y(this.role)
          }
      }
      get isAccepted() {
          return !!this.acceptedAt && this.acceptedAt <= new Date
      }
      get isExpired() {
          return this.isAccepted === !0 ? !0 : !!this.expiresAt && this.expiresAt <= new Date
      }
      get naturalIdentity() {
          return this.email.toLowerCase().trim()
      }
  }
  ,
  M([R({
      persistence: `createOnly`,
      default: ``
  })], GH.prototype, `email`, void 0),
  M([R({
      enum: su,
      persistence: `createOnly`,
      default: su.user
  })], GH.prototype, `role`, void 0),
  M([cg( () => J, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], GH.prototype, `invitee`, void 0),
  M([cg( () => J, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], GH.prototype, `inviter`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], GH.prototype, `acceptedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], GH.prototype, `expiresAt`, void 0),
  M([fg( () => K, void 0, {
      indexed: !0
  })], GH.prototype, `teams`, void 0),
  M([B( () => q, `invites`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], GH.prototype, `organization`, void 0),
  M([R({
      serializer: Fh,
      persistence: `createOnly`
  })], GH.prototype, `metadata`, void 0),
  GH = M([mg(`OrganizationInvite`)], GH)
}
)), qH, JH, Kle = t(( () => {
  zn(),
  qH = function(e) {
      return e.active = `active`,
      e.canceled = `canceled`,
      e.incomplete = `incomplete`,
      e.incompleteExpired = `incomplete_expired`,
      e.pastDue = `past_due`,
      e.trialing = `trialing`,
      e.unpaid = `unpaid`,
      e
  }({}),
  JH = class {
      static #e = this.activeStatuses = [qH.active, qH.pastDue, qH.trialing];
      static isActiveStatus(e) {
          return this.activeStatuses.includes(e)
      }
      static displayName(e) {
          switch (e) {
          case qH.active:
              return `Active`;
          case qH.canceled:
              return `Canceled`;
          case qH.incomplete:
              return `Incomplete`;
          case qH.incompleteExpired:
              return `Expired`;
          case qH.pastDue:
              return `Past due`;
          case qH.trialing:
              return `Trialing`;
          case qH.unpaid:
              return `Unpaid`;
          default:
              return y(e),
              `Unknown`
          }
      }
  }
}
)), YH, XH = t(( () => {
  hd(),
  F(),
  V(),
  $H(),
  N(),
  YH = class extends Jh {
      isPlanItem() {
          return this.type === fd.plan
      }
      isAddOnItem() {
          return this.type === fd.addOn
      }
  }
  ,
  M([R({
      persistence: `createOnly`,
      default: fd.plan
  })], YH.prototype, `type`, void 0),
  M([R({
      persistence: `createOnly`,
      default: 0
  })], YH.prototype, `units`, void 0),
  M([R({
      persistence: `createOnly`
  })], YH.prototype, `unitsMinimum`, void 0),
  M([R({
      persistence: `createOnly`
  })], YH.prototype, `unitsMaximum`, void 0),
  M([R({
      persistence: `createOnly`,
      default: j.free
  })], YH.prototype, `stripePriceId`, void 0),
  M([B( () => QH, `items`, {
      optional: !1,
      nullable: !1,
      persistence: `createOnly`
  })], YH.prototype, `subscription`, void 0),
  YH = M([mg(`SubscriptionItem`)], YH)
}
)), ZH, QH, $H = t(( () => {
  Oe(),
  ZH = e(we(), 1),
  nt(),
  hd(),
  Kle(),
  vd(),
  F(),
  V(),
  Ih(),
  XH(),
  iU(),
  N(),
  QH = class extends Jh {
      get quantity() {
          return (0,
          ZH.default)(this.seats, this.seatsMinimum || 0, this.seatsMaximum || 1 / 0)
      }
      get isActive() {
          return !this.archivedAt && JH.isActiveStatus(this.stripeStatus)
      }
      get pastDue() {
          return !this.archivedAt && this.stripeStatus === qH.pastDue
      }
      get cancelationDate() {
          if (!(this.type === j.free || !this.canceledAt || !this.isActive))
              return this.cancelAt || this.billingPeriodEnd
      }
      get nextBillingDate() {
          if (!(this.canceledAt || !this.isActive))
              return this.billingPeriodEnd
      }
      get legacyAutoSwitchDate() {
          if (!this.nextBillingAt)
              return;
          if (je(this.nextBillingAt, new Date(2026,1,1)))
              return this.nextBillingAt;
          let e = md.billingPeriodForSubscription(this.type)
            , t = this.nextBillingAt;
          for (; Ne(t, new Date(2026,1,1)); )
              t = e === cd.month ? Re(t, 1) : ut(t, 1);
          return t
      }
      isChangePending(e) {
          return !!(this.pendingChangeType && this.pendingChangeType === e)
      }
      canDowngradeTo(e) {
          let t = md.planForSubscriptionType(this.type);
          return e === t ? !1 : md.canSelfManageSubscriptionType(this.type) && _d.isPlanEqualOrBetterThan(t, e)
      }
      canUpgradeTo(e) {
          let t = md.planForSubscriptionType(this.type);
          return e === t ? !1 : _d.isPlanEqualOrBetterThan(e, t)
      }
      get changePending() {
          return !!(this.cancelationDate || this.pendingChangeType)
      }
      get details() {
          return {
              planType: md.planForSubscriptionType(this.type),
              billingPeriod: md.billingPeriodForSubscription(this.type),
              monthlyPrice: md.pricePerSeatForSubscription(this.type)
          }
      }
      get billingPeriodEnd() {
          if (this.type === j.free || !this.isActive)
              return;
          if (this.nextBillingAt)
              return this.nextBillingAt;
          let e = md.billingPeriodForSubscription(this.type)
            , t = De(this.createdAt);
          return new Date(t.add(t.diff(De(), e) + 1, e).epoch)
      }
  }
  ,
  M([R({
      persistence: `createOnly`,
      default: j.free
  })], QH.prototype, `type`, void 0),
  M([R({
      persistence: `createOnly`,
      default: 0
  })], QH.prototype, `seats`, void 0),
  M([R({
      persistence: `createOnly`
  })], QH.prototype, `seatsMinimum`, void 0),
  M([R({
      persistence: `createOnly`
  })], QH.prototype, `seatsMaximum`, void 0),
  M([R()], QH.prototype, `pendingChangeType`, void 0),
  M([B( () => q, `subscriptions`, {
      optional: !1,
      nullable: !1,
      persistence: `createOnly`
  })], QH.prototype, `organization`, void 0),
  M([R({
      serializer: Ah
  })], QH.prototype, `canceledAt`, void 0),
  M([R({
      persistence: `none`,
      serializer: Ah
  })], QH.prototype, `cancelAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `createOnly`
  })], QH.prototype, `nextBillingAt`, void 0),
  M([R({
      persistence: `none`,
      default: qH.active
  })], QH.prototype, `stripeStatus`, void 0),
  M([R({
      default: ld.automatic
  })], QH.prototype, `collectionMethod`, void 0),
  M([og( () => YH)], QH.prototype, `items`, void 0),
  QH = M([mg(`Subscription`)], QH)
}
)), eU, tU, nU = t(( () => {
  Bv(),
  V(),
  F(),
  om(),
  iU(),
  GU(),
  N(),
  tU = class extends Yh {
      static #e = eU = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static #r = this.partialPreloadForTeam = am.firstPriority;
      static createIssueSuggestionsBatchOperation(e) {
          return eU.create({
              type: Rv.IssueSuggestions,
              parameters: {
                  issueSuggestionsParameters: e
              }
          })
      }
      static createLabelMoveBatchOperation(e) {
          return eU.create({
              type: Rv.LabelMove,
              parameters: {
                  labelMoveParameters: e
              }
          })
      }
      static createLabelMergeBatchOperation(e) {
          return eU.create({
              type: Rv.LabelMerge,
              parameters: {
                  labelMergeParameters: e
              }
          })
      }
      static create(e) {
          let {type: t, parameters: n} = e
            , r = eU.createEmpty();
          return r.type = t,
          r.parameters = n,
          r
      }
  }
  ,
  M([B( () => q, `batchOperations`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], tU.prototype, `organization`, void 0),
  M([B( () => J, `batchOperations`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], tU.prototype, `creator`, void 0),
  M([R({
      persistence: `createOnly`,
      default: Rv.IssueSuggestions
  })], tU.prototype, `type`, void 0),
  M([R({
      persistence: `none`,
      default: Lv.created
  })], tU.prototype, `status`, void 0),
  M([R({
      persistence: `createOnly`
  })], tU.prototype, `parameters`, void 0),
  M([R({
      persistence: `none`
  })], tU.prototype, `result`, void 0),
  M([R({
      persistence: `none`
  })], tU.prototype, `progress`, void 0),
  tU = eU = M([mg(`BatchOperation`)], tU)
}
)), rU, q, iU = t(( () => {
  nt(),
  _n(),
  Vee(),
  Un(),
  zd(),
  Vd(),
  Ud(),
  Xd(),
  Xs(),
  iu(),
  $d(),
  tf(),
  Kd(),
  rf(),
  Yf(),
  ap(),
  up(),
  vd(),
  hd(),
  fp(),
  Ru(),
  Yr(),
  cc(),
  nc(),
  Od(),
  du(),
  gp(),
  pi(),
  kg(),
  jH(),
  wR(),
  oU(),
  V(),
  F(),
  Tm(),
  Nm(),
  FB(),
  dB(),
  bB(),
  Pz(),
  Ij(),
  ex(),
  NH(),
  Iy(),
  HA(),
  VR(),
  zR(),
  MV(),
  Xp(),
  DM(),
  rB(),
  Lq(),
  Rj(),
  kH(),
  FH(),
  YL(),
  WH(),
  KH(),
  iz(),
  Dk(),
  eM(),
  tj(),
  Ih(),
  $H(),
  mH(),
  gx(),
  Wz(),
  GU(),
  FA(),
  sH(),
  dH(),
  HH(),
  ws(),
  nU(),
  Oj(),
  Dce(),
  Uj(),
  TA(),
  N(),
  q = class extends Jh {
      static #e = rU = this;
      constructor(...e) {
          super(...e),
          this.allowedAiProviders = [],
          this.teamsPendingDelete = new Map,
          this.emojiByNameHydrationPromise = new Map
      }
      static #t = this.urlKeySchema = Bee().min(Qd.minUrlKeyLength, `Too short, must be at least ${Qd.minUrlKeyLength} characters`).max(Qd.maxUrlKeyLength, `Too long, cannot be more than ${Qd.maxUrlKeyLength} characters`).matches(Qd.validUrlKeyFormat, `Invalid format, can only contain letters, numbers, and dashes`).required(`Required`);
      get projectsPageFacets() {
          return this.facets.filter(e => e.sourcePage === `projects`)
      }
      get asksEmailIntakeAddresses() {
          return this.emailIntakeAddresses.filter(e => e.type === Pu.asks)
      }
      get isSingletonModel() {
          return !0
      }
      get isSamlEnabled() {
          return this.samlEnabled || this.identityProviders.some(e => e.samlEnabled)
      }
      get isScimEnabled() {
          return this.scimEnabled || this.identityProviders.some(e => e.scimEnabled)
      }
      get billedUserCount() {
          let e = this.activeSubscription;
          return dp(this.billedUsers.length, e?.seatsMinimum || 0, e?.seatsMaximum || 1 / 0)
      }
      get orderedRolloutStages() {
          let e = this.rolloutStages.groupBy(`type`);
          return [e.getCollectionOfGroup(Hd.dev)?.elements, e.getCollectionOfGroup(Hd.internal)?.elements, e.getCollectionOfGroup(Hd.partial)?.elements, e.getCollectionOfGroup(Hd.full)?.elements].flat().concrete()
      }
      get planFeatureOverridesArray() {
          return this.planFeatureOverrides?.filter(e => !e.expiresAt || e.expiresAt > Date.now()).map(e => e.feature) ?? []
      }
      get issueLabels() {
          return this.allIssueLabels.filter(e => e.isTeamLabel === !1)
      }
      get templates() {
          return this.allTemplates.filter(e => e.isTeamTemplate === !1 && e.isClone === !1)
      }
      get customViews() {
          return this.allCustomViews.filter(e => e.team === void 0 && sc(e.traits, Rd.hasFacet) === !1)
      }
      get dashboards() {
          return this.allDashboards.filter(e => e.team === void 0)
      }
      get projectVelocityDeciles() {
          let e = this.projects.filter(e => e.isActive && e.currentVelocity > .5).orderBy(`currentVelocity`)
            , t = [];
          for (let n = 0; n < 10; n++) {
              let r = Math.floor(e.length * n / 10);
              t.push(e.elements[r]?.currentVelocity ?? 0)
          }
          return t
      }
      get projectActivityAvailable() {
          return this.projects.filter(e => e.isActive && e.currentVelocity > .5).length > 10
      }
      get initiativesEnabled() {
          return this.roadmapEnabled
      }
      set initiativesEnabled(e) {
          this.roadmapEnabled = e
      }
      get subInitiativesAvailable() {
          return this.initiativesEnabled && this.canAccess(gd.subInitiatives)
      }
      get initiativeViewsAvailable() {
          return this.subInitiativesAvailable
      }
      get dashboardsAvailable() {
          return this.canAccess(gd.dashboards)
      }
      get initiativeVelocityDeciles() {
          let e = this.initiatives.filter(e => e.isActive && e.velocity > .5).orderBy(`velocity`)
            , t = [];
          for (let n = 0; n < 10; n++) {
              let r = Math.floor(e.length * n / 10);
              t.push(e.elements[r]?.velocity ?? 0)
          }
          return t
      }
      get initiativeActivityAvailable() {
          return this.initiatives.filter(e => e.isActive && e.velocity > .5).length > 8
      }
      get workflowDefinitions() {
          return this.allWorkflowDefinitions.filter(e => e.isTeamWorkflow === !1)
      }
      get triageWorkflowDefinitions() {
          return this.allWorkflowDefinitions.filter(e => e.type === op.triage && e.triggerType === cp.issue)
      }
      get issueTemplates() {
          return this.templates.filter(e => e.type === yf.issue)
      }
      get standardIssueTemplates() {
          return this.issueTemplates.filter(e => e.isStandardIssueTemplate)
      }
      get formIssueTemplates() {
          return this.issueTemplates.filter(e => e.isFormIssueTemplate)
      }
      get documentTemplates() {
          return this.templates.filter(e => e.type === yf.document)
      }
      get projectTemplates() {
          return this.templates.filter(e => e.type === yf.project)
      }
      get accessibleTeams() {
          return rU.store.user.hasPermission(Cd.teamManagement) ? this.teams.filter(e => e.userCanAccessTeam(rU.store.user)).orderBy(`displayName`) : this.teams
      }
      get activePublicTeams() {
          return this.teams.filter(e => !e.private && !e.archivedAt)
      }
      get projectStatusStartedCount() {
          return this.projectStatuses.reduce( (e, t) => e + (t.type === Wd.started ? 1 : 0), 0)
      }
      get viewPreferencesWithoutDependencies() {
          return this.viewPreferences.filter(e => !e.hasDependencies)
      }
      getViewPreferences(e) {
          return NA.getOrCreateFrom(this.viewPreferencesWithoutDependencies, e, {})
      }
      getLabels(e) {
          return e === OH ? this.issueLabels : this.allProjectLabels
      }
      get administrableTeams() {
          return this.teams
      }
      get activeSubscription() {
          return this.subscriptions.find(e => e.isActive)
      }
      get activeAddOnTypes() {
          return this.activeSubscription?.items.map(e => e.isAddOnItem() ? md.addOnForPrice(e.stripePriceId) : void 0).filter(Boolean) ?? []
      }
      get isFreePlan() {
          if (this.isInTrial === !0)
              return !1;
          let e = this.activeSubscription;
          return e ? md.planForSubscriptionType(e?.type) === A.free : !0
      }
      get users() {
          if (this.store.user?.guest ?? !1) {
              let e = this.store.user.teams.map(e => e.id);
              return this.allUsers.filter(t => !!t.teams.find(t => e.includes(t.id)))
          }
          return this.allUsers
      }
      get activeUsers() {
          return this.users.filter(e => e.isActive)
      }
      get activeNonAppUsers() {
          return this.users.filter(e => e.isActive && !e.app)
      }
      get activeGuestUsers() {
          return this.users.filter(e => e.isActive && e.guest)
      }
      get activeAndInvitedUsers() {
          return this.users.filter(e => e.isActive || e.isInvited)
      }
      get activeAndInvitedNonAppUsers() {
          return this.activeAndInvitedUsers.filter(e => !e.app)
      }
      get mentionableUsers() {
          return this.users.filter(e => (e.isActive || e.isInvited) && e.isMentionable)
      }
      get issueAndProjectAssignableUsers() {
          return this.users.filter(e => (e.isActive || e.isInvited) && e.isAssignable)
      }
      get billedUsers() {
          return this.users.filter(e => e.isActive && !e.app)
      }
      get invitedUsers() {
          return this.users.filter(e => e.isInvited)
      }
      get appUsers() {
          return this.users.filter(e => e.app)
      }
      get assignableAppUsers() {
          return this.appUsers.filter(e => e.isAssignable)
      }
      get agentAppUsers() {
          return this.appUsers.filter(e => e.isAgentAppUser)
      }
      get suspendedUsers() {
          return this.users.filter(e => !!e.isSuspended)
      }
      get allOwners() {
          return this.users.filter(e => e.isOwner)
      }
      get allAdmins() {
          return this.users.filter(e => e.isAdmin)
      }
      get canShowRolloutStage() {
          return this.rolloutStages.length > 0 && this.getIntegration(T.launchDarkly) != null
      }
      authServiceAllowed(e) {
          return this.allowedAuthServices.length === 0 ? !0 : this.allowedAuthServices.indexOf(e) > -1
      }
      allowedDomains(e) {
          return (e ? this.domains.filter(t => t.authType === e) : this.domains).map(e => e.name)
      }
      get githubConnected() {
          return !!this.getIntegration(T.github)
      }
      canAccess(e, t) {
          if (rU.store.user.settings.developerDisabledPlanFeatures.includes(e))
              return !1;
          if (this.planFeatureOverridesArray.includes(e))
              return !0;
          let n = this.activeSubscription ? md.planForSubscriptionType(this.activeSubscription.type) : A.free
            , r = this.isInTrial ? this.trialPlanType ?? A.business : A.free
            , i = _d.isPlanEqualOrBetterThan(n, r) ? n : r
            , a = this.activeAddOnTypes;
          return _d.canAccess(e, i, {
              tierValue: t,
              addOns: a
          }) || this.isInTrial && _d.canAccess(e, r, {
              tierValue: t,
              addOns: a
          })
      }
      canAccessSome(e) {
          return e.map(e => this.canAccess(e)).some(e => e)
      }
      findUser(e) {
          return this.activeUsers.find(t => t.id === e || t.name.toLowerCase() === e.toLowerCase() || t.displayName.toLowerCase() === e.toLowerCase() || t.email.toLowerCase() === e.toLowerCase())
      }
      findTeamByKey(e) {
          let t = Y.teamKeyFromIdentifier(e);
          return this.teams.find(e => e.key === t || e.keys.find(e => t === e.name) !== void 0)
      }
      get canUseMultiSaml() {
          return this.canAccess(gd.multiSaml)
      }
      get isSuperuserWorkspace() {
          return ru.superUserUrlKeys.includes(this.urlKey)
      }
      get isInTrial() {
          if (this.activeSubscription) {
              let e = md.planForSubscriptionType(this.activeSubscription.type);
              if (_d.isPlanEqualOrBetterThan(e, this.trialPlanType ?? A.business) && !md.legacyPlanTypes.includes(e))
                  return !1
          }
          return !!this.trialEndsAt && this.trialEndsAt > new Date(gn(b.HOUR))
      }
      get isInTrialEndingSoon() {
          return this.isInTrial && !!this.trialEndsAt && $e(this.trialEndsAt, new Date(gn(b.HOUR))) < 30
      }
      get isBusinessTrialAvailable() {
          return !this.trialEndsAt && !_d.isPlanEqualOrBetterThan(this.activePlanType, A.business)
      }
      get isEnterpriseTrialAvailable() {
          return !this.trialEndsAt && !_d.isPlanEqualOrBetterThan(this.activePlanType, A.enterprise)
      }
      get activePlanType() {
          return this.activeSubscription ? md.planForSubscriptionType(this.activeSubscription.type) : A.free
      }
      get featureTier() {
          let e = this.activeSubscription ? md.planForSubscriptionType(this.activeSubscription.type) : A.free
            , t = this.isInTrial ? this.trialPlanType ?? A.business : A.free;
          return this.activeSubscription && this.isInTrial && md.deprecatedSubscriptionTypes().includes(this.activeSubscription.type) ? t : _d.isPlanEqualOrBetterThan(e, t) ? e : t
      }
      get adminPermissionOverrides() {
          let e = this.store.user?.settings?.developerWorkspaceAdminPermissionOverrides || {};
          return Dd.mergeOverrides([this.unsafeAdminPermissionOverrides, e])
      }
      get unsafeAdminPermissionOverrides() {
          let e = {};
          for (let t of Object.values(pp)) {
              let n = hp.getConfig(t);
              n.permission && (e[n.permission] = hp.getValue(this, t))
          }
          return e[Cd.workspaceCreation] = this.domains.some(e => !e.disableOrganizationCreation) || this.domains.length === 0 ? su.user : void 0,
          e
      }
      get createdDaysAgo() {
          return $e(new Date, this.createdAt)
      }
      get dangerousAllIssues() {
          return new Jp(async (e, t) => {
              try {
                  await this.store.syncClient.loadPartialModels(Y, this.accessibleTeams.map(e => e.id)),
                  await Promise.all(this.accessibleTeams.map(e => e.issues.hydrate())),
                  e(this.accessibleTeams.reduce( (e, t) => e.concat(t.issues.elements), []))
              } catch (e) {
                  t(e)
              }
          }
          )
      }
      get showProjectsPage() {
          return !this.store.user.guest
      }
      get isSlaAccessible() {
          return !!this.slaEnabled && this.canAccess(gd.sla)
      }
      setSlaEnabled(e) {
          this.slaEnabled = e
      }
      get isCustomersAccessible() {
          return this.customersEnabled && this.canAccess(gd.customers)
      }
      get isFeedAccessible() {
          return this.feedEnabled && this.canAccess(gd.feed)
      }
      get isTriageSuggestionsAccessible() {
          return this.aiAddonEnabled && this.canAccess(gd.productIntelligence)
      }
      get isProductIntelligenceAccessible() {
          return this.canAccess(gd.productIntelligence) || this.canAccess(gd.basicAIAddon) && (ui.isEnabled(ui.aiGeneratedProjectUpdates) || ui.isEnabled(ui.aiGeneratedInitiativeUpdates))
      }
      get isLinearAiAccessible() {
          return this.canAccess(gd.linearAi) && ui.isEnabled(ui.linearAi)
      }
      get isLinearAiSlackAccessible() {
          return this.canAccess(gd.linearSlackAgent)
      }
      get isAgentSessionsTabAccessible() {
          return this.canAccess(gd.linearAgents) && ui.isEnabled(ui.agentSessionsTab)
      }
      numProjectStatusesOfType(e) {
          return this.numProjectStatusesPerType[e]
      }
      get numProjectStatusesPerType() {
          return Gd.allExceptPaused.reduce( (e, t) => (e[t] = this.projectStatuses.filter(e => e.type === t).length,
          e), {
              [Wd.backlog]: 0,
              [Wd.planned]: 0,
              [Wd.started]: 0,
              [Wd.completed]: 0,
              [Wd.canceled]: 0,
              [Wd.paused]: 0
          })
      }
      get defaultProjectStatus() {
          return this.firstProjectStatusForType(Wd.backlog)
      }
      firstProjectStatusForType(e) {
          let t = e === Wd.paused ? Wd.started : e
            , n = this.projectStatuses.filter(e => !e.isArchived).find(e => e.type === t);
          if (!n)
              throw Error(`Could not find project status for type ${t}`);
          return n
      }
      get defaultCustomerStatus() {
          let e = this.customerStatuses.orderBy(`position`).first;
          if (!e)
              throw Error(`Could not find default customer status for organization`);
          return e
      }
      getEmojiByName(e) {
          let t = Bd.toEmojiName(e)
            , n = this.emojiByNameHydrationPromise.get(t);
          return n || (n = new Jp(async e => {
              let n = this.emojisByNameMap.get(t);
              if (n)
                  return Bd.emojiColorCache.set(t, n.color),
                  e(n);
              try {
                  let n = await this.store.hydrateModels(MH, {
                      key: `name`,
                      value: t,
                      coveringPartialIndexes: [wm.createPartialIndex({
                          modelClass: MH,
                          indexedKey: `name`,
                          keyValue: t
                      }), wm.createPartialIndex({
                          modelClass: MH,
                          indexedKey: `organizationId`,
                          keyValue: this.id
                      })]
                  });
                  if (n === !0) {
                      let n = this.emojisByNameMap.get(t);
                      return Bd.emojiColorCache.set(t, n?.color),
                      e(n)
                  }
                  if (Array.isArray(n)) {
                      for (let r of n)
                          if (r.name === t)
                              return Bd.emojiColorCache.set(t, r?.color),
                              e(r)
                  }
                  return Bd.emojiColorCache.set(t, void 0),
                  e(void 0)
              } catch {
                  return setTimeout( () => {
                      this.emojiByNameHydrationPromise.delete(t)
                  }
                  , 10 * b.SECOND),
                  e(void 0)
              }
          }
          ),
          this.emojiByNameHydrationPromise.set(t, n)),
          n
      }
      unsafeGetEmojiByName(e) {
          return this.emojisByNameMap.get(e) ?? this.emojiByNameHydrationPromise.get(e)?.value
      }
      getTrait(e) {
          return sc(this.traits, e)
      }
      getIntegration(e, t) {
          if (!e) {
              w.warning(`getIntegration called with no service`);
              return
          }
          if (e.endsWith(`Personal`)) {
              w.warning(`Personal integrations cannot be accessed via the organization`, {
                  service: e
              });
              return
          }
          return (t ? this.integrations.filter(t) : this.integrations).find(t => t.service === e)
      }
      isAiProviderAllowed(e) {
          return !this.allowedAiProviders || this.allowedAiProviders.length === 0 || this.allowedAiProviders.includes(e)
      }
      get emojisByNameMap() {
          return new Map(this.emojis.existingElements.map(e => [e.name, e]))
      }
  }
  ,
  M([R({
      default: ``
  })], q.prototype, `name`, void 0),
  M([R({
      default: ``
  })], q.prototype, `urlKey`, void 0),
  M([R()], q.prototype, `logoUrl`, void 0),
  M([R({
      persistence: `createOnly`,
      default: !1,
      isVirtual: !0
  })], q.prototype, `active`, void 0),
  M([R({
      persistence: `createOnly`,
      default: 0
  })], q.prototype, `periodUploadVolume`, void 0),
  M([R({
      serializer: Ah,
      persistence: `createOnly`
  })], q.prototype, `deletionRequestedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `createOnly`
  })], q.prototype, `trialEndsAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `createOnly`
  })], q.prototype, `trialStartsAt`, void 0),
  M([R({
      default: !1,
      persistence: `none`
  })], q.prototype, `allowTeamToSelfUpgrade`, void 0),
  M([R({
      persistence: `createOnly`
  })], q.prototype, `trialPlanType`, void 0),
  M([R({
      default: !1,
      persistence: `none`
  })], q.prototype, `inviteLinkEnabled`, void 0),
  M([z( () => J, {
      index: `organizationId`,
      order: new P(`name`)
  })], q.prototype, `allUsers`, void 0),
  M([z( () => Fy, {
      index: `organizationId`,
      order: new P(`name`)
  })], q.prototype, `externalUsers`, void 0),
  M([z( () => VA, {
      index: `sourceOrganizationId`,
      order: new P(`sortOrder`)
  })], q.prototype, `facets`, void 0),
  M([z( () => tU, {
      index: `organizationId`,
      order: new P(`createdAt`,`desc`)
  })], q.prototype, `batchOperations`, void 0),
  M([L], q.prototype, `projectsPageFacets`, null),
  M([og( () => G, {
      order: new P(`sortOrder`)
  })], q.prototype, `projects`, void 0),
  M([og( () => ej, {
      order: new P(e => qd.getStatusOrder(e.type)).and(`position`)
  })], q.prototype, `projectStatuses`, void 0),
  M([z( () => Hj, {
      order: new P(`createdAt`,`desc`)
  })], q.prototype, `posts`, void 0),
  M([z( () => Og, {
      index: `organizationId`,
      order: new P(`updatedAt`,`desc`)
  })], q.prototype, `aiPrompts`, void 0),
  M([z( () => $j, {
      index: `organizationId`,
      order: new P(`updatedAt`,`desc`)
  })], q.prototype, `releasePipelines`, void 0),
  M([z( () => CR, {
      index: `organizationId`,
      order: new P(`updatedAt`,`desc`)
  })], q.prototype, `aiPromptRules`, void 0),
  M([z( () => AH, {
      index: `organizationId`,
      order: Ule()
  })], q.prototype, `aiPromptMemories`, void 0),
  M([og( () => uB, {
      order: new P(`position`)
  })], q.prototype, `customerStatuses`, void 0),
  M([og( () => yB, {
      order: new P(`position`)
  })], q.prototype, `customerTiers`, void 0),
  M([og( () => nB)], q.prototype, `integrations`, void 0),
  M([og( () => BH)], q.prototype, `identityProviders`, void 0),
  M([z( () => PH, {
      index: `organizationId`
  })], q.prototype, `oauthClients`, void 0),
  M([z( () => JL, {
      index: `organizationId`
  })], q.prototype, `oauthClientApprovals`, void 0),
  M([z( () => MH, {
      index: `organizationId`,
      order: new P(`createdAt`),
      customNetworkHydration: () => [{
          modelClass: MH
      }]
  })], q.prototype, `emojis`, void 0),
  M([z( () => GH, {
      index: `organizationId`
  })], q.prototype, `invites`, void 0),
  M([z( () => NA, {
      index: `organizationId`
  })], q.prototype, `viewPreferences`, void 0),
  M([og( () => W, {
      order: dj
  })], q.prototype, `initiatives`, void 0),
  M([og( () => RR, {
      order: new P(`sortOrder`)
  })], q.prototype, `rolloutStages`, void 0),
  M([og( () => BR, {
      order: new P(`key`)
  })], q.prototype, `featureFlags`, void 0),
  M([z( () => Dj, {
      index: `organizationId`,
      order: new P(`createdAt`,`desc`)
  })], q.prototype, `agentSessions`, void 0),
  M([z( () => UH, {
      index: `organizationId`,
      order: new P(`name`)
  })], q.prototype, `domains`, void 0),
  M([z( () => oH, {
      index: `organizationId`,
      order: new P(`createdAt`,`desc`)
  })], q.prototype, `webhooks`, void 0),
  M([z( () => aU, {
      index: `organizationId`,
      order: new P(`createdAt`,`desc`)
  })], q.prototype, `apiKeys`, void 0),
  M([og( () => $b, {
      order: new P(`address`)
  })], q.prototype, `emailIntakeAddresses`, void 0),
  M([L], q.prototype, `asksEmailIntakeAddresses`, null),
  M([z( () => Uz, {
      index: `organizationId`,
      order: new P(`name`)
  })], q.prototype, `timeSchedules`, void 0),
  M([og( () => OH, {
      order: new P(`sortName`)
  })], q.prototype, `allIssueLabels`, void 0),
  M([og( () => Ek, {
      order: new P(`sortName`)
  })], q.prototype, `allProjectLabels`, void 0),
  M([z( () => hx, {
      index: `organizationId`,
      order: new P(`sortOrder`).and(`name`)
  })], q.prototype, `allTemplates`, void 0),
  M([z( () => Az, {
      index: `organizationId`
  })], q.prototype, `allCustomViews`, void 0),
  M([z( () => Fj, {
      index: `organizationId`,
      order: new P(`displayName`),
      canSkipHydration: e => !e.getTrait(ef.hasDashboards)
  })], q.prototype, `allDashboards`, void 0),
  M([z( () => U, {
      index: `organizationId`,
      order: new P(`openedAt`,`desc`)
  })], q.prototype, `allPullRequests`, void 0),
  M([og( () => uH, {
      order: new P(`sortOrder`)
  })], q.prototype, `allWorkflowDefinitions`, void 0),
  M([og( () => QH, {
      order: new P(`isActive`,`desc`).and(`createdAt`, `desc`)
  })], q.prototype, `subscriptions`, void 0),
  M([z( () => Lj, {
      index: `organizationId`
  })], q.prototype, `issueImports`, void 0),
  M([z( () => jV, {
      index: `organizationId`,
      order: new P(`createdAt`,`desc`)
  })], q.prototype, `feed`, void 0),
  M([R()], q.prototype, `gitBranchFormat`, void 0),
  M([R({
      default: !1
  })], q.prototype, `gitLinkbackMessagesEnabled`, void 0),
  M([R({
      default: !1
  })], q.prototype, `gitPublicLinkbackMessagesEnabled`, void 0),
  M([R({
      default: !0
  })], q.prototype, `gitLinkbackDescriptionsEnabled`, void 0),
  M([R({
      default: !1
  })], q.prototype, `roadmapEnabled`, void 0),
  M([R()], q.prototype, `projectUpdateReminderFrequencyInWeeks`, void 0),
  M([R({
      enum: Vn,
      default: Vn.Friday
  })], q.prototype, `projectUpdateRemindersDay`, void 0),
  M([R({
      default: 14
  })], q.prototype, `projectUpdateRemindersHour`, void 0),
  M([R()], q.prototype, `initiativeUpdateReminderFrequencyInWeeks`, void 0),
  M([R({
      enum: Vn,
      default: Vn.Friday
  })], q.prototype, `initiativeUpdateRemindersDay`, void 0),
  M([R({
      default: 14
  })], q.prototype, `initiativeUpdateRemindersHour`, void 0),
  M([R({
      persistence: `none`,
      default: !1
  })], q.prototype, `samlEnabled`, void 0),
  M([R({
      serializer: Mh,
      persistence: `none`
  })], q.prototype, `samlSettings`, void 0),
  M([R({
      persistence: `none`,
      default: !1
  })], q.prototype, `scimEnabled`, void 0),
  M([R({
      serializer: Mh,
      persistence: `none`
  })], q.prototype, `scimSettings`, void 0),
  M([R({
      default: {}
  })], q.prototype, `securitySettings`, void 0),
  M([R({
      default: !1
  })], q.prototype, `reducedPersonalInformation`, void 0),
  M([R({
      default: !1,
      persistence: `none`
  })], q.prototype, `hipaaComplianceEnabled`, void 0),
  M([R({
      default: !1
  })], q.prototype, `oauthAppReview`, void 0),
  M([R({
      default: []
  })], q.prototype, `allowedAuthServices`, void 0),
  M([R({
      default: []
  })], q.prototype, `allowedAiProviders`, void 0),
  M([R()], q.prototype, `allowedFileUploadContentTypes`, void 0),
  M([R({
      persistence: `updateOnly`
  })], q.prototype, `ipRestrictions`, void 0),
  M([R({
      persistence: `createOnly`,
      default: []
  })], q.prototype, `previousUrlKeys`, void 0),
  M([R({
      persistence: `createOnly`,
      default: 0
  })], q.prototype, `approximateIssueCount`, void 0),
  M([R({
      persistence: `createOnly`,
      default: 0
  })], q.prototype, `approximateCustomerCount`, void 0),
  M([R({
      default: 0
  })], q.prototype, `fiscalYearStartMonth`, void 0),
  M([R({
      default: tc.MonToFri
  })], q.prototype, `workingDays`, void 0),
  M([og( () => K, {
      order: new P(`displayName`),
      private: !0
  })], q.prototype, `teams`, void 0),
  M([z( () => MB, {
      index: `organizationId`,
      canSkipNetworkHydration: async () => !0,
      customNetworkHydration: () => []
  })], q.prototype, `customers`, void 0),
  M([R()], q.prototype, `restrictAgentInvocationToMembers`, void 0),
  M([R()], q.prototype, `slaEnabled`, void 0),
  M([R({
      serializer: Mh,
      persistence: `none`
  })], q.prototype, `planFeatureOverrides`, void 0),
  M([R({
      default: !1
  })], q.prototype, `customersEnabled`, void 0),
  M([R({
      serializer: Mh,
      default: {}
  })], q.prototype, `customersConfiguration`, void 0),
  M([R({
      persistence: `none`
  })], q.prototype, `traits`, void 0),
  M([R({
      persistence: `none`,
      default: nf.public
  })], q.prototype, `releaseChannel`, void 0),
  M([R({
      serializer: Mh,
      persistence: `none`
  })], q.prototype, `quotaOverrides`, void 0),
  M([R({
      default: !1
  })], q.prototype, `feedEnabled`, void 0),
  M([R({
      default: !1
  })], q.prototype, `aiAddonEnabled`, void 0),
  M([R({
      default: !0
  })], q.prototype, `generatedUpdatesEnabled`, void 0),
  M([R({
      default: !1
  })], q.prototype, `codeIntelligenceEnabled`, void 0),
  M([R()], q.prototype, `codeIntelligenceRepository`, void 0),
  M([R({
      default: !1
  })], q.prototype, `aiTelemetryEnabled`, void 0),
  M([R({
      default: !0,
      persistence: `updateOnly`
  })], q.prototype, `aiThreadSummariesEnabled`, void 0),
  M([R({
      default: !0,
      persistence: `updateOnly`
  })], q.prototype, `aiDiscussionSummariesEnabled`, void 0),
  M([R({
      enum: rp,
      default: rp.daily
  })], q.prototype, `defaultFeedSummarySchedule`, void 0),
  M([L], q.prototype, `isSamlEnabled`, null),
  M([L], q.prototype, `isScimEnabled`, null),
  M([L], q.prototype, `billedUserCount`, null),
  M([L], q.prototype, `orderedRolloutStages`, null),
  M([L], q.prototype, `planFeatureOverridesArray`, null),
  M([L], q.prototype, `issueLabels`, null),
  M([L], q.prototype, `templates`, null),
  M([L], q.prototype, `customViews`, null),
  M([L], q.prototype, `dashboards`, null),
  M([L], q.prototype, `projectVelocityDeciles`, null),
  M([L], q.prototype, `projectActivityAvailable`, null),
  M([L], q.prototype, `initiativeVelocityDeciles`, null),
  M([L], q.prototype, `initiativeActivityAvailable`, null),
  M([L], q.prototype, `workflowDefinitions`, null),
  M([L], q.prototype, `triageWorkflowDefinitions`, null),
  M([L], q.prototype, `issueTemplates`, null),
  M([L], q.prototype, `standardIssueTemplates`, null),
  M([L], q.prototype, `formIssueTemplates`, null),
  M([L], q.prototype, `documentTemplates`, null),
  M([L], q.prototype, `projectTemplates`, null),
  M([L], q.prototype, `accessibleTeams`, null),
  M([L], q.prototype, `activePublicTeams`, null),
  M([L], q.prototype, `projectStatusStartedCount`, null),
  M([L], q.prototype, `viewPreferencesWithoutDependencies`, null),
  M([L], q.prototype, `users`, null),
  M([L], q.prototype, `activeUsers`, null),
  M([L], q.prototype, `activeNonAppUsers`, null),
  M([L], q.prototype, `activeGuestUsers`, null),
  M([L], q.prototype, `activeAndInvitedUsers`, null),
  M([L], q.prototype, `activeAndInvitedNonAppUsers`, null),
  M([L], q.prototype, `mentionableUsers`, null),
  M([L], q.prototype, `issueAndProjectAssignableUsers`, null),
  M([L], q.prototype, `billedUsers`, null),
  M([L], q.prototype, `invitedUsers`, null),
  M([L], q.prototype, `appUsers`, null),
  M([L], q.prototype, `assignableAppUsers`, null),
  M([L], q.prototype, `agentAppUsers`, null),
  M([L], q.prototype, `suspendedUsers`, null),
  M([L], q.prototype, `allOwners`, null),
  M([L], q.prototype, `allAdmins`, null),
  M([L], q.prototype, `canShowRolloutStage`, null),
  M([L], q.prototype, `isSuperuserWorkspace`, null),
  M([L], q.prototype, `isInTrial`, null),
  M([L], q.prototype, `isInTrialEndingSoon`, null),
  M([L], q.prototype, `isBusinessTrialAvailable`, null),
  M([L], q.prototype, `isEnterpriseTrialAvailable`, null),
  M([L], q.prototype, `activePlanType`, null),
  M([L], q.prototype, `featureTier`, null),
  M([L], q.prototype, `adminPermissionOverrides`, null),
  M([L], q.prototype, `unsafeAdminPermissionOverrides`, null),
  M([L], q.prototype, `createdDaysAgo`, null),
  M([L], q.prototype, `dangerousAllIssues`, null),
  M([L], q.prototype, `showProjectsPage`, null),
  M([L], q.prototype, `isSlaAccessible`, null),
  M([L], q.prototype, `emojisByNameMap`, null),
  q = rU = M([mg(`Organization`)], q)
}
)), aU, oU = t(( () => {
  Ju(),
  iU(),
  GU(),
  V(),
  F(),
  N(),
  aU = class extends Yh {
      get humanReadablePermissions() {
          let e = [];
          return this.scope && e.push(...this.scope.map(e => Gu[e])),
          this.requestedSyncGroups === void 0 ? (e.push(`public teams`),
          this.user.teams.some(e => e.private) && e.push(`private teams`)) : e.push(`selected teams`),
          e.map(e => e.toLowerCase()).join(`, `)
      }
  }
  ,
  M([R({
      default: ``
  })], aU.prototype, `label`, void 0),
  M([R({
      persistence: `createOnly`,
      isVirtual: !0
  })], aU.prototype, `key`, void 0),
  M([B( () => J, `apiKeys`, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], aU.prototype, `user`, void 0),
  M([B( () => q, `apiKeys`, {
      persistence: `none`,
      optional: !1,
      nullable: !1,
      indexed: !0
  })], aU.prototype, `organization`, void 0),
  M([R()], aU.prototype, `scope`, void 0),
  M([R({
      persistence: `none`
  })], aU.prototype, `requestedSyncGroups`, void 0),
  M([R({
      isVirtual: !0
  })], aU.prototype, `teamIds`, void 0),
  M([R({
      persistence: `none`
  })], aU.prototype, `lastActiveAt`, void 0),
  aU = M([mg(`ApiKey`)], aU)
}
)), sU, cU = t(( () => {
  GU(),
  V(),
  F(),
  Ih(),
  N(),
  sU = class extends Yh {
  }
  ,
  M([B( () => J, `pushSubscriptions`, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], sU.prototype, `user`, void 0),
  M([R({
      serializer: Mh,
      default: {}
  })], sU.prototype, `data`, void 0),
  sU = M([mg(`PushSubscription`)], sU)
}
));
async function qle(e, t) {
  let n = Ut`
  mutation UserSuspend($id: String!) {
    userSuspend(id: $id) {
      success
    }
  }
`;
  return e.mutate(n, t)
}
var Jle = t(( () => {
  Wt()
}
));
async function Yle(e, t) {
  let n = Ut`
  mutation UserUnsuspend($id: String!) {
    userUnsuspend(id: $id) {
      success
    }
  }
`;
  return e.mutate(n, t)
}
var Xle = t(( () => {
  Wt()
}
)), lU, uU = t(( () => {
  wu(),
  GU(),
  V(),
  F(),
  om(),
  Ih(),
  N(),
  lU = class extends qh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.full
  }
  ,
  M([B( () => J, `calendarEvents`, {
      optional: !1,
      nullable: !1,
      indexed: !0
  })], lU.prototype, `user`, void 0),
  M([R({
      serializer: Ah,
      default: () => new Date
  })], lU.prototype, `startsAt`, void 0),
  M([R({
      serializer: Ah,
      default: () => new Date
  })], lU.prototype, `endsAt`, void 0),
  M([R({
      default: xu.outOfOffice
  })], lU.prototype, `type`, void 0),
  lU = M([mg(`CalendarEvent`)], lU)
}
)), dU, fU = t(( () => {
  dU = function(e) {
      return e[e.online = 0] = `online`,
      e[e.away = 1] = `away`,
      e[e.offline = 2] = `offline`,
      e
  }({})
}
)), pU, mU, hU = t(( () => {
  nt(),
  Sy(),
  V(),
  Ih(),
  F(),
  GU(),
  N(),
  mU = pU = class extends Yh {
      get markdownContent() {
          return this.bodyData ? Hp.serialize(this.bodyData) : ``
      }
      get weekKey() {
          return `` + Fe(this.date.toLocalDate()) + this.date.toLocalDate().getFullYear()
      }
      static create(e) {
          let t = pU.createEmpty();
          return t.user = e.user,
          t.date = new Date().toTimelessDate(),
          t
      }
  }
  ,
  M([R({
      serializer: Mh,
      shallowObservation: !0
  })], mU.prototype, `bodyData`, void 0),
  M([B( () => J, `diaryEntries`, {
      persistence: `none`,
      optional: !1,
      nullable: !1
  })], mU.prototype, `user`, void 0),
  M([R({
      serializer: jh,
      default: () => new Date().toTimelessDate()
  })], mU.prototype, `date`, void 0),
  M([L], mU.prototype, `markdownContent`, null),
  M([L], mU.prototype, `weekKey`, null),
  mU = pU = M([mg(`DiaryEntry`)], mU)
}
)), gU, Zle = t(( () => {
  ws(),
  Vm(),
  F(),
  gU = class extends Bm {
      constructor(...e) {
          super(...e),
          this.errorReported = !1
      }
      get elements() {
          return super.elements.filter(e => {
              if (!e.team) {
                  if (!this.errorReported) {
                      this.errorReported = !0;
                      let t = qh.store.syncClient.bootstrappedAt?.toISOString();
                      w.error(`User had TeamMembership without Team`, void 0, {
                          membershipId: e.id,
                          teamId: e.teamId,
                          bootstrappedAt: t
                      }),
                      w.remote(`User had TeamMembership without Team`, {
                          membershipId: e.id,
                          teamId: e.teamId,
                          bootstrappedAt: t
                      })
                  }
                  return !1
              }
              return !0
          }
          )
      }
  }
}
));
function Qle(e) {
  class t extends e {
      constructor(...e) {
          super(...e),
          this.placeholder = !1
      }
      get isPlaceholder() {
          return this.placeholder
      }
      resolvePlaceholder() {
          return this.placeholderHydrationPromise ? this.placeholderHydrationPromise : Yp
      }
      async startHydratingPlaceholderModel() {
          let e = !1;
          return this.placeholder = !0,
          this.placeholderHydrationPromise = new Jp( (t, n) => this.store.hydrateLocalModelsByIds(this.modelClass, [this.id]).then(n => {
              e = n.length > 0,
              t()
          }
          ).catch(n)),
          await this.placeholderHydrationPromise,
          e && Mt( () => {
              this.placeholder = !1
          }
          ),
          e
      }
  }
  return t
}
var $le = t(( () => {
  zt(),
  Xp()
}
)), _U, vU, yU, bU, xU, SU = t(( () => {
  _U = e(a(), 1),
  vU = e(nn(), 1),
  wx(),
  ml(),
  H_(),
  yU = new RegExp(/\[(.*?)\]\(\/profiles\/(.*?)\/?\)/g),
  bU = Object.fromEntries(Object.entries(dl.nodes).filter( ([,e]) => e.spec.toPlainText).map( ([e,t]) => [e, t.spec.toPlainText])),
  xU = class e {
      static parseMarkdownUserMentions = e => {
          let t, n = [];
          for (; (t = yU.exec(e)) !== null; ) {
              t.index === yU.lastIndex && yU.lastIndex++;
              let e = t[2];
              n.indexOf(e) < 0 && n.push(e)
          }
          return n
      }
      ;
      static parseUserMentions = e => {
          if (!e)
              return [];
          let t = [];
          return V_(e).forEach(e => {
              e.type === `suggestion_userMentions` && e.attrs && e.attrs.id && t.push(e.attrs.id)
          }
          ),
          (0,
          _U.default)(t)
      }
      ;
      static doesDataMentionUser = (e, t) => V_(e).some(e => e.type === `suggestion_userMentions` && e.attrs?.id === t);
      static parseInlineCommentMarks = e => {
          let t = [];
          return V_(e).forEach(e => {
              t = t.concat(e.marks?.filter(e => e.type === `inlineComment`).map(e => e.attrs ?? {}) ?? [])
          }
          ),
          t
      }
      ;
      static parseURLs = e => {
          let t = [];
          return V_(e).forEach(e => {
              e.type === `text` && e.marks && e.marks.forEach(e => {
                  e.type === `link` && e.attrs?.href && t.push(e.attrs.href)
              }
              )
          }
          ),
          (0,
          _U.default)(t)
      }
      ;
      static parseFileUrls = e => {
          let t = V_(e)
            , n = {
              image: [],
              video: [],
              audio: [],
              file: []
          };
          return t.forEach(e => {
              switch (e.type) {
              case `image`:
                  e.attrs?.src && n.image.push(e.attrs?.src);
                  break;
              case `video`:
                  e.attrs?.src && n.video.push(e.attrs?.src);
                  break;
              case `audio`:
                  e.attrs?.src && n.audio.push(e.attrs?.src);
                  break;
              case `file`:
                  e.attrs?.href && n.file.push(e.attrs?.href);
                  break;
              default:
                  break
              }
          }
          ),
          n
      }
      ;
      static replaceFileUrls = (e, t) => {
          V_(e).forEach(e => {
              switch (e.type) {
              case `image`:
              case `audio`:
              case `video`:
                  e.attrs?.src && t[e.attrs.src] && (e.attrs.src = t[e.attrs.src]);
                  break;
              case `file`:
                  e.attrs?.href && t[e.attrs.href] && (e.attrs.href = t[e.attrs.href]);
                  break;
              default:
                  break
              }
          }
          )
      }
      ;
      static updateMarkAttrs = (t, n, r) => {
          let i = (0,
          vU.default)(t);
          return `content`in i && (i.content = i.content.map(t => {
              if (`content`in t)
                  return e.updateMarkAttrs(t, n, r);
              if (`marks`in t) {
                  let {marks: e} = t;
                  return e ? {
                      ...t,
                      marks: e?.map(e => n(e) ? {
                          ...e,
                          attrs: {
                              ...e.attrs,
                              ...r
                          }
                      } : e)
                  } : t
              } else
                  return t
          }
          )),
          i
      }
      ;
      static removeMarks = (t, n) => {
          let r = (0,
          vU.default)(t);
          return `content`in r && (r.content = r.content.map(t => {
              if (`content`in t)
                  return e.removeMarks(t, n);
              if (`marks`in t) {
                  let {marks: e, ...r} = t
                    , i = e?.filter(e => !n(e));
                  return i && i.length > 0 ? {
                      ...t,
                      marks: i
                  } : r
              } else
                  return t
          }
          )),
          r
      }
      ;
      static parseTextContent = (e, t) => {
          if (!e)
              return ``;
          let n = dl.nodeFromJSON(e)
            , r = Cx(n, 0, n.content.size, bU);
          return t === void 0 ? r.trim() : r.slice(0, t).trim()
      }
  }
}
)), CU, wU, TU = t(( () => {
  pk(),
  SU(),
  V(),
  F(),
  om(),
  WA(),
  Sm(),
  mH(),
  GU(),
  iz(),
  DM(),
  N(),
  wU = class extends Yh {
      static #e = CU = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static create({model: e, user: t, isSubscribed: n=!0, isSubscribedToSubProjects: r=!1}) {
          let i = CU.createEmpty();
          return i.user = t,
          i.isSubscribed = n,
          i.isSubscribedToSubProjects = r,
          i.team = e instanceof K ? vm.wrap(e) : void 0,
          i.project = e instanceof G ? e : void 0,
          i.initiative = e instanceof W ? vm.wrap(e) : void 0,
          i.save(!0),
          i
      }
      getSubscriptionModel() {
          return this.team?.value ?? this.project ?? this.initiative?.value
      }
      static isUserSubscribedToModel(e, t) {
          return CU.isUserSubscribedToModelResult(e, t).subscribed
      }
      static isUserSubscribedToUpdateResult(e, t, n) {
          let r = CU.isUserSubscribedToModelResult(e, t);
          return !r.subscribed && CU.isUserUpdateAuthor(e, n) ? {
              subscribed: !0,
              reason: dk.userAuthor
          } : !r.subscribed && n.bodyData && xU.doesDataMentionUser(n.bodyData, e.id) ? {
              subscribed: !0,
              reason: dk.userMention
          } : r
      }
      static isUserUpdateAuthor(e, t) {
          let n = t instanceof UA ? t.user?.id : t.creator?.id;
          return !!(n && e.id === n)
      }
      static isUserSubscribedToModelResult(e, t) {
          let n = e.feedSubscriptionsByModelId
            , r = n[t.id];
          if (r)
              return r.isSubscribed ? {
                  subscribed: !0,
                  reason: uk.getModelSubscriptionReason(t.modelName)
              } : {
                  subscribed: !1
              };
          if (t instanceof K)
              return uk.isSubscribedToTeamByDefault({
                  teamId: t.id,
                  userTeamIds: e.teams.map(e => e.id)
              });
          if (t instanceof G)
              return uk.isSubscribedToProjectByDefault({
                  projectTeamIds: t.accessibleTeams.map(e => e.id),
                  projectMemberIds: t.members.map(e => e.id),
                  initiativeOwnerIds: t.initiatives.map(e => e.owner?.id).concrete(),
                  initiativeIds: t.initiatives.map(e => e.id),
                  userId: e.id,
                  userTeamIds: e.teams.map(e => e.id),
                  subscriptions: n
              });
          if (t instanceof W)
              return uk.isSubscribedToInitiativeByDefault({
                  initiativeOwnerId: t.owner?.id,
                  initiativeProjectMemberIds: t.projects.flatMap(e => e.members.map(e => e.id)),
                  userId: e.id
              });
          throw Error(`Unsupported model provided to isUserSubscribedToModel`)
      }
      static isUserSubscribedToModelSubProjects(e, t) {
          let n = e.feedSubscriptionsByModelId[t.id];
          return n ? n.isSubscribedToSubProjects : t instanceof K ? e.teams.some(e => e.id === t.id) : !1
      }
  }
  ,
  M([B( () => J, `feedSubscriptions`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], wU.prototype, `user`, void 0),
  M([lg( () => K, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], wU.prototype, `team`, void 0),
  M([cg( () => G, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], wU.prototype, `project`, void 0),
  M([lg( () => W, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], wU.prototype, `initiative`, void 0),
  M([R({
      default: !0
  })], wU.prototype, `isSubscribed`, void 0),
  M([R({
      default: !1
  })], wU.prototype, `isSubscribedToSubProjects`, void 0),
  wU = CU = M([mg(`FeedSubscription`)], wU)
}
)), EU, eue = t(( () => {
  Zv(),
  EU = {
      Activity: {
          canHaveUserSyncGroup: !0
      },
      AgentActivity: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      AgentSession: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      AiConversation: {
          canHaveUserSyncGroup: !0
      },
      AiMessage: {
          canHaveUserSyncGroup: !0
      },
      AiPrompt: {
          [H.fullMemberAccess]: !0,
          canHaveUserSyncGroup: !0
      },
      AiPromptMemory: {
          canHaveTeamSyncGroup: !0
      },
      AiPromptProgress: {
          canHaveTeamSyncGroup: !0
      },
      AiPromptRules: {
          [H.fullMemberAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      AiPromptSubscription: {
          [H.fullMemberAccess]: !0,
          canHaveUserSyncGroup: !0
      },
      ApiKey: {
          [H.adminAccess]: !0,
          canHaveUserSyncGroup: !0
      },
      Attachment: {
          canHaveTeamSyncGroup: !0
      },
      BatchOperation: {
          [H.fullMemberAccess]: !0
      },
      CalendarEvent: {
          [H.everyone]: !0
      },
      Comment: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      CustomAttribute: {
          [H.everyone]: !0
      },
      CustomView: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      Customer: {
          [H.customerEntityAccess]: !0,
          [H.fullMemberAccess]: !0
      },
      CustomerGeneratedContent: {
          canHaveTeamSyncGroup: !0
      },
      CustomerNeed: {
          canHaveTeamSyncGroup: !0
      },
      CustomerSchema: {
          [H.everyone]: !0
      },
      CustomerSchemaField: {
          [H.everyone]: !0
      },
      CustomerStatus: {
          [H.customerEntityAccess]: !0,
          [H.fullMemberAccess]: !0
      },
      CustomerTier: {
          [H.customerEntityAccess]: !0,
          [H.fullMemberAccess]: !0
      },
      Cycle: {
          canHaveTeamSyncGroup: !0
      },
      Dashboard: {
          [H.fullMemberAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      DashboardWidgetSnapshot: {
          [H.fullMemberAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      DiaryEntry: {
          canHaveUserSyncGroup: !0
      },
      Document: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      DocumentContent: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      DocumentContentHistory: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      Draft: {
          canHaveUserSyncGroup: !0
      },
      EmailIntakeAddress: {
          [H.adminAccess]: !0,
          [H.everyone]: !0,
          [H.privateTeamSettingsAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      Emoji: {
          [H.everyone]: !0
      },
      EntityExternalLink: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      ExternalEntityRelation: {
          [H.everyone]: !0,
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          [H.privateTeamSettingsAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      ExternalUser: {
          [H.everyone]: !0
      },
      Facet: {
          [H.everyone]: !0,
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      Favorite: {
          canHaveUserSyncGroup: !0
      },
      FeatureFlag: {
          [H.everyone]: !0
      },
      FeatureFlagRolloutStage: {
          [H.everyone]: !0
      },
      FeedItem: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      FeedSubscription: {
          canHaveUserSyncGroup: !0
      },
      GitAutomationState: {
          [H.privateTeamSettingsAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      GitAutomationTargetBranch: {
          [H.adminAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      IdentityProvider: {
          [H.adminAccess]: !0
      },
      Initiative: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0
      },
      InitiativeHistory: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0
      },
      InitiativeRelation: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0
      },
      InitiativeToProject: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      InitiativeUpdate: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0
      },
      Integration: {
          [H.everyone]: !0,
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      IntegrationTemplate: {
          [H.everyone]: !0,
          [H.privateTeamSettingsAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      IntegrationsSettings: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      Issue: {
          canHaveTeamSyncGroup: !0
      },
      IssueDraft: {
          canHaveUserSyncGroup: !0
      },
      IssueHistory: {
          canHaveTeamSyncGroup: !0
      },
      IssueImport: {
          [H.adminAccess]: !0,
          [H.privateTeamSettingsAccess]: !0
      },
      IssueLabel: {
          [H.everyone]: !0,
          [H.privateTeamSettingsAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      IssueRelation: {
          canHaveTeamSyncGroup: !0
      },
      IssueSuggestion: {
          canHaveTeamSyncGroup: !0
      },
      IssueToRelease: {
          [H.everyone]: !0,
          canHaveTeamSyncGroup: !0
      },
      MediaMetadata: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      Notification: {
          canHaveUserSyncGroup: !0
      },
      NotificationSubscription: {
          canHaveUserSyncGroup: !0
      },
      OauthClient: {
          [H.adminAccess]: !0
      },
      OauthClientApproval: {
          [H.adminAccess]: !0
      },
      Organization: {
          [H.everyone]: !0
      },
      OrganizationDomain: {
          [H.everyone]: !0
      },
      OrganizationInvite: {
          [H.everyone]: !0
      },
      Post: {
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      Project: {
          canHaveTeamSyncGroup: !0
      },
      ProjectAttachment: {
          canHaveTeamSyncGroup: !0
      },
      ProjectHistory: {
          canHaveTeamSyncGroup: !0
      },
      ProjectLabel: {
          [H.everyone]: !0
      },
      ProjectMilestone: {
          canHaveTeamSyncGroup: !0
      },
      ProjectRelation: {
          canHaveTeamSyncGroup: !0
      },
      ProjectStatus: {
          [H.everyone]: !0
      },
      ProjectUpdate: {
          canHaveTeamSyncGroup: !0
      },
      PullRequest: {
          [H.fullMemberAccess]: !0,
          canHaveUserSyncGroup: !0
      },
      PullRequestComment: {
          [H.fullMemberAccess]: !0,
          canHaveUserSyncGroup: !0
      },
      PullRequestHistory: {
          [H.fullMemberAccess]: !0,
          canHaveUserSyncGroup: !0
      },
      PullRequestPendingReview: {
          canHaveUserSyncGroup: !0
      },
      PushSubscription: {
          canHaveUserSyncGroup: !0
      },
      Release: {
          [H.everyone]: !0
      },
      ReleasePipeline: {
          [H.everyone]: !0
      },
      ReleaseStage: {
          [H.everyone]: !0
      },
      Reminder: {
          canHaveUserSyncGroup: !0
      },
      ResourceFolder: {
          [H.fullMemberAccess]: !0,
          [H.initiativeEntityAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      Roadmap: {
          [H.fullMemberAccess]: !0
      },
      RoadmapToProject: {
          canHaveTeamSyncGroup: !0
      },
      SesDomainIdentity: {
          [H.fullMemberAccess]: !0
      },
      Subscription: {
          [H.everyone]: !0
      },
      SubscriptionItem: {
          [H.everyone]: !0
      },
      Summary: {
          canHaveTeamSyncGroup: !0
      },
      Team: {
          [H.privateTeamSettingsAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      TeamKey: {
          [H.privateTeamSettingsAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      TeamMembership: {
          [H.privateTeamSettingsAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      Template: {
          [H.everyone]: !0,
          [H.privateTeamSettingsAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      TimeSchedule: {
          [H.everyone]: !0
      },
      TriageResponsibility: {
          canHaveTeamSyncGroup: !0
      },
      User: {
          [H.everyone]: !0
      },
      UserAccess: {
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      UserSettings: {
          canHaveUserSyncGroup: !0
      },
      ViewPreferences: {
          [H.everyone]: !0,
          canHaveTeamSyncGroup: !0,
          canHaveUserSyncGroup: !0
      },
      Webhook: {
          [H.adminAccess]: !0
      },
      WorkflowCronJobDefinition: {
          [H.privateTeamSettingsAccess]: !0,
          canHaveTeamSyncGroup: !0
      },
      WorkflowDefinition: {
          [H.adminAccess]: !0,
          [H.everyone]: !0,
          canHaveTeamSyncGroup: !0
      },
      WorkflowState: {
          [H.privateTeamSettingsAccess]: !0,
          canHaveTeamSyncGroup: !0
      }
  }
}
)), DU, OU = t(( () => {
  ed(),
  Zv(),
  eue(),
  (function(e) {
      function t(e, t, n) {
          let r = EU[t];
          return r ? H.isConstant(n) ? H.isPublicTeamsAccess(n) ? r.canHaveTeamSyncGroup === !0 : r[n] === !0 : e ? n === e ? r.canHaveUserSyncGroup === !0 : r.canHaveTeamSyncGroup === !0 : r.canHaveUserSyncGroup === !0 || r.canHaveTeamSyncGroup === !0 : !1
      }
      e.canHaveSyncGroup = t;
      function n(e) {
          return e in EU
      }
      e.matches = n;
      function r() {
          return i ||= Qu(EU),
          i
      }
      e.allServerModelNames = r;
      let i
  }
  )(DU ||= {})
}
)), kU, AU, jU = t(( () => {
  kU = e(ge(), 1),
  OU(),
  bl(),
  qa(),
  AU = class e {
      static #e = this.MENTION_REGEX = /\[((?:[^\]]|\](?!\())*?)\]\(([a-zA-Z]+):([a-zA-Z0-9-]+)\)/g;
      static #t = this.XML_TAG_LABELED_REGEX = /<([A-Za-z-]+)\s+id=\"([a-zA-Z0-9-]+)\">([\s\S]*?)<\/\1>/g;
      static #n = this.XML_TAG_SELF_REGEX = /<([A-Za-z-]+)\s+id=\"([a-zA-Z0-9-]+)\"\s*\/>/g;
      static extractEntities(t, n={}) {
          let {validateUUIDs: r=!0} = n, i = [], a = new RegExp(e.MENTION_REGEX,`g`), o;
          for (; (o = a.exec(t)) !== null; ) {
              let[,,e,t] = o;
              DU.matches(e) && (!r || this.isValidIdForModel(t, e)) && i.push({
                  id: t,
                  type: e
              })
          }
          let s = new RegExp(e.XML_TAG_LABELED_REGEX,`g`);
          for (; (o = s.exec(t)) !== null; ) {
              let[,e,t] = o
                , n = this.kebabToPascalCase(e);
              DU.matches(n) && (!r || this.isValidIdForModel(t, n)) && i.push({
                  id: t,
                  type: n
              })
          }
          let c = new RegExp(e.XML_TAG_SELF_REGEX,`g`);
          for (; (o = c.exec(t)) !== null; ) {
              let[,e,t] = o
                , n = this.kebabToPascalCase(e);
              DU.matches(n) && (!r || this.isValidIdForModel(t, n)) && i.push({
                  id: t,
                  type: n
              })
          }
          return i
      }
      static replaceXmlWithMarkdownMentions(t) {
          if (!t)
              return t;
          let n = t.replace(e.XML_TAG_SELF_REGEX, (e, t, n) => {
              if (!this.isValidIdForModel(n, t))
                  return e;
              let r = this.kebabToPascalCase(t);
              return `[${r}](${r}:${n})`
          }
          );
          return n = n.replace(e.XML_TAG_LABELED_REGEX, (e, t, n, r) => {
              if (!this.isValidIdForModel(n, t))
                  return e;
              let i = this.kebabToPascalCase(t);
              return `[${r.replace(RegExp(`(?<!\\\\)\\[`, `g`), `\\[`).replace(RegExp(`(?<!\\\\)\\]`, `g`), `\\]`) || i}](${i}:${n})`
          }
          ),
          n
      }
      static kebabToPascalCase(e) {
          let t = (0,
          kU.default)(e);
          return t.charAt(0).toUpperCase() + t.slice(1)
      }
      static isValidIdForModel(e, t) {
          return t.toLowerCase() === `issue` && yl.possibleIdentifier(e) || Ka(e)
      }
  }
}
)), MU, NU = t(( () => {
  jU(),
  (function(e) {
      function t(e) {
          let t = e.replace(/[ \t]+\n/g, `
`);
          return AU.replaceXmlWithMarkdownMentions(t)
      }
      e.fixMarkdownOutput = t;
      function n(e, t) {
          let n = e.createdAt.getTime() - t.createdAt.getTime();
          return n === 0 ? t.role.localeCompare(e.role) : n
      }
      e.sortMessages = n
  }
  )(MU ||= {})
}
)), PU, FU = t(( () => {
  PU = function(e) {
      return e.assistant = `assistant`,
      e.user = `user`,
      e
  }({})
}
)), IU, LU, RU = t(( () => {
  FU(),
  V(),
  F(),
  om(),
  VU(),
  Sm(),
  N(),
  LU = class extends qh {
      static #e = IU = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      addContext(e) {
          this.context.some(t => t.type === e.type && t.id === e.id) || this.context.push(e)
      }
      static createUser(e) {
          let {conversation: t, context: n, prompt: r} = e
            , i = IU.createEmpty();
          return i.conversation = vm.wrap(t),
          i.role = PU.user,
          i.context = n ?? [],
          `aiPromptId`in r ? i.parts = [{
              type: `userSavedPrompt`,
              id: r.aiPromptId,
              text: r.text
          }] : `text`in r ? i.parts = [{
              type: `text`,
              text: r.text
          }] : i.parts = [{
              type: `savedPrompt`,
              id: r.id
          }],
          i
      }
      static createAssistant(e) {
          let {conversation: t, context: n} = e
            , r = IU.createEmpty();
          return r.conversation = vm.wrap(t),
          r.role = PU.assistant,
          r.context = n ?? [],
          r
      }
  }
  ,
  M([sg( () => BU, `messages`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], LU.prototype, `conversation`, void 0),
  M([R({
      default: []
  })], LU.prototype, `parts`, void 0),
  M([R({
      default: PU.user,
      persistence: `createOnly`
  })], LU.prototype, `role`, void 0),
  M([R({
      persistence: `createOnly`,
      default: []
  })], LU.prototype, `context`, void 0),
  M([R({
      persistence: `createOnly`
  })], LU.prototype, `llmModel`, void 0),
  M([R({
      persistence: `none`
  })], LU.prototype, `evalLogId`, void 0),
  M([I], LU, `createUser`, null),
  M([I], LU, `createAssistant`, null),
  LU = IU = M([mg(`AiMessage`)], LU)
}
)), zU, BU, VU = t(( () => {
  NU(),
  RU(),
  V(),
  F(),
  om(),
  Nm(),
  GU(),
  N(),
  BU = class extends Yh {
      static #e = zU = this;
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      addContext(e) {
          let t = Array.isArray(e) ? e : [e];
          for (let e of t) {
              if (this.context.some(t => t.type === e.type && t.id === e.id))
                  return;
              this.context.push(e)
          }
      }
      async orderedMessages() {
          return (await this.messages.hydrate()).elements.sort(MU.sortMessages)
      }
      isInContext(e) {
          return this.context.some(t => t.type === e.modelName && t.id === e.id)
      }
      static create(e) {
          let {user: t, context: n} = e
            , r = zU.createEmpty();
          return r.user = t,
          n && r.addContext(n),
          r
      }
  }
  ,
  M([B( () => J, `aiConversations`, {
      persistence: `createOnly`,
      optional: !1,
      nullable: !1,
      indexed: !0
  })], BU.prototype, `user`, void 0),
  M([z( () => LU, {
      index: `conversationId`,
      order: new P(`createdAt`,`asc`).and(`role`, `desc`)
  })], BU.prototype, `messages`, void 0),
  M([R({
      default: []
  })], BU.prototype, `context`, void 0),
  M([R({
      persistence: `none`
  })], BU.prototype, `summary`, void 0),
  M([I], BU, `create`, null),
  BU = zU = M([mg(`AiConversation`)], BU)
}
));
async function tue(e, t) {
  let n = Ut`
  mutation UserChangeRole($id: String!, $role: UserRoleType!) {
    userChangeRole(id: $id, role: $role) {
      success
    }
  }
`;
  return e.mutate(n, t)
}
var nue = t(( () => {
  Wt()
}
)), HU, UU, WU, J, GU = t(( () => {
  _n(),
  nt(),
  iu(),
  ou(),
  du(),
  pu(),
  _u(),
  Yr(),
  wu(),
  Du(),
  ku(),
  Ru(),
  Bu(),
  Yne(),
  Od(),
  Ld(),
  Xn(),
  ho(),
  JU(),
  oU(),
  bH(),
  Rj(),
  sR(),
  iU(),
  cU(),
  mH(),
  V(),
  F(),
  Vm(),
  Nm(),
  Pz(),
  Lq(),
  IL(),
  Jle(),
  Xle(),
  Ih(),
  rH(),
  TH(),
  uU(),
  fU(),
  HA(),
  hU(),
  Tm(),
  AM(),
  PR(),
  Zle(),
  nx(),
  FA(),
  Uj(),
  om(),
  xM(),
  TA(),
  DM(),
  $le(),
  Ij(),
  kH(),
  iz(),
  OA(),
  TU(),
  ws(),
  VU(),
  Eg(),
  Sj(),
  nU(),
  HH(),
  Wk(),
  nue(),
  N(),
  UU = b.MINUTE * 5,
  WU = b.HOUR * 2,
  J = class extends Qle(qh) {
      static #e = HU = this;
      constructor(...e) {
          super(...e),
          this.isAnonymous = !1
      }
      static #t = this.loadStrategy = rm.placeholder;
      static getAllInitialHydratedModelData(e) {
          return [e.userId]
      }
      get initials() {
          return fu(this.name)
      }
      get isMe() {
          return this.id === q.store.userId
      }
      get firstName() {
          return this.name.split(` `).shift() || this.name
      }
      get teamsCount() {
          return this.teamMemberships.length
      }
      get teams() {
          return Bm.of(K, DA.sortByUserSortOrder(this.teamMemberships.map(e => e.team).concrete()))
      }
      get nonMemberTeams() {
          return this.organization.accessibleTeams.filter(e => !this.memberOf(e))
      }
      get nonMemberTeamsSorted() {
          return DA.sortTeams(this.nonMemberTeams)
      }
      get teamIssueLabels() {
          let e = this.teams.flatMap(e => e.issueLabels.elements).distinct().filter(e => !e.inheritedFrom);
          return Bm.of(OH, e, {
              order: new P(`name`)
          })
      }
      get feedSubscriptionsByModelId() {
          return this.feedSubscriptions.elements.reduce( (e, t) => {
              let n = t.getSubscriptionModel()?.id;
              return n && (e[n] = t),
              e
          }
          , {})
      }
      get projects() {
          return this.store.organization.projects.filter(e => this.memberOf(e)).orderBy(new P(e => {
              let t = e.lead?.id === this.id
                , n = e.isActive;
              return n && t ? 0 : n && !t ? 1 : !n && t ? 2 : 3
          }
          ).and(`createdAt`, `desc`))
      }
      get ownedInitiatives() {
          return this.store.organization.initiatives.filter(e => this.memberOf(e))
      }
      canAccessTeam(e) {
          return e.userCanAccessTeam(this)
      }
      memberOf(e) {
          return e instanceof K ? !!this.teamMemberships.find(t => t.team === e) : e instanceof G ? e.lead?.id === this.id || e.members.some(e => e.id === this.id) : e instanceof W ? e.owner?.id === this.id : !1
      }
      toggleFavorite() {
          if (this.favorite)
              return this.favorite.delete(),
              !1;
          {
              let e = yH.create({
                  reference: this
              });
              return e.save(!0),
              e
          }
      }
      get canJoinAnotherTeam() {
          return this.organization.accessibleTeams.filter(e => e.canJoin(this)).length > this.teamMemberships.length
      }
      get unreadNotificationCount() {
          let e = this.notifications.filter(e => !(e.isHydrated() && (e.commentId && !e.comment?.value || e.documentId && !e.document?.value || e.issueId && !e.issue?.value || e.initiativeId && !e.initiative || e.oauthClientApprovalId && !e.oauthClientApproval || e.projectId && !e.project || e.projectUpdateId && !e.projectUpdate || e.projectMilestoneId && !e.projectMilestone)))
            , t = new Set
            , n = 0;
          return e.forEach(e => {
              if (!e.readAt && !e.snoozedUntilAt) {
                  let r = e.groupingEntityId;
                  t.has(r) || (n++,
                  t.add(r))
              }
          }
          ),
          n
      }
      get activeFavorites() {
          return Bm.of(yH, this.favorites.transientlyHydratedElements.filter(e => e.isActive))
      }
      get hasFavoriteFolders() {
          return this.activeFavorites.some(e => e.type === Ou.folder)
      }
      getViewPreferences(e) {
          return e === k.userProfileCreatedByUser ? this._viewPreferencesCreatedBy : this._viewPreferences
      }
      getIntegration(e, t) {
          return this.organization.integrations.find(n => n.service === e && n.creator.id === this.id && (t ? t(n) : !0))
      }
      getIntegrations(e, t) {
          return this.organization.integrations.filter(n => n.service === e && n.creator.id === this.id && (t ? t(n) : !0))
      }
      get _viewPreferences() {
          return NA.getOrCreateFrom(this.viewPreferences, k.userProfile, {
              user: this
          })
      }
      get _viewPreferencesCreatedBy() {
          return NA.getOrCreateFrom(this.viewPreferences, k.userProfileCreatedByUser, {
              user: this
          })
      }
      get isAdmin() {
          return (this.developerUserRoleOverrideValue || this.role) === su.admin
      }
      get isOwner() {
          return (this.developerUserRoleOverrideValue || this.role) === su.owner
      }
      get guest() {
          return (this.developerUserRoleOverrideValue || this.role) === su.guest
      }
      get developerUserRoleOverrideValue() {
          return this.isMe && this.settings ? this.settings.developerUserRoleOverrideValue : void 0
      }
      hasPermission(e, t={}) {
          let n = this.developerUserRoleOverrideValue || this.role;
          return Dd.hasPermission(e, n, this.organization.featureTier, Dd.mergeOverrides([this.organization.adminPermissionOverrides, t]))
      }
      get userRole() {
          return this.developerUserRoleOverrideValue || this.role
      }
      get unsafeUserRole() {
          return this.role
      }
      getMembershipForTeam(e) {
          return this.teamMemberships.find(t => t.team === e)
      }
      leaveTeam(e, t=!1) {
          let n = this.teamMemberships.find(t => t.team === e);
          if (n)
              return n.delete({
                  additionalDeleteArgs: {
                      alsoLeaveParentTeams: t
                  }
              })
      }
      joinTeam(e, t) {
          let n = new nH;
          return n.user = this,
          n.team = e,
          t?.owner && (n.owner = !0),
          {
              membership: n,
              transaction: n.save(!0)
          }
      }
      reorderTeamInSidebar(e, t) {
          let n = this.teamMemberships.elements
            , r = n.findIndex(e => e.team.id === t)
            , i = n.findIndex(t => t.team.id === e)
            , a = n[i];
          a.sortOrder = tx.calculateSortOrder(n, `sortOrder`, r, i),
          a.save()
      }
      setRole(e) {
          if (this.store)
              return tue(this.store.graphQLClient, {
                  id: this.id,
                  role: e
              })
      }
      get isActive() {
          return this.active
      }
      setActive() {
          if (this.store)
              return Yle(this.store.graphQLClient, {
                  id: this.id
              })
      }
      setDisabled() {
          if (this.store)
              return qle(this.store.graphQLClient, {
                  id: this.id
              })
      }
      get isMentionable() {
          return Yu.isMentionable({
              isAppUser: this.app,
              appScopes: this.appScopes
          })
      }
      get isAssignable() {
          return Yu.isAssignable({
              isAppUser: this.app,
              appScopes: this.appScopes
          })
      }
      get app() {
          return this.role === su.app
      }
      get isAgentAppUser() {
          return this.app && (this.isAssignable || this.isMentionable)
      }
      get isInvited() {
          return !this.isActive && this.disableReason === au.invitePending
      }
      get isSuspended() {
          return !this.isActive && this.disableReason && [au.adminSuspended, au.downgraded].includes(this.disableReason)
      }
      get isDowngraded() {
          return !this.isActive && this.disableReason === au.downgraded
      }
      get hasLeftWorkspace() {
          return !this.isActive && this.disableReason === au.leftWorkspace
      }
      get isNotInGoogleHostedDomain() {
          return !this.isActive && this.disableReason === au.notInGoogleHostedDomain
      }
      get isSuperuser() {
          return this.guest && !this.developerUserRoleOverrideValue ? !1 : ru.superUserDomains.includes(this.domain) && ru.superUserUrlKeys.includes(this.organization.urlKey)
      }
      get canCreateTeam() {
          return this.hasPermission(Cd.teamCreation)
      }
      canManageLabels(e) {
          return this.guest || this.app ? !1 : e ? e.hasPermission(Nd.labelManagement, this) : this.hasPermission(Cd.labelManagement)
      }
      canManageLabel(e) {
          let t = e instanceof OH ? e.team : void 0;
          return this.canManageLabels(t)
      }
      get canInviteUsers() {
          return this.hasPermission(Cd.invitations)
      }
      get canManageInviteLink() {
          return !(!this.hasPermission(Cd.inviteLink) || this.organization.isScimEnabled || this.organization.samlEnabled || this.organization.createdAt < Eu)
      }
      get hasMultipleWorkspaces() {
          return mo.hasMultipleWorkspaces()
      }
      isIdentityProviderManaged(e=`either`) {
          return (e === `scim` ? this.organization.scimEnabled : this.organization.samlEnabled || this.organization.scimEnabled) && !!this.identityProvider
      }
      get presence() {
          if (this.app || this.isInvited)
              return;
          if (this.isMe)
              return dU.online;
          this.ephemeralSubscribe(),
          gn(UU / 4);
          let e = this.lastUserInteraction && this.lastUserInteraction.getTime();
          return !e || e < Date.now() - WU ? dU.offline : e > Date.now() - UU ? dU.online : dU.away
      }
      get defaultTeamForIssues() {
          let e = this.teamMemberships.first?.team ?? this.organization.accessibleTeams.first;
          if (!e)
              throw Error(`User has no accessible teams`);
          return e
      }
      get allowSessionRecording() {
          return !!(Jn.COUNTRY_CODE === `US` && this.createdDaysAgo <= 1 && this.organization.isFreePlan && this.organization.users.length <= 10 && this.organization.createdDaysAgo <= 2)
      }
      get createdDaysAgo() {
          return $e(new Date, this.createdAt)
      }
      get feedSummarySchedule() {
          return this.settings.feedSummarySchedule ?? this.organization.defaultFeedSummarySchedule
      }
      showOnboarding(e) {
          let t = !e && !this.hasMultipleWorkspaces && this.settings.getFlag(mu.completedOnboarding) === 0;
          return t && this.createdDaysAgo > 30 ? (w.warning(`Onboarding flag unexpectedly not set`, {
              userId: this.id,
              createdDaysAgo: this.createdDaysAgo,
              flags: this.settings.getFlagsForDebugging(),
              sessionStartedAt: performance.now()
          }),
          !1) : t
      }
      get canAccessFeed() {
          return this.organization?.isFeedAccessible && !this.guest
      }
      static isOutOfOffice(e) {
          let t = HU.outOfOfficeIntervalAt(e, new Date);
          return !!(t && Ze(t.end, new Date) > Su.LEAVING_OOO_THRESHOLD_HOURS)
      }
      static outOfOfficeIntervalAt(e, t) {
          let n = e.filter(e => e.type === xu.outOfOffice).elements;
          return Su.getEventsIntervalAtDate(t, n)
      }
      static outOfOfficeStatusFormatted(e, t) {
          let n = t.filter(e => e.type === xu.outOfOffice).elements
            , r = Su.humanizeEventsInterval(new Date, n, e.timezone);
          return r ? `Away ` + r : void 0
      }
      async canSkipNetworkHydration(e) {
          return await this.store.syncClient.hasModelsForPartialIndexes(e.modelName, this.organization.accessibleTeams.map(e => wm.createPartialIndex({
              modelClass: K,
              syncGroup: e.id
          })), {
              requireAll: !0
          })
      }
      get domain() {
          return Lu.parseDomain(this.email)
      }
      updateForPlaceholder() {
          this.organization = this.store.organization,
          this.name = ``,
          this.displayName = ``,
          this.role = su.user,
          this.active = !0,
          this.email = ``,
          this.createdAt = new Date(0),
          this.updatedAt = new Date(0)
      }
  }
  ,
  M([R({
      default: ``
  })], J.prototype, `name`, void 0),
  M([R({
      default: ``
  })], J.prototype, `displayName`, void 0),
  M([R({
      persistence: `createOnly`,
      default: ``
  })], J.prototype, `email`, void 0),
  M([R()], J.prototype, `avatarUrl`, void 0),
  M([B( () => q, `allUsers`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], J.prototype, `organization`, void 0),
  M([og( () => XL)], J.prototype, `notifications`, void 0),
  M([z( () => bM, {
      index: `userId`
  })], J.prototype, `reminders`, void 0),
  M([og( () => sU)], J.prototype, `pushSubscriptions`, void 0),
  M([og( () => aU)], J.prototype, `apiKeys`, void 0),
  M([z( () => Y, {
      index: `assigneeId`,
      canSkipNetworkHydration: e => e.canSkipNetworkHydration(Y)
  })], J.prototype, `assignedIssues`, void 0),
  M([z( () => Y, {
      index: `creatorId`,
      canSkipNetworkHydration: e => e.canSkipNetworkHydration(Y),
      order: new P(`createdAt`,`desc`)
  })], J.prototype, `createdIssues`, void 0),
  M([z( () => Y, {
      index: `delegateId`,
      canSkipNetworkHydration: e => e.canSkipNetworkHydration(Y)
  })], J.prototype, `delegatedIssues`, void 0),
  M([z( () => lU, {
      index: `userId`,
      order: new P(`startsAt`,`asc`)
  })], J.prototype, `calendarEvents`, void 0),
  M([z( () => Y, {
      index: `subscriberIds`,
      canSkipNetworkHydration: e => e.canSkipNetworkHydration(Y)
  })], J.prototype, `subscribedIssues`, void 0),
  M([z( () => NR, {
      index: `subscriberIds`,
      canSkipNetworkHydration: e => e.canSkipNetworkHydration(NR)
  })], J.prototype, `subscribedDocuments`, void 0),
  M([z( () => VA, {
      index: `creatorId`
  })], J.prototype, `facets`, void 0),
  M([z( () => Hj, {
      index: `userId`
  })], J.prototype, `posts`, void 0),
  M([z( () => wU, {
      index: `userId`
  })], J.prototype, `feedSubscriptions`, void 0),
  M([z( () => VA, {
      index: `sourceFeedUserId`,
      order: new P(`sortOrder`)
  })], J.prototype, `feedFacets`, void 0),
  M([og( () => wH, {
      order: new P(`updatedAt`,`desc`)
  })], J.prototype, `issueDrafts`, void 0),
  M([og( () => kM, {
      order: new P(`updatedAt`,`desc`)
  })], J.prototype, `drafts`, void 0),
  M([z( () => Lj, {
      index: `creatorId`
  })], J.prototype, `issueImports`, void 0),
  M([og( () => yH, {
      order: new P(`sortOrder`)
  })], J.prototype, `favorites`, void 0),
  M([og( () => mU, {
      order: new P(`date`,`desc`)
  })], J.prototype, `diaryEntries`, void 0),
  M([ug({
      nullable: !0
  })], J.prototype, `favorite`, void 0),
  M([og( () => FL, {
      order: new P(`createdAt`)
  })], J.prototype, `subscriptions`, void 0),
  M([ug({
      nullable: !0
  })], J.prototype, `subscription`, void 0),
  M([z( () => NA, {
      index: `userId`,
      canSkipHydration: e => e.organization.viewPreferences.isHydrated()
  })], J.prototype, `viewPreferences`, void 0),
  M([ug({
      nullable: !0
  })], J.prototype, `settings`, void 0),
  M([og( () => nH, {
      order: new P(`sortOrder`),
      Collection: gU
  })], J.prototype, `teamMemberships`, void 0),
  M([z( () => Az, {
      index: `ownerId`,
      order: new P(`name`)
  })], J.prototype, `customViews`, void 0),
  M([z( () => Fj, {
      index: `ownerId`,
      order: new P(`name`)
  })], J.prototype, `dashboards`, void 0),
  M([og( () => W, {
      order: new P(`sortOrder`)
  })], J.prototype, `initiatives`, void 0),
  M([z( () => U, {
      index: `creatorId`,
      order: new P(`openedAt`,`desc`)
  })], J.prototype, `createdPullRequests`, void 0),
  M([z( () => U, {
      index: `reviewerUserIds`,
      order: new P(`openedAt`,`desc`)
  })], J.prototype, `reviewerOfPullRequests`, void 0),
  M([og( () => qU, {
      order: new P(`updatedAt`,`asc`)
  })], J.prototype, `activities`, void 0),
  M([z( () => BU, {
      index: `userId`,
      order: new P(`createdAt`,`desc`)
  })], J.prototype, `aiConversations`, void 0),
  M([z( () => Tg, {
      index: `userId`
  })], J.prototype, `aiPromptSubscriptions`, void 0),
  M([z( () => xj, {
      index: `userId`
  })], J.prototype, `createdAgentActivities`, void 0),
  M([z( () => tU, {
      index: `creatorId`,
      order: new P(`createdAt`,`desc`)
  })], J.prototype, `batchOperations`, void 0),
  M([R({
      persistence: `none`
  })], J.prototype, `disableReason`, void 0),
  M([R({
      persistence: `none`,
      serializer: Ah
  })], J.prototype, `lastSeen`, void 0),
  M([R()], J.prototype, `description`, void 0),
  M([R()], J.prototype, `statusEmoji`, void 0),
  M([R()], J.prototype, `statusLabel`, void 0),
  M([R({
      serializer: Ah
  })], J.prototype, `statusUntilAt`, void 0),
  M([R()], J.prototype, `timezone`, void 0),
  M([R({
      persistence: `createOnly`,
      default: {}
  })], J.prototype, `externalUserMapping`, void 0),
  M([R({
      persistence: `createOnly`,
      default: ``
  })], J.prototype, `userAccountId`, void 0),
  M([R({
      persistence: `none`
  })], J.prototype, `appBaseSyncGroups`, void 0),
  M([R({
      persistence: `none`
  })], J.prototype, `oauthClientId`, void 0),
  M([R({
      persistence: `none`
  })], J.prototype, `appScopes`, void 0),
  M([z( () => Uk, {
      index: `reviewerId`
  })], J.prototype, `pendingReviews`, void 0),
  M([B( () => BH, `users`, {
      nullable: !0,
      persistence: `none`,
      indexed: !0
  })], J.prototype, `identityProvider`, void 0),
  M([jre({
      serializer: Ah
  })], J.prototype, `lastUserInteraction`, void 0),
  M([L], J.prototype, `teamsCount`, null),
  M([L], J.prototype, `teams`, null),
  M([L], J.prototype, `nonMemberTeams`, null),
  M([L], J.prototype, `nonMemberTeamsSorted`, null),
  M([L], J.prototype, `teamIssueLabels`, null),
  M([L], J.prototype, `feedSubscriptionsByModelId`, null),
  M([L], J.prototype, `projects`, null),
  M([L], J.prototype, `ownedInitiatives`, null),
  M([I], J.prototype, `toggleFavorite`, null),
  M([L], J.prototype, `canJoinAnotherTeam`, null),
  M([L], J.prototype, `unreadNotificationCount`, null),
  M([L], J.prototype, `activeFavorites`, null),
  M([L], J.prototype, `hasFavoriteFolders`, null),
  M([L], J.prototype, `_viewPreferences`, null),
  M([L], J.prototype, `_viewPreferencesCreatedBy`, null),
  M([I], J.prototype, `leaveTeam`, null),
  M([I], J.prototype, `joinTeam`, null),
  M([I], J.prototype, `reorderTeamInSidebar`, null),
  M([L], J.prototype, `isMentionable`, null),
  M([L], J.prototype, `isAssignable`, null),
  M([L], J.prototype, `isAgentAppUser`, null),
  M([L], J.prototype, `presence`, null),
  M([L], J.prototype, `allowSessionRecording`, null),
  M([L], J.prototype, `createdDaysAgo`, null),
  M([L], J.prototype, `feedSummarySchedule`, null),
  M([R({
      persistence: `createOnly`,
      default: su.user
  })], J.prototype, `role`, void 0),
  M([R({
      default: !0,
      persistence: `none`
  })], J.prototype, `active`, void 0),
  J = HU = M([mg(`User`)], J)
}
)), KU, qU, JU = t(( () => {
  Lq(),
  GU(),
  V(),
  F(),
  ws(),
  N(),
  Ot(),
  kt( () => import(`./EmojiHelper.BVatZNFS.js`), [], import.meta.url).then(e => {
      KU = e.EmojiHelper
  }
  ),
  qU = class extends qh {
      matchInlineFind(e) {
          return this.issue?.value?.matchInlineFind(e) ? !0 : this.events.some(t => {
              if (`issueTitle`in t && t.issueTitle.toLowerCase().includes(e) || `commentText`in t && t.commentText.toLowerCase().includes(e))
                  return !0;
              if (`reactions`in t) {
                  if (!KU)
                      return w.warning(`EmojiHelper not loaded, skipping emoji search`),
                      !1;
                  let n = KU.findNativeBySymbol(e);
                  if (t.reactions.some(t => t.emoji.toLowerCase().includes(e) || n && t.emoji.toLowerCase().includes(n.name)))
                      return !0
              }
              return !1
          }
          )
      }
  }
  ,
  M([B( () => J, `activities`, {
      persistence: `none`,
      optional: !0,
      nullable: !1,
      indexed: !0
  })], qU.prototype, `user`, void 0),
  M([sg( () => Y, `activities`, {
      persistence: `none`,
      optional: !0,
      nullable: !1,
      indexed: !0
  })], qU.prototype, `issue`, void 0),
  M([R()], qU.prototype, `issueId`, void 0),
  M([R({
      default: []
  })], qU.prototype, `events`, void 0),
  qU = M([mg(`Activity`)], qU)
}
));
function YU(e) {
  return e.type === `apiKey` ? `API key` : e.type === `integration` && e.subType ? Ys.getDisplayName(e.subType) : e.type === `email` && e.emailIntakeMetadata?.from ? Lu.formatEmailAddress(e.emailIntakeMetadata.from) : e.userDisplayName ? e.userDisplayName : e.displayName ? e.displayName : `Linear`
}
var XU = t(( () => {
  Xs(),
  Ru()
}
)), ZU, QU = t(( () => {
  XU(),
  V(),
  om(),
  F(),
  AV(),
  _H(),
  Lq(),
  Rj(),
  kH(),
  iz(),
  mH(),
  GU(),
  dx(),
  Ih(),
  Iy(),
  WB(),
  N(),
  ZU = class extends qh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular;
      static #n = this.partialPreloadForTeam = am.secondPriority;
      actors() {
          let e = this.sourceMetadata?.userId, t = e ? this.store.findById(J, e) : void 0, n;
          return !t && this.sourceMetadata?.externalUserId && (n = this.store.hydrateModel(Fy, this.sourceMetadata.externalUserId)),
          (this.changes?.descriptionUpdatedByIds?.map(e => this.store.findById(J, e)) || [this.actor ?? t ?? n]).concrete()
      }
      getActorIdOrApplicationName() {
          if (this.actorId)
              return this.actorId;
          if (this.sourceMetadata?.externalUserId)
              return this.sourceMetadata.externalUserId;
          if (this.sourceMetadata?.userId)
              return this.sourceMetadata.userId;
          if (this.customerNeed?.value?.creator?.id)
              return this.customerNeed.value.creator.id;
          if (this.attachment?.value?.creator?.id)
              return this.attachment.value.creator.id;
          if (this.sourceMetadata)
              return YU(this.sourceMetadata)
      }
      userActor() {
          if (this.actor)
              return this.actor;
          if (this.sourceMetadata?.externalUserId)
              return this.store.hydrateModel(Fy, this.sourceMetadata.externalUserId);
          if (this.sourceMetadata?.userId)
              return this.store.findById(J, this.sourceMetadata.userId);
          if (this.customerNeed)
              return this.customerNeed.value?.creator;
          if (this.attachment)
              return this.attachment.value?.creator
      }
      hydrateExtra() {
          return {
              hydrate: async () => {
                  let e = this.sourceMetadata?.externalUserId;
                  e && await this.store.hydrateModel(Fy, e)
              }
              ,
              isHydrated: () => {
                  let e = this.sourceMetadata?.externalUserId;
                  return e ? !this.store.findById(Fy, e) : !0
              }
          }
      }
  }
  ,
  M([sg( () => Y, `history`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      trait: `useForPartialIndex`
  })], ZU.prototype, `issue`, void 0),
  M([R()], ZU.prototype, `actorId`, void 0),
  M([cg( () => J, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `actor`, void 0),
  M([R()], ZU.prototype, `sourceMetadata`, void 0),
  M([R()], ZU.prototype, `updatedDescription`, void 0),
  M([R()], ZU.prototype, `fromTitle`, void 0),
  M([R()], ZU.prototype, `toTitle`, void 0),
  M([R()], ZU.prototype, `fromAssigneeId`, void 0),
  M([cg( () => J, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `fromAssignee`, void 0),
  M([R()], ZU.prototype, `toAssigneeId`, void 0),
  M([cg( () => J, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `toAssignee`, void 0),
  M([R()], ZU.prototype, `fromPriority`, void 0),
  M([R()], ZU.prototype, `toPriority`, void 0),
  M([R()], ZU.prototype, `fromTeamId`, void 0),
  M([cg( () => K, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `fromTeam`, void 0),
  M([R()], ZU.prototype, `toTeamId`, void 0),
  M([cg( () => K, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `toTeam`, void 0),
  M([R()], ZU.prototype, `fromParentId`, void 0),
  M([lg( () => Y, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `fromParent`, void 0),
  M([R()], ZU.prototype, `toParentId`, void 0),
  M([lg( () => Y, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `toParent`, void 0),
  M([R()], ZU.prototype, `fromStateId`, void 0),
  M([cg( () => ux, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `fromState`, void 0),
  M([R()], ZU.prototype, `toStateId`, void 0),
  M([cg( () => ux, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `toState`, void 0),
  M([R()], ZU.prototype, `fromCycleId`, void 0),
  M([lg( () => gH, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `fromCycle`, void 0),
  M([lg( () => gH, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `toCycle`, void 0),
  M([R()], ZU.prototype, `fromProjectId`, void 0),
  M([cg( () => G, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `fromProject`, void 0),
  M([R()], ZU.prototype, `toProjectId`, void 0),
  M([cg( () => G, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `toProject`, void 0),
  M([cg( () => G, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `toConvertedProject`, void 0),
  M([R()], ZU.prototype, `fromEstimate`, void 0),
  M([R()], ZU.prototype, `toEstimate`, void 0),
  M([R()], ZU.prototype, `archived`, void 0),
  M([R()], ZU.prototype, `trashed`, void 0),
  M([lg( () => Lj, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `issueImport`, void 0),
  M([lg( () => kV, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `attachment`, void 0),
  M([lg( () => UB, {
      nullable: !0,
      onDelete: `NO ACTION`
  })], ZU.prototype, `customerNeed`, void 0),
  M([fg( () => OH, void 0, {
      onDelete: `NO ACTION`
  })], ZU.prototype, `addedLabels`, void 0),
  M([fg( () => OH, void 0, {
      onDelete: `NO ACTION`
  })], ZU.prototype, `removedLabels`, void 0),
  M([R({
      serializer: Mh,
      persistence: `none`
  })], ZU.prototype, `relationChanges`, void 0),
  M([R()], ZU.prototype, `autoClosed`, void 0),
  M([R()], ZU.prototype, `autoArchived`, void 0),
  M([R({
      serializer: jh
  })], ZU.prototype, `fromDueDate`, void 0),
  M([R({
      serializer: jh
  })], ZU.prototype, `toDueDate`, void 0),
  M([R({
      serializer: kh({
          fromSlaBreachesAt: {
              serializer: Ah,
              nullable: !0
          },
          toSlaBreachesAt: {
              serializer: Ah,
              nullable: !0
          },
          fromSlaStartedAt: {
              serializer: Ah,
              nullable: !0
          },
          toSlaStartedAt: {
              serializer: Ah,
              nullable: !0
          }
      }),
      shallowObservation: !0
  })], ZU.prototype, `changes`, void 0),
  ZU = M([mg(`IssueHistory`)], ZU)
}
));
function $U(e) {
  var t, n, r = ``;
  if (typeof e == `string` || typeof e == `number`)
      r += e;
  else if (typeof e == `object`)
      if (Array.isArray(e)) {
          var i = e.length;
          for (t = 0; t < i; t++)
              e[t] && (n = $U(e[t])) && (r && (r += ` `),
              r += n)
      } else
          for (n in e)
              e[n] && (r && (r += ` `),
              r += n);
  return r
}
function rue() {
  for (var e, t, n = 0, r = ``, i = arguments.length; n < i; n++)
      (e = arguments[n]) && (t = $U(e)) && (r && (r += ` `),
      r += t);
  return r
}
var eW, tW = t(( () => {
  eW = rue
}
));
function nW(e) {
  return new rW(e)
}
var rW, iW = t(( () => {
  rW = class extends Error {
      constructor(e) {
          super(`Unreachable case: ${e}`)
      }
  }
}
));
function aW(e) {
  switch (e) {
  case `micro`:
      return 14;
  case `tiny`:
      return 16;
  case `small`:
      return 18;
  case `regular`:
      return 24;
  case `large`:
      return 32;
  case `xlarge`:
      return 44;
  case `huge`:
      return 54;
  default:
      throw nW(e)
  }
}
function iue(e, t) {
  let n = `normal`;
  return (t?.length ?? 0) > 2 ? n = `threeInitials` : t === `WW` && (n = `ww`),
  {
      micro: {
          normal: 8,
          ww: 5,
          threeInitials: 4
      },
      tiny: {
          normal: 9,
          ww: 6,
          threeInitials: 5
      },
      small: {
          normal: 9,
          ww: 7,
          threeInitials: 5
      },
      regular: {
          normal: 11,
          ww: 9,
          threeInitials: 7
      },
      large: {
          normal: 14,
          ww: 12,
          threeInitials: 9
      },
      xlarge: {
          normal: 18,
          ww: 15,
          threeInitials: 12
      },
      huge: {
          normal: 22,
          ww: 18,
          threeInitials: 16
      }
  }[e][n]
}
var oW = t(( () => {
  iW()
}
)), aue = n(( (e, t) => {
  var n = Object.create
    , r = Object.defineProperty
    , i = Object.getOwnPropertyDescriptor
    , a = Object.getOwnPropertyNames
    , o = Object.getPrototypeOf
    , s = Object.prototype.hasOwnProperty
    , c = (e, t) => {
      for (var n in t)
          r(e, n, {
              get: t[n],
              enumerable: !0
          })
  }
    , l = (e, t, n, o) => {
      if (t && typeof t == `object` || typeof t == `function`)
          for (let c of a(t))
              !s.call(e, c) && c !== n && r(e, c, {
                  get: () => t[c],
                  enumerable: !(o = i(t, c)) || o.enumerable
              });
      return e
  }
    , u = (e, t, i) => (i = e == null ? {} : n(o(e)),
  l(t || !e || !e.__esModule ? r(i, `default`, {
      value: e,
      enumerable: !0
  }) : i, e))
    , d = e => l(r({}, `__esModule`, {
      value: !0
  }), e)
    , f = {};
  c(f, {
      $dispatcherGuard: () => oe,
      $makeReadOnly: () => ce,
      $reset: () => se,
      $structuralCheck: () => he,
      c: () => te,
      clearRenderCounterRegistry: () => ue,
      renderCounterRegistry: () => le,
      useRenderCounter: () => pe
  }),
  t.exports = d(f);
  var p = u(ht())
    , {useRef: m, useEffect: h, isValidElement: g} = p
    , _ = p.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE ?? p.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
    , ee = Symbol.for(`react.memo_cache_sentinel`)
    , te = typeof p.__COMPILER_RUNTIME?.c == `function` ? p.__COMPILER_RUNTIME.c : function(e) {
      return p.useMemo( () => {
          let t = Array(e);
          for (let n = 0; n < e; n++)
              t[n] = ee;
          return t[ee] = !0,
          t
      }
      , [])
  }
    , ne = {};
  [`readContext`, `useCallback`, `useContext`, `useEffect`, `useImperativeHandle`, `useInsertionEffect`, `useLayoutEffect`, `useMemo`, `useReducer`, `useRef`, `useState`, `useDebugValue`, `useDeferredValue`, `useTransition`, `useMutableSource`, `useSyncExternalStore`, `useId`, `unstable_isNewReconciler`, `getCacheSignal`, `getCacheForType`, `useCacheRefresh`].forEach(e => {
      ne[e] = () => {
          throw Error(`[React] Unexpected React hook call (${e}) from a React compiled function. Check that all hooks are called directly and named according to convention ('use[A-Z]') `)
      }
  }
  );
  var re = null;
  ne.useMemoCache = e => {
      if (re == null)
          throw Error(`React Compiler internal invariant violation: unexpected null dispatcher`);
      return re.useMemoCache(e)
  }
  ;
  function ie(e) {
      return _.ReactCurrentDispatcher.current = e,
      _.ReactCurrentDispatcher.current
  }
  var ae = [];
  function oe(e) {
      let t = _.ReactCurrentDispatcher.current;
      if (e === 0) {
          if (ae.push(t),
          ae.length === 1 && (re = t),
          t === ne)
              throw Error(`[React] Unexpected call to custom hook or component from a React compiled function. Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') and (2) components are returned as JSX instead of being directly invoked.`);
          ie(ne)
      } else if (e === 1) {
          let e = ae.pop();
          if (e == null)
              throw Error(`React Compiler internal error: unexpected null in guard stack`);
          ae.length === 0 && (re = null),
          ie(e)
      } else if (e === 2)
          ae.push(t),
          ie(re);
      else if (e === 3) {
          let e = ae.pop();
          if (e == null)
              throw Error(`React Compiler internal error: unexpected null in guard stack`);
          ie(e)
      } else
          throw Error(`React Compiler internal error: unreachable block` + e)
  }
  function se(e) {
      for (let t = 0; t < e.length; t++)
          e[t] = ee
  }
  function ce() {
      throw Error(`TODO: implement $makeReadOnly in react-compiler-runtime`)
  }
  var le = new Map;
  function ue() {
      for (let e of le.values())
          e.forEach(e => {
              e.count = 0
          }
          )
  }
  function de(e, t) {
      let n = le.get(e);
      n ?? (n = new Set,
      le.set(e, n)),
      n.add(t)
  }
  function fe(e, t) {
      le.get(e)?.delete(t)
  }
  function pe(e) {
      let t = m(null);
      t.current != null && (t.current.count += 1),
      h( () => {
          if (t.current == null) {
              let n = {
                  count: 0
              };
              de(e, n),
              t.current = n
          }
          return () => {
              t.current !== null && fe(e, t.current)
          }
      }
      )
  }
  var me = new Set;
  function he(e, t, n, r, i, a) {
      function o(e, t, o, s) {
          let c = `${r}:${a} [${i}] ${n}${o} changed from ${e} to ${t} at depth ${s}`;
          me.has(c) || (me.add(c),
          console.error(c))
      }
      function s(e, t, n, r) {
          if (!(r > 2) && e !== t)
              if (typeof e != typeof t)
                  o(`type ${typeof e}`, `type ${typeof t}`, n, r);
              else if (typeof e == `object`) {
                  let i = Array.isArray(e)
                    , a = Array.isArray(t);
                  if (e === null && t !== null)
                      o(`null`, `type ${typeof t}`, n, r);
                  else if (t === null)
                      o(`type ${typeof e}`, `null`, n, r);
                  else if (e instanceof Map)
                      if (!(t instanceof Map))
                          o(`Map instance`, `other value`, n, r);
                      else if (e.size !== t.size)
                          o(`Map instance with size ${e.size}`, `Map instance with size ${t.size}`, n, r);
                      else
                          for (let[i,a] of e)
                              t.has(i) ? s(a, t.get(i), `${n}.get(${i})`, r + 1) : o(`Map instance with key ${i}`, `Map instance without key ${i}`, n, r);
                  else if (t instanceof Map)
                      o(`other value`, `Map instance`, n, r);
                  else if (e instanceof Set)
                      if (!(t instanceof Set))
                          o(`Set instance`, `other value`, n, r);
                      else if (e.size !== t.size)
                          o(`Set instance with size ${e.size}`, `Set instance with size ${t.size}`, n, r);
                      else
                          for (let i of t)
                              e.has(i) || o(`Set instance without element ${i}`, `Set instance with element ${i}`, n, r);
                  else if (t instanceof Set)
                      o(`other value`, `Set instance`, n, r);
                  else if (i || a)
                      if (i !== a)
                          o(`type ${i ? `array` : `object`}`, `type ${a ? `array` : `object`}`, n, r);
                      else if (e.length !== t.length)
                          o(`array with length ${e.length}`, `array with length ${t.length}`, n, r);
                      else
                          for (let i = 0; i < e.length; i++)
                              s(e[i], t[i], `${n}[${i}]`, r + 1);
                  else if (g(e) || g(t))
                      g(e) === g(t) ? e.type === t.type ? s(e.props, t.props, `[props of ${n}]`, r + 1) : o(`React element of type ${e.type}`, `React element of type ${t.type}`, n, r) : o(`type ${g(e) ? `React element` : `object`}`, `type ${g(t) ? `React element` : `object`}`, n, r);
                  else {
                      for (let i in t)
                          i in e || o(`object without key ${i}`, `object with key ${i}`, n, r);
                      for (let i in e)
                          i in t ? s(e[i], t[i], `${n}.${i}`, r + 1) : o(`object with key ${i}`, `object without key ${i}`, n, r)
                  }
              } else if (typeof e == `function`)
                  return;
              else
                  isNaN(e) || isNaN(t) ? isNaN(e) !== isNaN(t) && o(`${isNaN(e) ? `NaN` : `non-NaN value`}`, `${isNaN(t) ? `NaN` : `non-NaN value`}`, n, r) : e !== t && o(e, t, n, r)
      }
      s(e, t, ``, 0)
  }
}
)), oue = n(( (e, t) => {
  t.exports = function(e, t, n, r) {
      var i = n ? n.call(r, e, t) : void 0;
      if (i !== void 0)
          return !!i;
      if (e === t)
          return !0;
      if (typeof e != `object` || !e || typeof t != `object` || !t)
          return !1;
      var a = Object.keys(e)
        , o = Object.keys(t);
      if (a.length !== o.length)
          return !1;
      for (var s = Object.prototype.hasOwnProperty.bind(t), c = 0; c < a.length; c++) {
          var l = a[c];
          if (!s(l))
              return !1;
          var u = e[l]
            , d = t[l];
          if (i = n ? n.call(r, u, d, l) : void 0,
          i === !1 || i === void 0 && u !== d)
              return !1
      }
      return !0
  }
}
)), sW, cW, lW, uW, dW, fW, pW, mW, hW, gW = t(( () => {
  sW = `-ms-`,
  cW = `-moz-`,
  lW = `-webkit-`,
  uW = `comm`,
  dW = `rule`,
  fW = `decl`,
  pW = `@import`,
  mW = `@keyframes`,
  hW = `@layer`
}
));
function sue(e, t) {
  return xW(e, 0) ^ 45 ? (((t << 2 ^ xW(e, 0)) << 2 ^ xW(e, 1)) << 2 ^ xW(e, 2)) << 2 ^ xW(e, 3) : 0
}
function _W(e) {
  return e.trim()
}
function vW(e, t) {
  return (e = t.exec(e)) ? e[0] : e
}
function yW(e, t, n) {
  return e.replace(t, n)
}
function bW(e, t, n) {
  return e.indexOf(t, n)
}
function xW(e, t) {
  return e.charCodeAt(t) | 0
}
function SW(e, t, n) {
  return e.slice(t, n)
}
function CW(e) {
  return e.length
}
function wW(e) {
  return e.length
}
function TW(e, t) {
  return t.push(e),
  e
}
function cue(e, t) {
  return e.map(t).join(``)
}
function EW(e, t) {
  return e.filter(function(e) {
      return !vW(e, t)
  })
}
var DW, OW, kW, AW = t(( () => {
  DW = Math.abs,
  OW = String.fromCharCode,
  kW = Object.assign
}
));
function jW(e, t, n, r, i, a, o, s) {
  return {
      value: e,
      root: t,
      parent: n,
      type: r,
      props: i,
      children: a,
      line: VW,
      column: HW,
      length: o,
      return: ``,
      siblings: s
  }
}
function MW(e, t) {
  return kW(jW(``, null, null, ``, null, null, 0, e.siblings), e, {
      length: -e.length
  }, t)
}
function NW(e) {
  for (; e.root; )
      e = MW(e.root, {
          children: [e]
      });
  TW(e, e.siblings)
}
function lue() {
  return GW
}
function uue() {
  return GW = WW > 0 ? xW(KW, --WW) : 0,
  HW--,
  GW === 10 && (HW = 1,
  VW--),
  GW
}
function PW() {
  return GW = WW < UW ? xW(KW, WW++) : 0,
  HW++,
  GW === 10 && (HW = 1,
  VW++),
  GW
}
function FW() {
  return xW(KW, WW)
}
function IW() {
  return WW
}
function LW(e, t) {
  return SW(KW, e, t)
}
function RW(e) {
  switch (e) {
  case 0:
  case 9:
  case 10:
  case 13:
  case 32:
      return 5;
  case 33:
  case 43:
  case 44:
  case 47:
  case 62:
  case 64:
  case 126:
  case 59:
  case 123:
  case 125:
      return 4;
  case 58:
      return 3;
  case 34:
  case 39:
  case 40:
  case 91:
      return 2;
  case 41:
  case 93:
      return 1
  }
  return 0
}
function due(e) {
  return VW = HW = 1,
  UW = CW(KW = e),
  WW = 0,
  []
}
function fue(e) {
  return KW = ``,
  e
}
function zW(e) {
  return _W(LW(WW - 1, BW(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
}
function pue(e) {
  for (; (GW = FW()) && GW < 33; )
      PW();
  return RW(e) > 2 || RW(GW) > 3 ? `` : ` `
}
function mue(e, t) {
  for (; --t && PW() && !(GW < 48 || GW > 102 || GW > 57 && GW < 65 || GW > 70 && GW < 97); )
      ;
  return LW(e, IW() + (t < 6 && FW() == 32 && PW() == 32))
}
function BW(e) {
  for (; PW(); )
      switch (GW) {
      case e:
          return WW;
      case 34:
      case 39:
          e !== 34 && e !== 39 && BW(GW);
          break;
      case 40:
          e === 41 && BW(e);
          break;
      case 92:
          PW();
          break
      }
  return WW
}
function hue(e, t) {
  for (; PW() && e + GW !== 57 && !(e + GW === 84 && FW() === 47); )
      ;
  return `/*` + LW(t, WW - 1) + `*` + OW(e === 47 ? e : PW())
}
function gue(e) {
  for (; !RW(FW()); )
      PW();
  return LW(e, WW)
}
var VW, HW, UW, WW, GW, KW, qW = t(( () => {
  AW(),
  VW = 1,
  HW = 1,
  UW = 0,
  WW = 0,
  GW = 0,
  KW = ``
}
));
function JW(e) {
  return fue(YW(``, null, null, null, [``], e = due(e), 0, [0], e))
}
function YW(e, t, n, r, i, a, o, s, c) {
  for (var l = 0, u = 0, d = o, f = 0, p = 0, m = 0, h = 1, g = 1, _ = 1, ee = 0, te = ``, ne = i, re = a, ie = r, ae = te; g; )
      switch (m = ee,
      ee = PW()) {
      case 40:
          if (m != 108 && xW(ae, d - 1) == 58) {
              bW(ae += yW(zW(ee), `&`, `&\f`), `&\f`, DW(l ? s[l - 1] : 0)) != -1 && (_ = -1);
              break
          }
      case 34:
      case 39:
      case 91:
          ae += zW(ee);
          break;
      case 9:
      case 10:
      case 13:
      case 32:
          ae += pue(m);
          break;
      case 92:
          ae += mue(IW() - 1, 7);
          continue;
      case 47:
          switch (FW()) {
          case 42:
          case 47:
              TW(_ue(hue(PW(), IW()), t, n, c), c);
              break;
          default:
              ae += `/`
          }
          break;
      case 123 * h:
          s[l++] = CW(ae) * _;
      case 125 * h:
      case 59:
      case 0:
          switch (ee) {
          case 0:
          case 125:
              g = 0;
          case 59 + u:
              _ == -1 && (ae = yW(ae, /\f/g, ``)),
              p > 0 && CW(ae) - d && TW(p > 32 ? ZW(ae + `;`, r, n, d - 1, c) : ZW(yW(ae, ` `, ``) + `;`, r, n, d - 2, c), c);
              break;
          case 59:
              ae += `;`;
          default:
              if (TW(ie = XW(ae, t, n, l, u, i, s, te, ne = [], re = [], d, a), a),
              ee === 123)
                  if (u === 0)
                      YW(ae, t, ie, ie, ne, a, d, s, re);
                  else
                      switch (f === 99 && xW(ae, 3) === 110 ? 100 : f) {
                      case 100:
                      case 108:
                      case 109:
                      case 115:
                          YW(e, ie, ie, r && TW(XW(e, ie, ie, 0, 0, i, s, te, i, ne = [], d, re), re), i, re, d, s, r ? ne : re);
                          break;
                      default:
                          YW(ae, ie, ie, ie, [``], re, 0, s, re)
                      }
          }
          l = u = p = 0,
          h = _ = 1,
          te = ae = ``,
          d = o;
          break;
      case 58:
          d = 1 + CW(ae),
          p = m;
      default:
          if (h < 1) {
              if (ee == 123)
                  --h;
              else if (ee == 125 && h++ == 0 && uue() == 125)
                  continue
          }
          switch (ae += OW(ee),
          ee * h) {
          case 38:
              _ = u > 0 ? 1 : (ae += `\f`,
              -1);
              break;
          case 44:
              s[l++] = (CW(ae) - 1) * _,
              _ = 1;
              break;
          case 64:
              FW() === 45 && (ae += zW(PW())),
              f = FW(),
              u = d = CW(te = ae += gue(IW())),
              ee++;
              break;
          case 45:
              m === 45 && CW(ae) == 2 && (h = 0)
          }
      }
  return a
}
function XW(e, t, n, r, i, a, o, s, c, l, u, d) {
  for (var f = i - 1, p = i === 0 ? a : [``], m = wW(p), h = 0, g = 0, _ = 0; h < r; ++h)
      for (var ee = 0, te = SW(e, f + 1, f = DW(g = o[h])), ne = e; ee < m; ++ee)
          (ne = _W(g > 0 ? p[ee] + ` ` + te : yW(te, /&\f/g, p[ee]))) && (c[_++] = ne);
  return jW(e, t, n, i === 0 ? dW : s, c, l, u, d)
}
function _ue(e, t, n, r) {
  return jW(e, t, n, uW, OW(lue()), SW(e, 2, -2), 0, r)
}
function ZW(e, t, n, r, i) {
  return jW(e, t, n, fW, SW(e, 0, r), SW(e, r + 1, -1), r, i)
}
var vue = t(( () => {
  gW(),
  AW(),
  qW()
}
));
function QW(e, t, n) {
  switch (sue(e, t)) {
  case 5103:
      return lW + `print-` + e + e;
  case 5737:
  case 4201:
  case 3177:
  case 3433:
  case 1641:
  case 4457:
  case 2921:
  case 5572:
  case 6356:
  case 5844:
  case 3191:
  case 6645:
  case 3005:
  case 6391:
  case 5879:
  case 5623:
  case 6135:
  case 4599:
  case 4855:
  case 4215:
  case 6389:
  case 5109:
  case 5365:
  case 5621:
  case 3829:
      return lW + e + e;
  case 4789:
      return cW + e + e;
  case 5349:
  case 4246:
  case 4810:
  case 6968:
  case 2756:
      return lW + e + cW + e + sW + e + e;
  case 5936:
      switch (xW(e, t + 11)) {
      case 114:
          return lW + e + sW + yW(e, /[svh]\w+-[tblr]{2}/, `tb`) + e;
      case 108:
          return lW + e + sW + yW(e, /[svh]\w+-[tblr]{2}/, `tb-rl`) + e;
      case 45:
          return lW + e + sW + yW(e, /[svh]\w+-[tblr]{2}/, `lr`) + e
      }
  case 6828:
  case 4268:
  case 2903:
      return lW + e + sW + e + e;
  case 6165:
      return lW + e + sW + `flex-` + e + e;
  case 5187:
      return lW + e + yW(e, /(\w+).+(:[^]+)/, lW + `box-$1$2` + sW + `flex-$1$2`) + e;
  case 5443:
      return lW + e + sW + `flex-item-` + yW(e, /flex-|-self/g, ``) + (vW(e, /flex-|baseline/) ? `` : sW + `grid-row-` + yW(e, /flex-|-self/g, ``)) + e;
  case 4675:
      return lW + e + sW + `flex-line-pack` + yW(e, /align-content|flex-|-self/g, ``) + e;
  case 5548:
      return lW + e + sW + yW(e, `shrink`, `negative`) + e;
  case 5292:
      return lW + e + sW + yW(e, `basis`, `preferred-size`) + e;
  case 6060:
      return lW + `box-` + yW(e, `-grow`, ``) + lW + e + sW + yW(e, `grow`, `positive`) + e;
  case 4554:
      return lW + yW(e, /([^-])(transform)/g, `$1` + lW + `$2`) + e;
  case 6187:
      return yW(yW(yW(e, /(zoom-|grab)/, lW + `$1`), /(image-set)/, lW + `$1`), e, ``) + e;
  case 5495:
  case 3959:
      return yW(e, /(image-set\([^]*)/, lW + "$1$`$1");
  case 4968:
      return yW(yW(e, /(.+:)(flex-)?(.*)/, lW + `box-pack:$3` + sW + `flex-pack:$3`), /s.+-b[^;]+/, `justify`) + lW + e + e;
  case 4200:
      if (!vW(e, /flex-|baseline/))
          return sW + `grid-column-align` + SW(e, t) + e;
      break;
  case 2592:
  case 3360:
      return sW + yW(e, `template-`, ``) + e;
  case 4384:
  case 3616:
      return n && n.some(function(e, n) {
          return t = n,
          vW(e.props, /grid-\w+-end/)
      }) ? ~bW(e + (n = n[t].value), `span`, 0) ? e : sW + yW(e, `-start`, ``) + e + sW + `grid-row-span:` + (~bW(n, `span`, 0) ? vW(n, /\d+/) : vW(n, /\d+/) - +vW(e, /\d+/)) + `;` : sW + yW(e, `-start`, ``) + e;
  case 4896:
  case 4128:
      return n && n.some(function(e) {
          return vW(e.props, /grid-\w+-start/)
      }) ? e : sW + yW(yW(e, `-end`, `-span`), `span `, ``) + e;
  case 4095:
  case 3583:
  case 4068:
  case 2532:
      return yW(e, /(.+)-inline(.+)/, lW + `$1$2`) + e;
  case 8116:
  case 7059:
  case 5753:
  case 5535:
  case 5445:
  case 5701:
  case 4933:
  case 4677:
  case 5533:
  case 5789:
  case 5021:
  case 4765:
      if (CW(e) - 1 - t > 6)
          switch (xW(e, t + 1)) {
          case 109:
              if (xW(e, t + 4) !== 45)
                  break;
          case 102:
              return yW(e, /(.+:)(.+)-([^]+)/, `$1` + lW + `$2-$3$1` + cW + (xW(e, t + 3) == 108 ? `$3` : `$2-$3`)) + e;
          case 115:
              return ~bW(e, `stretch`, 0) ? QW(yW(e, `stretch`, `fill-available`), t, n) + e : e
          }
      break;
  case 5152:
  case 5920:
      return yW(e, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(t, n, r, i, a, o, s) {
          return sW + n + `:` + r + s + (i ? sW + n + `-span:` + (a ? o : o - +r) + s : ``) + e
      });
  case 4949:
      if (xW(e, t + 6) === 121)
          return yW(e, `:`, `:` + lW) + e;
      break;
  case 6444:
      switch (xW(e, xW(e, 14) === 45 ? 18 : 11)) {
      case 120:
          return yW(e, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, `$1` + lW + (xW(e, 14) === 45 ? `inline-` : ``) + `box$3$1` + lW + `$2$3$1` + sW + `$2box$3`) + e;
      case 100:
          return yW(e, `:`, `:` + sW) + e
      }
      break;
  case 5719:
  case 2647:
  case 2135:
  case 3927:
  case 2391:
      return yW(e, `scroll-`, `scroll-snap-`) + e
  }
  return e
}
var $W = t(( () => {
  gW(),
  AW()
}
));
function eG(e, t) {
  for (var n = ``, r = 0; r < e.length; r++)
      n += t(e[r], r, e, t) || ``;
  return n
}
function tG(e, t, n, r) {
  switch (e.type) {
  case hW:
      if (e.children.length)
          break;
  case pW:
  case fW:
      return e.return = e.return || e.value;
  case uW:
      return ``;
  case mW:
      return e.return = e.value + `{` + eG(e.children, r) + `}`;
  case dW:
      if (!CW(e.value = e.props.join(`,`)))
          return ``
  }
  return CW(n = eG(e.children, r)) ? e.return = e.value + `{` + n + `}` : ``
}
var nG = t(( () => {
  gW(),
  AW()
}
));
function yue(e) {
  var t = wW(e);
  return function(n, r, i, a) {
      for (var o = ``, s = 0; s < t; s++)
          o += e[s](n, r, i, a) || ``;
      return o
  }
}
function bue(e) {
  return function(t) {
      t.root || (t = t.return) && e(t)
  }
}
function xue(e, t, n, r) {
  if (e.length > -1 && !e.return)
      switch (e.type) {
      case fW:
          e.return = QW(e.value, e.length, n);
          return;
      case mW:
          return eG([MW(e, {
              value: yW(e.value, `@`, `@` + lW)
          })], r);
      case dW:
          if (e.length)
              return cue(n = e.props, function(t) {
                  switch (vW(t, r = /(::plac\w+|:read-\w+)/)) {
                  case `:read-only`:
                  case `:read-write`:
                      NW(MW(e, {
                          props: [yW(t, /:(read-\w+)/, `:` + cW + `$1`)]
                      })),
                      NW(MW(e, {
                          props: [t]
                      })),
                      kW(e, {
                          props: EW(n, r)
                      });
                      break;
                  case `::placeholder`:
                      NW(MW(e, {
                          props: [yW(t, /:(plac\w+)/, `:` + lW + `input-$1`)]
                      })),
                      NW(MW(e, {
                          props: [yW(t, /:(plac\w+)/, `:` + cW + `$1`)]
                      })),
                      NW(MW(e, {
                          props: [yW(t, /:(plac\w+)/, sW + `input-$1`)]
                      })),
                      NW(MW(e, {
                          props: [t]
                      })),
                      kW(e, {
                          props: EW(n, r)
                      });
                      break
                  }
                  return ``
              })
      }
}
var Sue = t(( () => {
  gW(),
  AW(),
  qW(),
  nG(),
  $W()
}
))
, rG = t(( () => {
  gW(),
  AW(),
  vue(),
  $W(),
  qW(),
  nG(),
  Sue()
}
));
function iG(e, t, n=HG) {
  return e.theme !== n.theme && e.theme || t || n.theme
}
function aG(e) {
  return e.replace(WG, `-`).replace(GG, ``)
}
function oG(e) {
  let t, n = ``;
  for (t = Math.abs(e); t > 52; t = t / 52 | 0)
      n = qG(t % 52) + n;
  return (qG(t % 52) + n).replace(KG, `$1-$2`)
}
function sG(e) {
  return oG(YG(e) >>> 0)
}
function Cue(e) {
  return e.displayName || e.name || `Component`
}
function cG(e) {
  return typeof e == `string` && !0
}
function wue(e) {
  return cG(e) ? `styled.${e}` : `Styled(${Cue(e)})`
}
function lG(e) {
  return function(e) {
      return (`type`in e && e.type.$$typeof) === ZG
  }(e) ? tK : `$$typeof`in e ? nK[e.$$typeof] : $G
}
function uG(e, t, n) {
  if (typeof t != `string`) {
      if (cK) {
          let r = sK(t);
          r && r !== cK && uG(e, r, n)
      }
      let r = iK(t);
      aK && (r = r.concat(aK(t)));
      let i = lG(e)
        , a = lG(t);
      for (let o = 0; o < r.length; ++o) {
          let s = r[o];
          if (!(s in eK || n && n[s] || a && s in a || i && s in i)) {
              let n = oK(t, s);
              try {
                  rK(e, s, n)
              } catch {}
          }
      }
  }
  return e
}
function dG(e) {
  return typeof e == `function`
}
function fG(e) {
  return typeof e == `object` && `styledComponentId`in e
}
function pG(e, t) {
  return e && t ? `${e} ${t}` : e || t || ``
}
function mG(e, t) {
  if (e.length === 0)
      return ``;
  let n = e[0];
  for (let r = 1; r < e.length; r++)
      n += t ? t + e[r] : e[r];
  return n
}
function hG(e) {
  return typeof e == `object` && !!e && e.constructor.name === Object.name && !(`props`in e && e.$$typeof)
}
function gG(e, t, n=!1) {
  if (!n && !hG(e) && !Array.isArray(e))
      return t;
  if (Array.isArray(t))
      for (let n = 0; n < t.length; n++)
          e[n] = gG(e[n], t[n]);
  else if (hG(t))
      for (let n in t)
          e[n] = gG(e[n], t[n]);
  return e
}
function _G(e, ...t) {
  return Error(`An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#${e} for more information.${t.length > 0 ? ` Args: ${t.join(`, `)}` : ``}`)
}
function Tue() {
  return typeof __webpack_nonce__ < `u` ? __webpack_nonce__ : null
}
function vG(e, t) {
  return e.map(e => (e.type === `rule` && (e.value = `${t} ${e.value}`,
  e.value = e.value.replaceAll(`,`, `,${t} `),
  e.props = e.props.map(e => `${t} ${e}`)),
  Array.isArray(e.children) && e.type !== `@keyframes` && (e.children = vG(e.children, t)),
  e))
}
function yG({options: e=HG, plugins: t=VG}=HG) {
  let n, r, i, a = (e, t, i) => i.startsWith(r) && i.endsWith(r) && i.replaceAll(r, ``).length > 0 ? `.${n}` : e, o = t.slice();
  o.push(e => {
      e.type === `rule` && e.value.includes(`&`) && (e.props[0] = e.props[0].replace(EK, r).replace(i, a))
  }
  ),
  e.prefix && o.push(xue),
  o.push(tG);
  let s = (t, a=``, s=``, c=`&`) => {
      n = c,
      r = a,
      i = RegExp(`\\${r}\\b`, `g`);
      let l = t.replace(DK, ``)
        , u = JW(s || a ? `${s} ${a} { ${l} }` : l);
      e.namespace && (u = vG(u, e.namespace));
      let d = [];
      return eG(u, yue(o.concat(bue(e => d.push(e))))),
      d
  }
  ;
  return s.hash = t.length ? t.reduce( (e, t) => (t.name || _G(15),
  JG(e, t.name)), 5381).toString() : ``,
  s
}
function bG() {
  return (0,
  MG.useContext)(AK)
}
function Eue(e) {
  let[t,n] = (0,
  MG.useState)(e.stylisPlugins)
    , {styleSheet: r} = bG()
    , i = (0,
  MG.useMemo)( () => {
      let t = r;
      return e.sheet ? t = e.sheet : e.target && (t = t.reconstructWithOptions({
          target: e.target
      }, !1)),
      t
  }
  , [e.sheet, e.target, r])
    , a = (0,
  MG.useMemo)( () => yG({
      options: {
          namespace: e.namespace,
          prefix: e.enableVendorPrefixes
      },
      plugins: t
  }), [e.enableVendorPrefixes, e.namespace, t]);
  (0,
  NG.default)(t, e.stylisPlugins) || n(e.stylisPlugins);
  let o = (0,
  MG.useMemo)( () => ({
      shouldForwardProp: e.shouldForwardProp,
      styleSheet: i,
      stylis: a
  }), [e.shouldForwardProp, i, a]);
  return (0,
  jG.jsx)(AK.Provider, {
      value: o,
      children: (0,
      jG.jsx)(jK.Provider, {
          value: a,
          children: e.children
      })
  })
}
function xG(e) {
  let t = ``;
  for (let n = 0; n < e.length; n++) {
      let r = e[n];
      if (n === 1 && r === `-` && e[0] === `-`)
          return e;
      NK(r) ? t += `-` + r.toLowerCase() : t += r
  }
  return t.startsWith(`ms-`) ? `-` + t : t
}
function SG(e, t, n, r) {
  return PK(e) ? [] : fG(e) ? [`.${e.styledComponentId}`] : dG(e) ? function(e) {
      return dG(e) && !(e.prototype && e.prototype.isReactComponent)
  }(e) && t ? SG(e(t), t, n, r) : [e] : e instanceof MK ? n ? (e.inject(n, r),
  [e.getName(r)]) : [e] : hG(e) ? FK(e) : Array.isArray(e) ? e.flatMap(e => SG(e, t, n, r)) : [e.toString()]
}
function CG(e) {
  for (let t = 0; t < e.length; t += 1) {
      let n = e[t];
      if (dG(n) && !fG(n))
          return !1
  }
  return !0
}
function wG() {
  let e = (0,
  MG.useContext)(RK);
  if (!e)
      throw _G(18);
  return e
}
function TG(e) {
  let t = (0,
  MG.useContext)(RK)
    , n = (0,
  MG.useMemo)( () => function(e, t) {
      if (!e)
          throw _G(14);
      if (dG(e))
          return e(t);
      if (Array.isArray(e) || typeof e != `object`)
          throw _G(8);
      return t ? {
          ...t,
          ...e
      } : e
  }(e.theme, t), [e.theme, t]);
  return e.children ? (0,
  jG.jsx)(RK.Provider, {
      value: n,
      children: e.children
  }) : null
}
function Due(e, t) {
  let n = typeof e == `string` ? aG(e) : `sc`;
  zK[n] = (zK[n] || 0) + 1;
  let r = `${n}-${sG(LG + n + zK[n])}`;
  return t ? `${t}-${r}` : r
}
function Oue(e) {
  return `className: ${e}`
}
function kue(e) {
  return `styledComponentId: ${e}`
}
function Aue(e, t, n) {
  let r = fG(e)
    , i = e
    , a = !cG(e)
    , {attrs: o=VG, componentId: s=Due(t.displayName, t.parentComponentId), displayName: c=wue(e)} = t
    , l = t.displayName && t.componentId ? `${aG(t.displayName)}-${t.componentId}` : t.componentId || s
    , u = r && i.attrs ? i.attrs.concat(o).filter(Boolean) : o
    , {shouldForwardProp: d} = t;
  if (r && i.shouldForwardProp) {
      let e = i.shouldForwardProp;
      if (t.shouldForwardProp) {
          let n = t.shouldForwardProp;
          d = (t, r) => e(t, r) && n(t, r)
      } else
          d = e
  }
  let f = new LK(n,l,r ? i.componentStyle : void 0);
  function p(e, t) {
      return function(e, t, n) {
          let r = (0,
          AG.c)(3)
            , {attrs: i, componentStyle: a, defaultProps: o, foldedComponentIds: s, styledComponentId: c, target: l} = e
            , u = (0,
          MG.useContext)(RK)
            , d = bG()
            , f = e.shouldForwardProp || d.shouldForwardProp;
          (0,
          MG.useDebugValue)(c, kue);
          let p = iG(t, u, o) || HG
            , m = function(e, t, n) {
              let r = {
                  ...t,
                  className: void 0,
                  theme: n
              }, i;
              for (let t = 0; t < e.length; t += 1) {
                  i = e[t];
                  let n = dG(i) ? i(r) : i;
                  for (let e in n)
                      r[e] = e === `className` ? pG(r[e], n[e]) : e === `style` ? {
                          ...r[e],
                          ...n[e]
                      } : n[e]
              }
              return t.className && (r.className = pG(r.className, t.className)),
              r
          }(i, t, p)
            , h = m.as || l
            , g = {};
          for (let e in m)
              m[e] === void 0 || e[0] === `$` || e === `as` || e === `theme` && m.theme === p || (e === `forwardedAs` ? g.as = m.forwardedAs : f && !f(e, h) || (g[e] = m[e]));
          let _ = function(e, t, n, r) {
              let i = (0,
              AG.c)(5), a;
              i[0] !== e || i[1] !== r || i[2] !== n || i[3] !== t ? (a = e.generateStyles(r, n, t),
              i[0] = e,
              i[1] = r,
              i[2] = n,
              i[3] = t,
              i[4] = a) : a = i[4];
              let o = a;
              return (0,
              MG.useDebugValue)(o, Oue),
              o
          }(a, d.stylis, d.styleSheet, m), ee, te = pG(s, c);
          return _ && (te = te + ` ` + _),
          m.className && (te = te + ` ` + m.className),
          g[cG(h) && !UG.has(h) ? `class` : `className`] = te,
          n && (g.ref = n),
          d.styleSheet.server && a.flushStyles(d.styleSheet),
          r[0] !== a || r[1] !== d.styleSheet ? (ee = () => {
              d.styleSheet.server || a.flushStyles(d.styleSheet)
          }
          ,
          r[0] = a,
          r[1] = d.styleSheet,
          r[2] = ee) : ee = r[2],
          (0,
          MG.useInsertionEffect)(ee),
          (0,
          jG.jsx)(h, {
              ...g
          })
      }(m, e, t)
  }
  p.displayName = c;
  let m = (0,
  MG.forwardRef)(p);
  return m.attrs = u,
  m.componentStyle = f,
  m.displayName = c,
  m.shouldForwardProp = d,
  m.foldedComponentIds = r ? pG(i.foldedComponentIds, i.styledComponentId) : ``,
  m.styledComponentId = l,
  m.target = r ? i.target : e,
  Object.defineProperty(m, `defaultProps`, {
      get() {
          return this._foldedDefaultProps
      },
      set(e) {
          this._foldedDefaultProps = r ? function(e, ...t) {
              for (let n of t)
                  gG(e, n, !0);
              return e
          }({}, i.defaultProps, e) : e
      }
  }),
  Object.defineProperty(m, `toString`, {
      value: () => `.${m.styledComponentId}`
  }),
  a && uG(m, e, {
      attrs: !0,
      componentStyle: !0,
      displayName: !0,
      foldedComponentIds: !0,
      shouldForwardProp: !0,
      styledComponentId: !0,
      target: !0
  }),
  m
}
function EG(e, t) {
  let n = [e[0]];
  for (let r = 0, i = t.length; r < i; r += 1)
      n.push(t[r], e[r + 1]);
  return n
}
function DG(e, ...t) {
  if (dG(e) || hG(e))
      return BK(SG(EG(VG, [e, ...t])));
  let n = e;
  return t.length === 0 && n.length === 1 && typeof n[0] == `string` ? SG(n) : BK(SG(EG(n, t)))
}
function OG(e, t, n=HG) {
  if (!t)
      throw _G(1, t);
  let r = (r, ...i) => e(t, n, DG(r, ...i));
  return r.attrs = r => OG(e, t, {
      ...n,
      attrs: Array.prototype.concat(n.attrs, r).filter(Boolean)
  }),
  r.withConfig = r => OG(e, t, {
      ...n,
      ...r,
      componentId: n.componentId || r.componentId,
      displayName: n.displayName || r.displayName
  }),
  r
}
function kG(e, ...t) {
  let n = DG(e, ...t)
    , r = `sc-global-${sG(JSON.stringify(n))}`
    , i = new UK(n,r)
    , a = e => {
      let t = (0,
      AG.c)(9), n = bG(), a = (0,
      MG.useContext)(RK), s;
      t[0] === n.styleSheet ? s = t[1] : (s = () => n.styleSheet.allocateGSInstance(r),
      t[0] = n.styleSheet,
      t[1] = s);
      let[c] = (0,
      MG.useState)(s), l, u;
      return n.styleSheet.server && o(c, e, n.styleSheet, a, n.stylis),
      t[2] !== c || t[3] !== e || t[4] !== n.styleSheet || t[5] !== n.stylis || t[6] !== a ? (l = () => {
          if (!n.styleSheet.server)
              return o(c, e, n.styleSheet, a, n.stylis),
              () => i.removeStyles(c, n.styleSheet)
      }
      ,
      u = [c, e, n.styleSheet, a, n.stylis],
      t[2] = c,
      t[3] = e,
      t[4] = n.styleSheet,
      t[5] = n.stylis,
      t[6] = a,
      t[7] = l,
      t[8] = u) : (l = t[7],
      u = t[8]),
      (0,
      MG.useInsertionEffect)(l, u),
      null
  }
  ;
  function o(e, t, n, r, o) {
      if (i.isStatic)
          i.renderStyles(e, BG, n, o);
      else {
          let s = {
              ...t,
              theme: iG(t, r, a.defaultProps)
          };
          i.renderStyles(e, s, n, o)
      }
  }
  return (0,
  MG.memo)(a)
}
function jue(e, ...t) {
  let n = mG(DG(e, ...t));
  return new MK(sG(n),n)
}
var AG, jG, MG, NG, PG, FG, IG, LG, RG, zG, BG, VG, HG, UG, WG, GG, KG, qG, JG, YG, XG, ZG, QG, $G, eK, tK, nK, rK, iK, aK, oK, sK, cK, lK, uK, dK, fK, pK, mK, hK, gK, _K, vK, yK, bK, xK, SK, CK, wK, TK, EK, DK, OK, kK, AK, jK, MK, NK, PK, FK, IK, LK, RK, zK, BK, VK, HK, UK, WK = t(( () => {
  AG = e(aue()),
  jG = e(f()),
  MG = e(ht()),
  NG = e(oue()),
  rG(),
  mte(),
  PG = typeof process < `u` && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || `data-styled`,
  FG = `active`,
  IG = `data-styled-version`,
  LG = `6.1.18-20`,
  RG = `/*!sc*/
`,
  zG = typeof window < `u` && typeof document < `u`,
  BG = {},
  VG = Object.freeze([]),
  HG = Object.freeze({}),
  UG = new Set(`a.abbr.address.area.article.aside.audio.b.base.bdi.bdo.big.blockquote.body.br.button.canvas.caption.cite.code.col.colgroup.data.datalist.dd.del.details.dfn.dialog.div.dl.dt.em.embed.fieldset.figcaption.figure.footer.form.h1.h2.h3.h4.h5.h6.header.hgroup.hr.html.i.iframe.img.input.ins.kbd.keygen.label.legend.li.link.main.map.mark.menu.menuitem.meta.meter.nav.noscript.object.ol.optgroup.option.output.p.param.picture.pre.progress.q.rp.rt.ruby.s.samp.script.section.select.small.source.span.strong.style.sub.summary.sup.table.tbody.td.textarea.tfoot.th.thead.time.tr.track.u.ul.use.var.video.wbr.circle.clipPath.defs.ellipse.foreignObject.g.image.line.linearGradient.marker.mask.path.pattern.polygon.polyline.radialGradient.rect.stop.svg.text.tspan`.split(`.`)),
  WG = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
  GG = /(^-|-$)/g,
  KG = /(a)(d)/gi,
  qG = e => String.fromCharCode(e + (e > 25 ? 39 : 97)),
  JG = (e, t) => {
      let n = t.length;
      for (; n; )
          e = Math.imul(e, 33) ^ t.charCodeAt(--n);
      return e
  }
  ,
  YG = e => JG(5381, e),
  XG = typeof Symbol == `function` && Symbol.for,
  ZG = XG ? Symbol.for(`react.memo`) : 60115,
  QG = XG ? Symbol.for(`react.forward_ref`) : 60112,
  $G = {
      childContextTypes: !0,
      contextType: !0,
      contextTypes: !0,
      defaultProps: !0,
      displayName: !0,
      getDefaultProps: !0,
      getDerivedStateFromError: !0,
      getDerivedStateFromProps: !0,
      mixins: !0,
      propTypes: !0,
      type: !0
  },
  eK = {
      name: !0,
      length: !0,
      prototype: !0,
      caller: !0,
      callee: !0,
      arguments: !0,
      arity: !0
  },
  tK = {
      $$typeof: !0,
      compare: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
      type: !0
  },
  nK = {
      [QG]: {
          $$typeof: !0,
          render: !0,
          defaultProps: !0,
          displayName: !0,
          propTypes: !0
      },
      [ZG]: tK
  },
  rK = Object.defineProperty,
  iK = Object.getOwnPropertyNames,
  aK = Object.getOwnPropertySymbols,
  oK = Object.getOwnPropertyDescriptor,
  sK = Object.getPrototypeOf,
  cK = Object.prototype,
  lK = class {
      constructor(e) {
          this.groupSizes = new Uint32Array(512),
          this.length = 512,
          this.tag = e
      }
      indexOfGroup(e) {
          let t = 0;
          for (let n = 0; n < e; n++)
              t += this.groupSizes[n];
          return t
      }
      insertRules(e, t) {
          if (e >= this.groupSizes.length) {
              let t = this.groupSizes
                , n = t.length
                , r = n;
              for (; e >= r; )
                  if (r <<= 1,
                  r < 0)
                      throw _G(16, `${e}`);
              this.groupSizes = new Uint32Array(r),
              this.groupSizes.set(t),
              this.length = r;
              for (let e = n; e < r; e++)
                  this.groupSizes[e] = 0
          }
          let n = this.indexOfGroup(e + 1);
          for (let r = 0, i = t.length; r < i; r++)
              this.tag.insertRule(n, t[r]) && (this.groupSizes[e]++,
              n++)
      }
      clearGroup(e) {
          if (e < this.length) {
              let t = this.groupSizes[e]
                , n = this.indexOfGroup(e)
                , r = n + t;
              this.groupSizes[e] = 0;
              for (let e = n; e < r; e++)
                  this.tag.deleteRule(n)
          }
      }
      getGroup(e) {
          let t = ``;
          if (e >= this.length || this.groupSizes[e] === 0)
              return t;
          let n = this.groupSizes[e]
            , r = this.indexOfGroup(e)
            , i = r + n;
          for (let e = r; e < i; e++)
              t += `${this.tag.getRule(e)}${RG}`;
          return t
      }
  }
  ,
  uK = new Map,
  dK = new Map,
  fK = 1,
  pK = e => {
      if (uK.has(e))
          return uK.get(e);
      for (; dK.has(fK); )
          fK++;
      let t = fK++;
      return uK.set(e, t),
      dK.set(t, e),
      t
  }
  ,
  mK = e => dK.get(e),
  hK = (e, t) => {
      fK = t + 1,
      uK.set(e, t),
      dK.set(t, e)
  }
  ,
  gK = `style[${PG}][${IG}="${LG}"]`,
  _K = RegExp(`^${PG}\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)`),
  vK = (e, t, n) => {
      let r = n.split(`,`), i;
      for (let n = 0, a = r.length; n < a; n++)
          (i = r[n]) && e.registerName(t, i)
  }
  ,
  yK = (e, t) => {
      let n = (t.textContent ?? ``).split(RG)
        , r = [];
      for (let t = 0, i = n.length; t < i; t++) {
          let i = n[t].trim();
          if (!i)
              continue;
          let a = i.match(_K);
          if (a) {
              let t = 0 | parseInt(a[1], 10)
                , n = a[2];
              t !== 0 && (hK(n, t),
              vK(e, n, a[3]),
              e.getTag().insertRules(t, r)),
              r.length = 0
          } else
              r.push(i)
      }
  }
  ,
  bK = e => {
      let t = document.querySelectorAll(gK);
      for (let n = 0, r = t.length; n < r; n++) {
          let r = t[n];
          r && r.getAttribute(PG) !== FG && (yK(e, r),
          r.parentNode && r.parentNode.removeChild(r))
      }
  }
  ,
  xK = class {
      constructor(e) {
          this.element = (e => {
              let t = document.head
                , n = e || t
                , r = document.createElement(`style`)
                , i = (e => {
                  let t = Array.from(e.querySelectorAll(`style[${PG}]`));
                  return t[t.length - 1]
              }
              )(n)
                , a = i === void 0 ? null : i.nextSibling;
              r.setAttribute(PG, FG),
              r.setAttribute(IG, LG);
              let o = Tue();
              return o && r.setAttribute(`nonce`, o),
              n.insertBefore(r, a),
              r
          }
          )(e),
          this.element.appendChild(document.createTextNode(``)),
          this.sheet = (e => {
              if (e.sheet)
                  return e.sheet;
              let {styleSheets: t} = document;
              for (let n = 0, r = t.length; n < r; n++) {
                  let r = t[n];
                  if (r.ownerNode === e)
                      return r
              }
              throw _G(17)
          }
          )(this.element),
          this.length = 0
      }
      insertRule(e, t) {
          try {
              return this.sheet.insertRule(t, e),
              this.length++,
              !0
          } catch {
              return !1
          }
      }
      deleteRule(e) {
          this.sheet.deleteRule(e),
          this.length--
      }
      getRule(e) {
          let t = this.sheet.cssRules[e];
          return t && t.cssText ? t.cssText : ``
      }
  }
  ,
  SK = class {
      constructor(e) {
          this.rules = [],
          this.length = 0
      }
      insertRule(e, t) {
          return e <= this.length && (this.rules.splice(e, 0, t),
          this.length++,
          !0)
      }
      deleteRule(e) {
          this.rules.splice(e, 1),
          this.length--
      }
      getRule(e) {
          return e < this.length ? this.rules[e] : ``
      }
  }
  ,
  CK = zG,
  wK = {
      isServer: !zG
  },
  TK = class e {
      static registerId(e) {
          return pK(e)
      }
      constructor(e=HG, t={}, n) {
          this.options = {
              ...wK,
              ...e
          },
          this.gs = t,
          this.names = new Map(n),
          this.server = !!e.isServer,
          !this.server && zG && CK && (CK = !1,
          bK(this))
      }
      toString = () => (e => {
          let t = e.getTag()
            , {length: n} = t
            , r = ``;
          for (let i = 0; i < n; i++) {
              let n = mK(i);
              if (n === void 0)
                  continue;
              let a = e.names.get(n)
                , o = t.getGroup(i);
              if (a === void 0 || !a.size || o.length === 0)
                  continue;
              let s = `${PG}.g${i}[id="${n}"]`
                , c = ``;
              a !== void 0 && a.forEach(e => {
                  e.length > 0 && (c += `${e},`)
              }
              ),
              r += `${o}${s}{content:"${c}"}${RG}`
          }
          return r
      }
      )(this);
      rehydrate() {
          !this.server && zG && bK(this)
      }
      reconstructWithOptions(t, n=!0) {
          return new e({
              ...this.options,
              ...t
          },this.gs,n && this.names || void 0)
      }
      allocateGSInstance(e) {
          return this.gs[e] = (this.gs[e] || 0) + 1
      }
      getTag() {
          return this.tag ||= (e = ( ({isServer: e, target: t}) => e ? new SK(t) : new xK(t))(this.options),
          new lK(e));
          var e
      }
      hasNameForId(e, t) {
          return this.names.has(e) && this.names.get(e).has(t)
      }
      registerName(e, t) {
          if (pK(e),
          this.names.has(e))
              this.names.get(e).add(t);
          else {
              let n = new Set;
              n.add(t),
              this.names.set(e, n)
          }
      }
      insertRules(e, t, n) {
          this.registerName(e, t),
          this.getTag().insertRules(pK(e), n)
      }
      clearNames(e) {
          this.names.has(e) && this.names.get(e).clear()
      }
      clearRules(e) {
          this.getTag().clearGroup(pK(e)),
          this.clearNames(e)
      }
      clearTag() {
          this.tag = void 0
      }
  }
  ,
  EK = /&/g,
  DK = /^\s*\/\/.*$/gm,
  OK = new TK,
  kK = yG(),
  AK = (0,
  MG.createContext)({
      shouldForwardProp: void 0,
      styleSheet: OK,
      stylis: kK
  }),
  AK.displayName = `StyleSheetContext`,
  AK.Consumer,
  jK = (0,
  MG.createContext)(void 0),
  jK.displayName = `StylisContext`,
  MK = class {
      constructor(e, t) {
          this.name = e,
          this.id = `sc-keyframes-${e}`,
          this.rules = t
      }
      toString = () => {
          throw _G(12, String(this.name))
      }
      ;
      inject = (e, t=kK) => {
          let n = this.name + t.hash;
          e.hasNameForId(this.id, n) || e.insertRules(this.id, n, t(this.rules, n, `@keyframes`))
      }
      ;
      getName(e=kK) {
          return this.name + e.hash
      }
  }
  ,
  NK = e => e >= `A` && e <= `Z`,
  PK = e => e == null || !1 === e || e === ``,
  FK = e => {
      let t = [];
      for (let i in e) {
          let a = e[i];
          e.hasOwnProperty(i) && !PK(a) && (Array.isArray(a) && a.isCss || dG(a) ? t.push(`${xG(i)}:`, a, `;`) : hG(a) ? t.push(`${i} {`, ...FK(a), `}`) : t.push(`${xG(i)}: ${n = i,
          r = a,
          r == null || typeof r == `boolean` || r === `` ? `` : typeof r != `number` || r === 0 || n in pte || n.startsWith(`--`) ? String(r).trim() : `${r}px`};`))
      }
      var n, r;
      return t
  }
  ,
  IK = YG(LG),
  LK = class {
      staticRulesId = ``;
      buffer = [];
      constructor(e, t, n) {
          this.rules = e,
          this.isStatic = (n === void 0 || n.isStatic) && CG(e),
          this.componentId = t,
          this.baseHash = JG(IK, t),
          this.baseStyle = n,
          TK.registerId(t)
      }
      generateStyles(e, t, n) {
          let r = this.baseStyle?.generateStyles(e, t, n) ?? ``;
          if (this.isStatic && !n.hash)
              if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId))
                  r = pG(r, this.staticRulesId);
              else {
                  let i = mG(SG(this.rules, e, t, n))
                    , a = oG(JG(this.baseHash, i) >>> 0);
                  if (!t.hasNameForId(this.componentId, a)) {
                      let e = n(i, `.${a}`, void 0, this.componentId);
                      this.buffer.push([a, e])
                  }
                  r = pG(r, a),
                  this.staticRulesId = a
              }
          else {
              let i = JG(this.baseHash, n.hash)
                , a = ``;
              for (let r = 0; r < this.rules.length; r++) {
                  let o = this.rules[r];
                  if (typeof o == `string`)
                      a += o;
                  else if (o) {
                      let s = mG(SG(o, e, t, n));
                      i = JG(i, s + r),
                      a += s
                  }
              }
              if (a) {
                  let e = oG(i >>> 0);
                  if (!t.hasNameForId(this.componentId, e)) {
                      let t = n(a, `.${e}`, void 0, this.componentId);
                      this.buffer.push([e, t])
                  }
                  r = pG(r, e)
              }
          }
          return r
      }
      flushStyles(e) {
          this.baseStyle?.flushStyles(e);
          for (let[t,n] of this.buffer)
              e.hasNameForId(this.componentId, t) || e.insertRules(this.componentId, t, n);
          this.buffer.length = 0
      }
  }
  ,
  RK = (0,
  MG.createContext)(void 0),
  RK.displayName = `ThemeContext`,
  RK.Consumer,
  zK = {},
  BK = e => Object.assign(e, {
      isCss: !0
  }),
  VK = e => OG(Aue, e),
  HK = VK,
  UG.forEach(e => {
      HK[e] = VK(e)
  }
  ),
  UK = class {
      constructor(e, t) {
          this.rules = e,
          this.componentId = t,
          this.isStatic = CG(e),
          TK.registerId(this.componentId + 1)
      }
      createStyles(e, t, n, r) {
          let i = r(mG(SG(this.rules, t, n, r)), ``)
            , a = this.componentId + e;
          n.insertRules(a, a, i)
      }
      removeStyles(e, t) {
          t.clearRules(this.componentId + e)
      }
      renderStyles(e, t, n, r) {
          e > 2 && TK.registerId(this.componentId + e),
          this.removeStyles(e, n),
          this.createStyles(e, t, n, r)
      }
  }
  ,
  `${PG}`
}
)), GK, KK, qK, Mue = t(( () => {
  ht(),
  WK(),
  GK = e(f(), 1),
  KK = e => {
      let {$color: t, ...n} = e
        , r = wG()
        , i = t && t in r.color ? r.color[t] : t === `brand` ? void 0 : t;
      return (0,
      GK.jsx)(`svg`, {
          ...n,
          fill: e.fill ?? i,
          style: {
              ...e.style,
              "--icon-color": i
          },
          children: e.children
      })
  }
  ,
  qK = () => {
      let e = wG();
      return (0,
      GK.jsxs)(GK.Fragment, {
          children: [(0,
          GK.jsx)(`stop`, {
              offset: `0%`,
              stopColor: e.color.labelTitle
          }, `0`), (0,
          GK.jsx)(`stop`, {
              offset: `100%`,
              stopColor: e.color.labelMuted
          }, `1`)]
      })
  }
}
)), JK, YK, XK, ZK, QK = t(( () => {
  JK = e(ht(), 1),
  tW(),
  oW(),
  Mue(),
  YK = e(f(), 1),
  XK = e => {
      let {size: t=16, width: n, height: r, viewBox: i=`0 0 16 16`, color: a=`labelMuted`, blurGradient: o=!1, style: s, noFill: c=!1, className: l, ...u} = e, {children: d} = e, f = JK.Children.only(d), p = f.props.children, m;
      if (typeof t == `string`)
          try {
              m = aW(t)
          } catch {}
      else
          m = t;
      let h = JK.useId()
        , g = a === `gradient-x` || a === `gradient-y`
        , _ = {
          ...u,
          $color: g || a === `brand` || c ? void 0 : a,
          className: eW(l, {
              "color-override": a === `brand`
          }),
          style: {
              ...s,
              ...g && {
                  overflow: `visible`
              }
          },
          width: n ?? m ?? t,
          height: r ?? m ?? t,
          viewBox: i,
          fill: g ? `url(#${h}-gradient)` : void 0,
          role: `img`,
          focusable: `false`,
          "aria-hidden": `aria-hidden`in u ? u[`aria-hidden`] : `aria-label`in u ? void 0 : !0,
          xmlns: `http://www.w3.org/2000/svg`
      };
      return JK.isValidElement(f) ? g ? (0,
      YK.jsx)(KK, {
          ..._,
          children: (0,
          YK.jsxs)(YK.Fragment, {
              children: [(0,
              YK.jsx)(`g`, {
                  opacity: o ? `0.15` : `0`,
                  filter: `url(#${h}-filter0)`,
                  style: {
                      transition: `opacity 0.2s ease-in-out`
                  },
                  children: p
              }), (0,
              YK.jsx)(`g`, {
                  opacity: o ? `0.3` : `0`,
                  filter: `url(#${h}-filter1)`,
                  style: {
                      transition: `opacity 0.2s ease-in-out`
                  },
                  children: p
              }), p, (0,
              YK.jsxs)(`defs`, {
                  children: [(0,
                  YK.jsxs)(`filter`, {
                      id: `${h}-filter0`,
                      x: `-50%`,
                      y: `-50%`,
                      width: `200%`,
                      height: `200%`,
                      filterUnits: `userSpaceOnUse`,
                      colorInterpolationFilters: `sRGB`,
                      children: [(0,
                      YK.jsx)(`feFlood`, {
                          floodOpacity: `0`,
                          result: `BackgroundImageFix`
                      }), (0,
                      YK.jsx)(`feBlend`, {
                          mode: `normal`,
                          in: `SourceGraphic`,
                          in2: `BackgroundImageFix`,
                          result: `shape`
                      }), (0,
                      YK.jsx)(`feGaussianBlur`, {
                          stdDeviation: `4`,
                          result: `effect1_foregroundBlur_425_75660`
                      })]
                  }), (0,
                  YK.jsxs)(`filter`, {
                      id: `${h}-filter1`,
                      x: `-50%`,
                      y: `-50%`,
                      width: `200%`,
                      height: `200%`,
                      filterUnits: `userSpaceOnUse`,
                      colorInterpolationFilters: `sRGB`,
                      children: [(0,
                      YK.jsx)(`feFlood`, {
                          floodOpacity: `0`,
                          result: `BackgroundImageFix`
                      }), (0,
                      YK.jsx)(`feBlend`, {
                          mode: `normal`,
                          in: `SourceGraphic`,
                          in2: `BackgroundImageFix`,
                          result: `shape`
                      }), (0,
                      YK.jsx)(`feGaussianBlur`, {
                          stdDeviation: `2`,
                          result: `effect1_foregroundBlur_425_75660`
                      })]
                  }), (0,
                  YK.jsx)(`linearGradient`, {
                      id: `${h}-gradient`,
                      x1: `0`,
                      y1: `0`,
                      x2: a === `gradient-x` ? `1` : `0`,
                      y2: a === `gradient-y` ? `1` : `0`,
                      children: (0,
                      YK.jsx)(qK, {})
                  })]
              })]
          })
      }) : (0,
      YK.jsx)(KK, {
          ..._,
          children: p
      }) : null
  }
  ,
  ZK = ({includeColorVariables: e=!0}, t=`currentColor`) => e ? `var(--icon-color, ${t})` : t
}
));
function $K(e) {
  let {relationClosed: t, monochrome: n, ...r} = e;
  return (0,
  eq.jsx)(XK, {
      ...r,
      color: n || t ? `labelMuted` : `redText`,
      children: (0,
      eq.jsxs)(`svg`, {
          children: [(0,
          eq.jsx)(`path`, {
              d: `M10.7461 1C12.8172 1 14.4961 2.67893 14.4961 4.75V5.24561C14.4961 5.65982 14.1603 5.99561 13.7461 5.99561C13.3319 5.99561 12.9961 5.65982 12.9961 5.24561V4.75C12.9961 3.50736 11.9887 2.5 10.7461 2.5H4.74609C3.50345 2.5 2.49609 3.50736 2.49609 4.75V10.9705C2.49609 12.2131 3.50345 13.2205 4.74609 13.2205H5.25009C5.66431 13.2205 6.00009 13.5562 6.00009 13.9705C6.00009 14.3847 5.66431 14.7205 5.25009 14.7205H4.74609C2.67503 14.7205 0.996094 13.0415 0.996094 10.9705V4.75C0.996094 2.67893 2.67503 1 4.74609 1H10.7461Z`
          }), (0,
          eq.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M12.2409 7H9.7591C9.456 7 9.16531 7.12041 8.95098 7.33473L7.33473 8.95098C7.12041 9.16531 7 9.456 7 9.7591V12.2409C7 12.544 7.12041 12.8347 7.33473 13.049L8.95098 14.6653C9.16531 14.8796 9.456 15 9.7591 15H12.2409C12.544 15 12.8347 14.8796 13.049 14.6653L14.6653 13.049C14.8796 12.8347 15 12.544 15 12.2409V9.7591C15 9.456 14.8796 9.16531 14.6653 8.95098L13.049 7.33473C12.8347 7.12041 12.544 7 12.2409 7ZM9.22222 10.1111C8.97676 10.1111 8.77778 10.3101 8.77778 10.5556V11.4444C8.77778 11.6899 8.97676 11.8889 9.22222 11.8889H12.7778C13.0232 11.8889 13.2222 11.6899 13.2222 11.4444V10.5556C13.2222 10.3101 13.0232 10.1111 12.7778 10.1111H9.22222Z`
          })]
      })
  })
}
var eq, tq = t(( () => {
  ht(),
  QK(),
  eq = e(f(), 1)
}
));
function nq(e) {
  return (0,
  rq.jsx)(XK, {
      ...e,
      children: (0,
      rq.jsx)(`svg`, {
          children: (0,
          rq.jsx)(`path`, {
              d: `m8.83 7 1.641.523c.974.31 2.022.302 2.991-.023l.833-.28a.5.5 0 0 1 .66.475v3.946a.5.5 0 0 1-.34.474l-1.138.385a4.77 4.77 0 0 1-2.964.03l-1.059-.334v2.054a.75.75 0 0 1-.648.743L8.704 15a.75.75 0 0 1-.743-.648l-.007-.102v-6.5a.75.75 0 0 1 .876-.74V7Zm3.874-6a2.25 2.25 0 0 1 2.25 2.25V5a.75.75 0 0 1-1.5 0V3.25a.75.75 0 0 0-.75-.75h-6.5a.75.75 0 0 0-.75.75v.775h4.491c1.09 0 1.974.883 1.974 1.973a.75.75 0 0 1-1.493.102l-.007-.102-.008-.085a.474.474 0 0 0-.38-.38l-.086-.008H3.25a.75.75 0 0 0-.743.648l-.007.102v6.475c0 .38.282.694.648.743l.102.007h2.975a.75.75 0 0 1 .102 1.493L6.225 15H3.25a2.25 2.25 0 0 1-2.245-2.096L1 12.75V6.275A2.25 2.25 0 0 1 3.096 4.03l.154-.005.706-.001L3.954 4v-.75A2.25 2.25 0 0 1 6.204 1h6.5Z`
          })
      })
  })
}
var rq, iq = t(( () => {
  ht(),
  QK(),
  rq = e(f(), 1)
}
));
function aq(e) {
  let {relationClosed: t, monochrome: n, ...r} = e;
  return (0,
  oq.jsx)(XK, {
      ...r,
      color: n || t ? `labelMuted` : `redText`,
      children: (0,
      oq.jsx)(`svg`, {
          children: (0,
          oq.jsx)(`path`, {
              clipRule: `evenodd`,
              d: `M5.82843 1H10.1716C10.702 1 11.2107 1.21071 11.5858 1.58579L14.4142 4.41421C14.7893 4.78929 15 5.29799 15 5.82843V10.1716C15 10.702 14.7893 11.2107 14.4142 11.5858L11.5858 14.4142C11.2107 14.7893 10.702 15 10.1716 15H5.82843C5.29799 15 4.78929 14.7893 4.41421 14.4142L1.58579 11.5858C1.21071 11.2107 1 10.702 1 10.1716V5.82843C1 5.29799 1.21071 4.78929 1.58579 4.41421L4.41421 1.58579C4.78929 1.21071 5.29799 1 5.82843 1ZM4.5 6.75C4.22386 6.75 4 6.97386 4 7.25V8.75C4 9.02614 4.22386 9.25 4.5 9.25H11.5C11.7761 9.25 12 9.02614 12 8.75V7.25C12 6.97386 11.7761 6.75 11.5 6.75H4.5Z`
          })
      })
  })
}
var oq, sq = t(( () => {
  ht(),
  QK(),
  oq = e(f(), 1)
}
));
function cq(e) {
  return (0,
  lq.jsx)(XK, {
      ...e,
      children: (0,
      lq.jsx)(`svg`, {
          children: (0,
          lq.jsx)(`path`, {
              d: `m8.88 7 1.641.523c.974.31 2.022.302 2.991-.023l.833-.28a.5.5 0 0 1 .66.475v3.946a.5.5 0 0 1-.34.474l-1.138.385a4.77 4.77 0 0 1-2.964.03l-1.059-.333v2.053a.75.75 0 0 1-1.493.102l-.007-.102v-6.5a.75.75 0 0 1 .876-.74V7ZM4.75 1h6a3.75 3.75 0 0 1 3.745 3.55l.005.2v.496a.75.75 0 0 1-1.493.101L13 5.246V4.75a2.25 2.25 0 0 0-2.096-2.245L10.75 2.5h-6a2.25 2.25 0 0 0-2.245 2.096L2.5 4.75v6.22a2.25 2.25 0 0 0 2.096 2.245l.154.005h1.306a.75.75 0 0 1 .102 1.494l-.102.006H4.75a3.75 3.75 0 0 1-3.745-3.55L1 10.97V4.75a3.75 3.75 0 0 1 3.55-3.745L4.75 1h6-6Z`
          })
      })
  })
}
var lq, uq = t(( () => {
  ht(),
  QK(),
  lq = e(f(), 1)
}
)), dq, fq, pq = t(( () => {
  tq(),
  iq(),
  zn(),
  Qs(),
  sq(),
  uq(),
  Lq(),
  V(),
  om(),
  F(),
  GU(),
  N(),
  dq = e(f(), 1),
  fq = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialPreloadForTeam = am.firstPriority;
      get supportsUndoCreatedAtArguments() {
          return !0
      }
      get description() {
          let e = this.relatedIssue.value?.identifier;
          switch (this.type) {
          case Zs.blocks:
              return `Blocked issue ${e}`.trim();
          case Zs.duplicate:
              return `Merged duplicate ${e}`.trim();
          case Zs.related:
              return `Related issue ${e}`.trim();
          case Zs.similar:
              return ``;
          default:
              return y(this.type),
              ``
          }
      }
      get inverseDescription() {
          let e = this.issue.value?.identifier;
          switch (this.type) {
          case Zs.blocks:
              return `Blocking issue ${e}`.trim();
          case Zs.duplicate:
              return `Duplicate of ${e}`.trim();
          case Zs.related:
              return `Related issue ${e}`.trim();
          case Zs.similar:
              return ``;
          default:
              return y(this.type),
              ``
          }
      }
      get icon() {
          switch (this.type) {
          case Zs.blocks:
              return (0,
              dq.jsx)($K, {
                  relationClosed: !this.issue.value?.isOpen || !this.relatedIssue.value?.isOpen,
                  monochrome: this.issue.value?.state?.isCanceled || this.relatedIssue.value?.state?.isCanceled
              });
          case Zs.duplicate:
              return (0,
              dq.jsx)(nq, {});
          case Zs.related:
              return (0,
              dq.jsx)(cq, {});
          case Zs.similar:
              return null;
          default:
              return y(this.type),
              null
          }
      }
      get inverseIcon() {
          switch (this.type) {
          case Zs.blocks:
              return (0,
              dq.jsx)(aq, {
                  relationClosed: !this.issue.value?.isOpen || !this.relatedIssue.value?.isOpen,
                  monochrome: this.issue.value?.state?.isCanceled || this.relatedIssue.value?.state?.isCanceled
              });
          case Zs.duplicate:
              return (0,
              dq.jsx)(nq, {});
          case Zs.related:
              return (0,
              dq.jsx)(cq, {});
          case Zs.similar:
              return null;
          default:
              return y(this.type),
              null
          }
      }
  }
  ,
  M([cg( () => J, {
      persistence: `none`,
      nullable: !0,
      onDelete: `SET NULL`
  })], fq.prototype, `createdBy`, void 0),
  M([R({
      enum: Zs,
      default: Zs.related
  })], fq.prototype, `type`, void 0),
  M([R({
      persistence: `none`
  })], fq.prototype, `metadata`, void 0),
  M([sg( () => Y, `relations`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      trait: `useForPartialIndex`
  })], fq.prototype, `issue`, void 0),
  M([sg( () => Y, `inverseRelations`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      trait: `useForPartialIndex`
  })], fq.prototype, `relatedIssue`, void 0),
  fq = M([mg(`IssueRelation`)], fq)
}
)), mq, hq = t(( () => {
  mq = function(e) {
      return e.root = `root`,
      e.parent = `parent`,
      e.subIssue = `subIssue`,
      e.blocking = `blocking`,
      e.blocked = `blocked`,
      e.notBlocked = `notBlocked`,
      e.related = `related`,
      e.duplicateOf = `duplicateOf`,
      e.hasDuplicates = `hasDuplicates`,
      e
  }({})
}
)), gq, _q, vq = t(( () => {
  gq = e(Gt(), 1),
  _n(),
  gc(),
  oc(),
  zn(),
  Yr(),
  ic(),
  DV(),
  _q = class e {
      static #e = this.presetOptions = {
          twelveHours: {
              label: `12 hours`,
              value: ac.Duration.twelveHours
          },
          twentyFourHours: {
              label: `24 hours`,
              value: ac.Duration.twentyFourHours
          },
          fortyEightHours: {
              label: `48 hours`,
              value: ac.Duration.fortyEightHours
          },
          oneWeek: {
              label: `1 week`,
              value: ac.Duration.oneWeek
          },
          twoWeeks: {
              label: `2 weeks`,
              value: ac.Duration.twoWeeks
          },
          fourWeeks: {
              label: `4 weeks`,
              value: ac.Duration.fourWeeks
          }
      };
      static getOptionFromCustomDuration(e) {
          return e.slaType === rc.onlyBusinessDays ? {
              label: `${e.sla} ${(0,
              gq.default)(`business day`, e.sla)}`,
              unit: `bday`
          } : e.sla % b.WEEK === 0 ? {
              label: `${e.sla / b.WEEK} ${(0,
              gq.default)(`week`, e.sla / b.HOUR)}`,
              unit: `week`
          } : e.sla % b.DAY === 0 ? {
              label: `${e.sla / b.DAY} ${(0,
              gq.default)(`day`, e.sla / b.HOUR)}`,
              unit: `day`
          } : {
              label: `${e.sla / b.HOUR} ${(0,
              gq.default)(`hour`, e.sla / b.HOUR)}`,
              unit: `hour`
          }
      }
      static status(e) {
          let t = gn(b.MINUTE * 5);
          if (!e.slaBreachesAt || e.state.type === E.canceled)
              return;
          let n = !1;
          return n = e.completedAt ? e.slaBreachesAt ? e.completedAt.getTime() > e.slaBreachesAt.getTime() : !1 : e.slaBreachesAt ? t > e.slaBreachesAt.getTime() : !1,
          n ? e.completedAt ? ac.Status.Failed : ac.Status.Breached : e.completedAt ? ac.Status.Completed : e.slaHighRiskAt && e.slaHighRiskAt.getTime() <= t ? ac.Status.HighRisk : e.slaMediumRiskAt && e.slaMediumRiskAt.getTime() <= t ? ac.Status.MediumRisk : ac.Status.LowRisk
      }
      static getColor(t) {
          let n = e.status(t);
          switch (n) {
          case ac.Status.Breached:
              return `redText`;
          case ac.Status.Failed:
          case ac.Status.Completed:
          case ac.Status.HighRisk:
          case ac.Status.MediumRisk:
          case ac.Status.LowRisk:
          case void 0:
              return;
          default:
              throw y(n)
          }
      }
      static getStatusLabel(t) {
          let n = e.status(t)
            , r = {
              [ac.Status.Breached]: `Breached`,
              [ac.Status.Failed]: `Failed`,
              [ac.Status.Completed]: `Achieved`,
              [ac.Status.HighRisk]: `At high risk`,
              [ac.Status.MediumRisk]: `At medium risk`,
              [ac.Status.LowRisk]: `At low risk`
          };
          return n && r[n]
      }
      static getStatusColor(e, t) {
          switch (t) {
          case ac.Status.Breached:
              return e.color.redBase;
          case ac.Status.Failed:
              return e.color.labelMuted;
          case ac.Status.Completed:
              return e.color.greenBase;
          case ac.Status.HighRisk:
              return e.color.orangeBase;
          case ac.Status.MediumRisk:
              return e.color.yellowBase;
          case ac.Status.LowRisk:
              return e.color.labelMuted;
          case void 0:
              return e.color.labelMuted;
          default:
              throw y(t)
          }
      }
      static getDisplayText(e, t) {
          if (!e.slaBreachesAt)
              return ``;
          let n = {
              fullNames: t?.accessible
          };
          return e.completedAt ? e.slaStatus === ac.Status.Failed ? `Failed by ${Sr(e.completedAt, e.slaBreachesAt, n)}` : `Achieved ${Sr(e.slaBreachesAt, e.completedAt, n)} early` : e.slaStatus === ac.Status.Breached ? t?.compact ? Sr(new Date, e.slaBreachesAt, n) : `Breached by ${Sr(new Date, e.slaBreachesAt, n)}` : t?.compact ? Sr(e.slaBreachesAt, new Date, n) : `${Sr(e.slaBreachesAt, new Date, n)} remaining`
      }
      static getTooltipText(e) {
          if (!e.slaBreachesAt)
              return ``;
          let t = e.isSlaBreachedOrFailed;
          return e.completedAt ? `SLA ${t ? `failed` : `would have breached`} at ${eV(e.slaBreachesAt)}` : `${t ? `Due` : `Was due`} on ${eV(e.slaBreachesAt, {
              omitSeconds: !0
          })}`
      }
  }
}
));
function yq(e, t) {
  let n = pQ()
    , r = n.user.settings.debugSimilarIssuesMinThreshold ?? t.minSimilarity ?? Cq(t.action)
    , i = n.user.settings.debugSimilarIssuesTopK ?? t.topK;
  return e.query(bq, {
      ...t,
      minSimilarity: r,
      topK: i
  }, {
      cache: t.useCache === void 0 ? !0 : t.useCache
  })
}
var bq, xq, Sq, Cq, wq = t(( () => {
  Wt(),
  pi(),
  hQ(),
  bq = Ut`
query SimilarIssues($issueId: String!, $topK: Int = 5, $minSimilarity: Float) {
  similarIssueIds(issueId: $issueId, first: $topK, minSimilarity: $minSimilarity) {
    id
    metadata
  }
}
`,
  xq = () => ({
      creation: .8,
      triage: .65,
      markDuplicate: .65
  }),
  Sq = function(e) {
      return e.creation = `creation`,
      e.triage = `triage`,
      e.markDuplicate = `markDuplicate`,
      e
  }({}),
  Cq = e => {
      let t = xq();
      switch (e) {
      case Sq.creation:
          return di.getValue(di.similarIssuesCreationMinSimilarity, t.creation);
      case Sq.triage:
          return di.getValue(di.similarIssuesTriageMinSimilarity, t.triage);
      case Sq.markDuplicate:
          return di.getValue(di.similarIssuesMarkDuplicateMinSimilarity, t.markDuplicate);
      default:
          return .8
      }
  }
}
)), Tq, Eq = t(( () => {
  Sm(),
  (function(e) {
      function t(e, t) {
          if (!e.team)
              return;
          let n = (e.inheritedFrom ? _m.isLazy(e.inheritedFrom) ? e.inheritedFrom?.value : e.inheritedFrom : void 0) ?? e;
          return [n, ...n.inheritedBy].find(e => e.team === t)
      }
      e.findEquivalentModelForTeam = t;
      function n(e) {
          return (e.parent ?? e).withAccessibleDescendants
      }
      e.teamsInSameHierarchy = n;
      function r(e) {
          return e.filter(t => t.inheritedFrom ? !e.includes(t.inheritedFrom) : !0)
      }
      e.filterSourceModels = r;
      function i(e) {
          let t = (e.inheritedFrom ? _m.isLazy(e.inheritedFrom) ? e.inheritedFrom?.value : e.inheritedFrom : void 0) ?? e;
          return [t, ...t.inheritedBy]
      }
      e.modelsInSameHierarchy = i
  }
  )(Tq ||= {})
}
)), Dq, Nue = t(( () => {
  zn(),
  Jv(),
  Dq = class {
      static isInScope(e, t) {
          switch (e.productIntelligenceScope) {
          case qv.workspace:
              return !0;
          case qv.team:
              return t.id === e.id;
          case qv.teamHierarchy:
              return t.withAncestors[0]?.id === e.withAncestors[0]?.id;
          case qv.none:
              return !1;
          default:
              return y(e.productIntelligenceScope),
              !1
          }
      }
  }
}
));
function Oq() {
  return new P(e => Kne[e.type] ?? 999).and(e => e.groupKey, `asc`).and(e => Fl[e.state] ?? 999).and(e => e.metadata?.rank ?? 0, `asc`).and(`createdAt`, `asc`)
}
var kq, Aq = t(( () => {
  Il(),
  zn(),
  Qs(),
  V(),
  F(),
  om(),
  Lq(),
  kH(),
  mH(),
  iz(),
  GU(),
  Nue(),
  ML(),
  Nm(),
  N(),
  kq = class extends qh {
      static #e = this.loadStrategy = rm.partial;
      get suggestedModelPath() {
          switch (this.type) {
          case Nl.similarIssue:
          case Nl.relatedIssue:
              return this.suggestedIssue?.value ? CI(this.suggestedIssue.value) : void 0;
          case Nl.project:
              return this.suggestedProject ? aN(this.suggestedProject) : void 0;
          case Nl.team:
              return this.suggestedTeam ? lI(this.suggestedTeam) : void 0;
          case Nl.assignee:
          case Nl.label:
              return;
          default:
              y(this.type);
              return
          }
      }
      get isVisible() {
          return this.isActive && this.canApply && this.isRelevant && !this.metadata?.variant
      }
      isVisibleInTriage(e) {
          return this.metadata?.variant === e ? this.isAccepted ? this.isApplied : !this.isActive || !this.canApply ? !1 : !!e || this.isRelevant || !!this.issue.value?.suggestions.some(t => t !== this && t.metadata?.variant === e && t.groupKey === this.groupKey && t.isAccepted && t.isApplied) : !1
      }
      get isActive() {
          return this.state === Pl.active
      }
      get isAccepted() {
          return this.state === Pl.accepted
      }
      get isStale() {
          return this.state === Pl.stale
      }
      get isSuggestedIssueRelation() {
          return this.type === Nl.similarIssue || this.type === Nl.relatedIssue
      }
      get isSuggestedIssueProperty() {
          return this.type === Nl.assignee || this.type === Nl.label || this.type === Nl.project || this.type === Nl.team
      }
      get isRelevant() {
          let e = this.issue.value;
          if (!e)
              return !1;
          switch (this.type) {
          case Nl.assignee:
              return !e.assignee;
          case Nl.label:
              return !e.labels.some(e => e.id === this.suggestedLabel?.id || !!e.parent && e.parent.id === this.suggestedLabel?.parent?.id);
          case Nl.project:
              return !e.project;
          case Nl.team:
              return e.team !== this.suggestedTeam;
          case Nl.similarIssue:
          case Nl.relatedIssue:
              return !(e.relations.some(e => e.relatedIssue.id === this.suggestedIssue?.value?.id) || e.inverseRelations.some(e => e.issue.id === this.suggestedIssue?.value?.id));
          default:
              return y(this.type),
              !0
          }
      }
      get isApplied() {
          let e = this.issue.value;
          if (!e)
              return !1;
          switch (this.type) {
          case Nl.assignee:
              return e.assignee === this.suggestedUser;
          case Nl.label:
              return e.labels.some(e => e.id === this.suggestedLabel?.id);
          case Nl.project:
              return e.project === this.suggestedProject;
          case Nl.team:
              return e.team === this.suggestedTeam;
          case Nl.similarIssue:
          case Nl.relatedIssue:
              let t = this.suggestedIssue?.value?.id;
              if (!t)
                  return !1;
              let n = this.type === Nl.similarIssue ? Zs.duplicate : Zs.related;
              return e.relations.some(e => e.type === n && e.relatedIssue.id === t) || e.inverseRelations.some(e => e.type === n && e.issue.id === t);
          default:
              return y(this.type),
              !1
          }
      }
      get canApply() {
          let e = this.issue.value;
          if (!e || !this.isInScope)
              return !1;
          switch (this.type) {
          case Nl.assignee:
              return this.suggestedUser ? this.suggestedUser.isActive && this.suggestedUser.memberOf(e.team) : !1;
          case Nl.label:
              return !this.suggestedLabel || this.suggestedLabel.isRetired ? !1 : !this.suggestedLabel.isTeamLabel || this.suggestedLabel.team === e.team;
          case Nl.project:
              return !!this.suggestedProject;
          case Nl.team:
              return this.suggestedTeam ? e.team !== this.suggestedTeam : !1;
          case Nl.similarIssue:
          case Nl.relatedIssue:
              return this.suggestedIssue?.value ? !e.relations.some(e => e.relatedIssue.id === this.suggestedIssue?.value?.id) : !1;
          default:
              return y(this.type),
              !0
          }
      }
      get isInScope() {
          let e = this.issue.value;
          if (this.isSuggestedIssueRelation) {
              if (!e || !this.suggestedIssue?.value)
                  return !1;
              let t = e.team
                , n = this.suggestedIssue.value.team;
              if (!Dq.isInScope(t, n) || !Dq.isInScope(n, t))
                  return !1
          }
          return this.type === Nl.team ? !this.suggestedTeam || !e ? !1 : Dq.isInScope(e.team, this.suggestedTeam) : this.type === Nl.project ? !this.suggestedProject || !e ? !1 : this.suggestedProject.accessibleTeams.some(t => Dq.isInScope(t, e.team)) : !0
      }
      markActive() {
          this.state = Pl.active,
          this.save()
      }
      markAccepted() {
          this.state = Pl.accepted,
          this.save()
      }
      markDismissed() {
          this.state = Pl.dismissed,
          this.save()
      }
      get groupKey() {
          if (this.isSuggestedIssueRelation)
              return `issue:${this.suggestedIssue?.id}`;
          if (this.type === Nl.label && this.suggestedLabel) {
              let e = this.suggestedLabel;
              return e.parent ? `group:${e.parent.id}` : `label:${e.id}`
          }
          return this.type
      }
  }
  ,
  M([R({
      enum: Nl,
      persistence: `none`,
      default: Nl.similarIssue
  })], kq.prototype, `type`, void 0),
  M([R({
      enum: Pl,
      persistence: `updateOnly`,
      default: Pl.active
  })], kq.prototype, `state`, void 0),
  M([R({
      persistence: `updateOnly`,
      default: () => new Date
  })], kq.prototype, `stateChangedAt`, void 0),
  M([R({
      persistence: `updateOnly`
  })], kq.prototype, `dismissalReason`, void 0),
  M([R({
      persistence: `none`
  })], kq.prototype, `metadata`, void 0),
  M([sg( () => Y, `suggestions`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      trait: `useForPartialIndex`,
      persistence: `updateOnly`
  })], kq.prototype, `issue`, void 0),
  M([sg( () => Y, `incomingSuggestions`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      trait: `useForPartialIndex`,
      persistence: `updateOnly`
  })], kq.prototype, `suggestedIssue`, void 0),
  M([cg( () => OH, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], kq.prototype, `suggestedLabel`, void 0),
  M([cg( () => J, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], kq.prototype, `suggestedUser`, void 0),
  M([cg( () => K, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], kq.prototype, `suggestedTeam`, void 0),
  M([cg( () => G, {
      optional: !1,
      nullable: !1,
      persistence: `none`
  })], kq.prototype, `suggestedProject`, void 0),
  M([L], kq.prototype, `suggestedModelPath`, null),
  M([L], kq.prototype, `isRelevant`, null),
  M([L], kq.prototype, `isApplied`, null),
  M([L], kq.prototype, `canApply`, null),
  M([L], kq.prototype, `isInScope`, null),
  M([I], kq.prototype, `markActive`, null),
  M([I], kq.prototype, `markAccepted`, null),
  M([I], kq.prototype, `markDismissed`, null),
  M([L], kq.prototype, `groupKey`, null),
  kq = M([mg(`IssueSuggestion`)], kq)
}
)), jq, Mq, Nq, Pq, Fq, Iq, Y, Lq = t(( () => {
  nt(),
  jq = e(ee(), 1),
  Mq = e(fe(), 1),
  Nq = e(ne(), 1),
  Pq = e(ce(), 1),
  Fq = e(nn(), 1),
  zt(),
  zn(),
  Is(),
  Xs(),
  Qs(),
  oc(),
  cc(),
  uc(),
  mc(),
  vc(),
  gc(),
  Cc(),
  ml(),
  vl(),
  bl(),
  Dl(),
  Ml(),
  Il(),
  Bl(),
  Ul(),
  Ac(),
  Gl(),
  Jl(),
  pi(),
  hQ(),
  Zl(),
  eu(),
  ws(),
  JU(),
  XB(),
  _H(),
  AR(),
  bH(),
  QU(),
  kH(),
  sR(),
  iz(),
  PR(),
  mH(),
  gx(),
  GU(),
  AV(),
  Iy(),
  Rj(),
  WR(),
  pq(),
  hR(),
  dx(),
  V(),
  F(),
  om(),
  Vm(),
  Nm(),
  hq(),
  vq(),
  Xp(),
  Ih(),
  nx(),
  KA(),
  Sm(),
  AM(),
  WB(),
  xM(),
  TH(),
  wq(),
  TA(),
  FB(),
  BB(),
  PL(),
  qk(),
  Eq(),
  JR(),
  Aq(),
  sk(),
  $R(),
  KB(),
  Oj(),
  oM(),
  rM(),
  bR(),
  N(),
  Y = class extends Xh {
      static #e = Iq = this;
      constructor(...e) {
          super(...e),
          this.skipUpdatedAtKeys = new Set([`cycleId`, `sortOrder`, `prioritySortOrder`, `subIssueSortOrder`, `subscriberIds`]),
          this.similarIssuesHydratedAt = null,
          this.similarIssues = new Bm(Iq),
          this.similarIssuesMetadata = {},
          this.toggleFavorite = () => {
              if (this.favorite)
                  return this.favorite.delete(),
                  !1;
              let e = yH.create({
                  reference: this
              });
              return e.save(!0),
              e
          }
      }
      static #t = this.loadStrategy = rm.partial;
      static #n = this.partialLoadMode = im.regular;
      static #r = this.partialPreloadForTeam = am.firstPriority;
      static teamKeyFromIdentifier(e) {
          return e.split(`-`)[0].toUpperCase()
      }
      static issueNumberFromIdentifier(e) {
          let t = Number(e.split(`-`)[1]);
          return Number.isNaN(t) || t === 0 ? void 0 : t
      }
      get author() {
          return this.creator ?? this.externalUserCreator
      }
      get releases() {
          return Bm.of(aM, this.issueToReleases.map(e => e.release.value).filter(Boolean))
      }
      get reminder() {
          return this.reminders.elements[0]
      }
      get contributors() {
          return Bm.of(J, this.children.map(e => e.assignee).distinct().filter(Boolean).filter(e => e.id !== this.assignee?.id))
      }
      get descendants() {
          return Bm.of(Iq, this.children.elements.concat(this.children.elements.flatMap(e => e.descendants.elements)))
      }
      get identifier() {
          return `${this.team.key}-${this.number || this.team.nextIssueNumber}`
      }
      get availableLabels() {
          return this.team.allIssueLabels.filter(e => this.labels.indexOf(e) < 0)
      }
      get assignedToSuspendedUser() {
          return this.assignee ? !this.assignee.isActive : !1
      }
      get triageIssueSource() {
          let e = [T.front, T.zendesk, T.intercom];
          return !!(this.sourceMetadata && (this.sourceMetadata.type === `integration` && this.sourceMetadata.subType && e.includes(this.sourceMetadata.subType) || this.sourceMetadata.type === `oauthClient` && !this.sourceMetadata.oauthTokenUserId))
      }
      get relationshipType() {
          return this.parent ? mq.subIssue : mq.root
      }
      get dueDateQualifier() {
          return ql.qualifierForDueDate(this.dueDate)
      }
      get isImported() {
          return !!this.issueImport
      }
      get searchableContent() {
          return this.title + ` ` + (this.documentContent.value?.markdownContent || ``)
      }
      get isAutoClosed() {
          return this.autoClosedAt ? `true` : `false`
      }
      get isAutoArchived() {
          return this.autoArchivedAt ? `true` : `false`
      }
      get isReadOnly() {
          return this.isArchived || this.trashed === !0
      }
      get isAsksIssue() {
          return this.sourceMetadata?.subType === T.slackAsks
      }
      get nestedSubIssueSortOrder() {
          return (this.parent && this.subIssueSortOrder) ?? this.sortOrder
      }
      get slaStatus() {
          return _q.status(this)
      }
      get isSlaBreachedOrFailed() {
          let e = this.slaStatus;
          return e === ac.Status.Breached || e === ac.Status.Failed
      }
      get lastActivityAt() {
          return this.activities.last?.updatedAt
      }
      get activeSubscribers() {
          return this.subscribers.filter(e => e.isActive)
      }
      get startedTriageOrCreatedAt() {
          return this.startedTriageAt ?? this.createdAt
      }
      get addedToCyclePeriod() {
          let e = this.cycle?.value
            , t = this.addedToCycleAt?.getTime();
          if (e == null || t == null)
              return;
          let n = e.completedAt ?? e.endsAt;
          return Al.getAddedToCyclePeriod(t, e.startsAt, n)
      }
      get suggestedRelatedIssues() {
          return [...this.suggestions.elements].filter(e => e.isSuggestedIssueRelation && e.isVisible).map(e => e.suggestedIssue?.value).concat([...this.incomingSuggestions.elements].filter(e => e.isSuggestedIssueRelation && e.isVisible).map(e => e.issue?.value)).concrete().distinct()
      }
      get duplicateOfSuggestions() {
          return this.suggestions.filter(e => e.type === Nl.similarIssue && e.isVisible)
      }
      get duplicatedBySuggestions() {
          return this.incomingSuggestions.filter(e => e.type === Nl.similarIssue && e.isVisible)
      }
      get allRelatedIssueSuggestions() {
          return new ok(kq,[this.suggestions.filter(e => e.type === Nl.relatedIssue && e.isVisible), this.incomingSuggestions.filter(e => e.type === Nl.relatedIssue && e.isVisible)])
      }
      get hasSuggestedRelatedIssues() {
          return this.allRelatedIssueSuggestions.length > 0
      }
      get hasSuggestedSimilarIssues() {
          return this.duplicateOfSuggestions.length > 0
      }
      get hasSuggestedAssignees() {
          return this.suggestions.some(e => e.type === Nl.assignee && e.isVisibleInTriage())
      }
      get hasSuggestedLabels() {
          return this.suggestions.some(e => e.type === Nl.label && e.isVisibleInTriage())
      }
      get hasSuggestedTeams() {
          return this.suggestions.some(e => e.type === Nl.team && e.isVisibleInTriage())
      }
      get hasSuggestedProjects() {
          return this.suggestions.some(e => e.type === Nl.project && e.isVisibleInTriage())
      }
      getExternalIdentifier(e) {
          switch (e) {
          case T.jira:
              let t = this.sourceMetadata?.importMetadata?.service === Tc.jira ? this.sourceMetadata?.importMetadata?.identifier : void 0;
              return t ||= this.externalEntityRelations.elements.find(e => e.externalEntityType === Vl.jiraIssue)?.metadata?.jiraIssueMetadata?.issueKey,
              t || void 0;
          default:
              throw new Rn(e)
          }
      }
      latestAiPromptProgressOfType(e, t) {
          return this.aiPromptProgresses.find(n => n.type === e && !n.isCanceled && n.metadata.variant === t)
      }
      get leadTime() {
          if (this.completedAt != null)
              return this.completedAt.getTime() - this.createdAt.getTime()
      }
      get cycleTime() {
          if (!(this.completedAt == null || this.startedAt == null))
              return this.completedAt.getTime() - this.startedAt.getTime()
      }
      get ageTime() {
          if (!(this.completedAt != null || this.canceledAt != null))
              return Date.now() - this.createdAt.getTime()
      }
      get triageTime() {
          if (!(this.startedTriageAt == null || this.triagedAt == null))
              return this.triagedAt.getTime() - this.startedTriageAt.getTime()
      }
      isSaved() {
          return this.number !== void 0
      }
      clone(e) {
          let t = super.clone(e);
          return Mt( () => {
              t.lastAppliedTemplate = this.lastAppliedTemplate?.value ? this.lastAppliedTemplate : void 0
          }
          ),
          t
      }
      asksIssueRequester() {
          if (this.sourceMetadata?.subType === T.slackAsks && this.sourceMetadata?.asksMetadata) {
              if (this.sourceMetadata.asksMetadata.requesterUserId)
                  return new Jp(this.store.findById(J, this.sourceMetadata.asksMetadata.requesterUserId));
              if (this.sourceMetadata.asksMetadata.requesterExternalUserId)
                  return this.store.hydrateModel(Fy, this.sourceMetadata.asksMetadata.requesterExternalUserId)
          }
      }
      hasRelationCharacteristicType(e) {
          switch (e) {
          case mq.root:
              return this.parent === void 0;
          case mq.parent:
              return this.children.length !== 0;
          case mq.subIssue:
              return this.parent !== void 0;
          case mq.blocking:
              return this.blockingRelations.length !== 0;
          case mq.blocked:
              return this.blockedByRelations.length !== 0;
          case mq.notBlocked:
              return this.blockedByRelations.length === 0;
          case mq.related:
              return this.relatedRelations.length !== 0;
          case mq.duplicateOf:
              return this.duplicateOfRelation !== void 0;
          case mq.hasDuplicates:
              return this.duplicateRelations.length !== 0;
          default:
              return y(e),
              !1
          }
      }
      hasDueDateQualifierType(e) {
          let t = this.dueDateQualifier;
          return e === Kl.due ? t !== Kl.none : t === e
      }
      get isOpen() {
          return !this.state && this.store?.syncClient?.deltaSyncReceivedPromise?.isPending === !1 && w.error(`Issue with no state`, void 0, {
              id: this.id,
              stateId: this.stateId,
              teamId: this.team?.id ?? this.teamId,
              updatedAt: this.updatedAt,
              lastSyncId: this.store?.getLastSyncId?.()
          }),
          !this.state.isClosed
      }
      get doneAt() {
          return this.isOpen ? void 0 : this.completedAt || this.canceledAt || this.autoClosedAt
      }
      get initiatives() {
          return (this.project?.initiatives.length ?? 0) > 0 ? this.project?.initiatives : void 0
      }
      get blockingRelations() {
          return this.relations.transientlyHydratedElements.filter(this.checkForErroneousIssueRelation).filter(e => e.type === Zs.blocks && e.issue.value.isOpen === !0 && e.relatedIssue.value.isOpen === !0).map(e => ({
              issue: e.relatedIssue.value,
              relation: e,
              inverse: !1,
              icon: e.icon,
              inverseIcon: e.inverseIcon
          })).filter(this.checkForErroneousRelation)
      }
      get blockedByRelations() {
          return this.isOpen ? this.inverseRelations.transientlyHydratedElements.filter(this.checkForErroneousIssueRelation).filter(e => e.type === Zs.blocks && e.issue.value?.isOpen === !0).map(e => ({
              issue: e.issue.value,
              relation: e,
              inverse: !0,
              icon: e.inverseIcon,
              inverseIcon: e.icon
          })).filter(this.checkForErroneousRelation) : []
      }
      get relatedRelations() {
          return this.relations.transientlyHydratedElements.filter(this.checkForErroneousIssueRelation).filter(e => e.type === Zs.related || e.type === Zs.blocks && (!e.issue.value.isOpen || !e.relatedIssue.value.isOpen)).map(e => ({
              issue: e.relatedIssue.value,
              relation: e,
              inverse: !1,
              icon: e.icon,
              inverseIcon: e.inverseIcon
          })).filter(this.checkForErroneousRelation).concat(this.inverseRelations.transientlyHydratedElements.filter(this.checkForErroneousIssueRelation).filter(e => e.type === Zs.related || e.type === Zs.blocks && (!e.issue.value.isOpen || !e.relatedIssue.value.isOpen)).map(e => ({
              issue: e.issue.value,
              relation: e,
              inverse: !0,
              icon: e.inverseIcon,
              inverseIcon: e.icon
          })).filter(this.checkForErroneousRelation))
      }
      get duplicateRelations() {
          return this.inverseRelations.transientlyHydratedElements.filter(e => e.type === Zs.duplicate).map(e => ({
              issue: e.issue.value,
              relation: e,
              inverse: !0,
              icon: e.inverseIcon,
              inverseIcon: e.icon
          })).filter(this.checkForErroneousRelation)
      }
      get duplicateOfRelation() {
          return this.relations.transientlyHydratedElements.filter(this.checkForErroneousIssueRelation).filter(e => e.type === Zs.duplicate).map(e => ({
              issue: e.relatedIssue.value,
              relation: e,
              inverse: !1,
              icon: e.icon,
              inverseIcon: e.inverseIcon
          })).filter(this.checkForErroneousRelation)[0]
      }
      get emailIntakeMetadata() {
          if (this.sourceMetadata?.type === `email`)
              return this.externalEntityRelations.find(e => e.externalEntityType === Vl.emailMessage)?.metadata?.emailMessageMetadata
      }
      get currentAndFormerAttachments() {
          return new ok(kV,[this.attachments, this.formerAttachments])
      }
      hydrateAllAttachments() {
          return this.currentAndFormerAttachments.hydrate()
      }
      getBranchIdentifier(e) {
          let t = e.pullRequestAdapter
            , n = t.branchName
            , r = t.repoName;
          return n && r ? `${r}/${n}` : ``
      }
      get allAttachments() {
          let e = this.currentAndFormerAttachments
            , t = new Set;
          if (e.forEach(e => {
              if (e.isPullRequest) {
                  let n = this.getBranchIdentifier(e);
                  n && t.add(n)
              }
          }
          ),
          t.size > 0 && (e = e.filter(e => {
              if (e.isGithubCommit) {
                  let n = this.getBranchIdentifier(e);
                  if (n)
                      return !t.has(n)
              }
              return !0
          }
          )),
          NL(pQ().user).base) {
              let t = new Set;
              return this.allNeeds.elements.forEach(e => {
                  e.attachment?.value && t.add(e.attachment.value.url)
              }
              ),
              e.filter(e => !t.has(e.url))
          }
          return e
      }
      get standardAttachments() {
          return this.allAttachments.filter(e => !e.isSentryIssue && !e.isPullRequest)
      }
      get sentryAttachments() {
          return this.allAttachments.filter(e => e.isSentryIssue).orderBy(`createdAt`)
      }
      get hasSentryAttachments() {
          return this.sentryAttachments.length > 0
      }
      get pullRequestAttachments() {
          return this.allAttachments.filter(e => e.isPullRequest).orderBy(`createdAt`)
      }
      get hasPullRequestAttachments() {
          return this.pullRequestAttachments.length > 0
      }
      get syncedJiraIssueAttachment() {
          return this.attachments.find(e => e.isSyncedJiraIssue)
      }
      get syncedGithubIssueAttachment() {
          return this.attachments.find(e => e.isSyncedGithubIssue)
      }
      get syncedSlackIssueAttachment() {
          return this.attachments.find(e => e.isSyncedSlackThread)
      }
      get allNeeds() {
          return this.needs.concat(this.formerNeeds)
      }
      get customerCount() {
          return new Set(this.allNeeds.map(e => e.customer?.id ?? e.id).filter(Boolean)).size
      }
      get customerImportantCount() {
          let e = KR(this.allNeeds.elements);
          return Array.from(e.values()).filter(e => e.primaryNeed.priority.isImportant || e.additionalNeeds.some(e => e.priority.isImportant)).length
      }
      get aggregatedCustomersRevenue() {
          let e = new Set(this.allNeeds.map(e => e.customer?.value).filter(Boolean));
          return Array.from(e).reduce( (e, t) => e + (t.displayRevenue ?? 0), 0)
      }
      get sortedCustomerByImpact() {
          return QR(this.allNeeds.elements)
      }
      get hasBlockingRelations() {
          return this.blockingRelations.length > 0
      }
      get hasBlockedByRelations() {
          return this.blockedByRelations.length > 0
      }
      get hasRelatedRelations() {
          return this.relatedRelations.length > 0
      }
      get hasDuplicateRelations() {
          return this.duplicateRelations.length > 0 || this.duplicateOfRelation !== void 0
      }
      async getRelativeRelations() {
          let e = await Promise.all(this.relations.map(async e => ({
              issue: await e.relatedIssue.resolve(),
              type: e.type
          })))
            , t = await Promise.all(this.inverseRelations.map(async e => ({
              issue: await e.issue.resolve(),
              type: this.getInverseRelationType(e.type)
          })));
          return [...e, ...t]
      }
      getInverseRelationType(e) {
          switch (e) {
          case `blocks`:
              return `blockedBy`;
          case `related`:
              return `related`;
          case `duplicate`:
              return `duplicate`;
          case `similar`:
              return `similar`;
          default:
              return `related`
          }
      }
      get allChildren() {
          return this.children.reduce( (e, t) => e.concat(t, ...t.allChildren), [])
      }
      get subIssueProgress() {
          if (this.children.length !== 0)
              return Sc.progress(this.children.elements)
      }
      get totalSubIssueEstimatePoints() {
          return Sc.totalEstimatePoints(this.children.elements, {
              estimationEnabled: !0
          })
      }
      get branchNames() {
          let e = new Map;
          this.pullRequestAttachments.filter(e => {
              let t = e.metadata
                , n = t?.linkKind !== gl.links
                , r = !!t?.branch
                , i = t?.status !== hl.merged && t?.status !== hl.closed;
              return n && r && i
          }
          ).forEach(t => {
              let n = t.metadata.branch
                , r = t.metadata?.title;
              if (e.has(n)) {
                  let t = e.get(n);
                  t.detail = void 0
              } else
                  e.set(n, {
                      name: n,
                      detail: r
                  })
          }
          );
          let t = Array.from(e.values());
          if (t.length !== 1) {
              let e = this.team.organization.gitBranchFormat || Fs.defaultFormat;
              t.push({
                  name: Fs.branchName(e, {
                      username: pQ().user.displayName,
                      issueIdentifier: this.identifier,
                      issueTitle: this.title
                  }),
                  isNew: !0
              })
          }
          return t
      }
      get parents() {
          if (!this.parent)
              return new Jp([]);
          if (this.parent.value) {
              let e = []
                , t = this.parent.value;
              for (; t; )
                  if (e.push(t),
                  t.parent)
                      if (t.parent.value)
                          t = t.parent.value;
                      else
                          break;
                  else
                      return new Jp(e)
          }
          return new Jp(async (e, t) => {
              try {
                  let t = await this.parent;
                  e(t ? [t, ...await t.parents] : [])
              } catch (e) {
                  t(e)
              }
          }
          )
      }
      get aggregatedTimeByStateKey() {
          let e = this.store
            , t = this.state.team.id;
          return Wl.getAggregatedTimeByState(this.timeInStatus, t => e.findById(ux, t), (e, n) => n.team.id === t && e.team.id !== t)
      }
      get timeInStatusByStateKey() {
          let e = {};
          for (let t of this.aggregatedTimeByStateKey.values()) {
              let n = t.state.compositeKey;
              e[n] = (e[n] ?? 0) + t.duration,
              e[t.state.type] = (e[t.state.type] ?? 0) + t.duration
          }
          let t = this.timeInStatus?.accumulatedStateUpdatedAt;
          if (t) {
              let n = Date.now() - t.getTime()
                , r = this.state.compositeKey;
              e[r] = (e[r] ?? 0) + n,
              e[this.state.type] = (e[this.state.type] ?? 0) + n
          }
          return e
      }
      get accumulatedStateUpdatedAt() {
          if (!this.timeInStatus?.stateUpdatedAt)
              return null;
          let e = this.state.compositeKey
            , t = this.aggregatedTimeByStateKey.get(e)?.duration || 0;
          return new Date(this.timeInStatus.stateUpdatedAt.getTime() - t)
      }
      getTrait(e) {
          return sc(this.traits, e)
      }
      setSLA(e) {
          if (typeof e == `number` ? this.slaBreachesAt = see(new Date, e) : this.slaBreachesAt = e,
          this.slaBreachesAt) {
              let[e,t] = ac.calculateSLARiskThresholds(this.slaType, this.slaBreachesAt, this.team.timezone, this.team.organization.workingDays);
              this.slaHighRiskAt = t,
              this.slaMediumRiskAt = e,
              this.slaStartedAt = new Date
          } else
              this.slaHighRiskAt = void 0,
              this.slaMediumRiskAt = void 0,
              this.slaStartedAt = void 0
      }
      static createSubIssue({team: e, user: t, parentIssue: n, previousIssue: r, baseIssue: i}) {
          return Iq.create(t, {
              team: e,
              parentIssue: n,
              skipDefaultTemplate: !0,
              project: n.project,
              subIssueSortOrder: tx.lastSortOrder(n.children, `subIssueSortOrder`),
              prioritySortOrder: tx.lastSortOrder(n.children, `prioritySortOrder`),
              baseIssue: i,
              ...r ? {
                  estimate: r.estimate,
                  assignee: r.assignee,
                  labels: r.labels.elements,
                  cycle: r.cycle?.value,
                  priority: r.priority,
                  state: r.state,
                  skipStateOverride: !0
              } : {}
          })
      }
      static create(e, t) {
          let {team: n, baseIssue: r, title: i, descriptionData: a, attachmentsData: o, priority: s, assignee: c, delegate: l, estimate: u, dueDate: d, parentIssue: f, subIssues: p=[], cycle: m, project: h, projectMilestone: g, state: _, labels: ee, customer: te, customerNeed: ne, template: re, lastAppliedTemplate: ie, referenceComment: ae, skipDefaultTemplate: oe, skipStateOverride: se, overrideTemplateFields: ce, createdFromDraftId: le, referencedCommentId: ue, sourceComment: de, sourcePullRequestComment: fe, subIssueSortOrder: pe, prioritySortOrder: me, relatedIssues: he=[], newSubIssues: ge=[]} = t
            , v = r ?? Iq.createEmpty();
          if (v.title = i || ``,
          v.team = n ?? e.defaultTeamForIssues,
          v.isTemplateWithNoDefaultTeam = !n,
          v.state = _ && n && n === _.team && (n.userCanChangeIssueStatus(e) || se) ? _ : _ ? v.team.defaultStateForType(_.type) : v.team.defaultState(e),
          v.priority = s || v.priority || zl.NoPriority,
          c && (v.assignee = c),
          l && (v.delegate = l,
          v.assignee ||= e),
          pe && (v.subIssueSortOrder = pe),
          ue) {
              let e = this.store.findById(YB, ue);
              e && (v.referenceComment = vm.wrap(e))
          }
          if (me && (v.prioritySortOrder = me),
          v.estimate = u,
          v.dueDate = d,
          ae && (v.referenceComment = vm.wrap(ae)),
          v.createdFromDraftId = le,
          te && !v.needs.elements.some(e => e.customer?.id === te.id)) {
              let e = UB.create({
                  customer: te,
                  issue: v,
                  organization: v.team.organization
              });
              v.needs.add(e)
          }
          if (ne) {
              let e = ne.clone();
              e.project = void 0,
              e.issue = vm.wrap(v),
              e.markPropertyChanged(`issueId`, ne.issue?.id),
              e.save(),
              v.needs.add(e)
          }
          if (f) {
              if (v.parent = vm.wrap(f),
              v.priority = s || f.priority,
              !v.assignee && f.assignee && f.children.length > 0 && f.children.elements.every(e => e.assignee === f.assignee) && (v.assignee = f.assignee),
              !se && v.team.userCanChangeIssueStatus(e))
                  switch (f.state.type) {
                  case E.started:
                  case E.unstarted:
                  case E.completed:
                      v.state = v.team.defaultActiveState;
                      break;
                  case E.triage:
                      v.state = v.team.triageIssueState || v.team.defaultBacklogState;
                      break;
                  case E.canceled:
                  case E.backlog:
                      v.state = v.team.defaultBacklogState;
                      break;
                  default:
                      new Rn(f.state.type)
                  }
              v.team.cyclesEnabled && f.team === n && v.state.isActive && f.cycle && !f.cycle?.value?.isCompleted && v.addToCycle(f.cycle?.value),
              f.project && v.team.projects.contains(f.project) && v.setProjectAndMilestone(f.project, f.projectMilestone?.value)
          }
          for (let {issue: e, type: t} of he) {
              let n = new fq;
              t === `blockedBy` ? (n.type = Zs.blocks,
              n.issue = vm.wrap(e),
              n.relatedIssue = vm.wrap(v),
              n.save(!0)) : t === `blocks` ? (n.type = Zs.blocks,
              n.issue = vm.wrap(v),
              n.relatedIssue = vm.wrap(e),
              n.save(!0)) : t === `duplicate` ? (n.type = Zs.duplicate,
              n.issue = vm.wrap(v),
              n.relatedIssue = vm.wrap(e),
              n.save(!0)) : (n.type = Zs.related,
              n.issue = vm.wrap(v),
              n.relatedIssue = vm.wrap(e),
              n.save(!0))
          }
          de && (v.sourceComment = vm.wrap(de)),
          fe && (v.sourcePullRequestComment = vm.wrap(fe)),
          !v.assignee && c !== null && e.settings.autoAssignToSelf && !v.state.isTriage && (v.project && v.project.members.length > 0 ? v.project.members.contains(e) && (v.assignee = e) : v.assignee = e),
          v.team.cyclesEnabled && !v.cycle && (v.team.userCanChangeIssueStatus(e) && m && !m.isCompleted ? v.addToCycle(m) : v.team.cycleLockToActive && v.state.isActive && v.addToCycle(v.team.activeCycle ?? v.team.upcomingCycle(0))),
          h && h.accessibleTeams.contains(v.team) && (v.project = h,
          g && v.project?.projectMilestones.contains(g) && (v.projectMilestone = vm.wrap(g)));
          let _e = re || (oe ? void 0 : e.memberOf(v.team) ? v.team.defaultTemplateForMembers?.value : v.team.defaultTemplateForNonMembers?.value);
          ee && ee.filter(e => !e.team || e.team === n).forEach(e => v.labels.add(e)),
          _e && v.applyTemplate(_e),
          !_e && ie && (v.lastAppliedTemplate = vm.wrap(ie)),
          ce?.forEach(e => {
              if (t[e])
                  switch (e) {
                  case `state`:
                  case `priority`:
                  case `assignee`:
                  case `title`:
                  case `descriptionData`:
                  case `estimate`:
                      v[e] = t[e];
                      break;
                  case `project`:
                  case `projectMilestone`:
                      v.setProjectAndMilestone(t.project, t.projectMilestone);
                      break;
                  case `cycle`:
                      v.addToCycle(t[e]);
                      break;
                  case `labels`:
                      for (let n of t[e])
                          v.labels.filter(e => e.parent ? e.parent === n.parent : !1).forEach(e => v.labels.remove(e)),
                          v.labels.add(n);
                      break;
                  default:
                      throw new Rn(e)
                  }
          }
          );
          let ve = kR.getOrCreateFrom(v);
          a && ve.replaceWithContent(a);
          for (let e of p)
              e.parent = vm.wrap(v),
              e.save();
          for (let t of ge) {
              let r = Iq.create(e, {
                  parentIssue: v,
                  ...t,
                  team: n
              });
              r.save(!0),
              r.documentContent.value?.save(!0)
          }
          for (let e of o ?? [])
              kV.create({
                  issue: v,
                  url: e.url,
                  title: e.title
              }).save(!0);
          return v
      }
      prepareForAdd() {
          this.state ||= this.cycle ? this.team.defaultActiveState : this.team.defaultState(this.creator),
          this.preserveSortOrderOnCreate || (this.sortOrder = this.state.firstSortOrder(),
          this.prioritySortOrder = this.sortOrder),
          this.number = this.team.nextIssueNumber,
          this.creator = pQ().user
      }
      static #i = this.collectionsIncludedInLocalTransaction = [`children`];
      async moveToTeam(e, t, n={}) {
          await e.issues.hydrate(),
          this.moveToTeamUnsafe(e, t, n)
      }
      moveToTeamUnsafe(e, t, n={}) {
          let {skipSortOrderChange: r, forceAddTeamToProject: i, skipMoveIntoTriageState: a} = n, o = this.identifier, s = yl.getPossiblePreviousIssueNumberForTeam(this.previousIdentifiers, e.key), c;
          c = s || (this.clonedFromModel?.team === e ? this.clonedFromModel.number : e.nextIssueNumber);
          let l = this.team.defaultState(t) === this.state;
          this.team = e;
          let u = e.defaultState(t, {
              preferredState: n.moveToDefaultTeamState && l ? void 0 : e.states.find(e => e.filterMatchValue === this.state?.filterMatchValue) || e.states.find(e => e.type === this.state?.type)
          });
          t && !this.state.isClosed && e.triageEnabled && !u.isTriage && !e.userIsMember(t) && e.triageIssueState && !a && (u = e.triageIssueState),
          this.assignToState(u, {
              skipSortOrderChange: r
          });
          let d = this.cycle?.value ? Tq.findEquivalentModelForTeam(this.cycle.value, e) : void 0;
          d ? this.cycle = vm.wrap(d) : this.state?.isActive && e.cycleLockToActive ? this.addToCycle(e.activeCycle, {
              skipSortOrderChange: r
          }) : this.addToCycle(void 0, {
              skipSortOrderChange: r
          }),
          this.project?.accessibleTeams.contains(e) || (this.project && i ? this.project.administrableTeams.add(e) : this.persisted && (this.project && !this.project.persisted ? this.project.administrableTeams.add(e) : this.project ? (w.remote(`Rendering the old alert dialog to add team to project or create issue outside project`, {
              issueId: this.id
          }),
          new Xl({
              title: `${this.team.name} team is not in ${this.project.name}`,
              description: `The ${this.team.name} team is not currently part of the project. Would you like to add ${this.team.name} to the project? If not, this issue must be created outside the project.`,
              confirmButtonTitle: `Add team`,
              cancelButtonTitle: `Create issue outside project`
          }).show().then(e => {
              e === Yl.confirm && this.project ? (this.project.administrableTeams.add(this.team),
              this.project.save(),
              this.setProjectAndMilestone(this.project, this.projectMilestone?.value)) : this.setProjectAndMilestone(void 0, void 0)
          }
          )) : this.setProjectAndMilestone(void 0))),
          e.private && this.assignee && !e.userIsMember(this.assignee) && (this.assignee = void 0),
          this.number &&= (this.previousIdentifiers.includes(o) || this.previousIdentifiers.push(o),
          c)
      }
      assignToState(e, t={}) {
          let n = this.state;
          if (e === n)
              return;
          e.isActive && this.cycle === void 0 && this.team.cycleLockToActive && this.addToCycle(this.team.activeCycle);
          let r = this.store.user;
          e.isStarted && !this.assignee && r.settings.selfAssignOnGitBranchCopy && !t.skipSelfAssign && (this.assignee = r);
          let i = n && _c.isStateBefore(e, n);
          if (t.skipSortOrderChange || this.team.setIssueSortOrderOnStateChange === pc.noAction)
              this.sortOrder += Math.random() * 1e-4;
          else {
              let n = i || e.isClosed;
              this.sortOrder = t.beforeIssue === void 0 ? this.team.setIssueSortOrderOnStateChange === pc.last && !n ? e.lastSortOrder() : e.firstSortOrder() : e.sortOrderForIssueDropLocation(t.beforeIssue)
          }
          e.isCanceled && this.setSLA(void 0),
          this.state = e,
          (e.isBacklog || e.isTriage) && this.cycle && this.addToCycle(void 0)
      }
      applyTemplate(e, t={}) {
          let {overwrite: n=!1, editingContext: r, onlyChildren: i} = t
            , a = e.templateData;
          if (!a || !this.store)
              return;
          if (i && a.children) {
              a.children.map(n => this.createSubIssueFromTemplate({
                  childData: n,
                  parent: this,
                  options: {
                      ...t,
                      template: e
                  }
              }));
              return
          }
          let o = this.lastAppliedTemplate?.value;
          if (o && this.isClone && this.clearTemplate(o),
          a.title && (!this.title || n) && (this.title = a.title),
          this.applyIssueTemplateFields(this, a, {
              ...t,
              template: e
          }),
          a.formFields && a.formFields.length > 0 && r !== `template`) {
              let e = kR.getOrCreateFrom(this)
                , t = pl();
              !e.contentData || !e.hasContent || n ? e.replaceWithContent(t) : e.replaceWithContent({
                  ...e.contentData,
                  content: [...e.contentData.content, ...t.content]
              })
          } else if (a.descriptionData?.content) {
              let e = kR.getOrCreateFrom(this);
              !e.contentData || !e.hasContent || n ? e.replaceWithContent(a.descriptionData) : e.replaceWithContent({
                  ...e.contentData,
                  content: [...e.contentData.content, ...a.descriptionData.content]
              })
          }
          a.children && a.children.map(n => this.createSubIssueFromTemplate({
              childData: n,
              parent: this,
              options: {
                  ...t,
                  template: e
              }
          })),
          this.lastAppliedTemplate = vm.wrap(e)
      }
      clearTemplate(e) {
          let t = e.templateData;
          t && (t.title === this.title && (this.title = ``),
          this.documentContent.value?.hasContentEqualTo(t.descriptionData) && this.documentContent.value.replaceWithContent(pl()),
          t.labelIds && t.labelIds.length > 0 && t.labelIds.forEach(e => {
              let t = this.team.allIssueLabels.findById(e);
              t && this.labels.remove(t)
          }
          ),
          t.priority !== void 0 && t.priority === this.priority.priority && (this.priority = zl.NoPriority),
          t.assigneeId && t.assigneeId === this.assignee?.id && (this.assignee = void 0),
          this.state.id === t.stateId && this.assignToState(this.team.defaultState(), {
              skipSortOrderChange: !0
          }),
          t.projectId === this.project?.id && this.setProjectAndMilestone(void 0),
          t.children && t.children.forEach(e => {
              let t = this.children.find(t => {
                  let n = t.title === e.title
                    , r = !e.descriptionData && !t.documentContent.value?.hasContent
                    , i = !!t.documentContent.value?.hasContentEqualTo(e.descriptionData);
                  return n && (r || i)
              }
              );
              t && t.trash()
          }
          ),
          this.lastAppliedTemplate = void 0)
      }
      static createFormIssueFromTemplate(e, t) {
          let n = e.clone(!0);
          for (let e of [...n.children.elements])
              n.children.remove(e);
          let r = t.templateData.teamId
            , i = r ? n.store.findById(K, r) : void 0;
          i && n.team !== i && n.moveToTeamUnsafe(i, void 0, {
              skipMoveIntoTriageState: !0
          }),
          t.templateData.title && (n.title = t.templateData.title);
          let a = t.templateData.projectId ? n.store.findById(G, t.templateData.projectId) : void 0
            , o = t.templateData.projectMilestoneId ? n.store.findById(mR, t.templateData.projectMilestoneId) : void 0;
          if (n.setProjectAndMilestone(a, o),
          t.templateData.estimate !== void 0 && n.team.estimationEnabled && (n.estimate = t.templateData.estimate),
          t.templateData.priority !== void 0 && t.templateData.priority !== 0 && (n.priority = zl.createFromPriority(t.templateData.priority)),
          t.templateData.assigneeId && (n.assignee = n.store.findById(J, t.templateData.assigneeId)),
          t.templateData.delegateId && (n.delegate = n.store.findById(J, t.templateData.delegateId)),
          t.templateData.stateId) {
              let e = n.store.findById(ux, t.templateData.stateId)
                , r = e ? n.team.states.find(t => t.filterMatchValue === e.filterMatchValue) || n.team.states.find(t => t.type === e.type) : void 0;
              r ? n.assignToState(r, {
                  skipSortOrderChange: !0
              }) : (!n.state || n.state.team !== n.team) && n.assignToState(n.team.defaultState(n.store.user))
          } else
              (!n.state || n.state.team !== n.team) && n.assignToState(n.team.defaultState(n.store.user));
          return n.labels.clear(),
          (t.templateData.labelIds ?? []).filter(e => e !== null).forEach(e => {
              let t = n.team.allIssueLabels.findById(e);
              t && n.labels.add(t)
          }
          ),
          n.lastAppliedTemplate = vm.wrap(t),
          n
      }
      addToCycle(e, t={}) {
          t.skipSortOrderChange && (this.sortOrder += Math.random()),
          e === void 0 || e?.team === this.team ? (this.cycle = e ? vm.wrap(e) : void 0,
          e && (!this.state || this.state.isBacklog || this.state.isTriage) && (this.state = this.team.defaultActiveState),
          this.team.cycleLockToActive && e === void 0 && this.state?.isActive && this.team.activeCycle && (this.state = this.team.defaultBacklogState)) : this.cycle = void 0
      }
      addToProjectMilestone(e) {
          return e ? (this.setProjectAndMilestone(this.project, e),
          !0) : (this.setProjectAndMilestone(this.project, void 0),
          !1)
      }
      addToProjectWithoutPrompt(e, t, n) {
          if (!e)
              return this.setProjectAndMilestone(void 0, void 0),
              !1;
          if (e.accessibleTeams.contains(this.team))
              return this.setProjectAndMilestone(e, t),
              !0;
          if (n?.addTeamToProject)
              return e.administrableTeams.add(this.team),
              e.save(),
              this.setProjectAndMilestone(e, t),
              !0
      }
      setProjectAndMilestone(e, t) {
          if (!e) {
              this.project = void 0,
              this.projectMilestone = void 0;
              return
          }
          if (t && e.id !== t.project.id)
              throw Error(`Project milestone does not belong to the given project`);
          this.project = e,
          this.projectMilestone = t ? vm.wrap(t) : void 0
      }
      setEstimate(e) {
          this.estimate = e
      }
      get eligibleForDraft() {
          let e = this.title.length > 0
            , t = this.documentContent.value?.hasContent ?? !1
            , n = this.title.length >= 3
            , r = (this.documentContent?.value?.markdownContent?.length ?? 0) >= 3;
          return n || r || e && t
      }
      applyDraftValues(e, t) {
          let {title: n, descriptionData: r, teamId: i, priority: a, assigneeId: o, delegateId: s, estimate: c, parentIssue: l, projectId: u, projectMilestoneId: d, sourceCommentId: f, sourcePullRequestCommentId: p, stateId: m, cycleId: h, labels: g, attachments: _=[], needs: ee=[], dueDate: te} = e
            , ne = i ? this.store.findById(K, i) : void 0;
          ne && ne !== this.team && (this.team ? this.moveToTeamUnsafe(ne) : this.team = ne),
          this.title = n,
          this.priority = a,
          this.estimate = c,
          this.dueDate = te,
          this.assignee = o ? this.store.findById(J, o) : void 0,
          this.delegate = s ? this.store.findById(J, s) : void 0;
          let re = u ? this.store.findById(G, u) : void 0
            , ie = d ? this.store.findById(mR, d) : void 0;
          this.setProjectAndMilestone(re, ie);
          let ae = m ? this.store.findById(ux, m) : void 0;
          ae && ae !== this.state && ae.team === this.team && this.assignToState(ae);
          let oe = h ? this.store.findById(gH, h) : void 0;
          oe && oe.team === this.team && this.addToCycle(oe);
          let se = f ? this.store.findById(YB, f) : void 0;
          se && (this.sourceComment = vm.wrap(se));
          let ce = p ? this.store.findById(Kk, p) : void 0;
          ce && (this.sourcePullRequestComment = vm.wrap(ce));
          let le = this.labels.map(e => e.id);
          for (let e of g.elements)
              !e.isArchived && !e.isRetired && !le.includes(e.id) && (!e.team || e.team === this.team) && this.labels.add(e);
          let ue = this.attachments.map(e => e.url);
          if (_) {
              for (let e of _)
                  if (!ue.includes(e.url)) {
                      let t = kV.createFromDraftAttachment(e, this);
                      this.attachments.add(t)
                  }
          }
          this.needs.clear();
          for (let e of ee)
              if (e.customerId) {
                  let n = n => {
                      let r = UB.create({
                          customer: n,
                          issue: this,
                          organization: this.team.organization
                      });
                      e.priority && (r.priority = IB.createFromPriority(e.priority)),
                      r.bodyData = e.bodyData,
                      r.attachmentUrl = e.attachmentUrl,
                      t?.skipNeedsCreation || r.save(!0),
                      this.needs.add(r)
                  }
                    , r = this.store.findById(MB, e.customerId);
                  r ? n(r) : this.store.hydrateModel(MB, e.customerId).then(e => {
                      e && n(e)
                  }
                  )
              }
          this.createdFromDraftId = e.id;
          let de = l ? l.resolve() : void 0;
          this.parent = t?.parentDraftAsIssue ? vm.wrap(t.parentDraftAsIssue) : de?.value ? vm.wrap(de.value) : void 0,
          r && kR.getOrCreateFrom(this).replaceWithContent(r);
          let fe = e.lastAppliedTemplate?.value;
          fe && (this.lastAppliedTemplate = vm.wrap(fe));
          let pe = [];
          if (!t?.skipChildren) {
              for (let t of e.children.elements) {
                  let e = Iq.createEmpty()
                    , n = e.applyDraftValues(t, {
                      parentDraftAsIssue: this
                  });
                  kR.getOrCreateFrom(e),
                  pe.push(e, ...n)
              }
              if (!this.parent)
                  for (let e of pe)
                      e.save(!0),
                      e.documentContent.value?.save(!0)
          }
          return pe
      }
      markNotificationAsRead(e) {
          let t = this.notifications.find(t => t.id === e || t.groupingEntityId === e);
          if (!t)
              return;
          let n = t?.groupingEntityId;
          this.store.user.notifications.forEach(e => {
              e.readAt === void 0 && e.metadata?.issueIdForGrouping === this.id && (e.markAsRead(),
              e.save())
          }
          ),
          this.notifications.forEach(e => {
              e.readAt === void 0 && e.groupingEntityId === n && (e.markAsRead(),
              e.save())
          }
          )
      }
      markNonImportantNotificationsAsRead() {
          let e = e => e.type === O.issueSlaBreached || e.type === O.issueSlaHighRisk || e.type === O.issueReminder || e.type === O.issuePriorityUrgent;
          this.notifications.forEach(t => t.commentId || e(t) ? !1 : (t.markAsRead(),
          t.save(),
          !0))
      }
      matchInlineFind(e) {
          return $l([this.identifier, this.title, this.project?.name].concrete().join(` `)).toLowerCase().indexOf(e) !== -1
      }
      async hydrateSimilarIssues() {
          if (!this.shouldHydrateSimilarIssues())
              return this.similarIssues;
          this.similarIssuesHydratedAt = new Date;
          try {
              let e = await yq(this.store.graphQLClient, {
                  issueId: this.id,
                  topK: 3,
                  action: Sq.triage,
                  useCache: this.store.user.settings.debugShowSimilarIssues ? !1 : void 0
              });
              await this.setSimilarIssueResults(e.similarIssueIds)
          } catch (e) {
              w.error(`Similar issues hydration failed`, e, {
                  issueId: this.id
              })
          }
          return this.similarIssues
      }
      resetSimilarIssues() {
          this.similarIssues.clear(),
          this.similarIssuesHydratedAt = void 0
      }
      async hydrateSimilarIssuesFromBatch(e) {
          return this.similarIssuesHydratedAt = new Date,
          await this.setSimilarIssueResults(e),
          this.similarIssues
      }
      static async hydrateByIdentifier(e, t) {
          let n = Iq.issueNumberFromIdentifier(e);
          if (!n)
              return;
          if (this.store.isPreBootstrapRendering) {
              let t = this.store.allModelsOfType(Iq, yR.allModels)
                , r = t.find(t => t.identifier === e || t.previousIdentifiers.includes(e));
              return r || w.info(`Pre-bootstrap: hydrateByIdentifier called with unknown identifier`, {
                  identifier: e,
                  issueNumber: n,
                  issueCount: t.length
              }),
              r
          }
          let r = await this.store.hydrateModels(Iq, {
              key: `number`,
              value: n
          }, t);
          if (Array.isArray(r)) {
              for (let t of r)
                  if (t.identifier === e)
                      return t
          }
      }
      shouldHydrateSimilarIssues() {
          if (this.store.organization.isTriageSuggestionsAccessible || this.state.type !== E.triage)
              return !1;
          let e = this.team.organization.approximateIssueCount > 150;
          return this.store.user.settings.debugShowSimilarIssues || e && (!this.similarIssuesHydratedAt || this.similarIssuesHydratedAt < qe(new Date, 24))
      }
      isUnchangedTemplate(e) {
          let t = this.lastAppliedTemplate?.value;
          if (!t)
              return !1;
          function n(e, t) {
              let r = e
                , i = e.children?.map( (e, r) => n(e, t?.children?.[r]));
              if (e.teamId && t?.teamId === null) {
                  let {stateId: n, projectId: i, projectMilestoneId: a, teamId: o, ...s} = e;
                  r = {
                      ...s,
                      teamId: t?.teamId
                  }
              }
              return (0,
              Mq.default)({
                  ...r,
                  lastAppliedTemplateId: void 0,
                  descriptionData: TR(r.descriptionData),
                  children: i
              }, e => e !== void 0)
          }
          function r(e, t) {
              let n = e.children?.map(e => r(e, t))
                , i = e.teamId ? t.store.findById(K, e.teamId) ?? t.team : t.team
                , a = e.labelIds?.filter(e => !!i.allIssueLabels.findById(e))
                , o = e.stateId ? !!i.states.findById(e.stateId) : !1;
              return (0,
              Mq.default)({
                  ...e,
                  descriptionData: TR(e.descriptionData),
                  children: n,
                  stateId: o ? e.stateId : void 0,
                  labelIds: a?.length === 0 ? void 0 : a,
                  teamId: e.teamId === null ? void 0 : i.id,
                  lastAppliedTemplateId: void 0
              }, e => e !== void 0)
          }
          let i = t.templateData
            , a = r((0,
          Fq.default)(i), this)
            , o = n(this.getDataForTemplate(), a);
          return e ? (0,
          Nq.default)((0,
          jq.default)(a, e), (0,
          jq.default)(o, e)) : (0,
          Nq.default)(a, o)
      }
      getDataForTemplate() {
          return (0,
          Mq.default)({
              title: this.title,
              descriptionData: this.documentContent.value?.contentData,
              priority: this.priority.priority,
              assigneeId: this.assignee?.id,
              delegateId: this.delegate?.id,
              labelIds: this.labels.length ? this.labels.map(e => e.id).filter(e => !!e) : void 0,
              stateId: this.isTemplateWithNoDefaultTeam ? void 0 : this.state.id,
              projectId: this.project?.id,
              projectMilestoneId: this.projectMilestone?.id,
              teamId: this.isTemplateWithNoDefaultTeam ? null : this.team.id,
              children: this.children.length ? this.children.map(e => e.getDataForTemplate()) : void 0,
              lastAppliedTemplateId: this.lastAppliedTemplate?.id,
              estimate: this.estimate
          }, e => e !== void 0)
      }
      applyIssueTemplateFields(e, t, n) {
          let r = this.store
            , i = t.teamId;
          i && i === n.template.inheritedFrom?.value?.team?.id && (i = n.template.team?.id);
          let a = i ? r.findById(K, i) : void 0;
          e.isTemplateWithNoDefaultTeam = !1,
          a && a.id !== e.team.id && (e.team ? e.moveToTeamUnsafe(a) : e.team = a),
          a === void 0 && n.template.team && n.template.team !== e.team && e.moveToTeamUnsafe(n.template.team),
          a === null && n.editingContext === `template` && (e.isTemplateWithNoDefaultTeam = !0),
          a === void 0 && !n.template.team && n.editingContext === `template` && (e.isTemplateWithNoDefaultTeam = !0);
          let o = (t.labelIds || []).filter(e => e !== null);
          if (o && o.length > 0 && (n.labelsFromFilterContext && n.labelsFromFilterContext.forEach(t => {
              e.labels.map(e => e.id).includes(t.id) && e.labels.remove(t)
          }
          ),
          o.forEach(t => {
              let i = r.findById(OH, t)
                , a = i?.team ? Tq.findEquivalentModelForTeam(i, e.team) : i;
              a && (a.parent && e.labels.filter(e => e.parent === a.parent).forEach(t => {
                  e.labels.remove(t)
              }
              ),
              !(n.editingContext !== `template` && a.isRetired) && (a.isGroup || e.labels.add(a)))
          }
          )),
          t.priority !== void 0 && t.priority !== 0 && (e.priority = zl.createFromPriority(t.priority)),
          t.assigneeId && (e.assignee = r.findById(J, t.assigneeId)),
          t.delegateId && (e.delegate = r.findById(J, t.delegateId)),
          t.stateId) {
              let i = r.findById(ux, t.stateId)
                , a = i ? Tq.findEquivalentModelForTeam(i, e.team) : void 0;
              a && e.team === a.team && e.assignToState(a, {
                  skipSelfAssign: n.editingContext === `template`
              })
          }
          if ((!e.state || e.state.team !== e.team) && e.assignToState(e.team.defaultState(e.store.user)),
          t.projectId) {
              let n = r.findById(G, t.projectId)
                , i = t.projectMilestoneId ? r.findById(mR, t.projectMilestoneId) : void 0;
              e.setProjectAndMilestone(n, i)
          }
          t.estimate !== void 0 && e.team.estimationEnabled && (e.estimate = t.estimate)
      }
      createSubIssueFromTemplate(e) {
          let {childData: t, parent: n, options: r} = e
            , i = r.subIssuesInheritParentProperties ?? !0
            , a = Iq.createEmpty();
          if (a.team = this.team,
          a.title = t.title || ``,
          n.applyIssueTemplateFields(a, Object.assign({}, t, i ? {
              projectId: t.projectId ?? n.project?.id,
              projectMilestoneId: t.projectMilestoneId ?? n.projectMilestone?.id
          } : {}), r),
          t.descriptionData && kR.getOrCreateFrom(a).replaceWithContent(t.descriptionData),
          a.parent = vm.wrap(n),
          a.subIssueSortOrder = tx.lastSortOrder(n.children, `subIssueSortOrder`),
          a.prioritySortOrder = tx.lastSortOrder(n.children, `prioritySortOrder`),
          t.lastAppliedTemplateId) {
              let e = this.store.findById(hx, t.lastAppliedTemplateId);
              e && (a.lastAppliedTemplate = vm.wrap(e))
          }
          a.save(!0),
          a.documentContent?.value?.save(!0),
          t.children?.forEach(e => this.createSubIssueFromTemplate({
              childData: e,
              parent: a,
              options: r
          }))
      }
      includeInLocalTransactionVia() {
          return [this.parent?.value].concrete()
      }
      hydrateExtra() {
          return {
              hydrate: async () => {
                  let e = this.sourceMetadata?.asksMetadata?.requesterExternalUserId;
                  e && await this.store.hydrateModel(Fy, e)
              }
              ,
              isHydrated: () => {
                  let e = this.sourceMetadata?.asksMetadata?.requesterExternalUserId;
                  return e ? !this.store.findById(Fy, e) : !0
              }
          }
      }
      async setSimilarIssueResults(e) {
          let t = e.map(e => e.id);
          if (e && t && t.length > 0) {
              let n = (await Promise.all(t.map(e => this.store.hydrateModel(Iq, e)))).concrete()
                , r = (0,
              Pq.default)(t, n.map(e => e.id));
              if (r.length > 0) {
                  let e = (await Promise.all(r.map(e => this.store.findArchivedByIdentifier(Iq, e)))).concrete();
                  n.push(...e)
              }
              this.similarIssues.clear(),
              n.forEach(e => {
                  this.similarIssues.add(e)
              }
              ),
              this.similarIssuesMetadata = e.reduce( (e, t) => (e[t.id] = t.metadata,
              e), {})
          }
      }
      checkForErroneousIssueRelation(e) {
          return !e.issue.value || !e.relatedIssue.value ? (w.error(`Issue relation without a related issue`, void 0, {
              relation: {
                  id: e.id,
                  issueId: e.issue.id,
                  issueIsUnresolved: !e.issue.value,
                  relatedIssueId: e.relatedIssue.id,
                  relatedIssueIsUnresolved: !e.relatedIssue.value
              }
          }),
          !1) : !0
      }
      checkForErroneousRelation(e) {
          return e.issue ? !0 : (w.error(`Issue relation without a related issue`, void 0, {
              relation: {
                  id: e.relation.id,
                  issueId: e.relation?.issueId,
                  issueIsUnresolved: e.relation.issue === void 0,
                  relatedIssueId: e.relation?.relatedIssueId,
                  relatedIssueIsUnresolved: e.relation.relatedIssue === void 0
              }
          }),
          !1)
      }
  }
  ,
  M([R({
      persistence: `none`,
      indexed: !0,
      default: 0
  })], Y.prototype, `number`, void 0),
  M([R({
      default: ``
  })], Y.prototype, `title`, void 0),
  M([dg({
      nullable: !0
  })], Y.prototype, `documentContent`, void 0),
  M([B( () => K, `issues`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      trait: `useForPartialIndex`
  })], Y.prototype, `team`, void 0),
  M([Nre(e => e.team?.cyclesEnabled ?? !0), sg( () => gH, `issues`, {
      nullable: !0,
      indexed: !0,
      onDelete: `SET NULL`,
      onArchive: `NO ACTION`
  })], Y.prototype, `cycle`, void 0),
  M([B( () => G, `issues`, {
      nullable: !0,
      indexed: !0,
      onDelete: `SET NULL`,
      onArchive: `CASCADE`,
      trait: `useForPartialIndex`
  })], Y.prototype, `project`, void 0),
  M([sg( () => mR, `issues`, {
      nullable: !0,
      indexed: !0,
      onDelete: `SET NULL`,
      onArchive: `CASCADE`,
      trait: `useForPartialIndex`
  })], Y.prototype, `projectMilestone`, void 0),
  M([sg( () => Y, `children`, {
      nullable: !1,
      optional: !0,
      indexed: !0,
      onDelete: `SET NULL`,
      onArchive: `CASCADE`
  })], Y.prototype, `parent`, void 0),
  M([lg( () => hx, {
      nullable: !0,
      indexed: !0
  })], Y.prototype, `lastAppliedTemplate`, void 0),
  M([sg( () => hx, `recurringIssues`, {
      nullable: !0,
      indexed: !0,
      persistence: `none`
  })], Y.prototype, `recurringIssueTemplate`, void 0),
  M([z( () => GA, {
      index: `issueId`,
      canSkipHydration: e => !e.getTrait(lc.hasExternalEntityRelations)
  })], Y.prototype, `externalEntityRelations`, void 0),
  M([z( () => Y, {
      index: `parentId`,
      order: new P(`subIssueSortOrder`).and(`createdAt`),
      canSkipHydration: e => !e.getTrait(lc.hasChildren)
  })], Y.prototype, `children`, void 0),
  M([og( () => wH, {
      order: new P(`createdAt`,`asc`)
  })], Y.prototype, `draftChildren`, void 0),
  M([z( () => bM, {
      index: `issueId`,
      order: new P(`createdAt`,`desc`)
  })], Y.prototype, `reminders`, void 0),
  M([og( () => ZL)], Y.prototype, `notifications`, void 0),
  M([og( () => qU, {
      order: new P(`updatedAt`,`asc`)
  })], Y.prototype, `activities`, void 0),
  M([ug({
      nullable: !0
  })], Y.prototype, `featureFlag`, void 0),
  M([R({
      serializer: HR,
      default: () => zl.NoPriority
  })], Y.prototype, `priority`, void 0),
  M([R({})], Y.prototype, `estimate`, void 0),
  M([B( () => J, `createdIssues`, {
      persistence: `none`,
      nullable: !0,
      indexed: !0,
      trait: `useForPartialIndex`
  })], Y.prototype, `creator`, void 0),
  M([lg( () => Fy, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `none`
  })], Y.prototype, `externalUserCreator`, void 0),
  M([B( () => J, `assignedIssues`, {
      nullable: !0,
      indexed: !0,
      trait: `useForPartialIndex`
  })], Y.prototype, `assignee`, void 0),
  M([B( () => J, `delegatedIssues`, {
      nullable: !0,
      indexed: !0
  })], Y.prototype, `delegate`, void 0),
  M([cg( () => J, {
      nullable: !0,
      persistence: `updateOnly`
  })], Y.prototype, `snoozedBy`, void 0),
  M([fg( () => J, `subscribedIssues`, {
      indexed: !0,
      trait: `useForPartialIndex`
  })], Y.prototype, `subscribers`, void 0),
  M([z( () => U, {
      index: `linkedIssueIds`,
      canSkipHydration: e => !e.getTrait(lc.hasPullRequests)
  })], Y.prototype, `linkedPullRequests`, void 0),
  M([B( () => ux, `issues`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      onDelete: `NO ACTION`
  })], Y.prototype, `state`, void 0),
  M([sg( () => Lj, `issues`, {
      persistence: `none`,
      nullable: !0,
      indexed: !0
  })], Y.prototype, `issueImport`, void 0),
  M([R({
      default: 0
  })], Y.prototype, `sortOrder`, void 0),
  M([R({
      default: 0
  })], Y.prototype, `prioritySortOrder`, void 0),
  M([R()], Y.prototype, `subIssueSortOrder`, void 0),
  M([R({
      persistence: `none`,
      indexed: !0,
      multiEntry: !0,
      default: []
  })], Y.prototype, `previousIdentifiers`, void 0),
  M([ug({
      nullable: !0
  })], Y.prototype, `favorite`, void 0),
  M([lg( () => YB, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], Y.prototype, `referenceComment`, void 0),
  M([fg( () => OH, `issues`, {
      indexed: !0,
      order: new P(e => `${e.parent ? `0${e.parent.name}` : 1}${e.name}`)
  })], Y.prototype, `labels`, void 0),
  M([z( () => YB, {
      index: `issueId`
  })], Y.prototype, `comments`, void 0),
  M([z( () => NR, {
      index: `issueId`,
      order: new P(`createdAt`,`desc`),
      canSkipHydration: e => !ui.isEnabled(ui.documentsOnIssues) || !e.getTrait(lc.hasDocuments)
  })], Y.prototype, `documents`, void 0),
  M([og( () => kM, {
      order: new P(`createdAt`,`asc`)
  })], Y.prototype, `draftComments`, void 0),
  M([z( () => GB, {
      index: `issueId`,
      order: new P(`createdAt`,`desc`),
      canSkipHydration: e => !e.getTrait(lc.hasAiPromptProgress)
  })], Y.prototype, `aiPromptProgresses`, void 0),
  M([z( () => ZU, {
      index: `issueId`
  })], Y.prototype, `history`, void 0),
  M([z( () => kV, {
      index: `issueId`,
      canSkipHydration: e => !e.getTrait(lc.hasAttachments),
      private: !0
  })], Y.prototype, `attachments`, void 0),
  M([z( () => kV, {
      index: `originalIssueId`,
      canSkipHydration: e => !e.getTrait(lc.hasFormerAttachments),
      private: !0
  })], Y.prototype, `formerAttachments`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Y.prototype, `startedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Y.prototype, `startedTriageAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Y.prototype, `triagedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Y.prototype, `completedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Y.prototype, `canceledAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Y.prototype, `autoClosedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Y.prototype, `autoArchivedAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `updateOnly`
  })], Y.prototype, `snoozedUntilAt`, void 0),
  M([R({
      serializer: Ah
  })], Y.prototype, `slaStartedAt`, void 0),
  M([R({
      serializer: Ah
  })], Y.prototype, `slaBreachesAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Y.prototype, `slaHighRiskAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Y.prototype, `slaMediumRiskAt`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Y.prototype, `addedToCycleAt`, void 0),
  M([R({
      persistence: `none`,
      serializer: kh({
          stateUpdatedAt: {
              serializer: Ah,
              nullable: !1
          },
          accumulatedStateUpdatedAt: {
              serializer: Ah,
              nullable: !0
          }
      })
  })], Y.prototype, `timeInStatus`, void 0),
  M([R({
      default: `all`
  })], Y.prototype, `slaType`, void 0),
  M([R({
      persistence: `none`
  })], Y.prototype, `sourceMetadata`, void 0),
  M([sg( () => YB, `createdIssues`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], Y.prototype, `sourceComment`, void 0),
  M([sg( () => Kk, `createdIssues`, {
      nullable: !0,
      indexed: !0,
      persistence: `createOnly`
  })], Y.prototype, `sourcePullRequestComment`, void 0),
  M([z( () => fq, {
      index: `issueId`,
      order: new P(`type`).and(`createdAt`, `desc`),
      canSkipHydration: e => !e.getTrait(lc.hasRelations)
  })], Y.prototype, `relations`, void 0),
  M([z( () => fq, {
      index: `relatedIssueId`,
      order: new P(`type`).and(`createdAt`, `desc`),
      canSkipHydration: e => !e.getTrait(lc.hasReverseRelations)
  })], Y.prototype, `inverseRelations`, void 0),
  M([z( () => kq, {
      index: `issueId`,
      order: Oq(),
      canSkipHydration: e => !e.getTrait(lc.hasSuggestions)
  })], Y.prototype, `suggestions`, void 0),
  M([z( () => kq, {
      index: `suggestedIssueId`,
      order: new P(`createdAt`,`asc`),
      canSkipHydration: e => !e.getTrait(lc.hasIncomingSuggestions)
  })], Y.prototype, `incomingSuggestions`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`
  })], Y.prototype, `suggestionsGeneratedAt`, void 0),
  M([R({
      serializer: jh
  })], Y.prototype, `dueDate`, void 0),
  M([R({
      persistence: `updateOnly`
  })], Y.prototype, `trashed`, void 0),
  M([R({
      persistence: `createOnly`,
      default: !1,
      isVirtual: !0
  })], Y.prototype, `preserveSortOrderOnCreate`, void 0),
  M([R({
      persistence: `none`
  })], Y.prototype, `createdFromDraftId`, void 0),
  M([R({
      persistence: `none`
  })], Y.prototype, `traits`, void 0),
  M([R({
      persistence: `none`,
      serializer: Mh,
      default: []
  })], Y.prototype, `reactionData`, void 0),
  M([z( () => UB, {
      index: `issueId`,
      canSkipHydration: e => !e.getTrait(lc.hasCustomerNeeds)
  })], Y.prototype, `needs`, void 0),
  M([z( () => UB, {
      index: `originalIssueId`,
      canSkipHydration: e => !e.getTrait(lc.hasFormerCustomerNeeds),
      private: !0
  })], Y.prototype, `formerNeeds`, void 0),
  M([z( () => nM, {
      index: `issueId`,
      order: new P(`createdAt`,`desc`),
      canSkipHydration: e => !e.getTrait(lc.hasReleases)
  })], Y.prototype, `issueToReleases`, void 0),
  M([L], Y.prototype, `releases`, null),
  M([z( () => Dj, {
      index: `issueId`,
      order: new P(`createdAt`,`desc`),
      canSkipHydration: e => !e.getTrait(lc.hasAgentSessions)
  })], Y.prototype, `agentSessions`, void 0),
  M([L], Y.prototype, `reminder`, null),
  M([L], Y.prototype, `contributors`, null),
  M([L], Y.prototype, `descendants`, null),
  M([R({
      persistence: `none`
  })], Y.prototype, `lastAppliedIssueTemplateData`, void 0),
  M([R({
      persistence: `none`
  })], Y.prototype, `isTemplateWithNoDefaultTeam`, void 0),
  M([R({
      persistence: `none`
  })], Y.prototype, `isTemplate`, void 0),
  M([R({
      persistence: `updateOnly`,
      isVirtual: !0
  })], Y.prototype, `autoClosedByParentClosing`, void 0),
  M([R({
      persistence: `none`,
      serializer: kh({
          updatedAt: {
              serializer: Ah,
              nullable: !0
          }
      })
  })], Y.prototype, `activitySummary`, void 0),
  M([dg({
      nullable: !0,
      canSkipHydration: e => !e.getTrait(lc.hasSummary)
  })], Y.prototype, `summary`, void 0),
  M([L], Y.prototype, `nestedSubIssueSortOrder`, null),
  M([L], Y.prototype, `slaStatus`, null),
  M([L], Y.prototype, `lastActivityAt`, null),
  M([L], Y.prototype, `activeSubscribers`, null),
  M([L], Y.prototype, `startedTriageOrCreatedAt`, null),
  M([L], Y.prototype, `addedToCyclePeriod`, null),
  M([L], Y.prototype, `suggestedRelatedIssues`, null),
  M([L], Y.prototype, `duplicateOfSuggestions`, null),
  M([L], Y.prototype, `duplicatedBySuggestions`, null),
  M([L], Y.prototype, `allRelatedIssueSuggestions`, null),
  M([L], Y.prototype, `hasSuggestedRelatedIssues`, null),
  M([L], Y.prototype, `hasSuggestedSimilarIssues`, null),
  M([L], Y.prototype, `hasSuggestedAssignees`, null),
  M([L], Y.prototype, `hasSuggestedLabels`, null),
  M([L], Y.prototype, `hasSuggestedTeams`, null),
  M([L], Y.prototype, `hasSuggestedProjects`, null),
  M([L], Y.prototype, `initiatives`, null),
  M([L], Y.prototype, `blockingRelations`, null),
  M([L], Y.prototype, `blockedByRelations`, null),
  M([L], Y.prototype, `relatedRelations`, null),
  M([L], Y.prototype, `duplicateRelations`, null),
  M([L], Y.prototype, `duplicateOfRelation`, null),
  M([L], Y.prototype, `emailIntakeMetadata`, null),
  M([L], Y.prototype, `currentAndFormerAttachments`, null),
  M([L], Y.prototype, `allAttachments`, null),
  M([L], Y.prototype, `standardAttachments`, null),
  M([L], Y.prototype, `sentryAttachments`, null),
  M([L], Y.prototype, `pullRequestAttachments`, null),
  M([L], Y.prototype, `syncedJiraIssueAttachment`, null),
  M([L], Y.prototype, `syncedGithubIssueAttachment`, null),
  M([L], Y.prototype, `syncedSlackIssueAttachment`, null),
  M([L], Y.prototype, `allNeeds`, null),
  M([L], Y.prototype, `customerCount`, null),
  M([L], Y.prototype, `customerImportantCount`, null),
  M([L], Y.prototype, `aggregatedCustomersRevenue`, null),
  M([L], Y.prototype, `sortedCustomerByImpact`, null),
  M([L], Y.prototype, `branchNames`, null),
  M([L], Y.prototype, `parents`, null),
  M([L], Y.prototype, `aggregatedTimeByStateKey`, null),
  M([L], Y.prototype, `timeInStatusByStateKey`, null),
  M([I], Y, `createSubIssue`, null),
  M([I], Y, `create`, null),
  M([I], Y.prototype, `moveToTeamUnsafe`, null),
  M([I], Y.prototype, `assignToState`, null),
  M([I], Y.prototype, `applyTemplate`, null),
  M([I], Y.prototype, `clearTemplate`, null),
  M([I], Y.prototype, `addToCycle`, null),
  M([I], Y.prototype, `addToProjectMilestone`, null),
  M([I], Y.prototype, `addToProjectWithoutPrompt`, null),
  M([I], Y.prototype, `setProjectAndMilestone`, null),
  M([I], Y.prototype, `setEstimate`, null),
  M([I], Y.prototype, `applyDraftValues`, null),
  M([I], Y.prototype, `markNotificationAsRead`, null),
  M([I], Y.prototype, `markNonImportantNotificationsAsRead`, null),
  Y = Iq = M([mg(`Issue`)], Y)
}
)), Pue, Fue = t(( () => {
  (function(e) {
      (function(t) {
          var n = typeof global == `object` ? global : typeof self == `object` ? self : typeof this == `object` ? this : Function(`return this;`)()
            , r = i(e);
          n.Reflect === void 0 ? n.Reflect = e : r = i(n.Reflect, r),
          t(r);
          function i(e, t) {
              return function(n, r) {
                  typeof e[n] != `function` && Object.defineProperty(e, n, {
                      configurable: !0,
                      writable: !0,
                      value: r
                  }),
                  t && t(n, r)
              }
          }
      }
      )(function(e) {
          var t = Object.prototype.hasOwnProperty
            , n = typeof Symbol == `function`
            , r = n && Symbol.toPrimitive !== void 0 ? Symbol.toPrimitive : `@@toPrimitive`
            , i = n && Symbol.iterator !== void 0 ? Symbol.iterator : `@@iterator`
            , a = typeof Object.create == `function`
            , o = {
              __proto__: []
          }instanceof Array
            , s = !a && !o
            , c = {
              create: a ? function() {
                  return Re(Object.create(null))
              }
              : o ? function() {
                  return Re({
                      __proto__: null
                  })
              }
              : function() {
                  return Re({})
              }
              ,
              has: s ? function(e, n) {
                  return t.call(e, n)
              }
              : function(e, t) {
                  return t in e
              }
              ,
              get: s ? function(e, n) {
                  return t.call(e, n) ? e[n] : void 0
              }
              : function(e, t) {
                  return e[t]
              }
          }
            , l = Object.getPrototypeOf(Function)
            , u = typeof process == `object` && {}.REFLECT_METADATA_USE_MAP_POLYFILL === `true`
            , d = !u && typeof Map == `function` && typeof Map.prototype.entries == `function` ? Map : Fe()
            , f = !u && typeof Set == `function` && typeof Set.prototype.entries == `function` ? Set : Ie()
            , p = new (!u && typeof WeakMap == `function` ? WeakMap : Le());
          function m(e, t, n, r) {
              if (v(n)) {
                  if (!Te(e) || !De(t))
                      throw TypeError();
                  return oe(e, t)
              } else {
                  if (!Te(e) || !ye(t) || !ye(r) && !v(r) && !_e(r))
                      throw TypeError();
                  return _e(r) && (r = void 0),
                  n = we(n),
                  se(e, t, n, r)
              }
          }
          e(`decorate`, m);
          function h(e, t) {
              function n(n, r) {
                  if (!ye(n) || !v(r) && !Oe(r))
                      throw TypeError();
                  pe(e, t, n, r)
              }
              return n
          }
          e(`metadata`, h);
          function g(e, t, n, r) {
              if (!ye(n))
                  throw TypeError();
              return v(r) || (r = we(r)),
              pe(e, t, n, r)
          }
          e(`defineMetadata`, g);
          function _(e, t, n) {
              if (!ye(t))
                  throw TypeError();
              return v(n) || (n = we(n)),
              le(e, t, n)
          }
          e(`hasMetadata`, _);
          function ee(e, t, n) {
              if (!ye(t))
                  throw TypeError();
              return v(n) || (n = we(n)),
              ue(e, t, n)
          }
          e(`hasOwnMetadata`, ee);
          function te(e, t, n) {
              if (!ye(t))
                  throw TypeError();
              return v(n) || (n = we(n)),
              de(e, t, n)
          }
          e(`getMetadata`, te);
          function ne(e, t, n) {
              if (!ye(t))
                  throw TypeError();
              return v(n) || (n = we(n)),
              fe(e, t, n)
          }
          e(`getOwnMetadata`, ne);
          function re(e, t) {
              if (!ye(e))
                  throw TypeError();
              return v(t) || (t = we(t)),
              me(e, t)
          }
          e(`getMetadataKeys`, re);
          function ie(e, t) {
              if (!ye(e))
                  throw TypeError();
              return v(t) || (t = we(t)),
              he(e, t)
          }
          e(`getOwnMetadataKeys`, ie);
          function ae(e, t, n) {
              if (!ye(t))
                  throw TypeError();
              v(n) || (n = we(n));
              var r = ce(t, n, !1);
              if (v(r) || !r.delete(e))
                  return !1;
              if (r.size > 0)
                  return !0;
              var i = p.get(t);
              return i.delete(n),
              i.size > 0 || p.delete(t),
              !0
          }
          e(`deleteMetadata`, ae);
          function oe(e, t) {
              for (var n = e.length - 1; n >= 0; --n) {
                  var r = e[n]
                    , i = r(t);
                  if (!v(i) && !_e(i)) {
                      if (!De(i))
                          throw TypeError();
                      t = i
                  }
              }
              return t
          }
          function se(e, t, n, r) {
              for (var i = e.length - 1; i >= 0; --i) {
                  var a = e[i]
                    , o = a(t, n, r);
                  if (!v(o) && !_e(o)) {
                      if (!ye(o))
                          throw TypeError();
                      r = o
                  }
              }
              return r
          }
          function ce(e, t, n) {
              var r = p.get(e);
              if (v(r)) {
                  if (!n)
                      return;
                  r = new d,
                  p.set(e, r)
              }
              var i = r.get(t);
              if (v(i)) {
                  if (!n)
                      return;
                  i = new d,
                  r.set(t, i)
              }
              return i
          }
          function le(e, t, n) {
              if (ue(e, t, n))
                  return !0;
              var r = Pe(t);
              return _e(r) ? !1 : le(e, r, n)
          }
          function ue(e, t, n) {
              var r = ce(t, n, !1);
              return v(r) ? !1 : Se(r.has(e))
          }
          function de(e, t, n) {
              if (ue(e, t, n))
                  return fe(e, t, n);
              var r = Pe(t);
              if (!_e(r))
                  return de(e, r, n)
          }
          function fe(e, t, n) {
              var r = ce(t, n, !1);
              if (!v(r))
                  return r.get(e)
          }
          function pe(e, t, n, r) {
              ce(n, r, !0).set(e, t)
          }
          function me(e, t) {
              var n = he(e, t)
                , r = Pe(e);
              if (r === null)
                  return n;
              var i = me(r, t);
              if (i.length <= 0)
                  return n;
              if (n.length <= 0)
                  return i;
              for (var a = new f, o = [], s = 0, c = n; s < c.length; s++) {
                  var l = c[s]
                    , u = a.has(l);
                  u || (a.add(l),
                  o.push(l))
              }
              for (var d = 0, p = i; d < p.length; d++) {
                  var l = p[d]
                    , u = a.has(l);
                  u || (a.add(l),
                  o.push(l))
              }
              return o
          }
          function he(e, t) {
              var n = []
                , r = ce(e, t, !1);
              if (v(r))
                  return n;
              for (var i = Ae(r.keys()), a = 0; ; ) {
                  var o = Me(i);
                  if (!o)
                      return n.length = a,
                      n;
                  var s = je(o);
                  try {
                      n[a] = s
                  } catch (e) {
                      try {
                          Ne(i)
                      } finally {
                          throw e
                      }
                  }
                  a++
              }
          }
          function ge(e) {
              if (e === null)
                  return 1;
              switch (typeof e) {
              case `undefined`:
                  return 0;
              case `boolean`:
                  return 2;
              case `string`:
                  return 3;
              case `symbol`:
                  return 4;
              case `number`:
                  return 5;
              case `object`:
                  return e === null ? 1 : 6;
              default:
                  return 6
              }
          }
          function v(e) {
              return e === void 0
          }
          function _e(e) {
              return e === null
          }
          function ve(e) {
              return typeof e == `symbol`
          }
          function ye(e) {
              return typeof e == `object` ? e !== null : typeof e == `function`
          }
          function be(e, t) {
              switch (ge(e)) {
              case 0:
                  return e;
              case 1:
                  return e;
              case 2:
                  return e;
              case 3:
                  return e;
              case 4:
                  return e;
              case 5:
                  return e
              }
              var n = t === 3 ? `string` : t === 5 ? `number` : `default`
                , i = ke(e, r);
              if (i !== void 0) {
                  var a = i.call(e, n);
                  if (ye(a))
                      throw TypeError();
                  return a
              }
              return xe(e, n === `default` ? `number` : n)
          }
          function xe(e, t) {
              if (t === `string`) {
                  var n = e.toString;
                  if (Ee(n)) {
                      var r = n.call(e);
                      if (!ye(r))
                          return r
                  }
                  var i = e.valueOf;
                  if (Ee(i)) {
                      var r = i.call(e);
                      if (!ye(r))
                          return r
                  }
              } else {
                  var i = e.valueOf;
                  if (Ee(i)) {
                      var r = i.call(e);
                      if (!ye(r))
                          return r
                  }
                  var a = e.toString;
                  if (Ee(a)) {
                      var r = a.call(e);
                      if (!ye(r))
                          return r
                  }
              }
              throw TypeError()
          }
          function Se(e) {
              return !!e
          }
          function Ce(e) {
              return `` + e
          }
          function we(e) {
              var t = be(e, 3);
              return ve(t) ? t : Ce(t)
          }
          function Te(e) {
              return Array.isArray ? Array.isArray(e) : e instanceof Object ? e instanceof Array : Object.prototype.toString.call(e) === `[object Array]`
          }
          function Ee(e) {
              return typeof e == `function`
          }
          function De(e) {
              return typeof e == `function`
          }
          function Oe(e) {
              switch (ge(e)) {
              case 3:
                  return !0;
              case 4:
                  return !0;
              default:
                  return !1
              }
          }
          function ke(e, t) {
              var n = e[t];
              if (n != null) {
                  if (!Ee(n))
                      throw TypeError();
                  return n
              }
          }
          function Ae(e) {
              var t = ke(e, i);
              if (!Ee(t))
                  throw TypeError();
              var n = t.call(e);
              if (!ye(n))
                  throw TypeError();
              return n
          }
          function je(e) {
              return e.value
          }
          function Me(e) {
              var t = e.next();
              return t.done ? !1 : t
          }
          function Ne(e) {
              var t = e.return;
              t && t.call(e)
          }
          function Pe(e) {
              var t = Object.getPrototypeOf(e);
              if (typeof e != `function` || e === l || t !== l)
                  return t;
              var n = e.prototype
                , r = n && Object.getPrototypeOf(n);
              if (r == null || r === Object.prototype)
                  return t;
              var i = r.constructor;
              return typeof i != `function` || i === e ? t : i
          }
          function Fe() {
              var e = {}
                , t = []
                , n = function() {
                  function e(e, t, n) {
                      this._index = 0,
                      this._keys = e,
                      this._values = t,
                      this._selector = n
                  }
                  return e.prototype[`@@iterator`] = function() {
                      return this
                  }
                  ,
                  e.prototype[i] = function() {
                      return this
                  }
                  ,
                  e.prototype.next = function() {
                      var e = this._index;
                      if (e >= 0 && e < this._keys.length) {
                          var n = this._selector(this._keys[e], this._values[e]);
                          return e + 1 >= this._keys.length ? (this._index = -1,
                          this._keys = t,
                          this._values = t) : this._index++,
                          {
                              value: n,
                              done: !1
                          }
                      }
                      return {
                          value: void 0,
                          done: !0
                      }
                  }
                  ,
                  e.prototype.throw = function(e) {
                      throw this._index >= 0 && (this._index = -1,
                      this._keys = t,
                      this._values = t),
                      e
                  }
                  ,
                  e.prototype.return = function(e) {
                      return this._index >= 0 && (this._index = -1,
                      this._keys = t,
                      this._values = t),
                      {
                          value: e,
                          done: !0
                      }
                  }
                  ,
                  e
              }();
              return function() {
                  function t() {
                      this._keys = [],
                      this._values = [],
                      this._cacheKey = e,
                      this._cacheIndex = -2
                  }
                  return Object.defineProperty(t.prototype, `size`, {
                      get: function() {
                          return this._keys.length
                      },
                      enumerable: !0,
                      configurable: !0
                  }),
                  t.prototype.has = function(e) {
                      return this._find(e, !1) >= 0
                  }
                  ,
                  t.prototype.get = function(e) {
                      var t = this._find(e, !1);
                      return t >= 0 ? this._values[t] : void 0
                  }
                  ,
                  t.prototype.set = function(e, t) {
                      var n = this._find(e, !0);
                      return this._values[n] = t,
                      this
                  }
                  ,
                  t.prototype.delete = function(t) {
                      var n = this._find(t, !1);
                      if (n >= 0) {
                          for (var r = this._keys.length, i = n + 1; i < r; i++)
                              this._keys[i - 1] = this._keys[i],
                              this._values[i - 1] = this._values[i];
                          return this._keys.length--,
                          this._values.length--,
                          t === this._cacheKey && (this._cacheKey = e,
                          this._cacheIndex = -2),
                          !0
                      }
                      return !1
                  }
                  ,
                  t.prototype.clear = function() {
                      this._keys.length = 0,
                      this._values.length = 0,
                      this._cacheKey = e,
                      this._cacheIndex = -2
                  }
                  ,
                  t.prototype.keys = function() {
                      return new n(this._keys,this._values,r)
                  }
                  ,
                  t.prototype.values = function() {
                      return new n(this._keys,this._values,a)
                  }
                  ,
                  t.prototype.entries = function() {
                      return new n(this._keys,this._values,o)
                  }
                  ,
                  t.prototype[`@@iterator`] = function() {
                      return this.entries()
                  }
                  ,
                  t.prototype[i] = function() {
                      return this.entries()
                  }
                  ,
                  t.prototype._find = function(e, t) {
                      return this._cacheKey !== e && (this._cacheIndex = this._keys.indexOf(this._cacheKey = e)),
                      this._cacheIndex < 0 && t && (this._cacheIndex = this._keys.length,
                      this._keys.push(e),
                      this._values.push(void 0)),
                      this._cacheIndex
                  }
                  ,
                  t
              }();
              function r(e, t) {
                  return e
              }
              function a(e, t) {
                  return t
              }
              function o(e, t) {
                  return [e, t]
              }
          }
          function Ie() {
              return function() {
                  function e() {
                      this._map = new d
                  }
                  return Object.defineProperty(e.prototype, `size`, {
                      get: function() {
                          return this._map.size
                      },
                      enumerable: !0,
                      configurable: !0
                  }),
                  e.prototype.has = function(e) {
                      return this._map.has(e)
                  }
                  ,
                  e.prototype.add = function(e) {
                      return this._map.set(e, e),
                      this
                  }
                  ,
                  e.prototype.delete = function(e) {
                      return this._map.delete(e)
                  }
                  ,
                  e.prototype.clear = function() {
                      this._map.clear()
                  }
                  ,
                  e.prototype.keys = function() {
                      return this._map.keys()
                  }
                  ,
                  e.prototype.values = function() {
                      return this._map.values()
                  }
                  ,
                  e.prototype.entries = function() {
                      return this._map.entries()
                  }
                  ,
                  e.prototype[`@@iterator`] = function() {
                      return this.keys()
                  }
                  ,
                  e.prototype[i] = function() {
                      return this.keys()
                  }
                  ,
                  e
              }()
          }
          function Le() {
              var e = 16
                , n = c.create()
                , r = i();
              return function() {
                  function e() {
                      this._key = i()
                  }
                  return e.prototype.has = function(e) {
                      var t = a(e, !1);
                      return t === void 0 ? !1 : c.has(t, this._key)
                  }
                  ,
                  e.prototype.get = function(e) {
                      var t = a(e, !1);
                      return t === void 0 ? void 0 : c.get(t, this._key)
                  }
                  ,
                  e.prototype.set = function(e, t) {
                      var n = a(e, !0);
                      return n[this._key] = t,
                      this
                  }
                  ,
                  e.prototype.delete = function(e) {
                      var t = a(e, !1);
                      return t === void 0 ? !1 : delete t[this._key]
                  }
                  ,
                  e.prototype.clear = function() {
                      this._key = i()
                  }
                  ,
                  e
              }();
              function i() {
                  var e;
                  do
                      e = `@@WeakMap@@` + l();
                  while (c.has(n, e));
                  return n[e] = !0,
                  e
              }
              function a(e, n) {
                  if (!t.call(e, r)) {
                      if (!n)
                          return;
                      Object.defineProperty(e, r, {
                          value: c.create()
                      })
                  }
                  return e[r]
              }
              function o(e, t) {
                  for (var n = 0; n < t; ++n)
                      e[n] = Math.random() * 255 | 0;
                  return e
              }
              function s(e) {
                  return typeof Uint8Array == `function` ? typeof crypto < `u` ? crypto.getRandomValues(new Uint8Array(e)) : typeof msCrypto < `u` ? msCrypto.getRandomValues(new Uint8Array(e)) : o(new Uint8Array(e), e) : o(Array(e), e)
              }
              function l() {
                  var t = s(e);
                  t[6] = t[6] & 79 | 64,
                  t[8] = t[8] & 191 | 128;
                  for (var n = ``, r = 0; r < e; ++r) {
                      var i = t[r];
                      (r === 4 || r === 6 || r === 8) && (n += `-`),
                      i < 16 && (n += `0`),
                      n += i.toString(16).toLowerCase()
                  }
                  return n
              }
          }
          function Re(e) {
              return e.__ = void 0,
              delete e.__,
              e
          }
      })
  }
  )(Pue ||= {})
}
));
function Rq(e) {
  return typeof e != `object` || Array.isArray(e) || e === null ? !1 : Object.keys(e).length === 0
}
var zq = t(( () => {}
));
function Iue(e) {
  return typeof e == `string` && Bq.hasOwnProperty(e)
}
var Bq, Vq, Hq = t(( () => {
  Bu(),
  Bq = {
      all: `all`,
      created: `created`,
      following: `following`,
      popular: `popular`
  },
  Vq = {
      [Bq.all]: `Recent`,
      [Bq.created]: `Created`,
      [Bq.following]: `For me`,
      [Bq.popular]: `Popular`
  },
  Bq.all,
  k.feedAll,
  Bq.created,
  k.feedCreated,
  Bq.following,
  k.feedFollowing,
  Bq.popular,
  k.feedPopular
}
)), Uq, Lue, Wq, Gq, Kq, qq, Jq, Yq, Xq, Rue = t(( () => {
  Uq = {
      aws: {
          hipaaCompliant: !0
      },
      openai: {
          hipaaCompliant: !0
      },
      google: {
          hipaaCompliant: !0
      },
      "google-preview": {
          hipaaCompliant: !0
      },
      vertex: {
          hipaaCompliant: !0
      },
      anthropic: {
          hipaaCompliant: !1
      },
      cohere: {
          hipaaCompliant: !1
      }
  },
  (function(e) {
      function t(e) {
          return n().includes(e)
      }
      e.isValid = t;
      function n() {
          return [`openai`, `anthropic`, `google`, `google-preview`, `vertex`, `cohere`, `aws`]
      }
      e.allProviders = n;
      function r() {
          return [`openai`, `anthropic`, `google`, `google-preview`, `vertex`]
      }
      e.allModelProviders = r;
      function i(e) {
          return Uq[e]?.hipaaCompliant ?? !1
      }
      e.isHipaaCompliant = i
  }
  )(Lue ||= {}),
  Wq = function(e) {
      return e.ClaudeHaiku45 = `claude-haiku-4-5`,
      e.ClaudeSonnet45 = `claude-sonnet-4-5`,
      e.Gemini20Flash = `gemini-2.0-flash`,
      e.Gemini20FlashLite = `gemini-2.0-flash-lite`,
      e.Gemini20Flash_001 = `gemini-2.0-flash-001`,
      e.Gemini25Flash = `gemini-2.5-flash`,
      e.Gemini25Pro = `gemini-2.5-pro`,
      e.Gemini3ProPreview = `gemini-3-pro-preview`,
      e.Gpt41 = `gpt-4.1`,
      e.Gpt41Mini = `gpt-4.1-mini`,
      e.Gpt41Nano = `gpt-4.1-nano`,
      e.Gpt4oMini = `gpt-4o-mini`,
      e.Gpt4oMini_2024_07_18 = `gpt-4o-mini-2024-07-18`,
      e.Gpt4o_2024_11_20 = `gpt-4o-2024-11-20`,
      e.Gpt5 = `gpt-5`,
      e.Gpt51 = `gpt-5.1`,
      e.Gpt5Mini = `gpt-5-mini`,
      e.Gpt5Nano = `gpt-5-nano`,
      e.VertexGptOss20b = `openai/gpt-oss-20b-maas`,
      e.VertexGptOss120b = `openai/gpt-oss-120b-maas`,
      e.VertexQwen3Next80BA3BThinking = `qwen/qwen3-next-80b-a3b-thinking-maas`,
      e.VertexQwen3Next80BA3BInstruct = `qwen/qwen3-next-80b-a3b-instruct-maas`,
      e
  }({}),
  Gq = Wq.Gpt4oMini,
  Kq = e => e / 1e6,
  qq = {
      image: [`image/jpeg`, `image/png`, `image/webp`]
  },
  Jq = {
      image: [`image/jpeg`, `image/png`, `image/webp`]
  },
  Yq = {
      image: [`image/jpeg`, `image/png`, `image/webp`, `image/heic`, `image/heif`],
      video: [`video/x-flv`, `video/quicktime`, `video/mpeg`, `video/mpegs`, `video/mpg`, `video/mp4`, `video/webm`, `video/wmv`, `video/3gpp`],
      audio: [`audio/x-aac`, `audio/flac`, `audio/mp3`, `audio/m4a`, `audio/mpeg`, `audio/mpga`, `audio/mp4`, `audio/ogg`, `audio/pcm`, `audio/wav`, `audio/webm`]
  },
  Xq = {
      [Wq.ClaudeHaiku45]: {
          provider: `anthropic`,
          supportsMediaTypes: Jq,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * 1 + t * 5 + n * .1)
      },
      [Wq.ClaudeSonnet45]: {
          provider: `anthropic`,
          supportsMediaTypes: Jq,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e <= 2e5 ? e * 3 + t * 15 + n * .3 : e * 6 + t * 22.5 + n * .6)
      },
      [Wq.Gemini20Flash]: {
          provider: `google`,
          supportsMediaTypes: Yq,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * .1 + t * .4 + n * .025)
      },
      [Wq.Gemini20FlashLite]: {
          provider: `google`,
          supportsMediaTypes: Yq,
          cost: ({input: e, output: t}) => Kq(e * .075 + t * .3)
      },
      [Wq.Gemini20Flash_001]: {
          provider: `google`,
          supportsMediaTypes: Yq,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * .3 + t * 2.5 + n * .03)
      },
      [Wq.Gemini25Flash]: {
          provider: `google`,
          supportsMediaTypes: Yq,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * .3 + t * 2.5 + n * .03)
      },
      [Wq.Gemini25Pro]: {
          provider: `google`,
          supportsMediaTypes: Yq,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e <= 2e5 ? e * 1.25 + t * 10 + n * .125 : e * 2.5 + t * 15 + n * .25)
      },
      [Wq.Gemini3ProPreview]: {
          provider: `google-preview`,
          supportsMediaTypes: Yq,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e <= 2e5 ? e * 2 + t * 12 + n * .2 : e * 4 + t * 24 + n * .4)
      },
      [Wq.Gpt4oMini]: {
          provider: `openai`,
          supportsMediaTypes: qq,
          supportsTemperature: !0,
          supportsEncryptedReasoningContent: !1,
          supportsPromptCacheRetention: !1,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * .15 + t * .6 + n * .075)
      },
      [Wq.Gpt4oMini_2024_07_18]: {
          provider: `openai`,
          supportsMediaTypes: qq,
          supportsTemperature: !0,
          supportsEncryptedReasoningContent: !1,
          supportsPromptCacheRetention: !1,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * .15 + t * .6 + n * .075)
      },
      [Wq.Gpt4o_2024_11_20]: {
          provider: `openai`,
          supportsMediaTypes: qq,
          supportsTemperature: !0,
          supportsEncryptedReasoningContent: !1,
          supportsPromptCacheRetention: !1,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * 2.5 + t * 10 + n * 1.25)
      },
      [Wq.Gpt41]: {
          provider: `openai`,
          supportsMediaTypes: qq,
          supportsTemperature: !0,
          supportsEncryptedReasoningContent: !1,
          supportsPromptCacheRetention: !1,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * 2 + t * 8 + n * .5)
      },
      [Wq.Gpt41Mini]: {
          provider: `openai`,
          supportsMediaTypes: qq,
          supportsTemperature: !0,
          supportsEncryptedReasoningContent: !1,
          supportsPromptCacheRetention: !1,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * .4 + t * 1.6 + n * .1)
      },
      [Wq.Gpt41Nano]: {
          provider: `openai`,
          supportsMediaTypes: qq,
          supportsTemperature: !0,
          supportsEncryptedReasoningContent: !1,
          supportsPromptCacheRetention: !1,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * .1 + t * .4 + n * .025)
      },
      [Wq.Gpt5]: {
          provider: `openai`,
          supportsMediaTypes: qq,
          supportsTemperature: !1,
          supportsEncryptedReasoningContent: !0,
          supportsPromptCacheRetention: !0,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * 1.25 + t * 10 + n * .125)
      },
      [Wq.Gpt5Mini]: {
          provider: `openai`,
          supportsMediaTypes: qq,
          supportsTemperature: !1,
          supportsEncryptedReasoningContent: !0,
          supportsPromptCacheRetention: !1,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * .25 + t * 2 + n * .025)
      },
      [Wq.Gpt5Nano]: {
          provider: `openai`,
          supportsMediaTypes: qq,
          supportsTemperature: !1,
          supportsEncryptedReasoningContent: !0,
          supportsPromptCacheRetention: !1,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * .05 + t * .4 + n * .005)
      },
      [Wq.Gpt51]: {
          provider: `openai`,
          supportsMediaTypes: qq,
          supportsTemperature: !1,
          supportsEncryptedReasoningContent: !0,
          supportsPromptCacheRetention: !0,
          cost: ({input: e, output: t, cachedInput: n=0}) => Kq(e * 1.25 + t * 10 + n * .125)
      },
      [Wq.VertexGptOss20b]: {
          provider: `vertex`,
          cost: ({input: e, output: t}) => Kq(e * .07 + t * .25)
      },
      [Wq.VertexGptOss120b]: {
          provider: `vertex`,
          cost: ({input: e, output: t}) => Kq(e * .09 + t * .36)
      },
      [Wq.VertexQwen3Next80BA3BThinking]: {
          provider: `vertex`,
          cost: ({input: e, output: t}) => Kq(e * .15 + t * 1.2)
      },
      [Wq.VertexQwen3Next80BA3BInstruct]: {
          provider: `vertex`,
          cost: ({input: e, output: t}) => Kq(e * .15 + t * 1.2)
      }
  },
  (function(e) {
      e.defaultModel = Gq;
      function t(e) {
          if (Object.values(Wq).includes(e))
              return e
      }
      e.parse = t;
      function n(e) {
          return Xq[e].provider
      }
      e.provider = n;
      function r(e) {
          return Xq[e]
      }
      e.modelInfo = r;
      function i(e, t) {
          return t.startsWith(`image/`) && Xq[e].supportsMediaTypes?.image?.includes(t) ? {
              supported: !0,
              type: `image`
          } : t.startsWith(`video/`) && Xq[e].supportsMediaTypes?.video?.includes(t) ? {
              supported: !0,
              type: `video`
          } : t.startsWith(`audio/`) && Xq[e].supportsMediaTypes?.audio?.includes(t) ? {
              supported: !0,
              type: `audio`
          } : {
              supported: !1
          }
      }
      e.checkMediaSupport = i;
      function a(e, t) {
          let n = Xq[e].cost;
          return typeof n == `function` ? n(t) : n.input * t.input + n.output * t.output
      }
      e.estimateGenerationCost = a
  }
  )(Wq ||= {})
}
));
function zue(e) {
  return typeof e == `string` && Zq.hasOwnProperty(e)
}
var Zq, Qq, $q, eJ = t(( () => {
  Bu(),
  Zq = {
      assigned: `assigned`,
      created: `created`,
      subscribed: `subscribed`,
      activity: `activity`
  },
  Qq = {
      [Zq.assigned]: `Assigned`,
      [Zq.created]: `Created`,
      [Zq.subscribed]: `Subscribed`,
      [Zq.activity]: `Activity`
  },
  $q = {
      [Zq.assigned]: k.myIssues,
      [Zq.created]: k.myIssuesCreatedByMe,
      [Zq.subscribed]: k.myIssuesSubscribedTo,
      [Zq.activity]: k.myIssuesActivity
  }
}
)), tJ, nJ, rJ = t(( () => {
  nt(),
  tJ = class {
      static firstDayOfWeekByBrowserLocale() {
          let e = navigator.languages?.length ? navigator.languages[0] : navigator.language
            , t = nJ[e.substring(0, 2) + (e.length === 5 ? e.substring(3, 5) : ``)];
          return Me(new Date, {
              weekStartsOn: t
          }).getDay()
      }
  }
  ,
  nJ = {
      arMA: 1,
      az: 1,
      be: 1,
      bg: 1,
      bs: 1,
      ca: 1,
      cs: 1,
      da: 1,
      de: 1,
      deAT: 1,
      el: 1,
      enAU: 1,
      enGB: 1,
      enIN: 1,
      enNZ: 1,
      eo: 1,
      es: 1,
      et: 1,
      eu: 1,
      faIR: 6,
      fi: 1,
      fr: 1,
      frCH: 1,
      gl: 1,
      gu: 1,
      hr: 1,
      ht: 1,
      hu: 1,
      hy: 1,
      id: 1,
      is: 1,
      it: 1,
      ka: 1,
      kk: 1,
      kn: 1,
      lb: 1,
      lt: 1,
      lv: 1,
      mk: 1,
      mn: 1,
      ms: 1,
      mt: 1,
      nb: 1,
      nl: 1,
      nlBE: 1,
      nn: 1,
      pl: 1,
      pt: 1,
      ro: 1,
      ru: 1,
      sk: 1,
      sl: 1,
      sq: 1,
      sr: 1,
      srLatn: 1,
      sv: 1,
      ta: 1,
      tr: 1,
      uk: 1,
      uz: 1,
      vi: 1,
      zhCN: 1,
      zhTW: 1
  }
}
)), iJ, aJ = t(( () => {
  iJ = function(e) {
      return e.overview = `overview`,
      e.insights = `insights`,
      e
  }({})
}
)), oJ, sJ, cJ = t(( () => {
  ni(),
  oJ = `splashScreenConfig`,
  sJ = class {
      static update(e) {
          Object.assign(this.config, e),
          ei.set(oJ, this.config),
          ei.setSession(oJ, this.config)
      }
      static get config() {
          return this.configObject ||= ei.get(oJ) || {},
          this.configObject
      }
  }
}
));
function lJ(e, t) {
  return Ut`
  mutation UserFlagUpdate {
    userFlagUpdate(flag: ${e}, operation: ${t}) {
      flag
      value
      success
    }
  }
`
}
function Bue(e) {
  return Ut`
  mutation UserSettingsFlagsReset {
    userSettingsFlagsReset${e ? `(flags: [${e.join(`, `)}])` : ``} {
      success
    }
  }
`
}
async function Vue(e, t) {
  if (!uJ(e, t))
      return e.updateFlag(t)
}
function uJ(e, t) {
  return e.getFlag(t) >= hu[t]
}
var dJ = t(( () => {
  Wt(),
  _u()
}
)), fJ, pJ, mJ, hJ = t(( () => {
  zn(),
  fJ = function(e) {
      return e.system = `system`,
      e.light = `light`,
      e.pureLight = `pureLight`,
      e.dark = `dark`,
      e.magicBlue = `magicBlue`,
      e.classicDark = `classicDark`,
      e.ash = `ash`,
      e.dawn = `dawn`,
      e.midnight = `midnight`,
      e.pale = `pale`,
      e.custom = `custom`,
      e
  }({}),
  pJ = () => Object.keys(fJ).filter(e => ![fJ.ash, fJ.dawn, fJ.midnight, fJ.pale].includes(e)),
  mJ = e => {
      switch (e) {
      case fJ.system:
          return `System preference`;
      case fJ.light:
          return `Light`;
      case fJ.dark:
          return `Dark`;
      case fJ.magicBlue:
          return `Magic Blue`;
      case fJ.pureLight:
          return `Pure Light`;
      case fJ.classicDark:
          return `Classic Dark`;
      case fJ.ash:
          return `Ash`;
      case fJ.dawn:
          return `Dawn`;
      case fJ.midnight:
          return `Midnight`;
      case fJ.pale:
          return `Pale`;
      case fJ.custom:
          return `Custom`;
      default:
          throw new Rn(e)
      }
  }
}
)), gJ, _J, vJ, yJ = t(( () => {
  zn(),
  gJ = function(e) {
      return e.smaller = `smaller`,
      e.small = `small`,
      e.default = `default`,
      e.large = `large`,
      e.larger = `larger`,
      e
  }({}),
  _J = e => {
      switch (e) {
      case gJ.smaller:
          return `Smaller`;
      case gJ.small:
          return `Small`;
      case gJ.default:
          return `Default`;
      case gJ.large:
          return `Large`;
      case gJ.larger:
          return `Larger`;
      default:
          throw new Rn(e)
      }
  }
  ,
  vJ = e => {
      switch (e) {
      case gJ.smaller:
          return 14;
      case gJ.small:
          return 15;
      case gJ.default:
          return 16;
      case gJ.large:
          return 18;
      case gJ.larger:
          return 20;
      default:
          throw new Rn(e)
      }
  }
}
)), bJ, Hue = t(( () => {
  bJ = class {
      constructor(e, t) {
          this.maxSize = e,
          this.values = t
      }
      push(e) {
          this.values.length >= this.maxSize && this.values.shift(),
          this.values.push(e)
      }
      remove(e) {
          this.values = this.values.filter(t => t !== e)
      }
      includes(e) {
          return this.values.includes(e)
      }
      toJSON() {
          return [...this.values]
      }
  }
}
)), xJ, SJ, CJ, wJ, TJ, Uue = t(( () => {
  Hue(),
  xJ = 1500,
  SJ = {
      serialize: e => JSON.stringify(e.toJSON()),
      deserialize: e => {
          let t = JSON.parse(e);
          return Array.isArray(t) && t.length > 0 ? new CJ(t) : new CJ([])
      }
  },
  CJ = class e {
      static #e = this.DefaultEmptyState = SJ.serialize(new e([]));
      static #t = this.Serializer = SJ;
      constructor(e) {
          this.maxSizeArray = new bJ(xJ,e)
      }
      isOpen(e) {
          return !this.maxSizeArray.includes(e)
      }
      update(t, n) {
          let r = Array.isArray(t) ? t : [t];
          for (let e of r)
              n === `open` ? this.maxSizeArray.remove(e) : n === `closed` && !this.maxSizeArray.includes(e) && this.maxSizeArray.push(e);
          return new e(this.maxSizeArray.toJSON())
      }
      toJSON() {
          return this.maxSizeArray.toJSON()
      }
  }
  ,
  wJ = {
      serialize: e => JSON.stringify(e.toJSON()),
      deserialize: e => {
          let t = JSON.parse(e);
          return Array.isArray(t) && t.length > 0 ? new TJ(t) : new TJ([])
      }
  },
  TJ = class e extends CJ {
      static #e = this.DefaultEmptyState = wJ.serialize(new e([]));
      static #t = this.Serializer = wJ;
      isOpen(e) {
          return this.maxSizeArray.includes(e)
      }
      update(t, n) {
          let r = Array.isArray(t) ? t : [t];
          for (let e of r)
              n === `open` && !this.maxSizeArray.includes(e) ? this.maxSizeArray.push(e) : n === `closed` && this.maxSizeArray.remove(e);
          return new e(this.maxSizeArray.toJSON())
      }
      get expandedIds() {
          return new Set(this.maxSizeArray.toJSON())
      }
  }
}
)), EJ, DJ, OJ, kJ, AJ, jJ, MJ, NJ, PJ, FJ = t(( () => {
  ed(),
  EJ = function(e) {
      return e.BadgeCount = `BadgeCount`,
      e.Badge = `Badge`,
      e.None = `None`,
      e
  }({}),
  DJ = {
      [EJ.BadgeCount]: `Count`,
      [EJ.Badge]: `Dot`,
      [EJ.None]: `None`
  },
  OJ = function(e) {
      return e.Always = `Always`,
      e.WithNotifications = `WithNotifications`,
      e.MoreMenu = `MoreMenu`,
      e.Never = `Never`,
      e
  }({}),
  kJ = {
      [OJ.Always]: `Always show`,
      [OJ.WithNotifications]: `When badged`,
      [OJ.MoreMenu]: `Hide in more menu`,
      [OJ.Never]: `Never show`
  },
  AJ = {
      [OJ.Always]: 0,
      [OJ.WithNotifications]: 0,
      [OJ.MoreMenu]: 1,
      [OJ.Never]: 2
  },
  jJ = function(e) {
      return e.inbox = `inbox`,
      e.reviews = `reviews`,
      e.agents = `agents`,
      e.myIssues = `myIssues`,
      e.pulse = `pulse`,
      e.drafts = `drafts`,
      e.initiatives = `initiatives`,
      e.projects = `projects`,
      e.views = `views`,
      e.teams = `teams`,
      e.customers = `customers`,
      e.members = `members`,
      e.more_workspace = `more_workspace`,
      e
  }({}),
  MJ = {
      ...Object.values(jJ).reduce( (e, t) => ({
          ...e,
          [t]: OJ.Always
      }), {}),
      [jJ.drafts]: OJ.WithNotifications,
      [jJ.agents]: OJ.Always,
      [jJ.customers]: OJ.MoreMenu,
      [jJ.teams]: OJ.MoreMenu,
      [jJ.members]: OJ.MoreMenu
  },
  EJ.None,
  EJ.BadgeCount,
  EJ.Badge,
  NJ = [jJ.members, jJ.customers, jJ.initiatives, jJ.projects, jJ.teams, jJ.views],
  PJ = Qu(jJ).filter(e => e !== jJ.more_workspace && !NJ.includes(e))
}
));
function X(e, t, n) {
  return (r, i) => {
      let {serializer: a, clearOnLogout: o, onUpdate: s} = n || {};
      WJ[i] = Bt,
      o && GJ.push(i);
      function c(e, t) {
          if (t === Z.server) {
              let t = (0,
              IJ.default)(this.settings);
              this.settings[i] = e && a ? a.serialize(e) : e,
              this.markPropertyChanged(`settings`, t),
              this.store.isBootstrapped && this.save()
          } else if (t === Z.browser)
              try {
                  let t = e && a ? a.serialize(e) : e;
                  this.browserPersistedSettings[i] = t,
                  ei.set(BJ, this.browserPersistedSettings),
                  this.broadcastChannel != null && this.broadcastChannel.postMessage({
                      type: `setValue`,
                      key: i,
                      value: Lt(t)
                  })
              } catch (e) {
                  w.error(`Error persisting browser user settings`, e),
                  ei.remove(BJ)
              }
          else if (t === Z.browserSession)
              try {
                  let t = e && a ? a.serialize(e) : e;
                  this.browserSessionPersistedSettings[i] = t,
                  ei.setSession(BJ, this.browserSessionPersistedSettings);
                  let n = ei.get(VJ) ?? {};
                  n[i] = t,
                  ei.set(VJ, n)
              } catch (e) {
                  w.error(`Error persisting browserSession user settings`, e),
                  ei.removeSession(BJ),
                  ei.remove(VJ)
              }
          else
              t === Z.ephemeral ? this.ephemeralSettings[i] = e && a ? a.serialize(e) : e : y(t);
          s?.(this, e)
      }
      Object.defineProperty(r, i, {
          get: function() {
              let n, r = this, o = r.getStorageForPersistence(t);
              if (o[i] !== void 0 && (n = o[i]),
              n === void 0 || Rq(n)) {
                  let e = UJ.filter(e => e !== t);
                  for (let a of e)
                      if (n = r.getStorageForPersistence(a)[i],
                      n !== void 0 && !Rq(n)) {
                          c.apply(r, [n, t]),
                          c.apply(r, [void 0, a]);
                          break
                      }
              }
              return n ??= typeof e == `function` ? e.call(null, r) : e,
              n && a ? a.deserialize(n) : n
          },
          set: function(e) {
              c.apply(this, [e, t])
          },
          enumerable: !0,
          configurable: !1
      })
  }
}
var IJ, LJ, RJ, zJ, BJ, VJ, HJ, Z, UJ, WJ, GJ, Q, KJ, qJ = t(( () => {
  zt(),
  Fue(),
  IJ = e(nn(), 1),
  LJ = e(g(), 1),
  RJ = e(l(), 1),
  _u(),
  ap(),
  ir(),
  zn(),
  zq(),
  fw(),
  mw(),
  Yr(),
  Sl(),
  Hq(),
  Rue(),
  Ow(),
  eJ(),
  Xn(),
  lo(),
  ws(),
  Pz(),
  iz(),
  mH(),
  GU(),
  V(),
  F(),
  Ih(),
  ni(),
  rJ(),
  aJ(),
  Yk(),
  cJ(),
  dJ(),
  hJ(),
  JM(),
  yJ(),
  Uue(),
  DM(),
  FJ(),
  N(),
  zJ = rr.isPureTouchDevice && rr.isMobileSize,
  BJ = `userSettings`,
  VJ = `defaultUserSettings`,
  HJ = !zJ,
  Z = function(e) {
      return e[e.server = 0] = `server`,
      e[e.browser = 1] = `browser`,
      e[e.browserSession = 2] = `browserSession`,
      e[e.ephemeral = 3] = `ephemeral`,
      e
  }(Z || {}),
  UJ = [Z.server, Z.browser, Z.browserSession, Z.ephemeral],
  WJ = {},
  GJ = [],
  Q = class extends qh {
      static get openLinksInDesktop() {
          return ei.get(BJ)?.openLinksInDesktop
      }
      get theme() {
          return zJ ? this.themeMobileWeb : this.themeDesktop
      }
      get themeSystemLight() {
          return zJ ? this.themeMobileWebLight : this.themeDesktopLight
      }
      get themeSystemDark() {
          return zJ ? this.themeMobileWebDark : this.themeDesktopDark
      }
      set theme(e) {
          zJ ? this.themeMobileWeb = e : this.themeDesktop = e
      }
      set themeSystemLight(e) {
          zJ ? this.themeMobileWebLight = e : this.themeDesktopLight = e
      }
      set themeSystemDark(e) {
          zJ ? this.themeMobileWebDark = e : this.themeDesktopDark = e
      }
      get currentlySelectedCustomTheme() {
          return this.customThemes?.[0]
      }
      setCurrentCustomTheme(e) {
          e ? this.customThemes = [e] : this.customThemes = []
      }
      constructor() {
          super(),
          this.toggleNotificationBadge = () => {
              this.user.settings.notificationBadge = !this.user.settings.notificationBadge
          }
          ,
          this.toggleDebugActiveElement = () => {
              this.debugActiveElement = !this.debugActiveElement
          }
          ,
          this.toggleDebugBreadcrumbs = () => {
              this.debugBreadcrumbs = !this.debugBreadcrumbs
          }
          ,
          this.toggleDebugTooltips = () => {
              this.debugTooltips = !this.debugTooltips
          }
          ,
          this.toggleDebugAnalytics = () => (this.debugAnalytics = !this.debugAnalytics,
          this.debugAnalytics),
          this.toggleDebugActionManager = () => {
              this.debugActionManager = !this.debugActionManager
          }
          ,
          this.toggleDebugPositionLabels = () => {
              this.debugPositionLabels = !this.debugPositionLabels
          }
          ,
          this.toggleDebugProvider = () => {
              this.debugProvider = !this.debugProvider
          }
          ,
          this.toggleDebugSearchScore = () => {
              this.debugSearchScore = !this.debugSearchScore
          }
          ,
          this.toggleDebugActionsScore = () => {
              this.debugActionsScore = !this.debugActionsScore
          }
          ,
          this.toggleDebugSimilarIssuesScore = () => {
              this.debugSimilarIssuesScore = !this.debugSimilarIssuesScore
          }
          ,
          this.toggleDebugShowSimilarIssues = () => {
              this.debugShowSimilarIssues = !this.debugShowSimilarIssues
          }
          ,
          this.toggleDebugApplicationStore = () => {
              this.debugApplicationStore = !this.debugApplicationStore
          }
          ,
          this.toggleDebugNavigation = () => {
              this.debugNavigation = !this.debugNavigation
          }
          ,
          this.toggleDebugHydration = () => {
              this.debugHydration = !this.debugHydration
          }
          ,
          this.recordFlag = async (e, t=!0) => {
              let n = this.flags[e];
              if (t || n === void 0) {
                  if (!this.store) {
                      w.warning(`UserSettings.recordFlag called with no store`, {
                          flag: e,
                          increment: t,
                          existingValue: n
                      });
                      return
                  }
                  let r = await this.store.graphQLClient.mutate(lJ(e, gu.incr))
                    , i = r.userFlagUpdate;
                  return Mt( () => {
                      i.success && i.flag && i.value && (this.flags[i.flag] = i.value)
                  }
                  ),
                  r.userFlagUpdate.value
              }
          }
          ,
          this.updateFlag = async (e, t=gu.incr) => {
              if (this.store) {
                  let n = await this.store.graphQLClient.mutate(lJ(e, t))
                    , r = n.userFlagUpdate;
                  return Mt( () => {
                      r.success && r.flag && r.value && (this.flags[r.flag] = r.value)
                  }
                  ),
                  n.userFlagUpdate.value
              }
          }
          ,
          this.getFlagsForDebugging = () => this.flags,
          this.stopFlag = async (e, t=!0) => {
              let n = this.flags[e];
              if (this.store && (t || n === void 0)) {
                  let t = await this.store.graphQLClient.mutate(lJ(e, gu.lock))
                    , n = t.userFlagUpdate;
                  return Mt( () => {
                      n.success && n.flag && n.value && (this.flags[n.flag] = n.value)
                  }
                  ),
                  t.userFlagUpdate.value
              }
          }
          ,
          this.resetFlags = async e => {
              if (this.store) {
                  let t = await this.store.graphQLClient.mutate(Bue(e));
                  return t.userSettingsFlagsReset.success && Mt( () => {
                      if (e)
                          for (let t of e)
                              this.flags[t] = void 0;
                      else
                          this.flags = {}
                  }
                  ),
                  t.userSettingsFlagsReset.success
              }
              return !1
          }
          ,
          this.getFlag = e => this.flags[e] || 0,
          this.getNotificationCategoryPreference = (e, t) => ep.getNotificationCategoryPreference(t, e, this.notificationCategoryPreferences),
          this.setNotificationCategoryPreference = (e, t, n) => {
              let r = ep.setNotificationCategoryPreference(e, t, n, this.notificationCategoryPreferences);
              r && (this.notificationCategoryPreferences = r,
              this.save())
          }
          ,
          this.getCategoryValuesForChannel = e => {
              let t = new Map;
              return Object.values(D).forEach(n => {
                  n !== D.system && t.set(n, this.getNotificationCategoryPreference(e, n))
              }
              ),
              t
          }
          ,
          this.getChannelPreferences = () => ({
              [$f.desktop]: ep.getNotificationChannelPreference($f.desktop, this.notificationChannelPreferences),
              [$f.email]: ep.getNotificationChannelPreference($f.email, this.notificationChannelPreferences),
              [$f.slack]: ep.getNotificationChannelPreference($f.slack, this.notificationChannelPreferences),
              [$f.mobile]: ep.getNotificationChannelPreference($f.mobile, this.notificationChannelPreferences)
          }),
          this.setChannelPreference = (e, t) => {
              let n = (0,
              IJ.default)(this.getChannelPreferences());
              n[e] = t,
              this.notificationChannelPreferences = n,
              this.save()
          }
          ,
          this.getNotificationDeliveryPreferenceSchedule = e => this.notificationDeliveryPreferences[e]?.schedule,
          this.setNotificationDeliveryPreferenceSchedule = (e, t) => {
              let n = (0,
              IJ.default)(this.notificationDeliveryPreferences);
              return n[e] === void 0 ? n[e] = {
                  schedule: t
              } : n[e] = {
                  ...n[e],
                  schedule: t
              },
              this.notificationDeliveryPreferences = n,
              this.save()
          }
          ,
          this.subscribeNotificationChannel = e => {
              let t = (0,
              IJ.default)(this.notificationCategoryPreferences)
                , n = Object.values(D);
              for (let r = 0; r < n.length; r++) {
                  let i = n[r];
                  i !== D.system && (0,
                  LJ.default)(t, `${i}.${e}`, !0)
              }
              this.notificationCategoryPreferences = (0,
              RJ.default)(t, D.system),
              this.save()
          }
          ,
          this.getUsageWarningHistory = () => this.usageWarningHistory,
          this.setUsageWarningHistoryEntry = ({type: e, entityId: t, channel: n, level: r}) => {
              let i = (0,
              IJ.default)(this.usageWarningHistory)
                , a = i[e] || []
                , o = a.find(e => e.entityId === t);
              !o && r ? (o = {
                  entityId: t,
                  warningsShown: {
                      [n]: {
                          level: r,
                          updatedAt: new Date().toISOString()
                      }
                  }
              },
              a.push(o)) : o && !r ? delete o.warningsShown[n] : o && r && (o.warningsShown[n] = {
                  level: r,
                  updatedAt: new Date().toISOString()
              }),
              i[e] = a,
              Mt( () => {
                  this.usageWarningHistory = i,
                  this.save()
              }
              )
          }
          ,
          this.resetUserSettings = () => {
              this.settings = {},
              this.browserPersistedSettings = {},
              this.browserSessionPersistedSettings = {},
              this.ephemeralSettings = {},
              this.save()
          }
          ,
          this.ephemeralSettings = {},
          this.browserPersistedSettings = {},
          this.browserSessionPersistedSettings = {};
          let e = ei.get(BJ);
          e && (this.browserPersistedSettings = e);
          let t = ei.getSession(BJ);
          if (t)
              this.browserSessionPersistedSettings = t;
          else {
              let e = ei.get(VJ);
              e && (this.browserSessionPersistedSettings = e)
          }
          !co.isElectron && typeof BroadcastChannel == `function` && (this.broadcastChannel = new BroadcastChannel(KJ),
          this.broadcastChannel.addEventListener(`message`, e => {
              let t = e.data;
              switch (t.type) {
              case `setValue`:
                  Mt( () => {
                      this.browserPersistedSettings[t.key] = t.value
                  }
                  );
                  break;
              default:
                  w.error(`Invalid message type for UserSettings broadcast`, void 0, {
                      type: t.type
                  }),
                  y(t.type);
                  break
              }
          }
          )),
          At(this, {
              ephemeralSettings: Vt,
              browserPersistedSettings: Vt,
              browserSessionPersistedSettings: Vt,
              setActiveTeam: Ft,
              toggleNotificationBadge: Ft,
              toggleDebugActionManager: Ft,
              toggleDebugPositionLabels: Ft,
              toggleDebugAnalytics: Ft,
              toggleDebugApplicationStore: Ft,
              setOpenContainers: Ft,
              getOpenContainer: Ft,
              setCurrentCustomTheme: Ft,
              updateProjectInfo: Ft.bound,
              updateProjectInfoMilestone: Ft.bound,
              updateInitiativeInfo: Ft.bound,
              updateTeamInfo: Ft.bound,
              updateResourceListPreferences: Ft.bound,
              updateInitiativeUpdatesListPreferences: Ft.bound,
              updateTeamUpdatesListPreferences: Ft.bound,
              ...WJ
          })
      }
      clearAll() {
          let e = ei.get(VJ) ?? {};
          GJ.forEach(t => {
              this.browserPersistedSettings[t] = void 0,
              this.browserSessionPersistedSettings[t] = void 0,
              e[t] = void 0
          }
          ),
          ei.set(BJ, this.browserPersistedSettings),
          ei.setSession(BJ, this.browserSessionPersistedSettings),
          ei.set(VJ, e)
      }
      get activeTeam() {
          let e = this.store;
          return this.activeTeamId && e.findById(K, this.activeTeamId) || (this.user.teams.length > 0 ? this.user.teams.elements[0] : !1) || this.user.organization.accessibleTeams.elements[0]
      }
      get firstDayOfWeekAsNumber() {
          switch (this.firstDayOfWeek) {
          case Lr.sunday:
              return 0;
          case Lr.monday:
              return 1;
          case Lr.tuesday:
              return 2;
          case Lr.wednesday:
              return 3;
          case Lr.thursday:
              return 4;
          case Lr.friday:
              return 5;
          case Lr.saturday:
              return 6;
          default:
              throw new Rn(this.firstDayOfWeek)
          }
      }
      setActiveTeam(e) {
          e && e.private && !e.userIsMember(this.user) || (this.activeTeamId = e?.id)
      }
      getOpenContainer(e, t) {
          let n = this.openContainers[e];
          return n ? (n.accessed = Date.now(),
          n.value) : t
      }
      setOpenContainer(e, t) {
          this.setOpenContainers([e], t)
      }
      setOpenContainers(e, t) {
          let n = !1
            , r = {};
          for (let i of e) {
              let e = this.openContainers[i];
              e ? e.value !== t && (r[i] = {
                  value: t,
                  accessed: Date.now()
              },
              n = !0) : (r[i] = {
                  value: t,
                  accessed: Date.now()
              },
              n = !0)
          }
          n && (Object.entries(this.openContainers).forEach( ([e,t]) => {
              r[e] || (r[e] = t)
          }
          ),
          this.openContainers = r)
      }
      isIssueContainerOpen(e) {
          return e === `links` ? this.linksContainerOpen : e === `sub-issues` ? this.subIssueContainerOpen : e === `customerNeeds` ? this.customerNeedsContainerOpen : !1
      }
      updateIssueContainer(e, t) {
          e === `links` ? this.linksContainerOpen = t === `open` : e === `sub-issues` ? this.subIssueContainerOpen = t === `open` : e === `customerNeeds` && (this.customerNeedsContainerOpen = t === `open`)
      }
      updateExpandedCustomerNeeds(e, t, n) {
          n === `customerPage` ? this.expandedCustomerPageCustomerNeeds = this.expandedCustomerPageCustomerNeeds.update(e, t) : n === `projectPage` ? this.expandedProjectPageCustomerNeeds = this.expandedProjectPageCustomerNeeds.update(e, t) : this.expandedEmbeddedCustomerNeeds = this.expandedEmbeddedCustomerNeeds.update(e, t)
      }
      isGroupContainerOpen(e) {
          return this.collapsedGroups.isOpen(e)
      }
      updateGroupContainerState(e, t) {
          this.collapsedGroups = this.collapsedGroups.update(e, t)
      }
      getDefaultView() {
          if (!((this.defaultView === WM.allInitiatives || this.defaultView === WM.initiative) && !this.user.organization.initiativesEnabled))
              return this.defaultView
      }
      setDefaultView(e, t) {
          this.defaultView = e,
          this.defaultViewCustomViewId = t?.customViewId,
          this.defaultViewProjectId = t?.projectId,
          this.defaultViewInitiativeId = t?.initiativeId,
          this.save()
      }
      getDefaultViewCustomViewId() {
          return this.defaultViewCustomViewId
      }
      async getDefaultViewCustomView() {
          return this.defaultViewCustomViewId ? await this.store.hydrateModel(Az, this.defaultViewCustomViewId) : void 0
      }
      getDefaultViewProjectId() {
          if (this.defaultViewProjectId && this.store.findById(G, this.defaultViewProjectId))
              return this.defaultViewProjectId
      }
      getDefaultViewInitiativeId() {
          if (this.defaultViewInitiativeId && this.user.organization.initiativesEnabled && this.store.findById(W, this.defaultViewInitiativeId))
              return this.defaultViewInitiativeId
      }
      get desktopSpellcheck() {
          return co.isElectron ? this.spellcheck : !0
      }
      get desktopSpellcheckPreference() {
          return this.spellcheck
      }
      setDesktopSpellcheck(e) {
          this.spellcheck = e
      }
      getProjectLastSeenTab(e) {
          let t = this.projectInfos?.[e.id];
          if (t) {
              if (t.facetId)
                  return {
                      facetId: t.facetId
                  };
              if (t.mainTab) {
                  let e = lw(t.mainTab);
                  if (e && `tab`in e)
                      return {
                          mainTab: e.tab
                      };
                  if (e && `facetId`in e)
                      return {
                          facetId: e.facetId
                      }
              }
          }
      }
      getInitiativeLastSeenTab(e) {
          let t = this.initiativeInfos?.[e.id];
          if (t) {
              if (t.facetId)
                  return {
                      facetId: t.facetId
                  };
              if (t.mainTab) {
                  let e = Qoe(t.mainTab);
                  if (e && `tab`in e)
                      return {
                          mainTab: e.tab
                      };
                  if (e && `facetId`in e)
                      return {
                          facetId: e.facetId
                      }
              }
          }
      }
      getWorkspacePageLastSeenTab(e) {
          return this.fixedPageInfos?.[e]?.lastSeenTab
      }
      setWorkspacePageLastSeenTab(e, t) {
          let n = {
              ...this.fixedPageInfos?.[e],
              lastSeenTab: t
          };
          this.fixedPageInfos = {
              ...this.fixedPageInfos,
              [e]: n
          }
      }
      getTeamPageLastSeenTab(e, t) {
          return this.teamInfos?.[t]?.[e]?.lastSeenTab
      }
      setTeamPageLastSeenTab(e, t, n) {
          this.updateTeamInfo(t, {
              [e]: {
                  lastSeenTab: n
              }
          })
      }
      getTeamLastSeenMainTab(e) {
          return this.teamInfos?.[e]?.mainTab
      }
      setTeamLastSeenMainTab(e, t) {
          this.updateTeamInfo(e, {
              mainTab: t
          })
      }
      sortSidebarItems(e) {
          let t = (e={}, t) => {
              let n = Math.max(...Object.values(e)) ?? 0;
              return t.map(t => ({
                  key: t,
                  order: e?.[t] ?? n,
                  visibility: AJ[this.getSidebarItemVisibilityPreference(t)]
              })).orderBy([`visibility`, `order`], [`asc`, `asc`]).reduce( (e, t, n) => ({
                  ...e,
                  [t.key]: n
              }), {})
          }
          ;
          e === `top` && (this.topSidebarOrder = t(this.topSidebarOrder, PJ)),
          e === `workspace` && (this.workspaceSidebarOrder = t(this.workspaceSidebarOrder, NJ))
      }
      getSidebarItemVisibilityPreference(e) {
          return this.sidebarItemVisibilityPreference[e] ?? MJ[e]
      }
      setSidebarItemVisibilityPreference(e, t) {
          this.sidebarItemVisibilityPreference = {
              ...this.sidebarItemVisibilityPreference,
              [e]: t
          }
      }
      setSidebarItemNotificationPreference(e, t) {
          this.sidebarItemNotificationPreference = {
              ...this.sidebarItemNotificationPreference,
              perBadge: {
                  ...this.sidebarItemNotificationPreference.perBadge,
                  [e]: t
              }
          }
      }
      setSidebarItemDefaultNotificationPreference(e) {
          this.sidebarItemNotificationPreference = {
              ...this.sidebarItemNotificationPreference,
              default: e
          }
      }
      updateProjectInfo(e, t) {
          this.updateModelInfo(`project`, e, t)
      }
      updateProjectInfoMilestone(e, t, n) {
          let r = this.projectInfos?.[e]?.milestones;
          this.updateProjectInfo(e, {
              milestones: {
                  ...r,
                  [t]: {
                      ...r?.[t],
                      ...n
                  }
              }
          })
      }
      updateInitiativeInfo(e, t) {
          this.updateModelInfo(`initiative`, e, t)
      }
      updateTeamInfo(e, t) {
          this.updateModelInfo(`team`, e, t)
      }
      updateResourceListPreferences(e) {
          this.resourceListPreferences == null ? this.resourceListPreferences = e : this.resourceListPreferences = Object.assign(this.resourceListPreferences, e)
      }
      updateInitiativeUpdatesListPreferences(e) {
          this.initiativeUpdatesListPreferences == null ? this.initiativeUpdatesListPreferences = e : this.initiativeUpdatesListPreferences = Object.assign(this.initiativeUpdatesListPreferences, e)
      }
      updateTeamUpdatesListPreferences(e) {
          this.teamUpdatesListPreferences == null ? this.teamUpdatesListPreferences = e : this.teamUpdatesListPreferences = Object.assign(this.teamUpdatesListPreferences, e)
      }
      getStorageForPersistence(e) {
          if (e === Z.server)
              return this.settings;
          if (e === Z.browser)
              return this.browserPersistedSettings;
          if (e === Z.browserSession)
              return this.browserSessionPersistedSettings;
          if (e === Z.ephemeral)
              return this.ephemeralSettings;
          throw new Rn(e)
      }
      setLastUsedUpdateParentModel(e) {
          e instanceof K ? this.lastUsedPostTeam = e.id : e instanceof G ? this.lastUsedUpdateProject = e.id : e instanceof W && (this.lastUsedUpdateInitiative = e.id),
          this.lastUsedUpdateParentModelName = e.modelName
      }
      updateSidebarWidthForSplashScreen() {
          this.sidebarCollapsed ? sJ.update({
              sidebarWidth: 8
          }) : sJ.update({
              sidebarWidth: this.sidebarWidth
          })
      }
      getModelInfos(e) {
          switch (e) {
          case `project`:
              return this.projectInfos;
          case `initiative`:
              return this.initiativeInfos;
          case `team`:
              return this.teamInfos;
          default:
              throw y(e)
          }
      }
      setModelInfos(e, t) {
          switch (e) {
          case `project`:
              this.projectInfos = t;
              break;
          case `initiative`:
              this.initiativeInfos = t;
              break;
          case `team`:
              this.teamInfos = t;
              break;
          default:
              throw y(e)
          }
      }
      updateModelInfo(e, t, n) {
          let r = this.getModelInfos(e);
          if (r == null)
              this.setModelInfos(e, {
                  [t]: n
              });
          else {
              let i = r[t];
              i == null ? r[t] = n : Object.assign(i, n),
              this.setModelInfos(e, r)
          }
      }
  }
  ,
  M([X(void 0, Z.browserSession, {
      clearOnLogout: !0
  })], Q.prototype, `activeTeamId`, void 0),
  M([L], Q.prototype, `theme`, null),
  M([L], Q.prototype, `themeSystemLight`, null),
  M([L], Q.prototype, `themeSystemDark`, null),
  M([X(e => {
      let t = e.getStorageForPersistence(Z.browser);
      if (!zJ)
          return t.theme ?? fJ.system
  }
  , Z.server)], Q.prototype, `themeDesktop`, void 0),
  M([X(fJ.light, Z.server)], Q.prototype, `themeDesktopLight`, void 0),
  M([X(fJ.dark, Z.server)], Q.prototype, `themeDesktopDark`, void 0),
  M([X(e => {
      let t = e.getStorageForPersistence(Z.browser);
      if (zJ)
          return t.theme ?? fJ.system
  }
  , Z.server)], Q.prototype, `themeMobileWeb`, void 0),
  M([X(fJ.light, Z.server)], Q.prototype, `themeMobileWebLight`, void 0),
  M([X(fJ.dark, Z.server)], Q.prototype, `themeMobileWebDark`, void 0),
  M([X(e => {
      let t = e.getStorageForPersistence(Z.browser).customThemeInput;
      if (t && typeof t == `string`)
          try {
              return [JSON.parse(t)]
          } catch {}
  }
  , Z.server, {
      serializer: Mh
  })], Q.prototype, `customThemes`, void 0),
  M([L], Q.prototype, `currentlySelectedCustomTheme`, null),
  M([X(gJ.default, Z.browser)], Q.prototype, `fontSize`, void 0),
  M([X(void 0, Z.server, {
      serializer: Mh
  })], Q.prototype, `codeSyntaxThemeLight`, void 0),
  M([X(void 0, Z.server, {
      serializer: Mh
  })], Q.prototype, `codeSyntaxThemeDark`, void 0),
  M([X(Rr(tJ.firstDayOfWeekByBrowserLocale()), Z.server)], Q.prototype, `firstDayOfWeek`, void 0),
  M([X(!0, Z.server)], Q.prototype, `showFullUserNames`, void 0),
  M([X(!1, Z.server)], Q.prototype, `usePointerCursor`, void 0),
  M([X(!0, Z.server)], Q.prototype, `spellcheck`, void 0),
  M([X(Jk.defaultOption, Z.server)], Q.prototype, `gitAttachmentDisplayPreference`, void 0),
  M([X(!0, Z.browser)], Q.prototype, `alwaysShowTabBar`, void 0),
  M([R({
      persistence: `createOnly`,
      default: ``
  })], Q.prototype, `calendarHash`, void 0),
  M([X(!0, Z.server)], Q.prototype, `notificationBadge`, void 0),
  M([X(244, Z.browserSession, {
      onUpdate: e => {
          e.updateSidebarWidthForSplashScreen()
      }
  })], Q.prototype, `sidebarWidth`, void 0),
  M([X(!1, Z.browserSession, {
      onUpdate: e => {
          e.updateSidebarWidthForSplashScreen()
      }
  })], Q.prototype, `sidebarCollapsed`, void 0),
  M([X(!1, Z.browser)], Q.prototype, `showFullPulseSummaryUpdates`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `aiPanelExpanded`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `aiPanelWidth`, void 0),
  M([X(Wq.Gpt5, Z.browser)], Q.prototype, `aiPanelModel`, void 0),
  M([X(null, Z.browserSession)], Q.prototype, `aiPanelConversationId`, void 0),
  M([X([], Z.server, {
      serializer: Mh
  })], Q.prototype, `openAgentSessions`, void 0),
  M([X(Wq.Gemini25Pro, Z.server)], Q.prototype, `productIntelligenceAgentModel`, void 0),
  M([X(320, Z.browserSession)], Q.prototype, `timelineAsideWidth`, void 0),
  M([X(!0, Z.browserSession)], Q.prototype, `showTimelineAside`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `inboxListWidth`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `triageListWidth`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `searchListWidth`, void 0),
  M([X(482, Z.browserSession)], Q.prototype, `reviewsListWidth`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `agentsListWidth`, void 0),
  M([X([], Z.browser)], Q.prototype, `searchFilterTeamIds`, void 0),
  M([X(void 0, Z.browserSession)], Q.prototype, `customViewsViewType`, void 0),
  M([X(void 0, Z.browserSession)], Q.prototype, `teamCustomViewsViewType`, void 0),
  M([X(HJ, Z.browserSession)], Q.prototype, `showCycleDetailPane`, void 0),
  M([X(HJ, Z.browserSession)], Q.prototype, `showProjectDetailPane`, void 0),
  M([X(HJ, Z.browserSession)], Q.prototype, `showCustomViewDetailPane`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `showInitiativeDetailPane`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `showInitiativeDetailPaneInNotifications`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `showIssuesDetailPane`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `showUserDetailPane`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `showMyIssuesDetailPane`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `showQuickViewDetailPane`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `showProjectDetailPaneInNotifications`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `showPullRequestDetailPane`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `showPullRequestDetailPaneInNotifications`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `showPullRequestDetailPaneInReviews`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `showPullRequestDetailPaneInFullscreen`, void 0),
  M([X(330, Z.browserSession)], Q.prototype, `pullRequestDetailPaneWidth`, void 0),
  M([X(440, Z.browserSession)], Q.prototype, `issuesDetailPaneWidth`, void 0),
  M([X(e => e.issuesDetailPaneWidth, Z.browserSession)], Q.prototype, `issuesInsightsPaneWidth`, void 0),
  M([X(350, Z.browserSession)], Q.prototype, `myIssuesDetailPaneWidth`, void 0),
  M([X(e => e.myIssuesDetailPaneWidth, Z.browserSession)], Q.prototype, `myIssuesInsightsPaneWidth`, void 0),
  M([X(440, Z.browserSession)], Q.prototype, `quickViewDetailPaneWidth`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `projectDetailPaneWidth`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `projectDetailPaneOverviewWidth`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `projectDetailPaneIssuesWidth`, void 0),
  M([X(e => e.projectDetailPaneWidth, Z.browserSession)], Q.prototype, `projectInsightsPaneWidth`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `initiativeDetailPaneWidth`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `initiativeDetailPaneOverviewWidth`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `initiativeDetailPaneProjectsWidth`, void 0),
  M([X(400, Z.browserSession)], Q.prototype, `customViewDetailPaneWidth`, void 0),
  M([X(e => e.customViewDetailPaneWidth, Z.browserSession)], Q.prototype, `customViewInsightsPaneWidth`, void 0),
  M([X(440, Z.browserSession)], Q.prototype, `cycleDetailPaneWidth`, void 0),
  M([X(e => e.cycleDetailPaneWidth, Z.browserSession)], Q.prototype, `cycleInsightsPaneWidth`, void 0),
  M([X(iJ.overview, Z.browserSession)], Q.prototype, `projectDetailPaneTab`, void 0),
  M([X(iJ.overview, Z.browserSession)], Q.prototype, `initiativeDetailPaneTab`, void 0),
  M([X(iJ.overview, Z.browserSession)], Q.prototype, `teamIssuesDetailPaneTab`, void 0),
  M([X(iJ.overview, Z.browserSession)], Q.prototype, `userIssuesDetailPaneTab`, void 0),
  M([X(iJ.overview, Z.browserSession)], Q.prototype, `customViewDetailPaneTab`, void 0),
  M([X(iJ.overview, Z.browserSession)], Q.prototype, `cycleDetailPaneTab`, void 0),
  M([X(iJ.overview, Z.browserSession)], Q.prototype, `myIssuesDetailPaneTab`, void 0),
  M([X(iJ.overview, Z.browserSession)], Q.prototype, `pullRequestDetailPaneTab`, void 0),
  M([X(Zq.assigned, Z.browserSession)], Q.prototype, `myIssuesLastTab`, void 0),
  M([X(Bq.all, Z.browserSession)], Q.prototype, `feedLastTab`, void 0),
  M([X(void 0, Z.server, {
      serializer: Ah
  })], Q.prototype, `feedLastSeenTime`, void 0),
  M([X(1, Z.server)], Q.prototype, `feedPlaybackSpeed`, void 0),
  M([X(!1, Z.server)], Q.prototype, `forceShowIssueCount`, void 0),
  M([X(!0, Z.server)], Q.prototype, `showGutterComments`, void 0),
  M([X(`manual`, Z.server)], Q.prototype, `subIssueViewOrdering`, void 0),
  M([X(!1, Z.server)], Q.prototype, `startIssueOnGitBranchCopy`, void 0),
  M([X(!1, Z.server)], Q.prototype, `selfAssignOnGitBranchCopy`, void 0),
  M([X(!1, Z.server)], Q.prototype, `autoAssignToSelf`, void 0),
  M([X(!0, Z.server)], Q.prototype, `convertEmojisToEmoticons`, void 0),
  M([X(!1, Z.server)], Q.prototype, `doubleClickToEdit`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `openLinksInDesktop`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugActiveElement`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugBreadcrumbs`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugTooltips`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugActionManager`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugPositionLabels`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugProvider`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugSearchScore`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugActionsScore`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugSimilarIssuesScore`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugShowSimilarIssues`, void 0),
  M([X(void 0, Z.browserSession)], Q.prototype, `debugSimilarIssuesMinThreshold`, void 0),
  M([X(void 0, Z.browserSession)], Q.prototype, `debugSimilarIssuesTopK`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugApplicationStore`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugNavigation`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugHydration`, void 0),
  M([X(!1, Z.browserSession)], Q.prototype, `debugAnalytics`, void 0),
  M([X(void 0, Z.browserSession)], Q.prototype, `debugInsightsStatus`, void 0),
  M([X(void 0, Z.browser, {
      serializer: Ah
  })], Q.prototype, `lastUpgradeNotification`, void 0),
  M([X(void 0, Z.server, {
      serializer: Ah
  })], Q.prototype, `changelogReadAt`, void 0),
  M([X(!1, Z.server)], Q.prototype, `hideChangelogBanners`, void 0),
  M([X(!1, Z.server)], Q.prototype, `hideChangelogBannerPromptShown`, void 0),
  M([X(!1, Z.server)], Q.prototype, `hideMobileReleaseBanner`, void 0),
  M([X(!1, Z.server)], Q.prototype, `hideSharedSlackBanner`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `membersVisibility`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `teamMembersVisibility`, void 0),
  M([X(!1, Z.ephemeral)], Q.prototype, `cheatCodeEnabled`, void 0),
  M([X(!1, Z.server)], Q.prototype, `showReviewsInbox`, void 0),
  M([X(`all`, Z.server)], Q.prototype, `pullRequestNotificationsMode`, void 0),
  M([X(Dw.me, Z.browserSession)], Q.prototype, `reviewsLastTab`, void 0),
  M([X(!1, Z.server)], Q.prototype, `showReviewAsSplitDiff`, void 0),
  M([X(!1, Z.server)], Q.prototype, `showReviewAsStructuralDiff`, void 0),
  M([X(!1, Z.server)], Q.prototype, `reviewWrapLines`, void 0),
  M([X({
      default: EJ.BadgeCount,
      perBadge: {}
  }, Z.server, {
      serializer: Mh
  })], Q.prototype, `sidebarItemNotificationPreference`, void 0),
  M([X(MJ, Z.server, {
      serializer: Mh
  })], Q.prototype, `sidebarItemVisibilityPreference`, void 0),
  M([X(!0, Z.server)], Q.prototype, `delaySendingEmailOutsideOfWorkingHours`, void 0),
  M([X(!0, Z.server)], Q.prototype, `immediatelySendUrgentEmailNotifications`, void 0),
  M([X({}, Z.browser)], Q.prototype, `settingsListOrderBy`, void 0),
  M([X([], Z.browser)], Q.prototype, `settingsExpandedModels`, void 0),
  M([X([], Z.server)], Q.prototype, `customShortcuts`, void 0),
  M([R({
      default: !0
  })], Q.prototype, `subscribedToChangelog`, void 0),
  M([R({
      default: !0
  })], Q.prototype, `subscribedToDPA`, void 0),
  M([R({
      default: !0
  })], Q.prototype, `subscribedToInviteAccepted`, void 0),
  M([R({
      default: !0
  })], Q.prototype, `subscribedToPrivacyLegalUpdates`, void 0),
  M([R({
      default: !1
  })], Q.prototype, `subscribedToGeneralMarketingCommunications`, void 0),
  M([X(!0, Z.browser)], Q.prototype, `developerToolbarVisible`, void 0),
  M([X(!1, Z.browser)], Q.prototype, `developerToolbarMinimized`, void 0),
  M([X(!1, Z.browser)], Q.prototype, `developerToolbarAgentMode`, void 0),
  M([X(!0, Z.browser)], Q.prototype, `developerToolbarDebugPage`, void 0),
  M([X(!0, Z.browser)], Q.prototype, `developerToolbarUserRole`, void 0),
  M([X(!1, Z.browser)], Q.prototype, `developerToolbarUserPermissions`, void 0),
  M([X(!0, Jn.PREVIEW_BUILD ? Z.server : Z.browser)], Q.prototype, `developerToolbarReleaseChannel`, void 0),
  M([X(!0, Jn.PREVIEW_BUILD ? Z.server : Z.browser)], Q.prototype, `developerToolbarLogs`, void 0),
  M([X(!0, Jn.PREVIEW_BUILD ? Z.server : Z.browser)], Q.prototype, `developerToolbarPromptDesigner`, void 0),
  M([X(!0, Jn.PREVIEW_BUILD ? Z.server : Z.browser)], Q.prototype, `developerToolbarInteractionDelay`, void 0),
  M([X(!0, Jn.PREVIEW_BUILD ? Z.server : Z.browser)], Q.prototype, `developerToolbarFeatureFlags`, void 0),
  M([X(!0, Jn.PREVIEW_BUILD ? Z.server : Z.browser)], Q.prototype, `developerToolbarEnvironmentColors`, void 0),
  M([X(!0, Jn.PREVIEW_BUILD ? Z.server : Z.browser)], Q.prototype, `developerToolbarFrameJank`, void 0),
  M([X(!0, Jn.PREVIEW_BUILD ? Z.server : Z.browser)], Q.prototype, `developerToolbarNetwork`, void 0),
  M([X(!0, Jn.PREVIEW_BUILD ? Z.server : Z.browser)], Q.prototype, `developerToolbarMemory`, void 0),
  M([X(!0, Jn.PREVIEW_BUILD ? Z.server : Z.browser)], Q.prototype, `developerToolbarDarkMode`, void 0),
  M([X(!0, Jn.PREVIEW_BUILD ? Z.server : Z.browser)], Q.prototype, `developerToolbarHydration`, void 0),
  M([X(`production`, Z.browserSession)], Q.prototype, `developerCMSDatasetOverrideValue`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `developerUserRoleOverrideValue`, void 0),
  M([X(void 0, Z.browserSession)], Q.prototype, `developerUsageLimitsOverrideValue`, void 0),
  M([X([], Z.browser)], Q.prototype, `developerToolbarPinnedFeatureFlags`, void 0),
  M([X([], Z.browserSession)], Q.prototype, `developerDisabledPlanFeatures`, void 0),
  M([X(void 0, Z.browserSession)], Q.prototype, `developerWorkspaceAdminPermissionOverrides`, void 0),
  M([R({
      serializer: Mh,
      default: {}
  })], Q.prototype, `settings`, void 0),
  M([ug( () => J, `settings`, {
      optional: !1,
      nullable: !1,
      persistence: `createOnly`
  })], Q.prototype, `user`, void 0),
  M([X({}, Z.server)], Q.prototype, `openContainers`, void 0),
  M([X(void 0, Z.browser, {
      clearOnLogout: !0
  })], Q.prototype, `projectInfos`, void 0),
  M([X(void 0, Z.browser, {
      clearOnLogout: !0,
      serializer: Mh
  })], Q.prototype, `fixedPageInfos`, void 0),
  M([X(void 0, Z.browser, {
      clearOnLogout: !0
  })], Q.prototype, `initiativeInfos`, void 0),
  M([X(void 0, Z.browser, {
      clearOnLogout: !0
  })], Q.prototype, `teamInfos`, void 0),
  M([X(void 0, Z.server)], Q.prototype, `workspaceSidebarOrder`, void 0),
  M([X(void 0, Z.server)], Q.prototype, `topSidebarOrder`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `resourceListPreferences`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `initiativeUpdatesListPreferences`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `teamUpdatesListPreferences`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `lastDismissedDesktopUpdateVersion`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `lastUsedPostTeam`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `lastUsedUpdateProject`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `lastUsedUpdateInitiative`, void 0),
  M([X(void 0, Z.browser)], Q.prototype, `lastUsedUpdateParentModelName`, void 0),
  M([X(TJ.DefaultEmptyState, Z.browser, {
      serializer: TJ.Serializer
  })], Q.prototype, `expandedEmbeddedCustomerNeeds`, void 0),
  M([X(TJ.DefaultEmptyState, Z.browser, {
      serializer: TJ.Serializer
  })], Q.prototype, `expandedProjectPageCustomerNeeds`, void 0),
  M([X(TJ.DefaultEmptyState, Z.browser, {
      serializer: TJ.Serializer
  })], Q.prototype, `expandedCustomerPageCustomerNeeds`, void 0),
  M([X(GM, Z.server)], Q.prototype, `defaultView`, void 0),
  M([X(void 0, Z.server)], Q.prototype, `defaultViewCustomViewId`, void 0),
  M([X(void 0, Z.server)], Q.prototype, `defaultViewProjectId`, void 0),
  M([X(void 0, Z.server)], Q.prototype, `defaultViewInitiativeId`, void 0),
  M([X(!0, Z.server)], Q.prototype, `subIssueContainerOpen`, void 0),
  M([X(!0, Z.server)], Q.prototype, `linksContainerOpen`, void 0),
  M([X(!0, Z.server)], Q.prototype, `customerNeedsContainerOpen`, void 0),
  M([X(CJ.DefaultEmptyState, Z.browser, {
      serializer: CJ.Serializer
  })], Q.prototype, `collapsedGroups`, void 0),
  M([R({
      serializer: Mh,
      persistence: `none`,
      default: {}
  })], Q.prototype, `flags`, void 0),
  M([R({
      serializer: Fh,
      default: {}
  })], Q.prototype, `notificationCategoryPreferences`, void 0),
  M([R({
      serializer: Fh,
      default: {}
  })], Q.prototype, `notificationChannelPreferences`, void 0),
  M([R({
      serializer: Fh,
      default: {}
  })], Q.prototype, `notificationDeliveryPreferences`, void 0),
  M([R({
      serializer: Mh,
      default: {}
  })], Q.prototype, `usageWarningHistory`, void 0),
  M([R({
      default: rp.never
  })], Q.prototype, `feedSummarySchedule`, void 0),
  Q = M([mg(`UserSettings`)], Q),
  KJ = `userSettings`
}
));
function Wue(e) {
  return new Jp( (t, n) => {
      e.then(async e => {
          t(e),
          await e?.refresh()
      }
      ).catch(n)
  }
  )
}
var JJ, YJ = t(( () => {
  zt(),
  ws(),
  Xp(),
  N(),
  JJ = class {
      constructor(e, t) {
          this._isLoading = !1;
          let {clearCache: n, query: r, isFresh: i} = t;
          this._value = e,
          this._clearCache = n,
          i || (this._refresh = r()),
          this._query = r,
          At(this)
      }
      setValue(e, t=!0) {
          Mt( () => {
              this._value = e
          }
          ),
          t && this._clearCache()
      }
      get isLoading() {
          return this._isLoading
      }
      async forceRefresh() {
          this._refresh = this._query(),
          await this.refresh()
      }
      async refresh() {
          if (this._refresh === void 0)
              return;
          let e = this._refresh;
          this._refresh = void 0,
          this.setLoading(!0);
          try {
              this.setValue(await e, !1)
          } catch (e) {
              w.error(`Failed to refresh cache value`, e)
          } finally {
              this.setLoading(!1)
          }
      }
      get value() {
          return this._value
      }
      setLoading(e) {
          Mt( () => {
              this._isLoading = e
          }
          )
      }
  }
  ,
  M([Vt], JJ.prototype, `_value`, void 0),
  M([Vt], JJ.prototype, `_isLoading`, void 0)
}
)), XJ, ZJ, QJ, $J = t(( () => {
  XJ = `demo`,
  ZJ = RegExp(`^\\/${XJ}(?:\\/.*?)?$`),
  QJ = ZJ.test(window.location.pathname)
}
)), Gue = t(( () => {}
)), eY, Kue = t(( () => {
  La(),
  Gue(),
  Yr(),
  to(),
  Xn(),
  pi(),
  ws(),
  Ho(),
  es(),
  fY(),
  ai(),
  eY = class e {
      static async restModelsStream(e, t, n, r, i=0) {
          let a = typeof r?.retry == `number` ? {
              times: r.retry
          } : r?.retry;
          try {
              let i = [], a, o, s = !1, c = this.restModelsStreamGen(e, t, n, 2 ** 53 - 1, r), l = !0, u = !1;
              for await(let e of c) {
                  if (u)
                      throw Error(`restModelsStream got results after completed!`);
                  l ? (i = e.models,
                  a = e.syncActions,
                  o = e.metadata,
                  s = e.edgeCacheHit,
                  l = !1) : (i = i.length ? i.concat(e.models) : e.models,
                  e.syncActions && (a = a ? a.concat(e.syncActions) : e.syncActions),
                  e.metadata && (o = e.metadata))
              }
              if (u = !0,
              !o)
                  throw new $o({
                      type: `internal error`,
                      message: `Internal error: No _metadata_ in response from generator`,
                      userError: !1
                  });
              return {
                  models: i,
                  syncActions: a,
                  metadata: o,
                  edgeCacheHit: s
              }
          } catch (o) {
              if (Ko(o))
                  throw o;
              if (this.isModelsCountMismatchError(o) && i < 2)
                  return await ri(b.SECOND),
                  await this.restModelsStream(e, t, n, r, i + 1);
              if (a && a.times > i && (a.retryAllErrors || Go(o) || a.retryOnRatelimit && Jo(o)))
                  return a?.delayMs && await ri(a.delayMs(i, o.metaData?.rateLimitResult?.duration)),
                  await this.restModelsStream(e, t, n, r, i + 1);
              throw o
          }
      }
      static async*restModelsStreamGen(t, n, r, i, a) {
          let o = ui.isEnabled(`binary-streaming-responses`)
            , s = new URL(r,Jn.API_SERVER_URL);
          o && s.searchParams.set(`useBinaryProtocol`, o.toString());
          let c = s.toString();
          dY.registerCall(),
          a?.dontLog || w.network(`Sending REST query #${t}`, {
              url: c
          });
          let l = await fetch(c, {
              method: a?.method ?? `GET`,
              headers: {
                  ...n,
                  accept: `application/octet-stream, text/plain`,
                  "content-type": `application/json`
              },
              body: a?.method === `POST` ? a.body : void 0,
              credentials: `include`,
              signal: a?.abortSignal
          }).catch(e => {
              if (e instanceof DOMException && e.name === `AbortError`)
                  throw this.makeAbortedError();
              let t = Qa.isBrowserNetworkError(e);
              throw Vo.increment(`network.error`, {
                  source: `rest`,
                  path: r.split(`?`)[0]
              }, {
                  onlySendWhenOnline: !0
              }),
              new $o({
                  type: `network error`,
                  message: `Network error: ${einstanceof Error ? e.message : String(e)}`,
                  userError: !0,
                  requestId: void 0,
                  skipSentry: t
              })
          }
          );
          if (!l.ok)
              throw await Xo(l);
          let u = Qo(l.headers)
            , d = u === `hit`;
          if (!l.body)
              throw new $o({
                  type: `internal error`,
                  message: `Internal error: No response body`,
                  userError: !1,
                  requestId: Zo(l.headers),
                  metaData: {
                      statusCode: l.status,
                      edgeCacheStatus: u
                  }
              });
          let f = [], p, m = 0, h, g = {}, _ = e.getReadErrorHandler(l, u), ee = l.headers.get(`content-type`) || ``, te = ee.includes(`application/octet-stream`);
          if (w.network(`Processing REST query response #${t}`, {
              url: c,
              contentType: ee,
              isBinary: te
          }),
          te) {
              let e = new Qi({
                  useRecords: !0,
                  bundleStrings: !1,
                  sequential: !0
              }), t = e => {
                  if (!e)
                      return;
                  let t = e.__class;
                  for (let t in e)
                      e[t] === null && (e[t] = void 0);
                  if (!t)
                      throw new $o({
                          type: `internal error`,
                          message: `Internal error: invalid streaming response object without __class`,
                          userError: !1,
                          requestId: Zo(l.headers),
                          metaData: {
                              statusCode: l.status,
                              edgeCacheStatus: u
                          }
                      });
                  if (h)
                      throw new $o({
                          type: `internal error`,
                          message: `Internal error: _metadata_ not last entity in response`,
                          userError: !1,
                          requestId: Zo(l.headers),
                          metaData: {
                              statusCode: l.status,
                              edgeCacheStatus: u
                          }
                      });
                  t === `_metadata_` ? h = e : t === `SyncAction` ? (p ||= [],
                  p.push(e),
                  m++,
                  g[t] = (g[t] || 0) + 1) : (f.push(e),
                  m++,
                  g[t] = (g[t] || 0) + 1)
              }
              , n = l.body.getReader(), r;
              for (; ; ) {
                  if (a?.abortSignal?.aborted)
                      throw this.makeAbortedError();
                  let {value: o, done: s} = await n.read().catch(_);
                  if (o) {
                      let n = new Uint8Array((r?.length ?? 0) + o.length);
                      r && n.set(r),
                      n.set(o, r?.length ?? 0),
                      r = void 0;
                      let i;
                      try {
                          i = e.unpackMultiple(n)
                      } catch (e) {
                          if (e?.incomplete)
                              r = n.slice(e.lastPosition),
                              i = e.values;
                          else
                              throw e
                      }
                      for (let e of i || [])
                          t(e)
                  }
                  if (m >= i && (yield{
                      models: f,
                      syncActions: p,
                      metadata: h,
                      edgeCacheHit: d
                  },
                  f = [],
                  p = void 0,
                  m = 0),
                  s) {
                      if (r?.length) {
                          if (a?.abortSignal?.aborted)
                              throw this.makeAbortedError();
                          try {
                              let n = e.unpackMultiple(r);
                              for (let e of n)
                                  t(e)
                          } catch (e) {
                              await _(e)
                          }
                      }
                      break
                  }
              }
              (f.length > 0 || p || h) && (yield{
                  models: f,
                  syncActions: p,
                  metadata: h,
                  edgeCacheHit: d
              })
          } else {
              let e = e => {
                  if (!e)
                      return;
                  let t = e[0] === `{` ? -1 : e.indexOf(`=`), n, r;
                  if (t >= 0) {
                      n = e.substring(0, t);
                      let i = e.substring(t + 1);
                      r = JSON.parse(i),
                      r.__class ||= n
                  } else
                      r = JSON.parse(e),
                      n = r.__class;
                  if (!n)
                      throw new $o({
                          type: `internal error`,
                          message: `Internal error: invalid streaming response line without modelName: ${e.substring(0, t > 0 ? t : 30)}`,
                          userError: !1,
                          requestId: Zo(l.headers),
                          metaData: {
                              statusCode: l.status,
                              edgeCacheStatus: u
                          }
                      });
                  if (h)
                      throw new $o({
                          type: `internal error`,
                          message: `Internal error: _metadata_ not last entity in response: ${e.substring(0, t > 0 ? t : 30)}`,
                          userError: !1,
                          requestId: Zo(l.headers),
                          metaData: {
                              statusCode: l.status,
                              edgeCacheStatus: u
                          }
                      });
                  n === `_metadata_` ? h = r : n === `SyncAction` ? (p ||= [],
                  p.push(r),
                  m++,
                  g[n] = (g[n] || 0) + 1) : (f.push(r),
                  m++,
                  g[n] = (g[n] || 0) + 1)
              }
              ;
              await (async (t, n) => {
                  let r = 0
                    , i = 0;
                  for (; ; ) {
                      ++r % 2e3 == 0 && await new Promise(e => setTimeout(e, 0));
                      let a = t.indexOf(`
`, i);
                      if (a === -1)
                          if (n)
                              a = void 0;
                          else
                              return t.substring(i);
                      if (e(t.substring(i, a)),
                      a === void 0)
                          return ``;
                      i = a + 1
                  }
              }
              )(await l.text().catch(_), !0),
              yield{
                  models: f,
                  syncActions: p,
                  metadata: h,
                  edgeCacheHit: d
              }
          }
          if (!h)
              throw new $o({
                  type: `internal error`,
                  message: `Internal error: No _metadata_ in response`,
                  userError: !1,
                  requestId: Zo(l.headers),
                  metaData: {
                      statusCode: l.status,
                      edgeCacheStatus: u
                  }
              });
          if (a?.dontLog || w.network(`Received REST query response #${t}`, {
              url: c,
              requestId: Zo(l.headers),
              metadata: h,
              ...Jn.DEBUG_LOG_NETWORK_DATA && {
                  models: f,
                  syncActions: p,
                  metadata: h
              }
          }),
          h.returnedModelsCount) {
              let e = [];
              for (let[t,n] of Object.entries(h.returnedModelsCount))
                  (g[t] || 0) !== (n || 0) && e.push(`${t}: ${g[t]}/${n}`);
              if (e.length)
                  throw w.error(`Stream response models count mismatch`, void 0, {
                      url: c,
                      requestId: Zo(l.headers),
                      errors: e,
                      readModelsCount: g,
                      returnedModelsCount: h.returnedModelsCount
                  }),
                  new $o({
                      type: `internal error`,
                      message: `Internal error: Stream response models count mismatch`,
                      userError: !1,
                      requestId: Zo(l.headers),
                      metaData: {
                          statusCode: l.status,
                          edgeCacheStatus: u
                      }
                  })
          }
      }
      static getReadErrorHandler(e, t) {
          return async n => {
              let r = `${ninstanceof Error ? n.message : typeof n == `string` ? n : `Unknown error`}`;
              throw Qa.isAbortError(n) ? new $o({
                  type: `network error`,
                  message: `Abort error while reading streaming response: ${r}`,
                  userError: !0,
                  requestId: Zo(e.headers),
                  metaData: {
                      statusCode: e.status,
                      edgeCacheStatus: t
                  }
              }) : Qa.isBrowserNetworkError(n) ? new $o({
                  type: `network error`,
                  message: `Network error while reading streaming response: ${r}`,
                  userError: !0,
                  requestId: Zo(e.headers),
                  metaData: {
                      statusCode: e.status,
                      edgeCacheStatus: t
                  },
                  skipSentry: !0
              }) : (Vo.increment(`network.error`, {
                  source: `rest_stream_body`
              }, {
                  onlySendWhenOnline: !0
              }),
              new $o({
                  type: `internal error`,
                  message: `Internal/Network error while reading streaming response: ${r}`,
                  userError: !1,
                  requestId: Zo(e.headers),
                  metaData: {
                      statusCode: e.status,
                      edgeCacheStatus: t
                  }
              }))
          }
      }
      static isModelsCountMismatchError(e) {
          return qo(e) && e.type === `internal error` && e.message.includes(`Stream response models count mismatch`)
      }
      static makeAbortedError() {
          return new $o({
              type: `aborted`,
              message: `Request aborted`,
              userError: !0,
              skipSentry: !0
          })
      }
  }
}
)), tY, nY, rY, iY, aY, oY = t(( () => {
  Xn(),
  ni(),
  tY = `linear-force-graphql-429`,
  nY = `linear-force-graphql-429-delay`,
  rY = `x-force-429`,
  iY = 4e3,
  aY = class e {
      static #e = this.FORCE_GRAPHQL_RATE_LIMIT_KEY = tY;
      static #t = this.FORCE_GRAPHQL_RATE_LIMIT_DELAY_KEY = nY;
      static #n = this.DEFAULT_FORCE_GRAPHQL_RATE_LIMIT_DELAY_MS = iY;
      static normalizeForceRateLimitDelay(e) {
          return typeof e != `number` || Number.isNaN(e) || e <= 0 ? iY : Math.round(e)
      }
      static readForceGraphQLRateLimitState() {
          if (!Jn.IS_DEVELOPMENT_ENV)
              return {
                  enabled: !1,
                  delayMs: iY
              };
          let t = ei.getString(tY) === `true`
            , n = ei.getString(nY)
            , r = n ? Number(n) : void 0;
          return {
              enabled: t,
              delayMs: e.normalizeForceRateLimitDelay(r)
          }
      }
      static persistForceGraphQLRateLimitState(t) {
          if (!Jn.IS_DEVELOPMENT_ENV)
              return {
                  enabled: !1,
                  delayMs: iY
              };
          let n = e.normalizeForceRateLimitDelay(t.delayMs);
          return t.enabled ? (ei.setString(tY, `true`),
          ei.setString(nY, n.toString())) : (ei.remove(tY),
          ei.remove(nY)),
          {
              enabled: t.enabled,
              delayMs: n
          }
      }
      static getDevNetworkToolsHeaders() {
          if (!Jn.IS_DEVELOPMENT_ENV)
              return;
          let t = e.readForceGraphQLRateLimitState();
          if (t.enabled)
              return {
                  [rY]: `${t.delayMs}`
              }
      }
  }
}
));
function que(e) {
  if (e instanceof $o && e.type === `downtime`) {
      let t = e.metaData?.downtimeMode;
      return t ? t !== `read-only` && t !== `shutdown` && t !== `offline` ? (y(t),
      w.error(`Downtime API error with unknown mode "${t}", defaults to read-only`),
      `read-only`) : t : (w.error(`Downtime API error without mode, defaults to read-only`, e),
      `read-only`)
  }
}
var sY, cY, lY, uY, dY, fY = t(( () => {
  sY = e(l(), 1),
  Wt(),
  cY = e(qp(), 1),
  zt(),
  _r(),
  Gc(),
  zn(),
  to(),
  Xn(),
  Ho(),
  ws(),
  ni(),
  YJ(),
  $J(),
  Es(),
  Kue(),
  oY(),
  es(),
  lY = class e {
      get onClientReady() {
          return this._onClientReady
      }
      constructor(e) {
          this.downtimeMode = void 0,
          this._onClientReady = new Ts,
          this.headers = {
              "Linear-Client-Version": gr.versionString(Jn.BUILD_REVISION, Jn.PREVIEW_PR_NUMBER),
              "Linear-Client-ID": w.clientId
          },
          this.client = new yee(e.httpURL,{
              credentials: `include`,
              errorPolicy: `none`,
              keepalive: !0
          }),
          At(this, {
              downtimeMode: Vt
          })
      }
      setUser({userId: e, userAccountId: t, organizationId: n, authenticationToken: r}) {
          e ? this.headers.user = e : delete this.headers.user,
          t ? this.headers.userAccount = t : delete this.headers.userAccount,
          n ? this.headers.organization = n : delete this.headers.organization,
          r ? this.headers.authorization = r : delete this.headers.authorization,
          this._onClientReady.autoFire()
      }
      get userId() {
          return this.headers.user
      }
      async cacheGetAndRefresh(e, t, n, r) {
          let i = this.getGraphQLHeaders(n)
            , a = this.createCacheKey({
              query: e,
              variables: t,
              userId: i.user
          })
            , o = this.cacheGet(a)
            , s = i => this.query(e, t, {
              ...n,
              cache: !1
          }).then(o => (i && !n?.dontLog && w.network(`Refreshed cache with GraphQL response`, {
              query: e,
              variables: t
          }),
          this.cacheSet(a, o, n?.cacheTTL),
          r ? r(o) : o))
            , c = () => {
              this.cacheDelete(a)
          }
          ;
          return o ? new JJ(r ? r(o) : o,{
              clearCache: c,
              query: () => s(!0)
          }) : new JJ(await s(),{
              clearCache: c,
              query: () => s(!0),
              isFresh: !0
          })
      }
      async query(e, t, n) {
          let r = this.getGraphQLHeaders(n)
            , i = this.registerCall()
            , a = this.outdent(e);
          n?.dontLog || w.network(`Sending query #${i}`, {
              query: a,
              variables: t
          });
          let o;
          if (n?.cache) {
              o = this.createCacheKey({
                  query: e,
                  variables: t,
                  cacheKey: n.cacheKey,
                  userId: r.user
              });
              let s = this.cacheGet(o);
              if (s)
                  return n?.dontLog || w.network(`Returning cached query response #${i}`, {
                      query: a,
                      variables: t
                  }),
                  s
          }
          let s = aY.getDevNetworkToolsHeaders()
            , c = s ? {
              ...r,
              ...s
          } : r
            , l = await this.client.request(a, t, c).catch(r => {
              let i = Yo(r)
                , o = this.operationName(a);
              if (i.type === `network error`) {
                  let r = n?.retry;
                  if (r !== void 0 && r > 0)
                      return this.query(e, t, {
                          ...n,
                          retry: r - 1
                      });
                  w.network(`Network error executing query` + (o ? ` ` + o : ``), {
                      query: a,
                      variables: t
                  })
              } else {
                  let e = i.metaData?.code === `GRAPHQL_VALIDATION_FAILED`;
                  if (i.userError && !e)
                      w.info(`User error executing query${o ? ` ` + o : ``}`, {
                          error: i,
                          query: a,
                          variables: t
                      });
                  else {
                      let n = e ? `Validation failure executing query` : `Error executing query`;
                      w.error(`${n}${o ? ` ` + o : ``}`, i, {
                          query: a,
                          variables: t
                      })
                  }
              }
              throw i
          }
          );
          return n?.dontLog || w.network(`Received query result #${i}`, {
              ...Jn.DEBUG_LOG_NETWORK_DATA && {
                  result: l
              }
          }),
          n?.cache && o && this.cacheSet(o, l, n.cacheTTL),
          l
      }
      queryCacheOnly(e, t, n) {
          let r = this.getGraphQLHeaders(n)
            , i = this.registerCall()
            , a = this.outdent(e);
          n?.dontLog || w.network(`Sending query #${i}`, {
              query: a,
              variables: t
          });
          let o = this.createCacheKey({
              query: e,
              variables: t,
              cacheKey: n?.cacheKey,
              userId: r.user
          })
            , s = this.cacheGet(o);
          if (s)
              return n?.dontLog || w.network(`Returning cached query response #${i}`, {
                  query: a,
                  variables: t
              }),
              s
      }
      async mutate(t, n, r) {
          let i = this.getGraphQLHeaders(r)
            , a = this.outdent(t)
            , o = this.registerCall();
          if (r?.dontLog || w.network(`Sending mutation #${o}`, {
              mutation: a,
              variables: n
          }),
          QJ) {
              let e = this.operationName(a);
              return e ? Promise.resolve({
                  [e]: {
                      success: !0
                  }
              }) : Promise.resolve({})
          }
          let s = aY.getDevNetworkToolsHeaders()
            , c = s ? {
              ...i,
              ...s
          } : i
            , l = await this.client.request(a, n, c).catch(i => {
              let o = Yo(i)
                , s = this.operationName(a);
              if (e.graphqlErrorSignal.fire(o),
              o.type === `network error` || o.type === `downtime` || o.type === `lock timeout`) {
                  this.updateDowntimeMode(o);
                  let e = r?.retry;
                  if (e !== void 0 && e > 0)
                      return this.mutate(t, n, {
                          ...r,
                          retry: e - 1
                      });
                  let i = o.type === `network error` ? `Network` : o.type.capitalize();
                  w.network(`${i} error executing mutation` + (s ? ` ` + s : ``), {
                      query: a,
                      variables: n
                  })
              } else
                  (!o.userError || r?.logUserErrors) && w.error(`Error executing mutation` + (s ? ` ` + s : ``), o, {
                      query: a,
                      variables: n
                  });
              throw o
          }
          );
          return this.updateDowntimeMode(void 0),
          r?.dontLog || w.network(`Received mutation result #${o}`, {
              ...Jn.DEBUG_LOG_NETWORK_DATA && {
                  result: l
              }
          }),
          l
      }
      async restModelsStream(e, t, n=0) {
          let r = this.registerCall()
            , i = t?.asUserAccount === !0 ? (0,
          sY.default)(this.headers, `user`) : {
              ...this.headers
          }
            , a = aY.getDevNetworkToolsHeaders()
            , o = a ? {
              ...i,
              ...a
          } : i;
          QJ && (o[`linear-load-demo-workspace`] = `true`);
          try {
              let i = await eY.restModelsStream(r, o, e, t, n);
              return this.updateDowntimeMode(void 0),
              i
          } catch (e) {
              throw this.updateDowntimeMode(e),
              e
          }
      }
      async restExecute(e, t) {
          let n = `${Jn.API_SERVER_URL}${e.startsWith(`/`) ? `` : `/`}${e}`
            , r = t?.asUserAccount === !0 ? (0,
          sY.default)(this.headers, `user`) : {
              ...this.headers
          }
            , i = aY.getDevNetworkToolsHeaders()
            , a = i ? {
              ...r,
              ...i
          } : r
            , o = this.registerCall();
          t?.dontLog || w.network(`Sending REST query #${o}`, {
              url: n
          });
          let s = t?.method ?? `GET`
            , c = await fetch(n, {
              method: s,
              headers: {
                  ...a,
                  accept: `application/json`,
                  "content-type": `application/json`
              },
              body: t?.method === `POST` ? t.body : void 0,
              credentials: `include`
          }).catch(t => {
              let n = Qa.isBrowserNetworkError(t);
              throw Vo.increment(`network.error`, {
                  source: `rest`,
                  path: e.split(`?`)[0]
              }, {
                  onlySendWhenOnline: !0
              }),
              new $o({
                  type: `network error`,
                  message: `Network error: ${tinstanceof Error ? t.message : String(t)}`,
                  userError: !0,
                  requestId: void 0,
                  skipSentry: n
              })
          }
          );
          if (!c.ok) {
              let e = await Xo(c);
              throw this.updateDowntimeMode(e),
              e
          }
          return s === `POST` && this.updateDowntimeMode(void 0),
          await c.json()
      }
      getFirstSyncId() {
          return this._firstSyncId
      }
      setFirstSyncId(e) {
          this._firstSyncId = e
      }
      clearCache(e) {
          this.cacheDelete(e)
      }
      static #e = this.graphqlErrorSignal = new Ts;
      static #t = this.requestNumber = 1;
      updateDowntimeMode(e) {
          if (e) {
              let t = que(e);
              t && Mt( () => this.downtimeMode = t)
          } else
              this.downtimeMode && Mt( () => this.downtimeMode = void 0)
      }
      getGraphQLHeaders(e) {
          let t = {
              ...this.headers
          };
          return e?.asUserAccount === !0 && (delete t.user,
          delete t.organization),
          e?.asAnonymous === !0 && (delete t.user,
          delete t.userAccount,
          delete t.organization,
          t[`linear-force-anonymous`] = `true`),
          QJ && (t[`linear-load-demo-workspace`] = `true`),
          e?.region && (t[Uc] = e.region),
          t
      }
      cacheGet(e) {
          let t = ei.getSession(e);
          if (t && typeof t == `object` && `cacheData`in t) {
              let n = t
                , r = n.expiresAt;
              if (r === null || Date.now() < r)
                  return n.cacheData;
              this.cacheDelete(e);
              return
          }
          return t
      }
      cacheSet(e, t, n=1 / 0) {
          ei.setSession(e, {
              cacheData: t,
              expiresAt: Date.now() + n
          })
      }
      cacheDelete(e) {
          ei.removeSession(e)
      }
      outdent(e) {
          let t = e;
          for (; t.substring(0, 1) === `
`; )
              t = t.substring(1);
          let n = 0;
          for (; n < t.length && t.substring(n, n + 1) === ` `; )
              n++;
          if (n === 0)
              return t.trim();
          {
              let e = RegExp(`^\\s{${n}}`, `gm`);
              return t = t.replace(e, ``).trim(),
              t
          }
      }
      operationName(e) {
          let t = e.match(/\{[^\w]*(\w*)/);
          if (t)
              return t[1]
      }
      createCacheKey(e) {
          let {cacheKey: t, query: n, variables: r, userId: i} = e
            , a = [uY];
          return i && a.push(i),
          t && a.push((0,
          cY.default)(t)),
          a.push((0,
          cY.default)(n + (r ? JSON.stringify(r) : ``))),
          a.join(`_`)
      }
      registerCall() {
          let t = e.requestNumber++;
          return dY.registerCall(),
          t
      }
  }
  ,
  uY = `cache`,
  dY = class {
      static #e = this.callCount = 0;
      static registerCall() {
          this.callCount += 1
      }
      static reset() {
          this.callCount = 0
      }
  }
}
)), pY, mY, hY = t(( () => {
  zt(),
  pY = function(e) {
      return e[e.online = 0] = `online`,
      e[e.offline = 1] = `offline`,
      e
  }({}),
  mY = class {
      constructor() {
          this.onlineStatus = pY.online,
          this.handleOnlineChange = Ft( () => {
              this.onlineStatus = navigator.onLine ? pY.online : pY.offline
          }
          ),
          this.onlineStatus = navigator.onLine ? pY.online : pY.offline,
          window.addEventListener(`online`, this.handleOnlineChange),
          window.addEventListener(`offline`, this.handleOnlineChange),
          At(this, {
              onlineStatus: Vt
          })
      }
      refreshOnlineStatus() {
          this.handleOnlineChange()
      }
      get isOnline() {
          return this.onlineStatus === pY.online
      }
      get isOffline() {
          return this.onlineStatus === pY.offline
      }
  }
}
)), gY, Jue = t(( () => {
  gY = function(e) {
      return e.desktopThenPush = `desktopThenPush`,
      e.desktopAndPush = `desktopAndPush`,
      e.desktop = `desktop`,
      e.push = `push`,
      e
  }({})
}
));
function _Y(e) {
  let t = Ut`
  query PushSubscriptionTest($strategy: SendStrategy) {
    pushSubscriptionTest(sendStrategy: $strategy) {
      success
    }
  }
`;
  return e.mutate(t, {
      strategy: co.isElectron ? gY.desktop : gY.push
  })
}
var vY = t(( () => {
  Wt(),
  Jue(),
  lo()
}
));
function Yue(e) {
  let t = (e + `=`.repeat((4 - e.length % 4) % 4)).replace(/\-/g, `+`).replace(/_/g, `/`)
    , n = window.atob(t)
    , r = new Uint8Array(n.length);
  for (let e = 0; e < n.length; ++e)
      r[e] = n.charCodeAt(e);
  return r
}
var yY, bY, xY, SY = t(( () => {
  yY = e(ne(), 1),
  zt(),
  ir(),
  Xn(),
  sy(),
  ni(),
  cU(),
  vY(),
  V(),
  N(),
  bY = function(e) {
      return e[e.unknown = 0] = `unknown`,
      e[e.ineligible = 1] = `ineligible`,
      e[e.denied = 2] = `denied`,
      e[e.unsubscribed = 3] = `unsubscribed`,
      e[e.subscribing = 4] = `subscribing`,
      e[e.unsubscribing = 5] = `unsubscribing`,
      e[e.subscribed = 6] = `subscribed`,
      e[e.error = 7] = `error`,
      e
  }({}),
  xY = class {
      constructor(e) {
          this.subscriptionStatus = bY.unknown,
          this.store = e,
          Nt(this)
      }
      async subscribeUser(e=!0) {
          if (!this.registration)
              throw Error(`Service worker not registered`);
          let t = Yue(Jn.PUSH_MESSAGE_VAPID_PUBLIC_KEY || ``);
          this.subscriptionStatus = bY.subscribing;
          try {
              this.subscription = await this.registration.pushManager.subscribe({
                  userVisibleOnly: !0,
                  applicationServerKey: t
              })
          } catch (e) {
              return rr.isBrave && e.message.includes(`push service error`) ? new oy(ay.error,`Brave settings need updating`,`To enable browser push notifications you must enable 'Use Google services for push messaging.' in Brave settings.`).show() : new oy(ay.error,`Error subscribing`,`Please go to your desktop settings and grant Linear permissions to post push notifications to enable this feature.`).show(),
              !1
          }
          if (this.subscription && this.user) {
              ei.setPersistent(`subscribed_to_push_notifications`, this.user, !0);
              let e = new sU;
              e.data = this.subscription.toJSON(),
              e.user = this.user,
              await e.save(!0).result().catch(async e => {
                  await this.subscription?.unsubscribe(),
                  this.setStatus()
              }
              )
          }
          return this.setStatus(),
          e && _Y(this.store.graphQLClient),
          !0
      }
      async unsubscribeUser() {
          if (!this.subscription)
              throw Error(`No active subscription`);
          if (!this.user)
              throw Error(`No active user`);
          ei.removePersistent(`subscribed_to_push_notifications`, this.user),
          this.subscriptionStatus = bY.unsubscribing;
          let e = this.subscriptionForThisBrowser;
          await this.subscription.unsubscribe() ? (this.subscription = null,
          e?.delete(),
          this.setStatus()) : new oy(ay.error,`Error unsubscribing`,`Could not unsubscribe from push notifications for an unknown reason.`).show()
      }
      async setServiceWorkerRegistration(e) {
          if (this.registration = e,
          !this.registration || !this.registration.pushManager) {
              this.subscriptionStatus = bY.ineligible;
              return
          }
          this.subscription = await this.registration.pushManager.getSubscription(),
          await this.setStatus()
      }
      async setUser(e) {
          this.user = e,
          await this.setStatus()
      }
      async setStatus() {
          if (typeof Notification > `u`)
              this.subscriptionStatus = bY.ineligible;
          else if (Notification.permission === `denied`)
              this.subscriptionStatus = bY.denied;
          else if (!this.user || !this.registration)
              this.subscriptionStatus = bY.unknown;
          else if (!this.registration.pushManager)
              this.subscriptionStatus = bY.ineligible;
          else {
              if (!this.subscription && ei.getPersistent(`subscribed_to_push_notifications`, this.user) && !await this.subscribeUser(!1)) {
                  this.subscriptionStatus = bY.error;
                  return
              }
              this.subscriptionStatus = this.subscriptionForThisBrowser ? bY.subscribed : bY.unsubscribed
          }
      }
      get subscriptionForThisBrowser() {
          if (!(!this.user || !this.subscription)) {
              for (let e of this.user.pushSubscriptions.elements)
                  if ((0,
                  yY.default)(e.data, this.subscription.toJSON()))
                      return e
          }
      }
  }
  ,
  M([I], xY.prototype, `subscribeUser`, null),
  M([I], xY.prototype, `unsubscribeUser`, null),
  M([I], xY.prototype, `setServiceWorkerRegistration`, null),
  M([I], xY.prototype, `setUser`, null),
  M([I], xY.prototype, `setStatus`, null)
}
)), CY, wY, TY = t(( () => {
  Zv(),
  OU(),
  cm(),
  CY = 30,
  wY = class e {
      static #e = this.MAX_VALUE = 2 ** CY - 1;
      static create(t, n) {
          n === sm.FULLY_LOADED_INDEX_NAME && (n = void 0);
          let r = `${t}:${n ?? ``}`
            , i = 2166136261;
          for (let e = 0; e < r.length; e++)
              i ^= r.charCodeAt(e),
              i = Math.imul(i, 16777619);
          let a = i >>> 0;
          if (CY === 32)
              return a;
          let o = e.MAX_VALUE;
          return (a >>> 32 - CY ^ a & o) & o
      }
      static validate(t) {
          return typeof t == `number` && t >= 0 && t <= e.MAX_VALUE
      }
      static isSubscribed(e, t) {
          if (Array.isArray(t)) {
              if (t.some(t => e.has(t)))
                  return !0
          } else if (e.has(t))
              return !0;
          return !1
      }
      static deduplicate(e) {}
      static getFullySubscribedModels(t) {
          return Array.isArray(t) ? DU.allServerModelNames().filter(n => t.includes(e.create(n))) : DU.allServerModelNames().filter(n => t.has(e.create(n)))
      }
      static #t = this.allSubscribedSyncGroups = H.all().filter(e => !H.isPublicTeamsAccess(e))
  }
}
));
function EY(e, t) {
  let n = no()
    , r = setTimeout( () => n.reject(new DY(`Promise timed out`)), t);
  return Promise.resolve(e).then(e => n.resolve(e)).catch(e => n.reject(e)).finally( () => {
      clearTimeout(r)
  }
  ),
  n
}
var DY, OY = t(( () => {
  ro(),
  DY = class extends Error {
      constructor(e) {
          super(e),
          Object.defineProperty(this, `name`, {
              value: `TimeoutError`
          })
      }
  }
}
)), kY, AY = t(( () => {
  Xn(),
  Os(),
  Ho(),
  $J(),
  kY = class e {
      static addStartupSpanTag(e, t) {
          this.startupTags[e] = t
      }
      static reportStartupSpans() {
          if (Ds.hasBeenHiddenDuringSession)
              return;
          let {spans: t, bootstrapType: n} = e.getStartupSpanData();
          if (!QJ)
              switch (n) {
              case `full`:
                  Vo.increment(`startup.bootstrap.full`),
                  Vo.reportSpans(`Startup`, `Full bootstrap`, t, this.startupTags);
                  break;
              case `partial`:
                  Vo.increment(`startup.bootstrap.partial`),
                  Vo.reportSpans(`Startup`, `Partial bootstrap`, t, this.startupTags);
                  break;
              default:
                  Vo.increment(`startup.bootstrap.local`),
                  Vo.reportSpans(`Startup`, `Local bootstrap`, t, this.startupTags);
                  break
              }
      }
      static getStartupSpanData() {
          let e = performance.getEntriesByType(`measure`)
            , t = [];
          for (let n of e)
              n.startTime && n.duration && t.push({
                  name: n.name,
                  startTime: n.startTime,
                  endTime: n.startTime + n.duration
              });
          return {
              spans: t,
              bootstrapType: this.startupTags[`bootstrap.type`]
          }
      }
      static #e = this.startupTags = {
          "client.connection": navigator.connection?.effectiveType || `unknown`,
          "client.downlink": navigator.connection?.downlink?.toString() || `unknown`,
          "client.countryCode": Jn.COUNTRY_CODE || `unknown`
      }
  }
}
)), jY, MY = t(( () => {
  to(),
  zn(),
  Zv(),
  TY(),
  pi(),
  ws(),
  Qp(),
  es(),
  Tm(),
  nm(),
  N(),
  jY = class {
      static applyDeltaSyncOnModelObjectCollection(e, t) {
          if (t.length === 0)
              return e;
          let n = {}
            , r = {};
          for (let t of e)
              n[t.id] = t,
              r[t.__class] || (r[t.__class] = []),
              r[t.__class].push(t);
          let i = new Set;
          for (let e of t)
              (e.action === `A` || e.action === `D`) && i.add(e.modelId);
          let a = !1;
          for (let i of t) {
              let t = i.action;
              if (t === `I` || t === `V` || t === `U`) {
                  let t = n[i.modelId];
                  t ? Object.assign(t, i.data) : (a ||= (e = [...e],
                  !0),
                  e.push({
                      ...i.data,
                      __class: i.modelName
                  }))
              } else if (t === `B`) {
                  for (let e of r[i.modelName] ?? [])
                      if (this.shouldApplyBulkOperationToValue(e, i.data)) {
                          let {indexedKey: t, operation: n} = i.data;
                          e[t] = this.applyBulkOperationToValue(n, e[t])
                      }
              }
          }
          return e.filter(e => !i.has(e.id))
      }
      static applySyncActionRecords(e, t) {
          if (!t?.length)
              return e;
          let n = new Set
            , r = new Map;
          for (let e of t)
              e.action === `B` ? r.set(e.modelName, (r.get(e.modelName) ?? []).concat(e.operation)) : e.action === `A` || e.action === `D` ? n?.add(e.id) : y(e.action);
          return e.filter(e => !n?.has(e.id || ``)).map(e => {
              let t = r?.get(e.__class);
              if (!t?.length)
                  return e;
              for (let {indexedKey: n, operation: r, filters: i} of t)
                  this.modelMatchesFilters(e, i) && (e[n] = this.applyBulkOperationToValue(r, e[n]));
              return e
          }
          )
      }
      static modelMatchesFilters(e, t) {
          if (!t)
              return !0;
          for (let n in t)
              if (e[n] !== t[n])
                  return !1;
          return !0
      }
      static shouldApplyBulkOperationToValue(e, t) {
          let {filters: n, operation: r, indexedKey: i} = t
            , a = e[i];
          switch (r.type) {
          case `UPDATE`:
              return a === r.oldKeyValue && this.modelMatchesFilters(e, n);
          case `REPLACE`:
          case `REPLACE_DISTINCT`:
          case `REMOVE`:
              return this.modelMatchesFilters(e, n) && Array.isArray(a) && a.includes(r.oldKeyValue);
          default:
              return y(r),
              !1
          }
      }
      static applyBulkOperationToValue(e, t) {
          switch (e.type) {
          case `UPDATE`:
              return t === e.oldKeyValue ? e.newKeyValue : t;
          case `REPLACE`:
              if (Array.isArray(t) && t.includes(e.oldKeyValue)) {
                  let {oldKeyValue: n, newKeyValue: r} = e;
                  return t.map(e => e === n ? r : e)
              }
              return t;
          case `REPLACE_DISTINCT`:
              if (Array.isArray(t) && t.includes(e.oldKeyValue)) {
                  let {oldKeyValue: n, newKeyValue: r} = e;
                  return t.includes(r) ? t.filter(e => e !== n) : t.map(e => e === n ? r : e)
              }
              return t;
          case `REMOVE`:
              return Array.isArray(t) && t.includes(e.oldKeyValue) ? t.filter(t => t !== e.oldKeyValue) : t;
          default:
              return y(e),
              t
          }
      }
      static async getDeltaSyncGroupChanges(e, t, n, r) {
          let i = new Set(n?.all), a = (e, t) => {
              let n = e.filter(e => !i.has(e))
                , r = i ? Array.from(i).filter(t => !e.includes(t)) : [];
              if (t && !t.some(e => i.has(e) || n.includes(e))) {
                  let e = t.filter(e => !H.isConstant(e) && !r.includes(e));
                  e.length > 0 && r.push(...e)
              }
              return {
                  addedGroups: n,
                  removedGroups: r
              }
          }
          , o = new Set, s = new Set, c = new Map, l = new Set, u = new Set, d = 0, f;
          for (let e of r)
              if (e.action === `G` || e.action === `S`) {
                  d = Math.max(d, e.id);
                  let t = a(e.data.syncGroups, e.action === `G` ? e.data.entitySyncGroups : void 0);
                  for (let n of t.addedGroups)
                      i.add(n),
                      s.has(n) ? s.delete(n) : (o.add(n),
                      e.action === `G` && e.data.newSyncGroup === !0 && u.add(n),
                      (e.action !== `G` || !u.has(n)) && l.add(n));
                  for (let e of t.removedGroups)
                      i.delete(e),
                      o.has(e) ? o.delete(e) : s.add(e),
                      l.delete(e);
                  c.set(e.id, t.removedGroups),
                  f = {
                      all: new Set(e.data.syncGroups),
                      optimized: new Set(e.data.syncGroupsOptimized)
                  }
              }
          let p, m = 0;
          if (l.size > 0) {
              let n = t.modelsToLoadForNewSyncGroups()
                , r = await Qa.executeWithRetries({
                  maxRetries: di.getValue(di.bootstrapRatelimitedInSyncDeltaRetryCount, 3),
                  backoff: e => Jo(e) && e.metaData?.rateLimitResult?.duration || 1e3,
                  shouldRetry: e => Jo(e)
              }, async () => {
                  let r = d;
                  r === 0 && w.error(`First syncid is 0 when loading new sync groups. This should never happen.`);
                  let i = [];
                  for (let e of n)
                      for (let t of l) {
                          let n = em.getModelClass(e)
                            , r = wm.createPartialIndex({
                              modelClass: n,
                              syncGroup: t
                          }).value;
                          i.push(wY.create(e, r))
                      }
                  await e.ensureSubscribed(i);
                  let a = await t.loadPartialModels(n, [...l], r);
                  return w.remote(`Loaded new sync groups models`, {
                      modelsToLoad: n,
                      loadSyncGroups: l,
                      firstSyncId: r,
                      returnedModelsCount: a?.returnedModelsCount
                  }),
                  a
              }
              );
              r && (p = r.data,
              m = r.lastSyncId)
          }
          for (let[e,t] of c.entries()) {
              let n = t.filter(e => s.has(e));
              n.length > 0 ? c.set(e, n) : c.delete(e)
          }
          return {
              updatedUserSyncGroups: f && (o.size > 0 || s.size > 0) ? f : void 0,
              loadedSyncGroups: p ? {
                  syncGroups: [...l],
                  models: p,
                  lastSyncId: m
              } : void 0,
              perPacketRemovedSyncGroups: c
          }
      }
  }
  ,
  M([Zp.trace(`startup`)], jY, `getDeltaSyncGroupChanges`, null)
}
)), NY, PY = t(( () => {
  ws(),
  NY = class {
      static fullBootstrap(e, t, n) {
          w.remote(`[Sync] Full bootstrap completed`, {
              lastSyncId: e,
              returnedModelsCount: t,
              method: n
          })
      }
      static partialBootstrap(e, t, n) {
          w.remote(`[Sync] Partial bootstrap completed`, {
              lastSyncId: e,
              loadedModels: t,
              returnedModelsCount: n
          })
      }
      static deltaSync(e, t, n, r) {
          w.remote(`[Sync] Delta sync completed`, {
              fromSyncId: e,
              toSyncId: t,
              packetCount: n,
              syncIdRange: t - e,
              partOfBootstrap: r
          })
      }
      static deltaSyncFailure(e, t, n, r) {
          w.remote(`[Delta] Delta sync failed`, {
              error: e,
              fromSyncId: t,
              toSyncId: n,
              syncIdRange: n ? n - t : `unbounded`,
              failureCount: r
          })
      }
      static syncGroupsAdded(e, t, n) {
          w.remote(`[Sync] Added sync groups`, {
              lastSyncId: n,
              syncGroups: e,
              modelCount: t
          })
      }
      static syncGroupsRemoved(e, t) {
          w.remote(`[Sync] Removed sync groups`, {
              syncGroups: e,
              syncId: t
          })
      }
      static userSyncGroupsChanged(e) {
          w.remote(`[Sync] User sync groups changed`, {
              allCount: `length`in e.all ? e.all.length : e.all.size,
              optimizedCount: `length`in e.optimized ? e.optimized.length : e.optimized.size
          })
      }
  }
}
)), FY, IY, LY, RY = t(( () => {
  FY = e(qp(), 1),
  IY = e(oe(), 1),
  OU(),
  Xv(),
  ws(),
  AY(),
  Qp(),
  nm(),
  om(),
  es(),
  ai(),
  $J(),
  cX(),
  MY(),
  PY(),
  N(),
  LY = class e {
      static #e = this.constructorName = `BootstrapHelper`;
      static async fullBootstrap(t, n, r, i) {
          if (kY.addStartupSpanTag(`fullBootstrap`, !0),
          w.network(`Full bootstrap`),
          i?.forceNoCache !== !0 && !QJ) {
              w.network(`Full bootstrap sync groups`, {
                  syncGroups: r.optimized
              });
              let a = this.splitToCacheableRequests(t.userId, r, n);
              kY.addStartupSpanTag(`bootstrap.requests`, a.length);
              let o = 2
                , s = (await Promise.all(a.map(async e => {
                  let n = `/sync/bootstrap?type=full&noSyncPackets=true&useCFCaching=true&noCache=true`;
                  n += `&syncGroups=${e.syncGroups.join(`,`)}`,
                  n += `&onlyModels=${e.onlyModels.join(`,`)}`,
                  n += `&modelsHash=${e.modelsHash}`;
                  let r = await t.restModelsStream(n).catch(async r => {
                      if (r instanceof $o && r.flags?.noSyncGroupsAccess === !0) {
                          w.info(`No sync groups access`, {
                              syncGroups: e.syncGroups
                          });
                          return
                      }
                      if (r instanceof $o && (r.metaData?.edgeCacheStatus === `hit` || r.metaData?.edgeCacheStatus === `unknown`))
                          return n += `&forceInvalidateCFCache=true`,
                          kY.addStartupSpanTag(`bootstrap.forceInvalidateCFCache`, !0),
                          await t.restModelsStream(n);
                      if (r instanceof $o && r.flags?.generatingBootstrapCacheRetryIn)
                          return await ri(r.flags.generatingBootstrapCacheRetryIn),
                          n += `&forceBypassCacheDeduplication=true`,
                          kY.addStartupSpanTag(`bootstrap.forceBypassCacheDeduplication`, !0),
                          await t.restModelsStream(n);
                      throw r
                  }
                  );
                  return o = Math.min(o, this.edgeCacheHitScore(t.userId, e.syncGroups, r)),
                  r
              }
              ))).concrete();
              if (s.length === 0)
                  throw Error(`Nothing to bootstrap`);
              kY.addStartupSpanTag(`bootstrap.edgeCacheHit`, o);
              let c = e.combineMetadata(s)
                , l = []
                , u = e.combineModels(s);
              if (Object.keys(c.returnedModelsCount ?? {}).length === 0)
                  return w.network(`Full bootstrap returned no models, retrying without cache`),
                  await this.fullBootstrap(t, n, r, {
                      ...i,
                      forceNoCache: !0
                  });
              let d = this.getBootstrapResults(c, u, l);
              return w.network(`Full bootstrap done`, {
                  lastSyncId: d.lastSyncId,
                  returnedModelsCount: c.returnedModelsCount
              }),
              NY.fullBootstrap(d.lastSyncId, c.returnedModelsCount, d.method),
              d
          } else {
              let e = `/sync/bootstrap?type=full&onlyModels=${n.join(`,`)}`;
              i?.forceNoCache === !0 && (e += `&noCache=true`);
              let r = await t.restModelsStream(e)
                , a = (r.syncActions || []).reverse()
                , o = this.getBootstrapResults(r.metadata, r.models, a);
              return w.network(`Full bootstrap done`, {
                  lastSyncId: o.lastSyncId,
                  returnedModelsCount: r.metadata.returnedModelsCount
              }),
              NY.fullBootstrap(o.lastSyncId, r.metadata.returnedModelsCount, o.method),
              o
          }
      }
      static async partialBootstrap(t, n, r, i, a=!1) {
          let o = Yv(r) ? r : void 0;
          i.partOfBootstrap ? kY.addStartupSpanTag(`partialBootstrap`, !0) : i.partOfBootstrap || Zp.addArguments(`syncGroupBootstrap`),
          w.network(`Partial bootstrap`, {
              modelsToLoad: n,
              syncGroupsToLoad: o
          });
          let s, c;
          if (i?.forceNoCache !== !0) {
              w.network(`Partial bootstrap sync groups`, {
                  syncGroups: Yv(r) ? r : r.optimized
              });
              let o = this.splitToCacheableRequests(t.userId, r, n);
              kY.addStartupSpanTag(`bootstrap.requests`, o.length);
              let l = 2
                , u = (await Promise.all(o.map(async e => {
                  let n = `/sync/bootstrap?type=partial&noSyncPackets=true&useCFCaching=true&noCache=true`;
                  n += `&firstSyncId=${i.firstSyncId ?? ``}`,
                  n += `&syncGroups=${e.syncGroups.join(`,`)}`,
                  n += `&onlyModels=${e.onlyModels.join(`,`)}`,
                  n += `&modelsHash=${e.modelsHash}`;
                  let r = await t.restModelsStream(n).catch(async r => {
                      if (r instanceof $o && r.flags?.noSyncGroupsAccess === !0) {
                          w.info(`No sync groups access`, {
                              syncGroups: e.syncGroups
                          });
                          return
                      }
                      if (r instanceof $o && (r.metaData?.edgeCacheStatus === `hit` || r.metaData?.edgeCacheStatus === `unknown`))
                          return n += `&forceInvalidateCFCache=true`,
                          i.partOfBootstrap && kY.addStartupSpanTag(`bootstrap.forceInvalidateCFCache`, !0),
                          await t.restModelsStream(n);
                      if (r instanceof $o && r.flags?.generatingBootstrapCacheRetryIn)
                          return await ri(r.flags.generatingBootstrapCacheRetryIn),
                          n += `&forceBypassCacheDeduplication=true`,
                          i.partOfBootstrap && kY.addStartupSpanTag(`bootstrap.forceBypassCacheDeduplication`, !0),
                          await t.restModelsStream(n);
                      throw r
                  }
                  );
                  return l = Math.min(l, this.edgeCacheHitScore(t.userId, e.syncGroups, r)),
                  r
              }
              ))).concrete();
              if (u.length === 0)
                  return;
              i.partOfBootstrap && kY.addStartupSpanTag(`bootstrap.edgeCacheHit`, l);
              try {
                  let r = o.flatMap(e => e.syncGroups);
                  c = e.combineMetadata(u);
                  let a = c.lastSyncId < i.lastSyncId ? await this.fetchDeltaPackets(t, c.lastSyncId, void 0, {
                      modelNames: n,
                      syncGroups: r,
                      onlyModelPackets: !0,
                      bootstrapType: sX.partial
                  }) : void 0
                    , l = jY.applyDeltaSyncOnModelObjectCollection(e.combineModels(u), a?.delta || []);
                  s = this.getBootstrapResults(c, l, [])
              } catch (e) {
                  if (!a && e instanceof $o && e.flags?.reSyncRequired === !0)
                      return w.warning(`Partial bootstrap retry required as delta is too big`),
                      await this.partialBootstrap(t, n, r, i, !0);
                  throw e
              }
          } else {
              let e = `/sync/bootstrap?type=partial&onlyModels=${n.join(`,`)}`;
              o && (e += `&syncGroups=${o.join(`,`)}`),
              i?.firstSyncId && (e += `&firstSyncId=${i.firstSyncId}`),
              i?.forceNoCache === !0 && (e += `&noCache=true`);
              let r = await t.restModelsStream(e)
                , a = (r.syncActions || [])?.reverse()
                , l = jY.applyDeltaSyncOnModelObjectCollection(r.models, a);
              c = r.metadata,
              s = this.getBootstrapResults(c, l, [])
          }
          return w.network(`Partial bootstrap done`, {
              modelsToLoad: n,
              syncGroupsToLoad: o,
              returnedModelsCount: c.returnedModelsCount
          }),
          i.partOfBootstrap && NY.partialBootstrap(s.lastSyncId, n, c.returnedModelsCount),
          s
      }
      static async fetchDeltaPackets(e, t, n, r) {
          let i = `/sync/delta?lastSyncId=${t}`;
          n && (i += `&toSyncId=${n}`),
          r?.modelNames && (i += `&modelNames=${r?.modelNames.join(`,`)}`),
          r?.syncGroups && (i += `&syncGroups=${r?.syncGroups.join(`,`)}`),
          r?.syncSubscriptions && (i += `&syncSubscriptions=${r?.syncSubscriptions.join(`,`)}`),
          r?.onlyModelPackets && (i += `&onlyModelPackets=true`),
          r?.bootstrapType && (i += `&bootstrapType=${r.bootstrapType}`);
          let a = await e.restModelsStream(i)
            , o = a.syncActions || [];
          return o.reverse(),
          w.network(`Received ${o.length} delta packets`, {
              fromSyncId: t,
              toSyncId: n,
              length: o.length
          }),
          {
              delta: o,
              metadata: a.metadata
          }
      }
      static async fetchUserSyncGroups(e) {
          return await e.restExecute(`/sync/user_sync_groups`)
      }
      static splitToCacheableRequests(e, t, n) {
          let r = Yv(t) ? t : t.optimized
            , i = r.length;
          if (i > 50) {
              w.remote(`BootstrapHelper: sync groups to load is greater than 50, doing a special request`, {
                  syncGroupsCount: i
              });
              let t = (0,
              IY.default)(r, 50);
              return e && r.includes(e) ? [...this.getSyncGroupsRequest(e, [e], n) ?? [], ...t.flatMap(t => this.getSyncGroupsRequest(e, t.filter(t => t !== e), n))].concrete() : t.flatMap(t => this.getSyncGroupsRequest(e, t, n)).concrete()
          }
          return r.flatMap(t => this.getSyncGroupsRequest(e, [t], n)).concrete()
      }
      static getSyncGroupsRequest(e, t, n) {
          let r = t.flatMap(t => n.filter(n => DU.canHaveSyncGroup(e, n, t))).distinct();
          if (r.length === 0)
              return;
          let i = []
            , a = [];
          for (let e of r)
              em.getModelClass(e)?.loadStrategy === rm.partial ? i.push([e]) : a.push(e);
          return a.length && i.push(a),
          i.map(e => ({
              onlyModels: e,
              modelsHash: (0,
              FY.default)(e.map(e => em.propertyHashOfModel(e)).sort().join(`,`)),
              syncGroups: t
          }))
      }
      static edgeCacheHitScore(e, t, n) {
          return n ? t.length === 1 && t[0] === e ? n?.edgeCacheHit === !0 ? 2 : 1 : n?.edgeCacheHit === !0 ? 2 : 0 : 2
      }
      static combineModels(e) {
          let t = new Set;
          return e.flatMap(e => {
              let n = e.models.filter(e => !t.has(e.id));
              return n.forEach(e => t.add(e.id)),
              n
          }
          )
      }
      static combineMetadata(e) {
          if (e.length === 0)
              throw Error(`No results to combine`);
          return {
              ...e[0].metadata,
              method: e[0].metadata.method,
              lastSyncId: e.reduce( (e, {metadata: t}) => Math.min(e, t.lastSyncId), e[0].metadata.lastSyncId),
              maxSyncId: e.reduce( (e, {metadata: t}) => Math.max(e, t.maxSyncId), e[0].metadata.maxSyncId),
              returnedModelsCount: e.reduce( (e, {metadata: t}) => {
                  for (let[n,r] of Object.entries(t.returnedModelsCount || {}))
                      e[n] = (e[n] || 0) + r;
                  return e
              }
              , {})
          }
      }
      static getBootstrapResults(e, t, n) {
          return {
              databaseVersion: e.databaseVersion || 0,
              lastSyncId: e.lastSyncId || 0,
              method: e.method,
              data: t,
              syncDeltaPackets: n,
              returnedModelsCount: e.returnedModelsCount
          }
      }
  }
  ,
  M([Zp.trace(`startup`)], LY, `fullBootstrap`, null),
  M([Zp.trace(`startup`)], LY, `partialBootstrap`, null),
  M([Zp.trace(`startup`)], LY, `fetchDeltaPackets`, null),
  M([Zp.trace(`startup`)], LY, `fetchUserSyncGroups`, null)
}
)), zY, BY, VY, HY = t(( () => {
  zY = `_transactions`,
  BY = `_meta`,
  VY = function(e) {
      return e[e.forceOn = 1] = `forceOn`,
      e[e.forceOff = 2] = `forceOff`,
      e
  }({})
}
)), UY, WY, GY, KY = t(( () => {
  yn(),
  UY = e(qp(), 1),
  WY = e(oe(), 1),
  ro(),
  ai(),
  ws(),
  nm(),
  Xp(),
  HY(),
  GY = class {
      get isReady() {
          return this.ready
      }
      get requiresFlushing() {
          return this.cachedData !== void 0 && !this.flushed
      }
      get isCurrentlyFlushing() {
          return this.cachedData !== void 0 && this.flushed && !this.flushErrored
      }
      waitUntilReady() {
          return this.ready ? Yp : this.readyPromise
      }
      get cacheSize() {
          return this.cachedData?.length
      }
      constructor(e, t, n) {
          this.ready = !1,
          this.flushed = !1,
          this.flushErrored = !1,
          this.graphQLClient = t,
          this.modelName = e,
          this.options = n,
          this.storeName = (0,
          UY.default)(e + em.propertyHashOfModel(e)),
          this.readyPromise = new Promise(e => {
              this.readyPromiseResolver = e
          }
          )
      }
      async modelCount(e) {
          return this.cachedData ? this.cachedData.length : await e.count(this.storeName) || 0
      }
      async getById(e, t, n, r) {
          if (!this.isReady) {
              if (r?.onlyIfLocallyAvailable)
                  return;
              await this.waitUntilReady()
          }
          return this.cachedData ? this.cachedData.find(e => e.id === n) : await t.addRequest({
              modelName: this.modelName,
              id: n
          })
      }
      async getAllForIndexedKey(e, t, n, r) {
          return this.cachedData ? this.cachedData.filter(e => Array.isArray(e[n.key]) ? e[n.key].includes(n.value) : e[n.key] === n.value) : t ? await t.addRequest({
              modelName: this.modelName,
              key: n.key,
              value: n.value
          }) : []
      }
      async getByIds(e, t) {
          return this.isReady || await this.waitUntilReady(),
          this.cachedData ? this.cachedData.filter(e => t.includes(e.id)) : await e.addRequest({
              modelName: this.modelName,
              ids: t
          })
      }
      async getAll(e) {
          return this.isReady || await this.waitUntilReady(),
          this.cachedData ? this.cachedData : await e.getAll(this.storeName)
      }
      checkStore(e, t, n) {
          n.has(this.storeName) || (w.network(`Creating new store ${this.storeName} for model ${this.modelName}`),
          t.objectStore(BY).put({
              persisted: !1
          }, this.modelName),
          e.createObjectStore(this.storeName, {
              keyPath: `id`
          })),
          this.createIndexes(t),
          n.delete(this.storeName)
      }
      async clearStore(e) {
          return e.clear(this.storeName)
      }
      setModelData(e) {
          this.cachedData = e,
          this.ready = !0,
          this.flushed = !1,
          this.readyPromiseResolver()
      }
      async checkIsReady(e) {
          let[t,n] = await Promise.all([e.objectStore(BY).get(this.modelName), e.objectStore(this.storeName).count()]);
          t && typeof t == `object` && t.persisted && (!this.options.required || n > 0) ? (this.ready = !0,
          this.readyPromiseResolver()) : this.ready = !1
      }
      async setIsReady(e) {
          let t = e.transaction([BY], `readwrite`, {
              durability: `relaxed`
          });
          await t.objectStore(BY).put({
              persisted: !0
          }, this.modelName),
          await t.done,
          this.ready = !0,
          this.readyPromiseResolver()
      }
      async hasModelsForPartialIndexes(e, t, n) {
          return !0
      }
      async removeLoadedPartialIndexes(e, t) {
          return []
      }
      async setPartialIndex(e, t) {}
      async getPartialIndexes(e) {
          return []
      }
      inflightRequestForPartialIndexValue(e) {}
      async flush(e, t=!0) {
          if (!this.cachedData || this.flushed)
              return;
          this.flushed = !0;
          let n = (0,
          WY.default)(this.cachedData, 1e4);
          n.length === 0 && n.push([]),
          w.network(`Flushing object store ${this.modelName}`, {
              chunks: n.length,
              models: this.cachedData.length
          });
          try {
              t && e.clear(this.storeName);
              let r = [];
              for (; n.length; ) {
                  let i = n.shift()
                    , a = n.length === 0 ? [this.storeName, BY] : [this.storeName]
                    , o = e.transaction(a, `readwrite`, {
                      durability: `relaxed`
                  })
                    , s = vn(o)
                    , c = s.objectStore(this.storeName);
                  for (let e of i || [])
                      if (t)
                          c.put(e);
                      else {
                          let t = c.add(e);
                          t.onerror = e => {
                              if (t.error?.name === `ConstraintError`) {
                                  e.preventDefault(),
                                  e.stopPropagation();
                                  return
                              }
                              throw t.error
                          }
                      }
                  n.length === 0 && s.objectStore(BY).put({
                      persisted: !0
                  }, this.modelName),
                  r.push(o.done),
                  await ri(0)
              }
              let i = no();
              return Promise.all(r).then(async () => {
                  this.flushed = !1,
                  this.cachedData = void 0,
                  this.ready = !0,
                  this.readyPromiseResolver(),
                  i.resolve()
              }
              ).catch( () => {
                  this.flushErrored = !0,
                  i.reject()
              }
              ),
              {
                  writeComplete: i
              }
          } catch (e) {
              throw this.flushErrored = !0,
              e
          }
      }
      createIndexes(e) {
          let t = e.objectStore(this.storeName)
            , n = em.propertiesOfModel(this.modelName);
          for (let e in n) {
              let r = n[e];
              r.indexed && (t.indexNames.contains(e) || (w.network(`Creating${r.multiEntry ? ` multientry` : ``} index ${e} for model ${this.modelName}`),
              t.createIndex(e, e, {
                  multiEntry: r.multiEntry
              })))
          }
      }
  }
}
)), qY, JY = t(( () => {
  KY(),
  nm(),
  Xp(),
  qY = class e extends GY {
      static #e = this.immediateCacheThreshold = 200;
      static #t = this.memoryCacheThreshold = 5e3;
      static #n = this.schemaVersion = 1;
      constructor(e, t) {
          super(e, t, {
              required: !1
          }),
          this.hasCheckedMemoryCache = !1,
          this.partialIndexStoreName = this.storeName + `_partial`
      }
      checkStore(e, t, n) {
          super.checkStore(e, t, n),
          n.has(this.partialIndexStoreName) || e.createObjectStore(this.partialIndexStoreName, {
              keyPath: `id`
          }),
          n.delete(this.partialIndexStoreName)
      }
      async clearStore(e) {
          return await super.clearStore(e),
          this.partialIndexKeyMemoryCache = new Set,
          this.hasCheckedMemoryCache = !0,
          e.clear(this.partialIndexStoreName)
      }
      waitUntilReady() {
          return Yp
      }
      async getById(e, t, n, r) {
          if (!this.isReady) {
              let i = [{
                  value: n
              }]
                , a = await super.getById(e, t, n);
              return a && a !== `needs_network_hydration` ? a : r?.onlyIfLocallyAvailable || e && (i === void 0 || await this.hasModelsForPartialIndexes(e, i) || r?.canSkipNetworkHydration && await r?.canSkipNetworkHydration()) || !em.getModelClass(this.modelName) ? void 0 : `needs_network_hydration`
          }
          return super.getById(e, t, n)
      }
      async getAllForIndexedKey(e, t, n, r) {
          return this.isReady ? await super.getAllForIndexedKey(e, t, n) : e && t && (n.coveringPartialIndexes === void 0 || await this.hasModelsForPartialIndexes(e, n.coveringPartialIndexes) || await r?.canSkipNetworkHydration?.()) ? await t.addRequest({
              modelName: this.modelName,
              key: n.key,
              value: n.value
          }) : `needs_network_hydration`
      }
      async hasModelsForPartialIndexes(e, t, n) {
          if (this.isReady)
              return !0;
          if (t.length === 0)
              return !1;
          if (await this.initializeMemoryCache(e),
          this.partialIndexKeyMemoryCache !== void 0)
              return n?.requireAll ? t.every(e => this.partialIndexKeyMemoryCache.has(e.value)) : t.some(e => this.partialIndexKeyMemoryCache.has(e.value));
          if (n?.requireAll) {
              for (let n of t)
                  if (!await e.get(this.partialIndexStoreName, IDBKeyRange.only(n.value)))
                      return !1;
              return !0
          } else {
              for (let n of t)
                  if (await e.get(this.partialIndexStoreName, IDBKeyRange.only(n.value)))
                      return !0;
              return !1
          }
      }
      async removeLoadedPartialIndexes(e, t) {
          if (this.isReady || t.length === 0)
              return [];
          let n = e.transaction(this.partialIndexStoreName, `readonly`).objectStore(this.partialIndexStoreName);
          if (await n.count() < 5e3) {
              let e = await n.getAll()
                , r = new Set(e.map(e => e.id));
              return t.filter(e => !r.has(e.value)).map(e => e.value)
          } else {
              let e = [];
              for (let r of t)
                  await n.getKey(r.value) === void 0 && e.push(r.value);
              return e
          }
      }
      async setPartialIndex(e, t) {
          this.partialIndexKeyMemoryCache?.add(t);
          let n = e.put(this.partialIndexStoreName, {
              id: t
          });
          this.partialIndexKeyMemoryCache || await n,
          this.partialIndexKeyMemoryCache?.add(t)
      }
      deletePartialIndexValue(e, t) {
          this.partialIndexKeyMemoryCache && !this.partialIndexKeyMemoryCache.has(t) || (this.partialIndexKeyMemoryCache?.delete(t),
          e.objectStores[this.modelName].delete(IDBKeyRange.only(t)),
          e.transaction.done.then( () => {
              this.partialIndexKeyMemoryCache?.delete(t)
          }
          ))
      }
      async getPartialIndexes(e) {
          return await this.initializeMemoryCache(e),
          this.partialIndexKeyMemoryCache === void 0 ? (await e.getAll(this.partialIndexStoreName)).map(e => e.id) : Array.from(this.partialIndexKeyMemoryCache)
      }
      async initializeMemoryCache(t) {
          if (this.partialIndexKeyMemoryCache !== void 0 || this.hasCheckedMemoryCache)
              return;
          this.hasCheckedMemoryCache = !0;
          let n = await t.count(this.partialIndexStoreName);
          if (n <= e.immediateCacheThreshold) {
              let e = await t.getAll(this.partialIndexStoreName);
              this.partialIndexKeyMemoryCache = new Set(e.map(e => e.id))
          } else
              n <= e.memoryCacheThreshold && t.getAll(this.partialIndexStoreName).then(e => {
                  this.partialIndexKeyMemoryCache = new Set(e.map(e => e.id))
              }
              )
      }
  }
}
)), YY, XY, Xue = t(( () => {
  yn(),
  YY = e(qp(), 1),
  ro(),
  ng(),
  XY = class {
      constructor() {
          this.storeIsEmpty = !1,
          this.storeName = (0,
          YY.default)(`syncActionStore` + Qh.syncActionStoreVersion)
      }
      checkStore(e, t) {
          if (!t.has(this.storeName)) {
              let t = e.createObjectStore(this.storeName, {
                  keyPath: `id`
              });
              t.createIndex(`syncId`, `syncId`),
              t.createIndex(`modelName`, `modelName`),
              this.storeIsEmpty = !0
          }
          t.delete(this.storeName)
      }
      async getDeletionsAndBatchUpdates(e, t, n) {
          if (this.storeIsEmpty)
              return [];
          let r = no()
            , i = []
            , a = vn(e).objectStore(this.storeName).index(`modelName`).openCursor(IDBKeyRange.only(t));
          return a.onsuccess = function() {
              let e = a.result;
              if (e) {
                  let t = e.value;
                  t.syncId >= n && (t.action ||= `D`,
                  i.push(t)),
                  e.continue()
              } else
                  r.resolve(i)
          }
          ,
          r
      }
      async cleanupStore(e, t) {
          if (this.storeIsEmpty)
              return;
          let n = no()
            , r = vn(e).objectStore(this.storeName)
            , i = r.index(`syncId`).openKeyCursor(IDBKeyRange.upperBound(t));
          return i.onsuccess = function() {
              let e = i.result;
              e ? (e.primaryKey && r.delete(e.primaryKey),
              e.continue()) : n.resolve()
          }
          ,
          n
      }
      addSyncPacket(e, t) {
          if (this.storeIsEmpty = !1,
          t.action === `I` || t.action === `V` || t.action === `U`)
              t.modelId && e.delete(t.modelId);
          else if (t.action === `A` || t.action === `D`) {
              let n = {
                  id: t.modelId,
                  modelName: t.modelName,
                  syncId: t.id,
                  action: t.action
              };
              e.put(n)
          } else if (t.action === `B`) {
              let n = {
                  id: `B-${t.modelName}-${t.id}`,
                  modelName: t.modelName,
                  syncId: t.id,
                  action: t.action,
                  operation: t.data
              };
              e.put(n)
          }
      }
  }
}
)), ZY, QY, Zue = t(( () => {
  yn(),
  ZY = e(te(), 1),
  ws(),
  om(),
  nm(),
  Es(),
  KY(),
  JY(),
  HY(),
  Xue(),
  QY = class {
      get onSavingStoreCountChange() {
          return this._onSavingStoreCountChange
      }
      get requiresFlushing() {
          return this.objectStores.some(e => e.requiresFlushing)
      }
      storeIsCached(e) {
          return this.objectStore(e).cacheSize !== void 0
      }
      constructor(e, t) {
          this.objectStoreLookup = {},
          this.objectStores = [],
          this._onSavingStoreCountChange = new Ts;
          let n = t.requiredModels.map(e => e.modelName);
          for (let t of em.getModelNames()) {
              let r = em.getModelClass(t)?.loadStrategy === rm.partial ? new qY(t,e) : new GY(t,e,{
                  required: n.includes(t)
              });
              this.objectStoreLookup[t] = r,
              this.objectStores.push(r)
          }
          this.syncActionStore = new XY
      }
      createTransaction(e, t, n) {
          if (!e)
              return;
          let r = n.stores ? n.stores.map(e => this.objectStore(e)) : this.objectStores
            , i = r.map(e => e.storeName);
          n.metaStore && i.push(BY),
          n.syncActionStore && i.push(this.syncActionStore.storeName);
          try {
              let a = e.transaction(i, t, {
                  durability: `relaxed`
              })
                , o = vn(a)
                , s = {};
              for (let e of r)
                  s[e.modelName] = o.objectStore(e.storeName);
              return n.syncActionStore && (s[this.syncActionStore.storeName] = o.objectStore(this.syncActionStore.storeName)),
              n.metaStore && (s[BY] = o.objectStore(BY)),
              {
                  transaction: a,
                  objectStores: s
              }
          } catch {
              return
          }
      }
      createPartialIndexTransaction(e) {
          if (!e)
              return;
          let t = this.partialObjectStores.map(e => e.partialIndexStoreName);
          try {
              let n = e.transaction(t, `readwrite`, {
                  durability: `relaxed`
              })
                , r = vn(n)
                , i = {};
              for (let e of this.partialObjectStores)
                  i[e.modelName] = r.objectStore(e.partialIndexStoreName);
              return {
                  transaction: n,
                  objectStores: i
              }
          } catch {
              return
          }
      }
      createStores(e, t) {
          let n = new Set(e.objectStoreNames);
          n.has(`_transactions`) || e.createObjectStore(zY, {
              keyPath: `id`,
              autoIncrement: !0
          }),
          n.has(`_meta`) || e.createObjectStore(BY),
          n.delete(zY),
          n.delete(BY);
          for (let r of this.objectStores)
              r.checkStore(e, t, n);
          this.syncActionStore.checkStore(e, n),
          n.forEach(t => {
              w.network(`Deleting old store ${t}`),
              e.deleteObjectStore(t)
          }
          )
      }
      async clearStores(e) {
          await Promise.all(this.objectStores.map(t => t.clearStore(e)))
      }
      objectStore(e) {
          return this.objectStoreLookup[e]
      }
      setModelData(e, t) {
          this.objectStore(e).setModelData(t)
      }
      get readyStores() {
          return this.objectStores.filter(e => e.isReady)
      }
      async flush(e, t) {
          let n = this.objectStores.sortBy(e => e.cacheSize ?? 0).filter(e => (!t?.modelNames || t.modelNames.includes(e.modelName)) && e.requiresFlushing).map(n => n.flush(e, t?.clearStore).then(e => (e?.writeComplete.catch(ZY.default).finally( () => this.updateFlushingCount()),
          e)).catch( () => {
              this.updateFlushingCount()
          }
          ))
            , r = (await Promise.all(n)).concrete().map(e => e.writeComplete);
          return {
              updatesFlushed: Promise.all(r)
          }
      }
      async statistics(e) {
          let t = {};
          return await Promise.all(this.objectStores.map(async n => {
              t[n.modelName] = {
                  count: await n.modelCount(e),
                  partialIndexValues: await n.getPartialIndexes(e),
                  isReady: n.isReady
              }
          }
          )),
          t
      }
      async checkReadinessOfStores(e) {
          let t = e.transaction(this.objectStores.map(e => e.storeName).concat(BY), `readwrite`);
          await Promise.all(this.objectStores.map(e => e.checkIsReady(t)))
      }
      get partialObjectStores() {
          return this.objectStores.filter(e => e instanceof qY)
      }
      updateFlushingCount() {
          this._onSavingStoreCountChange.fire(this.objectStores.filter(e => e.isCurrentlyFlushing).length)
      }
  }
}
)), $Y, eX, tX, nX = t(( () => {
  ro(),
  So(),
  ws(),
  $Y = 5e3,
  eX = 10,
  tX = class {
      constructor(e) {
          this.nextBatch = [],
          this.uniqueRequests = new Map,
          this.inflightRequests = new Set,
          this.nextBatchResults = [],
          this.allProcessedResults = [],
          this.allProcessedQueuedResults = [],
          this.handleResolve = async () => {
              if (this.nextBatch.length === 0)
                  return;
              let e = this.uniqueRequests;
              this.uniqueRequests = new Map,
              this.inflightRequests.add(e);
              let t = this.nextBatch;
              this.nextBatch = [];
              let n = this.nextBatchResults.concat();
              this.nextBatchResults = [];
              try {
                  let r = await this.handleBatch(t);
                  for (let e of n)
                      e.resolve(r.result);
                  if (n = [],
                  this.allProcessedResults.length && this.allProcessedQueuedResults.push(r.result),
                  this.nextBatch.length === 0 && (this.inflightRequests.size === 0 || this.inflightRequests.size === 1 && this.inflightRequests.has(e))) {
                      for (let e of this.allProcessedResults)
                          e.resolve(this.allProcessedQueuedResults);
                      this.allProcessedQueuedResults = [],
                      this.allProcessedResults = []
                  }
                  await r.fullyPersisted
              } catch (e) {
                  t.map(t => t.reject(e));
                  for (let t of n)
                      t.reject(e);
                  for (let t of this.allProcessedResults)
                      t.reject(e);
                  this.allProcessedQueuedResults = [],
                  this.allProcessedResults = [],
                  xo(e) && e.userError ? w.info(`Network error caught in BatchedRequest.handleResolve`, e) : w.error(`Error caught in BatchedRequest.handleResolve`, e)
              } finally {
                  this.inflightRequests.delete(e)
              }
          }
          ,
          this.batchInterval = e?.batchInterval ?? eX,
          this.maxBatchedRequests = e?.maxBatchedRequests ?? $Y
      }
      nextBatchedResult() {
          let e = no();
          return this.nextBatchResults.push(e),
          e
      }
      allProcessedResult() {
          let e = no();
          return this.allProcessedResults.push(e),
          e
      }
      addRequest(e) {
          let t = this.getInflightRequest(e);
          if (t)
              return t;
          this.nextBatch.length === 0 && setTimeout(this.handleResolve, this.batchInterval);
          let n = this.serializeKeys(e);
          if (n)
              for (let e of n) {
                  let t = this.uniqueRequests.get(e);
                  if (t)
                      return t
              }
          let r = new Promise( (t, n) => {
              this.nextBatch.push({
                  request: e,
                  resolve: t,
                  reject: n
              })
          }
          );
          return n?.length && this.uniqueRequests.set(n[0], r),
          this.nextBatch.length >= this.maxBatchedRequests && this.handleResolve(),
          r
      }
      getInflightRequest(e) {
          let t = this.serializeKeys(e);
          if (t)
              for (let e of t)
                  for (let t of this.inflightRequests) {
                      let n = t.get(e);
                      if (n)
                          return n
                  }
      }
      serializeKeys(e) {
          let t = this.serializeRequest(e);
          if (t !== void 0)
              return Array.isArray(t) ? t : [t]
      }
  }
}
)), rX, Que = t(( () => {
  zn(),
  nX(),
  rX = class extends tX {
      constructor(e) {
          super({
              batchInterval: 0,
              maxBatchedRequests: 5e3
          }),
          this.database = e
      }
      addRequest(e) {
          return super.addRequest(e)
      }
      async handleBatch(e) {
          if (e.length === 0)
              return {
                  result: void 0
              };
          let t = new Set;
          for (let n of e)
              t.add(n.request.modelName);
          let n;
          try {
              await this.database.readTransaction({
                  metaStore: !1,
                  syncActionStore: !1,
                  stores: Array.from(t)
              }, async t => {
                  n = await this.readData(t, e)
              }
              )
          } catch (t) {
              for (let n of e)
                  n.reject(t);
              throw t
          }
          if (n)
              throw n;
          return {
              result: void 0
          }
      }
      serializeRequest(e) {}
      async readData(e, t) {
          return (await Promise.allSettled(t.map(async t => {
              if (`id`in t.request)
                  await e.get(t.request.modelName, t.request.id).then(t.resolve).catch(e => {
                      throw t.reject(e),
                      e
                  }
                  );
              else if (`ids`in t.request)
                  await Promise.all(t.request.ids.map(n => e.get(t.request.modelName, n))).then(e => t.resolve(e.concrete())).catch(e => {
                      throw t.reject(e),
                      e
                  }
                  );
              else if (`key`in t.request)
                  await e.getByIndex(t.request.modelName, t.request.key, t.request.value).then(t.resolve).catch(e => {
                      throw t.reject(e),
                      e
                  }
                  );
              else
                  throw new Rn(t.request)
          }
          ))).find(e => e.status === `rejected`)?.reason
      }
  }
}
)), iX, aX, oX, sX, cX = t(( () => {
  yn(),
  ss(),
  Yr(),
  ro(),
  TY(),
  OY(),
  cm(),
  pi(),
  Xn(),
  As(),
  ws(),
  Es(),
  om(),
  nm(),
  es(),
  Ho(),
  RY(),
  Zue(),
  ng(),
  HY(),
  Qp(),
  Tm(),
  $J(),
  AY(),
  MY(),
  JY(),
  Que(),
  ni(),
  N(),
  iX = class e {
      static #e = this.constructorName = `Database`;
      static shouldLogModelAction(e, t) {
          return t === `delete` || t === `archive` ? di.getValue(`debug-client-deletion-models`, []).includes(e) : !1
      }
      get onDatabaseUnavailable() {
          return this._onDatabaseUnavailable
      }
      get onSavingStoreCountChange() {
          return this.storeManager.onSavingStoreCountChange
      }
      get id() {
          return this.metadata?.databaseId
      }
      get bootstrappedAt() {
          return this.metadata?.bootstrappedAt
      }
      requiredBootstrap() {
          let e = this.metadata;
          if (!e)
              throw Error(`Database metadata not defined`);
          let t = e.lastSyncId
            , n = em.getModelNamesByLoadStrategy(rm.instant, rm.lazy)
            , r = new Set(this.storeManager.readyStores.map(e => e.modelName))
            , i = n.filter(e => !r.has(e))
            , a = Jn.LINEAR_DEMO_ORGANIZATION_ID && this.openOptions?.organizationId === Jn.LINEAR_DEMO_ORGANIZATION_ID
            , o = QJ || a ? !1 : this.hasTimelyData(e, i.length === 0);
          return r.size === 0 || !t || navigator.onLine === !0 && o === !1 ? {
              type: sX.full,
              untimelyLocalData: !o,
              modelsToLoad: n,
              lastSyncId: 0
          } : i.length === 0 ? {
              type: sX.local,
              modelsToLoad: i,
              lastSyncId: t
          } : {
              type: sX.partial,
              modelsToLoad: i,
              lastSyncId: t
          }
      }
      constructor(e, t) {
          this.options = t,
          this._onDatabaseUnavailable = new Ts,
          this.handleReadError = e => {
              let {error: t, method: n, modelName: r} = e;
              throw w.remote(`Database read error for ${n}`, {
                  error: t.message,
                  modelName: r
              }),
              w.warning(`Database read error for ${n}. ${t.message}`, {
                  error: t.name,
                  stack: t.stack,
                  modelName: r
              }),
              Vo.increment(`error.database.read`),
              t
          }
          ,
          this.handleWriteError = async e => {
              Vo.increment(`error.database.write`);
              let t;
              if (e.name === `QuotaExceededError`) {
                  w.info(`Database quota exceeded. Deleting local database.`, {
                      error: e
                  }),
                  Vo.increment(`error.database.quota_exceeded`),
                  this._onDatabaseUnavailable.fire(oX.quotaExceeded);
                  try {
                      await eg.deleteAllDatabases()
                  } catch (e) {
                      t = e,
                      w.info(`Error deleting all databases`, {
                          error: t,
                          name: this.name
                      })
                  }
              } else
                  try {
                      await this.deleteDatabase()
                  } catch (e) {
                      t = e,
                      w.info(`Error deleting database`, {
                          error: t,
                          name: this.name
                      })
                  }
              w.remote(`Database write error detected`, {
                  error: e,
                  deleteError: t
              }),
              w.warning(`Database write error detected. ${e.message}`, {
                  error: e,
                  deleteError: t
              })
          }
          ,
          this.graphQLClient = e,
          this.databaseOpened = no()
      }
      async open(e) {
          this.openOptions = e,
          w.network(`Getting database info for user ${e.userId}`);
          let t = di.getValue(di.clientDatabaseMinVersion, 56)
            , n = await eg.databaseInfo({
              ...e,
              minVersion: t
          });
          eg.registerDatabase(n).catch(e => {
              w.error(`Failed to register database`, e)
          }
          ),
          this.name = n.name,
          w.network(`Using database ${this.name} schema version ${n.schemaVersion}`);
          let r = ei.getSession(`open-database-recovery-timestamp`) || 0
            , i = Date.now() - r < 5 * b.MINUTE
            , a = i ? 40 * b.SECOND : 3 * b.SECOND
            , o = !1;
          try {
              this.database = await EY(Jee(this.name, n.schemaVersion, {
                  upgrade: (e, t, n, r) => {
                      w.info(`Upgrading database.`, {
                          name: this.name
                      }),
                      w.network(`Upgrading database ${this.name}`),
                      o = !0,
                      this.storeManager.createStores(e, r)
                  }
                  ,
                  blocked: (e, t) => {
                      w.info(`Database connection blocked by older database version.`, {
                          currentVersion: e,
                          blockedVersion: t
                      }),
                      w.remote(`Database connection blocked by older database version.`, {
                          currentVersion: e,
                          blockedVersion: t
                      })
                  }
                  ,
                  blocking: (e, t) => {
                      w.remote(`Database connection blocking new version.`, {
                          currentVersion: e,
                          blockedVersion: t
                      }),
                      this.close(`blocking`),
                      eg.deletingDatabase || this._onDatabaseUnavailable.fire(oX.upgraded)
                  }
                  ,
                  terminated: () => {
                      w.info(`Database connection abnormally terminated.`),
                      this.handleWriteError(Error(`Database connection terminated`))
                  }
              }), a),
              this.loader = new rX(this)
          } catch (t) {
              if (!i && t instanceof DY)
                  try {
                      w.warning(`Database open timeout, bumping user version and reloading`, {
                          error: t,
                          name: this.name,
                          version: n.version,
                          schemaVersion: n.schemaVersion,
                          openTimeout: a
                      }),
                      ei.setSession(`open-database-recovery-timestamp`, Date.now()),
                      await eg.incrementUserVersion(e.userId),
                      ks.forceRefresh(`database-open-timeout-recovery`),
                      await new Promise(aX)
                  } catch (e) {
                      throw w.warning(`Failed to increment user version during database open timeout recovery`, {
                          error: e
                      }),
                      t
                  }
              if (t instanceof Error && /The requested version .+ is less than the existing version/.test(t?.message || ``))
                  try {
                      w.warning(`Increasing database ${n.name} version because of schema version mismatch.`, {
                          error: t
                      }),
                      await eg.incrementUserVersion(e.userId),
                      ks.forceRefresh(`database-upgrade-schema-version-mismatch`),
                      await new Promise(aX)
                  } catch (e) {
                      throw w.warning(`Failed to increment user version during database open schema version mismatch recovery`, {
                          error: e
                      }),
                      t
                  }
              throw t
          }
          if (this.metadata = await this.getMetadata(o),
          !this.database)
              throw Error(`Database was closed immediately after opening.`);
          await this.storeManager.checkReadinessOfStores(this.database),
          this.databaseOpened.resolve(),
          eg.cleanOutdatedDatabases(e.userId, n.version, n.userVersion),
          QJ || eg.deleteOutdatedDemoDatabases()
      }
      close(e) {
          w.network(`Closing database due to ${e}`, {
              database: {
                  name: this.name,
                  metadata: this.metadata
              }
          }),
          this.closeDatabase()
      }
      async writeTransaction(e, t) {
          return await this.performTransaction(`readwrite`, e, t)
      }
      async readTransaction(e, t) {
          await this.performTransaction(`readonly`, e, t)
      }
      async getAllInitialHydratedModelData(e) {
          let t = await this.getDatabaseContext();
          if (!t)
              throw Error(`Trying to access closed database`);
          let {database: n, loader: r} = t
            , i = em.getModelNames(rm.instant)
            , a = i.map(e => this.storeManager.objectStore(e).getAll(n))
            , o = em.getModelNamesByLoadStrategy(rm.placeholder, rm.partial)
            , s = {};
          for (let t of o) {
              let i = em.getModelClass(t)?.getAllInitialHydratedModelData(e);
              i?.length && (s[t] = i.map(e => typeof e == `string` ? this.storeManager.objectStore(t).getById(n, r, e).then(e => e === `needs_network_hydration` || !e ? [] : [e]) : this.storeManager.objectStore(t).getAllForIndexedKey(n, r, e).then(e => e === `needs_network_hydration` ? [] : e)))
          }
          let c = await Promise.all(a).catch(e => this.handleReadError({
              error: e,
              method: `getAllInitialHydratedModelData`
          }))
            , l = 0
            , u = {};
          for (let e of i)
              u[e] = c[l++];
          for (let e in s)
              s[e].length > 0 && (u[e] = (await Promise.all(s[e])).flat());
          return u
      }
      objectStoreReady(e) {
          return this.storeManager.objectStore(e).isReady
      }
      async getModelDataById(e, t, n) {
          Zp.addArguments(e, t);
          let r = await this.getDatabaseContext();
          if (r)
              return this.storeManager.objectStore(e).getById(r.database, r.loader, t, n).catch(t => this.handleReadError({
                  error: t,
                  method: `getModelDataById`,
                  modelName: e
              }))
      }
      async getModelDataByIndexedKey(e, t, n) {
          Zp.addArguments(e.modelName, t.key);
          let r = e.modelName
            , i = this.storeManager.objectStore(r);
          try {
              return await i.getAllForIndexedKey(this.database, this.loader, t, n)
          } catch (e) {
              return w.info(`Failed fetching data for index`, {
                  indexedKey: t,
                  error: e
              }),
              []
          }
      }
      async getModelDataByIds(e, t) {
          Zp.addArguments(e, t);
          let n = await this.getDatabaseContext();
          return n ? this.storeManager.objectStore(e).getByIds(n.loader, t).catch(t => this.handleReadError({
              error: t,
              method: `getModelDataByIds`,
              modelName: e
          })) : []
      }
      async getAllModelData(e) {
          Zp.addArguments(e);
          let t = this.database;
          return t ? this.storeManager.objectStore(e).getAll(t).catch(t => this.handleReadError({
              error: t,
              method: `getAllModelData`,
              modelName: e
          })) : []
      }
      async getModelCount(e) {
          Zp.addArguments(e);
          let t = this.database;
          return t ? this.storeManager.objectStore(e).modelCount(t).catch(t => this.handleReadError({
              error: t,
              method: `getCount`,
              modelName: e
          })) : 0
      }
      setBackendDatabaseVersion(e) {
          if (!this.metadata)
              throw Error(`Database metadata not defined`);
          this.metadata.backendDatabaseVersion = e,
          this.database?.put(BY, this.metadata, `meta`).catch(this.handleWriteError)
      }
      async getMetadata(e=!1) {
          if (!this.database)
              throw Error(`Trying to access closed database`);
          let t = await this.database.get(BY, `meta`);
          return {
              databaseId: t?.databaseId ?? os(),
              backendDatabaseVersion: t?.backendDatabaseVersion ?? 0,
              firstSyncId: e ? void 0 : t?.firstSyncId,
              lastSyncId: t?.lastSyncId ?? 0,
              updatedAt: t?.updatedAt instanceof Date ? t?.updatedAt : new Date,
              userSyncGroups: t?.userSyncGroups,
              syncSubscriptions: t?.syncSubscriptions,
              bootstrappedAt: t?.bootstrappedAt,
              regionName: t?.regionName
          }
      }
      async getAllTransactions() {
          return this.database ? await this.database.transaction(zY).store.getAll() : []
      }
      async putTransactions(e) {
          if (this.database)
              try {
                  let t = this.database.transaction(zY, `readwrite`, {
                      durability: `relaxed`
                  })
                    , n = t.objectStore(zY);
                  for (let t of e) {
                      let e = t.serialize();
                      await n.put(e)
                  }
                  await t.done
              } catch {
                  navigator.onLine === !1 && this._onDatabaseUnavailable.fire(oX.transactionFailedAndClientOffline)
              }
      }
      async deleteTransaction(e) {
          if (this.database) {
              if (e)
                  return this.database.delete(zY, e).catch(this.handleWriteError);
              w.error(`Tried to delete a transaction without an id`)
          }
      }
      async resetDatabase(e) {
          if (!this.database) {
              w.info(`Trying to reset closed database`, {
                  name: this.name
              });
              return
          }
          w.remote(`Resetting database`, {
              idb: {
                  name: this.name
              }
          });
          try {
              e?.dangerouslyIncrementUserVersion && this.openOptions ? (await eg.incrementUserVersion(this.openOptions.userId),
              this.close(`reset`),
              await this.open(this.openOptions),
              this.metadata = await this.getMetadata()) : (await this.storeManager.clearStores(this.database),
              await this.database.clear(BY),
              this.metadata = await this.getMetadata())
          } catch (e) {
              w.error(`Error resetting database`, e)
          }
      }
      async deleteDatabase() {
          if (w.remote(`Delete local database`, {
              idb: {
                  name: this.name
              }
          }),
          this.closeDatabase(),
          this.name)
              return await eg.deleteDatabase(this.name)
      }
      async statistics() {
          return this.database ? this.storeManager.statistics(this.database) : {}
      }
      async bootstrap() {
          if (!this.database)
              throw Error(`Cannot bootstrap without a database`);
          let e = this.requiredBootstrap();
          kY.addStartupSpanTag(`bootstrap.type`, e.type);
          let t = e.type !== sX.local && !QJ ? LY.fetchUserSyncGroups(this.graphQLClient).then(e => ({
              all: e.all,
              optimized: e.optimized
          })) : void 0;
          e.untimelyLocalData && (kY.addStartupSpanTag(`bootstrap.noTimelyData`, !0),
          await this.resetDatabase({
              dangerouslyIncrementUserVersion: !0
          }));
          for (let t of e.modelsToLoad)
              this.database?.put(BY, {
                  persisted: !1
              }, t).catch( () => {}
              );
          let n = this.metadata;
          if (!n)
              throw Error(`Cannot bootstrap without database metadata`);
          let r, i;
          if (e.type === sX.local)
              r = {
                  all: n.userSyncGroups.all,
                  optimized: n.userSyncGroups.optimized
              };
          else {
              if (r = e.type === sX.full ? await t : n.userSyncGroups ? {
                  all: n.userSyncGroups.all,
                  optimized: n.userSyncGroups.optimized
              } : await t,
              r === void 0)
                  if (QJ)
                      r = {
                          all: [],
                          optimized: []
                      };
                  else
                      throw Error(`User sync groups are required for cached full bootstrap`);
              let a = await (e.type === sX.full ? LY.fullBootstrap(this.graphQLClient, e.modelsToLoad, r) : this.loadPartialModels(e.modelsToLoad, r, void 0, !0)).catch(t => {
                  throw t.userError || w.error(`Sync bootstrap query error`, t, {
                      type: e.type,
                      lastSyncId: n.lastSyncId,
                      backendDatabaseVersion: n.backendDatabaseVersion
                  }),
                  qo(t) && t.userError ? t : new $o({
                      type: `bootstrap error`,
                      message: `could not load bootstrap`,
                      userError: t.userError ?? !1,
                      userPresentableMessage: t.userPresentableMessage ?? `Could not reach Linear servers in order to load workspace data. Please check your internet connection and try again.`
                  })
              }
              );
              a && (kY.addStartupSpanTag(`bootstrap.networkModelCount`, a.data.length),
              kY.addStartupSpanTag(`bootstrap.syncPacketCount`, a.syncDeltaPackets?.length || 0));
              let o = a?.data.reduce( (e, t) => {
                  let n = t.__class;
                  return delete t.__class,
                  n && (e[n] = e[n] || [],
                  e[n].push(t)),
                  e
              }
              , {}) ?? {};
              for (let t of e.modelsToLoad)
                  o[t] || (o[t] = []);
              for (let e in i = a?.syncDeltaPackets,
              o)
                  this.storeManager.setModelData(e, o[e] ?? []);
              if (e.type === sX.full && !a)
                  throw Error(`Full bootstrap returned no result`);
              if (a) {
                  if (n.backendDatabaseVersion = a.databaseVersion,
                  n.userSyncGroups = r,
                  e.type === sX.full)
                      n.lastSyncId = a.lastSyncId,
                      n.firstSyncId = a.lastSyncId,
                      n.bootstrappedAt = new Date,
                      n.syncSubscriptions = ui.isEnabled(`sync-subscriptions`) === !0 ? e.modelsToLoad.map(e => wY.create(e)) : void 0;
                  else if (e.type === sX.partial && n.syncSubscriptions)
                      for (let t of e.modelsToLoad) {
                          let e = wY.create(t);
                          n.syncSubscriptions.includes(e) || n.syncSubscriptions.push(e)
                      }
                  this.database?.put(BY, n, `meta`).catch(this.handleWriteError)
              }
          }
          return {
              firstSyncId: n.firstSyncId,
              lastSyncId: n.lastSyncId,
              userSyncGroups: r,
              syncSubscriptions: n.syncSubscriptions,
              type: e.type,
              backendDatabaseVersion: n.backendDatabaseVersion,
              syncDeltaPackets: i,
              regionName: n.regionName
          }
      }
      async loadPartialModels(e, t, n, r) {
          if (Zp.addArguments(e, t),
          e.length === 0)
              throw Error(`No models to load`);
          let i = await this.getDatabaseContext();
          if (!i)
              return;
          let a = await LY.partialBootstrap(this.graphQLClient, e, t, {
              partOfBootstrap: r,
              lastSyncId: i.metadata.lastSyncId,
              firstSyncId: Math.max(i.metadata.firstSyncId ?? 0, n ?? 0) || void 0
          });
          if (!a)
              return;
          let o = this.database ? await this.getDeletionsAndBatchUpdates(e, a.lastSyncId) : void 0;
          return {
              ...a,
              data: jY.applySyncActionRecords(a.data, o)
          }
      }
      async hasModelsForPartialIndexes(e, t, n) {
          return Zp.addArguments(e, t),
          this.database !== void 0 && this.storeManager.objectStore(e).hasModelsForPartialIndexes(this.database, t, n)
      }
      async removeLoadedPartialIndexes(e, t) {
          return Zp.addArguments(e, t),
          this.database === void 0 ? t.map(e => e.value) : this.storeManager.objectStore(e).removeLoadedPartialIndexes(this.database, t)
      }
      async setPartialIndexForModel(e, t) {
          if (Zp.addArguments(e, t),
          !this.database)
              return;
          let n = this.storeManager.objectStore(e);
          t === sm.FULLY_LOADED_INDEX_NAME ? await n.setIsReady(this.database) : await n.setPartialIndex(this.database, t)
      }
      setModelData(e, t) {
          this.storeManager.objectStore(e).setModelData(t)
      }
      async flush(e) {
          if (!(!this.database || !this.storeManager.requiresFlushing))
              try {
                  (await this.storeManager.flush(this.database, e)).updatesFlushed.catch(this.handleWriteError)
              } catch (e) {
                  await this.handleWriteError(e)
              }
      }
      storeIsCached(e) {
          return this.storeManager.storeIsCached(e)
      }
      async isOpenAndHealthy() {
          try {
              return !this.database || this.metadata?.closedAt ? !1 : (await this.database.transaction([BY], `readonly`, {
                  durability: `relaxed`
              }).objectStore(BY).get(`meta`),
              !0)
          } catch (e) {
              return w.debug(`Database health check failed with error`, {
                  error: e
              }),
              !1
          }
      }
      async cleanupSyncActionStore(e) {
          let t = this.database ? this.database.transaction([this.storeManager.syncActionStore.storeName], `readwrite`, {
              durability: `relaxed`
          }) : void 0;
          t && await this.storeManager.syncActionStore.cleanupStore(t, e)
      }
      async getDeletionsAndBatchUpdates(e, t) {
          if (!this.database)
              return;
          let n = []
            , r = this.storeManager.syncActionStore.storeName
            , i = this.database.transaction([r], `readwrite`, {
              durability: `relaxed`
          });
          for (let r of e)
              n.push(...await this.storeManager.syncActionStore.getDeletionsAndBatchUpdates(i, r, t));
          return await i.done,
          n
      }
      modelsToLoadForNewSyncGroups() {
          return em.getModelClasses().filter(e => this.storeManager.objectStore(e.modelName).isReady || e.isFullyLoaded).map(e => e.modelName)
      }
      closeDatabase() {
          this.database?.close(),
          this.database = void 0,
          this.loader = void 0,
          this.metadata && (this.metadata.closedAt = new Date)
      }
      async getDatabaseContext() {
          if (!this.metadata?.closedAt) {
              if ((!this.database || !this.loader || !this.metadata) && (await this.databaseOpened,
              !this.database || !this.loader || !this.metadata))
                  throw Error(`Database not initialized after waiting`);
              return {
                  database: this.database,
                  loader: this.loader,
                  metadata: this.metadata
              }
          }
      }
      get storeManager() {
          return this._storeManager ||= new QY(this.graphQLClient,this.options),
          this._storeManager
      }
      hasTimelyData(e, t) {
          let n = di.getValue(di.timeBeforeFullBootstrap, {
              allModelsReady: `28d`,
              hasNotReadyModels: `14d`
          })
            , r = t === !0 ? n.allModelsReady : n.hasNotReadyModels
            , i = Yte(r) ? Xte(r) : b.DAY * 28;
          return Date.now() - e.updatedAt.getTime() < i
      }
      async performTransaction(t, n, r) {
          let i = this.storeManager.createTransaction(this.database, t, n);
          if (!i)
              return await r({
                  get: async () => void 0,
                  getByIndex: async () => [],
                  put: aX,
                  add: aX,
                  delete: aX,
                  iterate: aX,
                  addSyncPacket: aX,
                  setLastSyncId: aX,
                  setFirstSyncId: aX,
                  setUserSyncGroups: aX,
                  setRegionName: aX,
                  ensureSyncSubscriptions: aX,
                  commit: aX
              }),
              {
                  writeComplete: Promise.resolve()
              };
          let {objectStores: a, transaction: o} = i
            , s = await this.getDatabaseContext();
          if (!s)
              throw Error(`Trying to access closed database`);
          let {metadata: c} = s, l = this.storeManager.syncActionStore, u = !1, d = 0, f = 0, p, m, h, g = {}, _ = () => {
              if (u)
                  throw Error(`Commit operation invoked after transaction has been closed`);
              u = !0,
              f && (c.firstSyncId = f),
              d && (c.lastSyncId = d,
              c.firstSyncId ||= d),
              p && (c.userSyncGroups = p),
              m && (c.syncSubscriptions = m),
              h !== void 0 && (c.regionName = h),
              c.updatedAt = new Date,
              (d || f || p || m || h !== void 0) && a[BY].put(c, `meta`)
          }
          ;
          if (await r({
              get: (e, t) => new Promise( (n, r) => {
                  let i = a[e].get(t);
                  i.onsuccess = () => {
                      n(i.result)
                  }
                  ,
                  i.onerror = () => {
                      r(i.error)
                  }
              }
              ),
              getByIndex: (e, t, n) => new Promise( (r, i) => {
                  let o = a[e].index(t).getAll(IDBKeyRange.only(n));
                  o.onsuccess = () => {
                      r(o.result ?? [])
                  }
                  ,
                  o.onerror = () => {
                      i(o.error)
                  }
              }
              ),
              put: (e, t) => {
                  a[e] && a[e].put(t)
              }
              ,
              add: (e, t) => {
                  if (a[e]) {
                      let n = a[e].get(IDBKeyRange.only(t.id));
                      n.onsuccess = () => {
                          n.result === void 0 && a[e].put(t)
                      }
                  }
              }
              ,
              delete: (t, n) => {
                  a[t] && (e.shouldLogModelAction(t, `delete`) && w.debug(`Removing model from database`, {
                      modelName: t,
                      id: n
                  }),
                  a[t].delete(n),
                  (g[t] = g[t] || []).push(n))
              }
              ,
              iterate: async (e, t, n) => {
                  let r = vn(o).objectStore(this.storeManager.objectStore(e).storeName);
                  if (t && r.indexNames.contains(t.key))
                      await Promise.all(t.values.map(e => {
                          let i = no()
                            , a = r.index(t.key).openCursor(IDBKeyRange.only(e));
                          return a.onsuccess = function() {
                              let e = a.result;
                              e ? (n(e),
                              e.continue()) : i.resolve()
                          }
                          ,
                          i
                      }
                      ));
                  else {
                      let e = t ? new Set(t.values) : void 0
                        , i = no()
                        , a = r.openCursor();
                      a.onsuccess = function() {
                          let r = a.result;
                          if (r) {
                              if (t) {
                                  let i = r.value[t.key];
                                  Array.isArray(i) ? i.find(t => e.has(t)) && n(r) : e.has(i) && n(r)
                              } else
                                  n(r);
                              r.continue()
                          } else
                              i.resolve()
                      }
                      ,
                      await i
                  }
              }
              ,
              addSyncPacket(e) {
                  l.addSyncPacket(a[l.storeName], e)
              },
              setLastSyncId: e => {
                  d = Math.max(e, d)
              }
              ,
              setFirstSyncId: e => {
                  f = Math.max(e, f)
              }
              ,
              setUserSyncGroups(e) {
                  p = e
              },
              setRegionName(e) {
                  h = e
              },
              async ensureSyncSubscriptions(e) {
                  let t = await new Promise( (e, t) => {
                      let n = a[BY].get(`meta`);
                      n.onsuccess = () => {
                          e(n.result)
                      }
                      ,
                      n.onerror = () => {
                          t(n.error)
                      }
                  }
                  );
                  m = Array.from(new Set([...t?.syncSubscriptions || [], ...e]))
              },
              commit: _
          }),
          u || _(),
          Object.keys(g).length !== 0) {
              let e = this.storeManager.createPartialIndexTransaction(this.database);
              if (e)
                  for (let[t,n] of Object.entries(g)) {
                      let r = this.storeManager.objectStore(t);
                      if (r instanceof qY)
                          for (let t of n)
                              r.deletePartialIndexValue(e, t);
                      let i = this.storeManager.partialObjectStores;
                      for (let r of i)
                          for (let i of wm.partialIndexInfoForModel(r.modelName, {
                              onlyReferencingModelType: t
                          }))
                              for (let t of n) {
                                  let n = wm.createPartialIndex(i, t).value;
                                  r.deletePartialIndexValue(e, n)
                              }
                  }
          }
          return {
              writeComplete: o.done
          }
      }
  }
  ,
  M([Zp.trace(`database`)], iX.prototype, `open`, null),
  M([Zp.trace(`database`)], iX.prototype, `close`, null),
  M([Zp.trace(`database`)], iX.prototype, `writeTransaction`, null),
  M([Zp.trace(`database`)], iX.prototype, `readTransaction`, null),
  M([Zp.trace(`database`)], iX.prototype, `getAllInitialHydratedModelData`, null),
  M([Zp.trace(`databaseQueries`)], iX.prototype, `getModelDataById`, null),
  M([Zp.trace(`databaseQueries`)], iX.prototype, `getModelDataByIndexedKey`, null),
  M([Zp.trace(`databaseQueries`)], iX.prototype, `getModelDataByIds`, null),
  M([Zp.trace(`database`)], iX.prototype, `getAllModelData`, null),
  M([Zp.trace(`database`)], iX.prototype, `getModelCount`, null),
  M([Zp.trace(`database`)], iX.prototype, `setBackendDatabaseVersion`, null),
  M([Zp.trace(`database`)], iX.prototype, `getMetadata`, null),
  M([Zp.trace(`database`)], iX.prototype, `getAllTransactions`, null),
  M([Zp.trace(`database`)], iX.prototype, `putTransactions`, null),
  M([Zp.trace(`database`)], iX.prototype, `deleteTransaction`, null),
  M([Zp.trace(`database`)], iX.prototype, `resetDatabase`, null),
  M([Zp.trace(`database`)], iX.prototype, `deleteDatabase`, null),
  M([Zp.trace(`database`)], iX.prototype, `bootstrap`, null),
  M([Zp.trace(`databaseQueries`)], iX.prototype, `loadPartialModels`, null),
  M([Zp.trace(`databaseQueries`)], iX.prototype, `hasModelsForPartialIndexes`, null),
  M([Zp.trace(`databaseQueries`)], iX.prototype, `removeLoadedPartialIndexes`, null),
  M([Zp.trace(`databaseQueries`)], iX.prototype, `setPartialIndexForModel`, null),
  M([Zp.trace(`database`)], iX.prototype, `flush`, null),
  M([Zp.trace(`database`)], iX.prototype, `cleanupSyncActionStore`, null),
  aX = async () => {}
  ,
  oX = function(e) {
      return e[e.quotaExceeded = 0] = `quotaExceeded`,
      e[e.upgraded = 1] = `upgraded`,
      e[e.transactionFailedAndClientOffline = 2] = `transactionFailedAndClientOffline`,
      e
  }({}),
  sX = function(e) {
      return e.full = `full`,
      e.partial = `partial`,
      e.local = `local`,
      e
  }({})
}
));
function lX(e, t) {
  return (n, r) => {
      Object.defineProperty(n, r, {
          get: function() {
              return this.browserPersistedSettings[r] === void 0 ? e : this.browserPersistedSettings[r]
          },
          set: function(e) {
              this.browserPersistedSettings[r] = e,
              ei.set(`globalSettings`, this.browserPersistedSettings),
              t && t(e)
          },
          enumerable: !0,
          configurable: !0
      }),
      uX[r] = Bt,
      t && t(e)
  }
}
var uX, dX, $ue = t(( () => {
  zt(),
  Xn(),
  ws(),
  ni(),
  cX(),
  N(),
  uX = {
      browserPersistedSettings: Vt
  },
  dX = class {
      constructor() {
          for (let e in this.browserPersistedSettings = ei.get(`globalSettings`) || {},
          this.browserPersistedSettings || {})
              this[e] = this.browserPersistedSettings[e];
          At(this, uX)
      }
  }
  ,
  M([lX(Jn.IS_PRODUCTION_ENV || Jn.IS_TEST_ENV ? xs.none : xs.regular, e => {
      w.loggingLevel = e
  }
  )], dX.prototype, `loggingLevel`, void 0),
  M([lX(void 0, e => {
      e !== void 0 && (iX.lazyModelInstantiationSettings = e)
  }
  )], dX.prototype, `lazyModelInstantiationSettings`, void 0),
  M([lX(void 0)], dX.prototype, `disableServiceWorkerCaching`, void 0)
}
)), fX, pX = t(( () => {
  fX = class {
      constructor(e=0) {
          this.sharedQueue = [],
          this.exclusiveQueue = [],
          this.sharedCount = 0,
          this.exclusiveCount = 0,
          this.maxExclusiveQueueLength = e
      }
      async runShared(e) {
          return this.addCallback(e, !0)
      }
      async runExclusive(e) {
          return this.addCallback(e, !1)
      }
      async addCallback(e, t) {
          let n = new Promise( (n, r) => {
              t ? this.sharedQueue.push({
                  callback: e,
                  resolve: n,
                  reject: r
              }) : this.maxExclusiveQueueLength < 1 || this.exclusiveQueue.length + this.exclusiveCount < this.maxExclusiveQueueLength ? this.exclusiveQueue.push({
                  callback: e,
                  resolve: n,
                  reject: r
              }) : n(void 0)
          }
          );
          return this.executeNext(),
          n
      }
      executeNext() {
          if (this.exclusiveCount === 0) {
              if (this.sharedQueue.length > 0)
                  this.sharedQueue.forEach(e => this.execute(e, !0)),
                  this.sharedQueue = [];
              else if (this.sharedCount === 0) {
                  let e = this.exclusiveQueue.shift();
                  e && this.execute(e, !1)
              }
          }
      }
      async execute(e, t) {
          t ? ++this.sharedCount : ++this.exclusiveCount;
          try {
              let t = await e.callback();
              e.resolve(t)
          } catch (t) {
              let n = t instanceof Error ? t : Error(String(t));
              e.reject(n)
          } finally {
              t ? --this.sharedCount : --this.exclusiveCount,
              this.executeNext()
          }
      }
  }
}
)), mX, hX, gX, _X = t(( () => {
  mX = `chromiumForkDetected`,
  hX = function(e) {
      return e.background = `background`,
      e.normal = `normal`,
      e.important = `important`,
      e
  }({}),
  gX = [hX.background, hX.normal, hX.important]
}
)), vX, ede = t(( () => {
  vX = class {
      static shouldRetrySendingOnceConnected(e) {
          switch (e.cmd) {
          case `collab`:
          case `ephs`:
              return !1;
          default:
              return !0
          }
      }
  }
}
)), yX, bX, xX = t(( () => {
  ws(),
  yX = 1e3,
  bX = class {
      constructor() {
          this.reportedWarning = !1,
          this.token = 0,
          this.queue = []
      }
      wait(e) {
          return this.token >= e ? Promise.resolve() : new Promise(t => {
              this.queue.push({
                  token: e,
                  resolve: t
              }),
              this.queue.length > yX && !this.reportedWarning && (this.reportedWarning = !0,
              w.warning(`Wait queue exceeded ${yX} entries`))
          }
          )
      }
      progressQueue(e) {
          this.token = e;
          for (let t = this.queue.length - 1; t >= 0; t--) {
              let n = this.queue[t];
              e >= n.token && (n.resolve(),
              this.queue.splice(t, 1))
          }
      }
  }
}
)), SX, CX, wX, TX, EX, DX, OX, kX = t(( () => {
  SX = e(ve(), 1),
  zn(),
  Yr(),
  lo(),
  ws(),
  CX = function(e) {
      return e[e.onIdleOrActive = 0] = `onIdleOrActive`,
      e[e.periodicWhileActive = 1] = `periodicWhileActive`,
      e
  }({}),
  wX = class e {
      constructor() {
          this.callbacks = [],
          this.lastUserInteraction = Date.now(),
          this.timerIds = [],
          this.intervalIds = [],
          this.eventHandlers = {},
          this.idleByTimeout = {},
          this.lastCursorHash = 0,
          this.isInvokingCallback = !1,
          this.handleUserInteraction = async () => {
              this.lastUserInteraction = Date.now();
              for (let e of this.callbacks.entries())
                  await this.checkTimeout(e)()
          }
          ,
          this.checkCursorMovement = e => {
              let t = e[1];
              return async () => {
                  let n = co.bridge.getCursorScreenPoint();
                  if (n) {
                      let r = n.x / 1e5 + n.y;
                      if (this.lastCursorHash !== r) {
                          if (this.lastCursorHash = r,
                          !t.shouldCall(this.lastUserInteraction, EX.osCursorMovement))
                              return;
                          await this.checkTimeout(e, EX.osCursorMovement)()
                      }
                  }
              }
          }
          ,
          this.checkTimeout = (e, t=EX.userInteraction) => {
              let[n,r] = e;
              return async () => {
                  let i = Date.now() - this.lastUserInteraction;
                  if (this.isInvokingCallback || !r.shouldCall(this.lastUserInteraction, t))
                      return;
                  let a = !1;
                  try {
                      this.isInvokingCallback = !0,
                      a = await r.call(this.lastUserInteraction)
                  } catch (e) {
                      w.error(`Failed to invoke callback for IdleNotifier`, e)
                  } finally {
                      this.isInvokingCallback = !1
                  }
                  if (this.setUserIsIdle(r.timeout, i >= r.timeout),
                  a) {
                      window.clearTimeout(this.timerIds[n]);
                      let t = Math.min(r.timeout - i, r.timeout);
                      this.timerIds[n] = window.setTimeout(this.checkTimeout(e), t)
                  }
              }
          }
          ;
          for (let e of TX) {
              let t = (0,
              SX.default)(this.handleUserInteraction, b.SECOND);
              this.eventHandlers[e] = t,
              self.document.addEventListener(e, t)
          }
          e.notifierCount === 20 && w.error(`More than 20 IdleNotifier instances created. Most likely older instances haven't been cleared with a call to cancel().`),
          e.notifierCount++
      }
      subscribe(e, t, n={}) {
          let {behaviour: r=CX.onIdleOrActive, checkOSCursorMovement: i=!0} = n, a;
          switch (r) {
          case CX.onIdleOrActive:
              a = new DX({
                  callback: e,
                  timeout: t,
                  ...n,
                  behaviour: r
              },this);
              break;
          case CX.periodicWhileActive:
              a = new OX({
                  callback: e,
                  timeout: t,
                  ...n,
                  behaviour: r
              },this);
              break;
          default:
              throw new Rn(r)
          }
          this.callbacks.push(a);
          let o = this.callbacks.length - 1;
          this.timerIds.push(window.setTimeout(this.checkTimeout([o, a]), t)),
          i && this.intervalIds.push(window.setInterval(this.checkCursorMovement([o, a]), t / 2))
      }
      userIsIdle(e) {
          return this.idleByTimeout[e] || !1
      }
      cancel() {
          this.timerIds.forEach(window.clearTimeout),
          this.intervalIds.forEach(window.clearInterval);
          for (let[e,t] of Object.entries(this.eventHandlers))
              self.document.removeEventListener(e, t);
          e.notifierCount--
      }
      static #e = this.notifierCount = 0;
      setUserIsIdle(e, t) {
          this.idleByTimeout[e] = t
      }
  }
  ,
  TX = [`mousemove`, `keydown`, `visibilitychange`, `touchstart`],
  EX = function(e) {
      return e[e.osCursorMovement = 0] = `osCursorMovement`,
      e[e.userInteraction = 1] = `userInteraction`,
      e
  }(EX || {}),
  DX = class {
      constructor(e, t) {
          this.notifierCallback = e,
          this.idleNotifier = t
      }
      get timeout() {
          return this.notifierCallback.timeout
      }
      shouldCall(e, t) {
          return Date.now() - e >= this.timeout || this.idleNotifier.userIsIdle(this.timeout)
      }
      async call(e) {
          let t = Date.now() - e >= this.timeout;
          return t !== this.idleNotifier.userIsIdle(this.timeout) && await this.callback(t, e),
          !t
      }
      get callback() {
          return this.notifierCallback.callback
      }
  }
  ,
  OX = class {
      constructor(e, t) {
          this.lastTimeCallbackInvoked = -1,
          this.lastSentUserInteraction = -1,
          this.notifierCallback = e,
          this.idleNotifier = t
      }
      get timeout() {
          return this.notifierCallback.timeout
      }
      shouldCall(e, t) {
          if (t === EX.osCursorMovement && !this.notifierCallback.checkOSCursorMovement)
              return !1;
          let n = this.idleNotifier.userIsIdle(this.timeout)
            , r = Date.now() - e >= this.timeout;
          return n && r ? !1 : this.lastTimeCallbackInvoked + this.timeout <= Date.now() + b.SECOND || n !== r
      }
      async call(e) {
          let t = Date.now() - e >= this.timeout;
          return this.lastSentUserInteraction === e ? !t : (await this.callback(t, e),
          this.lastSentUserInteraction = e,
          this.lastTimeCallbackInvoked = Date.now(),
          !t)
      }
      get callback() {
          return this.notifierCallback.callback
      }
      get behaviour() {
          return this.notifierCallback.behaviour
      }
  }
}
)), AX, jX, MX, NX, PX, FX, IX, LX = t(( () => {
  zt(),
  La(),
  ede(),
  _r(),
  pX(),
  Yr(),
  Xn(),
  pi(),
  lo(),
  Os(),
  ws(),
  xX(),
  kX(),
  Es(),
  AX = 3,
  jX = b.SECOND * 20,
  MX = b.MINUTE * 30,
  NX = b.MINUTE * 5,
  PX = !0,
  FX = class {
      static #e = this.constructorName = `SyncWebSocket`;
      get onConnect() {
          return this._onConnect
      }
      get onDisconnect() {
          return this._onDisconnect
      }
      get onAuthenticationError() {
          return this._onAuthenticationError
      }
      get onSyncMessage() {
          return this._onSyncMessage
      }
      get onEphemeralMap() {
          return this._onEphemeralMap
      }
      get onEphemeralPrimitive() {
          return this._onEphemeralPrimitive
      }
      get onMessage() {
          return this._onMessage
      }
      get connectionId() {
          return this._connectionId
      }
      setSyncSubscriptions(e) {
          this.syncSubscriptions = e
      }
      constructor(e) {
          this.status = IX.disconnected,
          this.reconnectBackoffCount = 0,
          this.lastPong = 0,
          this._onConnect = new Ts,
          this._onDisconnect = new Ts,
          this._onAuthenticationError = new Ts,
          this._onSyncMessage = new Ts,
          this._onEphemeralMap = new Ts,
          this._onEphemeralPrimitive = new Ts,
          this._onMessage = new Ts,
          this._connectionId = 1,
          this.preHandshakeMessages = [],
          this.preHandshakeCommands = [],
          this.explicityClosed = !1,
          this.periodicPingId = 0,
          this.pingId = 0,
          this.pingQueue = new bX,
          this.connectionLock = new fX,
          this.handshakeSuccess = Ft( () => {
              w.network(`WebSocket authenticated`),
              this.packer = new Pa({
                  useRecords: !1,
                  bundleStrings: !1,
                  sequential: !1
              }),
              this.status = IX.connected;
              for (let e of this.preHandshakeCommands)
                  this.send(e);
              this.preHandshakeCommands = [];
              for (let e of this.preHandshakeMessages)
                  this.handleMessage(e);
              this.preHandshakeMessages = [],
              this._onConnect.fire(),
              this.ping()
          }
          ),
          this.handleReconnectIfNecessary = () => {
              (Date.now() - this.lastPong > 90 * 1e3 || this.reconnectTimeout || this.status !== IX.connected) && this.initConnection()
          }
          ,
          this.closeWebSocket = Ft(e => {
              this._connectionId++,
              this.reconnectBackoffCount > 2 ? this.status = IX.failingToConnect : this.status = this.idleNotifier.userIsIdle(MX) ? IX.disconnectedDueToUserIdle : IX.disconnected,
              e.onmessage = null,
              e.onopen = null,
              e.onclose = null,
              (e.readyState === WebSocket.CONNECTING || e.readyState === WebSocket.OPEN) && e.close()
          }
          ),
          this.handleIdleTimeout = e => {
              e ? this.webSocket.close() : this.handleReconnectIfNecessary()
          }
          ,
          this.clientType = e,
          At(this, {
              status: Vt
          })
      }
      connect(e) {
          this.url = e.url,
          this.userId = e.userId,
          this.userAccountId = e.userAccountId,
          this.syncSubscriptions = e.syncSubscriptions,
          this.databaseId = e.databaseId,
          this.regionName = e.regionName,
          this.handshakeCallback = e.handshakeCallback,
          this.reconnect()
      }
      disconnect() {
          window.clearInterval(this.periodicPingId),
          Ds.onVisible.unsubscribe(this.handleReconnectIfNecessary),
          this.idleNotifier?.cancel(),
          this.explicityClosed = !0,
          this.webSocket && this.closeWebSocket(this.webSocket)
      }
      reconnect() {
          if (!this.url)
              throw Error(`Connection not configured`);
          this.explicityClosed = !1,
          this.lastPong = Date.now(),
          this.idleNotifier = new wX,
          this.idleNotifier.subscribe(this.handleIdleTimeout, MX),
          this.idleNotifier.subscribe( (e, t) => {
              this.updateLastActiveAt(t)
          }
          , NX, {
              behaviour: CX.periodicWhileActive,
              checkOSCursorMovement: !1
          }),
          this.initConnection(),
          Ds.onVisible.subscribe(this.handleReconnectIfNecessary)
      }
      restart() {
          this.webSocket && (this.webSocket.onmessage = null,
          this.webSocket.close())
      }
      send(e, t) {
          this.status === IX.connected || e.cmd === `hshk` ? (w.verbose( () => ({
              message: ` WebSocket`,
              metaData: e
          })),
          this.packer ? this.webSocket.send(this.packer.pack(e)) : this.webSocket.send(JSON.stringify(e))) : vX.shouldRetrySendingOnceConnected(e) && t?.onlySendWhenOnline !== !0 && this.preHandshakeCommands.push(e)
      }
      async ping() {
          let e = {
              cmd: `ping`,
              id: ++this.pingId
          };
          this.send(e),
          await this.pingQueue.wait(this.pingId)
      }
      updateLastActiveAt(e) {
          let t = {
              cmd: `presence`,
              time: e
          };
          this.send(t)
      }
      initConnection() {
          window.clearInterval(this.periodicPingId),
          window.clearTimeout(this.reconnectTimeout),
          this.webSocket && this.closeWebSocket(this.webSocket),
          this.reconnectTimeout = void 0;
          let e = new URL(this.url);
          e.searchParams.set(`userAccountId`, this.userAccountId),
          e.searchParams.set(`userId`, this.userId),
          this.webSocket = new WebSocket(e.toString()),
          this.webSocket.binaryType = `arraybuffer`,
          this.packer = void 0,
          this.unpacker = new Qi({
              useRecords: !1,
              bundleStrings: !1,
              sequential: !1
          }),
          this.webSocket.onopen = () => {
              this.preHandshakeMessages = [];
              let e = {
                  cmd: `hshk`,
                  userId: this.userId,
                  userAccountId: this.userAccountId,
                  syncSubscriptions: this.syncSubscriptions,
                  clientType: this.clientType,
                  clientDatabaseId: this.databaseId,
                  protocolVersion: AX,
                  clientVersion: gr.versionString(Jn.BUILD_REVISION, Jn.PREVIEW_PR_NUMBER),
                  releaseChannelOverride: fi.getReleaseChannelOverride(this.userId),
                  useBinaryProtocol: PX,
                  supportsSpectatorMode: !0,
                  regionName: this.regionName
              };
              this.send(e)
          }
          ,
          this.webSocket.onmessage = e => {
              try {
                  let t = e.data;
                  if (t instanceof ArrayBuffer) {
                      let e = this.unpacker.unpack(t);
                      if (typeof e != `object`)
                          throw Error(`Received non-object from unpacker`);
                      this.handleMessage(e)
                  } else {
                      let e = JSON.parse(t);
                      this.handleMessage(e)
                  }
              } catch (e) {
                  w.error(`Received incorrect WebSocket message`, e)
              }
          }
          ,
          this.webSocket.onerror = e => {
              w.network(`WebSocket errored`, {
                  event: e
              })
          }
          ,
          this.webSocket.onclose = e => {
              w.network(this.idleNotifier.userIsIdle(MX) ? `WebSocket closed due to idle user` : `WebSocket closed`, {
                  code: e.code,
                  reason: e.reason,
                  event: e
              }),
              window.clearInterval(this.periodicPingId),
              this.closeWebSocket(this.webSocket),
              this._onDisconnect.fire(e.code),
              !(this.explicityClosed || this.idleNotifier.userIsIdle(MX) === !0) && this.connectionLock.runExclusive(async () => {
                  this.reconnectBackoffCount = Math.min(this.reconnectBackoffCount + 1, 12);
                  let e = Math.min(3e4, (200 + Math.random() * 100) * this.reconnectBackoffCount ** 2);
                  this.reconnectTimeout = window.setTimeout( () => {
                      this.initConnection()
                  }
                  , e)
              }
              )
          }
      }
      async handleMessage(e) {
          if (w.verbose( () => ({
              message: ` WebSocket`,
              metaData: e
          })),
          e.cmd === `noauth`) {
              this._onAuthenticationError.fire();
              return
          }
          if (e.cmd !== `hshk` && this.status !== IX.connected) {
              this.preHandshakeMessages.push(e);
              return
          }
          switch (e.cmd) {
          case `hshk`:
              e.sync && (w.network(`Received handshake sync`, {
                  messageLastSyncId: e.sync.lastSyncId,
                  messageLastSequentialSyncId: e.sync.lastSequentialSyncId,
                  userSyncGroups: e.sync.userSyncGroups
              }),
              window.clearInterval(this.periodicPingId),
              this.periodicPingId = window.setInterval( () => {
                  if (this.webSocket.readyState === WebSocket.OPEN) {
                      let e = {
                          cmd: `ping`,
                          id: ++this.pingId
                      };
                      this.send(e)
                  }
              }
              , jX),
              this.connectionLock.runExclusive(async () => {
                  await this.handshakeCallback(e).catch(e => {
                      w.error(`Handshake callback reported error`, e),
                      this.webSocket.close()
                  }
                  ) && this.webSocket.readyState === WebSocket.OPEN ? this.handshakeSuccess() : this.webSocket.close()
              }
              ));
              break;
          case `sync`:
              this._onSyncMessage.fire(e);
              break;
          case `ephm`:
              this._onEphemeralMap.fire(e);
              break;
          case `ephp`:
              this._onEphemeralPrimitive.fire(e);
              break;
          case `pong`:
              this.reconnectBackoffCount = Math.max(this.reconnectBackoffCount - 2, 0),
              this.lastPong = Date.now(),
              this.pingQueue.progressQueue(e.id);
              break;
          case `push`:
              if (!co.isElectron)
                  break;
              `notifyPushMessage`in co.bridge && co.bridge.notifyPushMessage(e);
              break;
          default:
              this._onMessage.fire(e)
          }
      }
  }
  ,
  IX = function(e) {
      return e[e.connected = 0] = `connected`,
      e[e.disconnected = 1] = `disconnected`,
      e[e.disconnectedDueToUserIdle = 2] = `disconnectedDueToUserIdle`,
      e[e.failingToConnect = 3] = `failingToConnect`,
      e
  }({})
}
)), RX, tde = t(( () => {
  RX = class {
      schedule(e) {
          this.scheduled || (this.scheduled = Promise.resolve(),
          this.scheduled.then( () => {
              this.scheduled = void 0,
              e()
          }
          ))
      }
  }
}
)), zX, BX, VX, HX = t(( () => {
  zX = class e {
      constructor(t, n, r, i, a, o) {
          this.retries = 0,
          this.id = e.nextId++,
          this.type = t,
          this.model = n,
          this.batchIndex = r,
          this.syncClient = i,
          this.graphQLClient = a,
          this.options = o,
          this.completionPromise = new Promise( (e, t) => {
              this.resolve = e,
              this.reject = t
          }
          ),
          this.completionPromise.catch( () => {}
          )
      }
      async result() {
          return this.completionPromise
      }
      cancel() {
          this.syncClient.cancelTransaction(this),
          this.rollback()
      }
      independentOf(e) {
          return this.model.independentOf(e.model)
      }
      static setNextId(e) {
          this.nextId = e
      }
      async transactionCompleted(e, t=0) {
          this.syncIdNeededForCompletion = t,
          e ? (this.rollback(),
          this.reject(e)) : (await this.syncClient.waitUntilSyncId(t),
          this.resolve(BX.completed))
      }
      offlined(e=VX.network, t) {
          this.offlineReason = e,
          this.rateLimitDelayMs = e === VX.rateLimit ? t : void 0,
          this.resolve(BX.offlined)
      }
      prepare(e) {
          let t = this.graphQLMutation(e);
          if (!t)
              return;
          let n = this;
          return n.graphQLMutationPrepared = typeof t == `string` ? {
              mutationText: t
          } : t,
          n
      }
      static graphQLMutationSize(e) {
          if (e)
              return typeof e == `string` ? e.length : e.mutationText.length + JSON.stringify(e.variables || {}).length + JSON.stringify(e.variableTypes || {}).length
      }
      static #e = this.nextId = Math.floor(Math.random() * 1e6) + 1
  }
  ,
  BX = function(e) {
      return e[e.completed = 0] = `completed`,
      e[e.offlined = 1] = `offlined`,
      e
  }({}),
  VX = function(e) {
      return e.network = `network`,
      e.rateLimit = `rateLimit`,
      e.downtime = `downtime`,
      e
  }({})
}
)), UX, WX = t(( () => {
  ws(),
  nm(),
  F(),
  es(),
  Vh(),
  HX(),
  UX = class e extends zX {
      static async fromSerializedData(t, n, r, i) {
          let a = em.getModelClass(i.modelClass);
          if (!a) {
              w.info(`ArchiveTransaction: Unknown model class ${i.modelClass}`);
              return
          }
          let o = await n.hydrateModel(a, i.modelId);
          if (o && o instanceof Jh) {
              let a = new e(o,i.batchIndex,n,r,i.options);
              return a.id = t,
              a
          } else
              w.info(`ArchiveTransaction: ${i.modelClass} is not an ArchivableModel`, {
                  model: o
              })
      }
      get graphQLOperationName() {
          return `${Rh(this.model.modelName)}Archive`
      }
      graphQLMutation(e) {
          return this.model.archiveMutation()
      }
      constructor(e, t, n, r, i) {
          super(`archive`, e, t, n, r, i),
          this.syncClient.archiveModel(e)
      }
      transformError(e) {
          return e instanceof $o ? e : new $o({
              type: `internal error`,
              message: `Archive transaction failed`,
              userError: !0,
              userPresentableMessage: `Failed to update ${this.model.modelName}`
          })
      }
      serialize() {
          return {
              id: this.id,
              type: `archive`,
              batchIndex: this.batchIndex,
              modelId: this.model.id,
              modelClass: this.model.modelName,
              options: this.options
          }
      }
      undoTransaction() {
          return this.syncClient.unarchive(this.model)
      }
      writeLocalTransactionToDatabase(e) {
          e.delete(this.model.modelName, this.model.id)
      }
      rollback() {
          this.options?.skipRollback !== !0 && (this.model.archivedAt = void 0,
          this.syncClient.addModel(this.model),
          this.model.attachToReferencedProperties())
      }
  }
}
)), GX, KX = t(( () => {
  HX(),
  GX = class {
      constructor(e) {
          this.model = e
      }
      result() {
          return Promise.resolve(BX.completed)
      }
      cancel() {}
      undoTransaction() {
          return this
      }
  }
}
)), qX, JX = t(( () => {
  F(),
  nm(),
  es(),
  Vh(),
  HX(),
  KX(),
  qX = class e extends zX {
      static async fromSerializedData(t, n, r, i) {
          let a = em.getModelClass(i.modelType);
          if (!a)
              throw Error(`Could not retrieve class for model type '${i.modelType}'`);
          let o = new a;
          o.updateFromData(i.model);
          let s = new e(o,i.batchIndex,n,r,i.additionalCreationArgs,i.options);
          return s.id = t,
          s
      }
      get graphQLOperationName() {
          return `${Rh(this.model.modelName)}Create`
      }
      graphQLMutation(e) {
          return this.model.createMutation(e, this.additionalCreationArgs)
      }
      constructor(e, t, n, r, i, a) {
          super(`create`, e, t, n, r, a),
          this.additionalCreationArgs = i,
          this.syncClient.addModel(e) && e.attachToReferencedProperties(),
          e.clearSnapshot()
      }
      transformError(e) {
          return e instanceof $o ? e : new $o({
              type: `internal error`,
              message: `Create transaction failed`,
              userError: !0,
              userPresentableMessage: `Failed to save ${this.model.modelName}`
          })
      }
      serialize() {
          return {
              id: this.id,
              type: `create`,
              batchIndex: this.batchIndex,
              modelType: this.model.modelName,
              model: this.model.serialize({
                  onlyForCreate: !0
              }),
              additionalCreationArgs: this.additionalCreationArgs,
              options: this.options
          }
      }
      undoTransaction() {
          return this.model instanceof Yh ? this.syncClient.delete(this.model) : this.model instanceof Jh ? this.syncClient.archive(this.model) : new GX(this.model)
      }
      writeLocalTransactionToDatabase(e) {
          e.add(this.model.modelName, this.model.serialize({
              onlyForCreate: !0
          }))
      }
      rollback() {
          this.options?.skipRollback !== !0 && this.syncClient.deleteModelAndDependencies(this.model)
      }
  }
}
)), YX, XX = t(( () => {
  nm(),
  F(),
  es(),
  Vh(),
  HX(),
  YX = class e extends zX {
      static async fromSerializedData(t, n, r, i) {
          let a = em.getModelClass(i.modelClass);
          if (!a)
              return;
          let o = await n.hydrateModel(a, i.modelId);
          if (o && (o instanceof Yh || o instanceof Xh)) {
              let a = new e(o,i.batchIndex,n,r,i.additionalDeleteArgs,i.options);
              return a.id = t,
              a
          }
      }
      get graphQLOperationName() {
          return `${Rh(this.model.modelName)}Delete`
      }
      graphQLMutation(e) {
          return this.model.deleteMutation(this.additionalDeleteArgs)
      }
      constructor(e, t, n, r, i, a) {
          super(`delete`, e, t, n, r, a),
          this.syncClient.archiveModel(e),
          this.additionalDeleteArgs = i
      }
      transformError(e) {
          return e instanceof $o ? e : new $o({
              type: `internal error`,
              message: `Delete transaction failed`,
              userError: !0,
              userPresentableMessage: `Failed to delete ${this.model.modelName}`
          })
      }
      serialize() {
          return {
              id: this.id,
              type: `delete`,
              batchIndex: this.batchIndex,
              modelId: this.model.id,
              modelClass: this.model.modelName,
              additionalDeleteArgs: this.additionalDeleteArgs,
              options: this.options
          }
      }
      undoTransaction() {
          return this.model.archivedAt = void 0,
          this.model instanceof Xh ? this.syncClient.unarchive(this.model) : this.syncClient.add(this.model, this.model.supportsUndoCreatedAtArguments ? {
              additionalCreationArgs: {
                  overrideCreatedAt: this.model.createdAt
              }
          } : void 0)
      }
      writeLocalTransactionToDatabase(e) {
          e.delete(this.model.modelName, this.model.id)
      }
      rollback() {
          this.options?.skipRollback !== !0 && (this.model.archivedAt = void 0,
          this.syncClient.addModel(this.model),
          this.model.attachToReferencedProperties())
      }
  }
}
)), ZX, QX, $X, nde = t(( () => {
  So(),
  Yr(),
  es(),
  HX(),
  ZX = 8,
  QX = b.SECOND,
  $X = class {
      constructor(e, t) {
          this.transactions = e,
          this.graphQLClient = t,
          this.offlineDelayMs = void 0,
          this.completionPromise = new Promise( (e, t) => {
              this.resolve = e,
              this.reject = t
          }
          )
      }
      getOfflineDelayMs() {
          return this.offlineDelayMs
      }
      async execute() {
          if (this.transactions.length === 0)
              return BX.completed;
          try {
              let e = this.transactions.length === 1
                , t = this.transactions[0].graphQLOperationName;
              if (!e) {
                  let e = this.transactions.reduce( (e, t) => {
                      let n = t.graphQLOperationName;
                      return e[n] ? e[n] += 1 : e[n] = 1,
                      e
                  }
                  , {});
                  t = Object.keys(e).map(t => t + (e[t] > 1 ? `s` : ``)).join(`_`)
              }
              let n = this.transactions.flatMap(e => Object.entries(e.graphQLMutationPrepared.variableTypes || {}).map( ([e,t]) => `$${e}: ${t}!`)).join(`, `)
                , r = this.transactions.reduce( (e, t) => ({
                  ...e,
                  ...t.graphQLMutationPrepared.variables
              }), {})
                , i = `mutation ${t}${n ? `(${n})` : ``} { ${this.transactions.map( (t, n) => (e ? `` : `o${n + 1}:`) + (typeof t == `string` ? t : t.graphQLMutationPrepared.mutationText)).join(`, `)} }`
                , a = await this.graphQLClient.mutate(i, r, {
                  logUserErrors: !0
              })
                , o = Object.keys(a).reduce( (e, t) => Math.max(e, a[t].lastSyncId), 0);
              for (let e of this.transactions)
                  e.transactionCompleted(void 0, o);
              this.resolve()
          } catch (e) {
              let t = this.transactions.reduce( (e, t) => Math.max(e, t.retries), 0);
              if (qo(e) && e.type === `lock timeout` && t < ZX) {
                  for (let e of this.transactions)
                      e.retries++;
                  this.resolve(BX.offlined)
              } else if (qo(e) && (e.type === `network error` || e.type === `downtime` && e.metaData?.downtimeMode === `offline`)) {
                  let t = e.type === `network error` ? VX.network : VX.downtime;
                  this.resolve(BX.offlined);
                  for (let e of this.transactions)
                      e.offlined(t)
              } else if (Jo(e)) {
                  this.offlineDelayMs = e?.metaData?.rateLimitResult?.duration || QX,
                  this.resolve(BX.offlined);
                  for (let e of this.transactions)
                      e.offlined(VX.rateLimit, this.offlineDelayMs)
              } else {
                  this.reject(e);
                  for (let t of this.transactions)
                      t.transactionCompleted(t.transformError(e))
              }
          }
          return this.completionPromise
      }
  }
}
)), eZ, tZ = t(( () => {
  nm(),
  F(),
  es(),
  Vh(),
  KX(),
  HX(),
  eZ = class e extends zX {
      static async fromSerializedData(t, n, r, i) {
          let a = em.getModelClass(i.modelClass);
          if (!a)
              return;
          let o = await n.hydrateModel(a, i.modelId);
          if (o) {
              let a = new e(o,i.batchIndex,n,r,i.options);
              return a.id = t,
              a
          }
      }
      get graphQLOperationName() {
          return `${Rh(this.model.modelName)}Unarchive`
      }
      graphQLMutation(e) {
          return this.model.unarchiveMutation()
      }
      constructor(e, t, n, r, i) {
          super(`unarchive`, e, t, n, r, i),
          this.syncClient.addModel(e),
          e.attachToReferencedProperties()
      }
      transformError(e) {
          return e instanceof $o ? e : new $o({
              type: `internal error`,
              message: `Unarchive transaction failed`,
              userError: !0,
              userPresentableMessage: `Failed to un-archive ${this.model.modelName}`
          })
      }
      serialize() {
          return {
              id: this.id,
              type: `unarchive`,
              batchIndex: this.batchIndex,
              modelId: this.model.id,
              modelClass: this.model.modelName,
              options: this.options
          }
      }
      undoTransaction() {
          return this.model instanceof Xh ? this.syncClient.delete(this.model) : this.model instanceof Jh ? this.syncClient.archive(this.model) : new GX(this.model)
      }
      writeLocalTransactionToDatabase(e) {
          e.add(this.model.modelName, this.model.serialize())
      }
      rollback() {
          this.options?.skipRollback !== !0 && (this.model.archivedAt = new Date,
          this.syncClient.archiveModel(this.model))
      }
  }
}
)), nZ, rZ = t(( () => {
  zt(),
  nm(),
  es(),
  Vh(),
  KX(),
  HX(),
  nZ = class e extends zX {
      static async fromSerializedData(t, n, r, i) {
          let a = em.getModelClass(i.modelClass);
          if (!a)
              return;
          let o = await n.hydrateModel(a, i.modelId);
          if (o) {
              let a = new e(o,i.batchIndex,n,r,i.additionalUpdateArgs,i.options);
              for (let e in a.id = t,
              a.changeSnapshot = i.changeSnapshot,
              i.changeSnapshot.changes) {
                  let t = i.changeSnapshot.changes[e].unoptimizedUpdated || i.changeSnapshot.changes[e].updated;
                  o.setSerializedValue(e, t, o.properties[e])
              }
              return a
          }
      }
      get graphQLOperationName() {
          return `${Rh(this.model.modelName)}Update`
      }
      graphQLMutation(e) {
          return this.model.updateMutation(e, this.changeSnapshot, this.additionalUpdateArgs)
      }
      constructor(e, t, n, r, i, a) {
          super(`update`, e, t, n, r, a),
          this.changeSnapshot = e.changeSnapshot(),
          this.additionalUpdateArgs = i || {}
      }
      transformError(e) {
          return e instanceof $o ? e : new $o({
              type: `internal error`,
              message: `Update transaction failed`,
              userError: !0,
              userPresentableMessage: `Failed to update ${this.model.modelName}`
          })
      }
      rebase() {
          if (this.changeSnapshot)
              for (let e in this.changeSnapshot.changes) {
                  let t = this.changeSnapshot.changes[e].unoptimizedUpdated || this.changeSnapshot.changes[e].updated;
                  this.changeSnapshot.changes[e].original = this.model.serializedValue(e, this.model[e]),
                  this.model.setSerializedValue(e, t, this.model.properties[e])
              }
      }
      serialize() {
          return {
              id: this.id,
              type: `update`,
              batchIndex: this.batchIndex,
              modelId: this.model.id,
              modelClass: this.model.modelName,
              changeSnapshot: this.changeSnapshot,
              additionalUpdateArgs: this.additionalUpdateArgs,
              options: this.options
          }
      }
      undoTransaction() {
          if (this.changeSnapshot) {
              for (let e in this.changeSnapshot.changes)
                  this.model.setSerializedValue(e, this.changeSnapshot.changes[e].updatedFrom, this.model.properties[e]);
              return this.syncClient.update(this.model)
          }
          return new GX(this.model)
      }
      writeLocalTransactionToDatabase(e) {
          e.put(this.model.modelName, this.model.serialize())
      }
      rollback() {
          if (this.options?.skipRollback !== !0 && this.changeSnapshot) {
              let e = {};
              for (let t in this.changeSnapshot.changes)
                  e[t] = this.changeSnapshot.changes[t].original;
              Mt( () => {
                  this.model.updateFromData(e)
              }
              )
          }
      }
  }
}
)), iZ, aZ, oZ, sZ, rde = t(( () => {
  tde(),
  Yr(),
  zn(),
  ws(),
  Es(),
  om(),
  es(),
  WX(),
  JX(),
  XX(),
  HX(),
  nde(),
  tZ(),
  rZ(),
  iZ = 40,
  aZ = 9e6,
  oZ = 3 * b.SECOND,
  sZ = class {
      get onTransactionCountChange() {
          return this._onTransactionCountChange
      }
      get onTransactionQueued() {
          return this._onTransactionQueued
      }
      constructor(e, t) {
          this.createdTransactions = [],
          this.queuedTransactions = [],
          this.executingTransactions = [],
          this.completedButUnsyncedTransactions = [],
          this._onTransactionCountChange = new Ts,
          this._onTransactionQueued = new Ts,
          this.dequeueTransaction = new RX,
          this.batchIndex = 0,
          this.commitCreatedTransactions = new RX,
          this.handleTimedRecheck = () => {
              this.dequeueNextTransactions()
          }
          ,
          this.graphQLClient = e,
          this.syncClient = t
      }
      create(e, t) {
          let n = new qX(e,this.batchIndex,this.syncClient,this.graphQLClient,t?.additionalCreationArgs,t?.transactionOptions);
          return t?.sendSynchronously ? this.immediatelyExecuteTransaction(n) : this.enqueueTransaction(n),
          n
      }
      update(e, t) {
          let n = new nZ(e,this.batchIndex,this.syncClient,this.graphQLClient,t?.additionalUpdateArgs,t?.transactionOptions);
          return t?.sendSynchronously && this.transactionIsIndependentOfRunningTransactions(n) ? this.immediatelyExecuteTransaction(n) : this.enqueueTransaction(n),
          e.didUpdate(),
          n
      }
      archive(e, t) {
          let n = new UX(e,this.batchIndex,this.syncClient,this.graphQLClient,t);
          return this.enqueueTransaction(n),
          n
      }
      unarchive(e, t) {
          let n = new eZ(e,this.batchIndex,this.syncClient,this.graphQLClient,t);
          return this.enqueueTransaction(n),
          n
      }
      delete(e, t) {
          let n = new YX(e,this.batchIndex,this.syncClient,this.graphQLClient,t?.additionalDeleteArgs,t?.transactionOptions);
          return this.enqueueTransaction(n),
          n
      }
      modelUpserted(e) {
          if (this.persistedTransactionsEnqueue?.length) {
              let t;
              for (let n of this.persistedTransactionsEnqueue)
                  n instanceof qX && n.model.id === e && (this.cancelTransaction(n).catch(e => {
                      w.error(`Error canceling transaction`, e, {
                          transaction: {
                              id: n.id,
                              modelId: n.model.id
                          }
                      })
                  }
                  ),
                  w.info(`Canceling persisted create transaction for model ${e} as we received an I packet for it`),
                  t ??= [],
                  t.push(n));
              t?.length && (this.persistedTransactionsEnqueue = this.persistedTransactionsEnqueue.filter(e => !t.includes(e)))
          }
      }
      rebaseTransactions(e, t) {
          if (this.lastSyncId = t,
          this.completedButUnsyncedTransactions.length && (this.completedButUnsyncedTransactions = this.completedButUnsyncedTransactions.filter(e => (e.syncIdNeededForCompletion || 0) > t)),
          this.persistedTransactionsEnqueue?.length || this.queuedTransactions.length || this.executingTransactions.length || this.completedButUnsyncedTransactions.length) {
              let t = this.completedButUnsyncedTransactions.concat(this.executingTransactions, this.queuedTransactions, this.persistedTransactionsEnqueue ?? []);
              for (let n of t)
                  n instanceof nZ && n.model === e && n.rebase()
          }
      }
      async loadPersistedTransactions(e) {
          this.database = e;
          let t = await this.database.getAllTransactions();
          w.network(`Loaded ${t.length} persisted transactions`),
          this.persistedTransactionsEnqueue = (await Promise.all(t.map(async e => {
              let t = await this.deserialize(e.id, e);
              if (t?.id)
                  return t;
              t ? w.error(`Invalid deserialized transaction`, void 0, {
                  transaction: t,
                  serializedTransaction: e
              }) : w.info(`Could not deserialize transaction`, {
                  transaction: t,
                  serializedTransaction: e
              }),
              this.database.deleteTransaction(e.id)
          }
          ))).concrete();
          let n = this.persistedTransactionsEnqueue.reduce( (e, t) => Math.max(e, t.id), 0);
          zX.setNextId(n + 1),
          await Promise.all(this.persistedTransactionsEnqueue.map(e => this.syncClient.hydrateModel(e.model.modelClass, e.model.id, {
              onlyIfLocallyAvailable: !0
          })))
      }
      confirmPersistedTransactions() {
          if (this.persistedTransactionsEnqueue) {
              for (let e of this.persistedTransactionsEnqueue)
                  this.enqueueTransaction(e).catch(t => {
                      w.error(`Error enqueueing persisted transaction`, t, {
                          transaction: {
                              id: e.id,
                              modelId: e.model.id
                          }
                      })
                  }
                  );
              this.persistedTransactionsEnqueue = void 0
          }
      }
      async cancelTransaction(e) {
          await this.database.deleteTransaction(e.id);
          let t = this.queuedTransactions.indexOf(e);
          t !== -1 && this.queuedTransactions.splice(t, 1),
          this.outstandingTransactionCountChanged()
      }
      transactionsForModel(e) {
          return this.queuedTransactions.concat(this.executingTransactions).concat(this.createdTransactions).filter(t => t.model === e)
      }
      async deserialize(e, t) {
          switch (t.type) {
          case `create`:
              return await qX.fromSerializedData(e, this.syncClient, this.graphQLClient, t);
          case `update`:
              return await nZ.fromSerializedData(e, this.syncClient, this.graphQLClient, t);
          case `archive`:
              return await UX.fromSerializedData(e, this.syncClient, this.graphQLClient, t);
          case `unarchive`:
              return await eZ.fromSerializedData(e, this.syncClient, this.graphQLClient, t);
          case `delete`:
              return await YX.fromSerializedData(e, this.syncClient, this.graphQLClient, t);
          default:
              w.error(`Unknown transaction type`, void 0, {
                  serializedData: t
              }),
              y(t);
              return
          }
      }
      async immediatelyExecuteTransaction(e) {
          let t = new Set;
          this._onTransactionQueued.fire(e);
          let n, r;
          try {
              n = e.prepare(t)
          } catch (t) {
              w.error(`Error preparing transaction`, t, {
                  transaction: {
                      id: e.id,
                      modelId: e.model.id,
                      modelName: e.model.modelName
                  }
              }),
              r = new $o({
                  type: `other`,
                  message: `error preparing transaction`,
                  userError: !1
              })
          }
          if (!n) {
              e.transactionCompleted(r),
              this.outstandingTransactionCountChanged();
              return
          }
          this.database.putTransactions([e]),
          this.executeTransactionBatch([n]),
          this.outstandingTransactionCountChanged()
      }
      async enqueueTransaction(e) {
          if (e.model.modelClass.loadStrategy === rm.local) {
              this.database.writeTransaction({
                  metaStore: !1,
                  syncActionStore: !1
              }, t => {
                  e.writeLocalTransactionToDatabase(t)
              }
              ),
              e.transactionCompleted();
              return
          }
          this.createdTransactions.push(e),
          this._onTransactionQueued.fire(e),
          this.commitCreatedTransactions.schedule(async () => {
              this.batchIndex++;
              let e = this.createdTransactions.concat();
              this.createdTransactions = [],
              this.queuedTransactions.push(...e),
              await this.database.putTransactions(e),
              this.outstandingTransactionCountChanged(),
              this.dequeueNextTransactions()
          }
          )
      }
      dequeueNextTransactions() {
          this.dequeueTransaction.schedule( () => {
              if (this.isRateLimited() || this.queuedTransactions.length === 0 || this.executingTransactions.length >= iZ)
                  return;
              let e = 0
                , t = this.queuedTransactions[0].batchIndex
                , n = []
                , r = new Set;
              for (; e < aZ && this.queuedTransactions.length > 0 && n.length < iZ && this.queuedTransactions[0].batchIndex === t && this.transactionIsIndependentOfRunningTransactions(this.queuedTransactions[0]); ) {
                  let t = this.queuedTransactions[0];
                  if (!t)
                      break;
                  let i, a;
                  try {
                      i = t.prepare(r)
                  } catch (e) {
                      w.error(`Error preparing transaction`, e, {
                          transaction: {
                              id: t.id,
                              modelId: t.model.id,
                              modelName: t.model.modelName
                          }
                      }),
                      a = new $o({
                          type: `other`,
                          message: `error preparing transaction`,
                          userError: !1
                      })
                  }
                  if (!i) {
                      t.transactionCompleted(a),
                      this.database.deleteTransaction(t.id),
                      this.queuedTransactions.shift();
                      continue
                  }
                  let o = zX.graphQLMutationSize(i.graphQLMutationPrepared) ?? 0;
                  if (e > 0 && e + o > aZ)
                      break;
                  for (let e of Object.keys(i.graphQLMutationPrepared.variables || {}))
                      r.add(e);
                  this.queuedTransactions.shift(),
                  n.push(i),
                  e += o
              }
              if (n.length === 0) {
                  this.outstandingTransactionCountChanged(),
                  this.queuedTransactions.length > 0 && this.executingTransactions.length === 0 && this.dequeueNextTransactions();
                  return
              }
              this.executeTransactionBatch(n),
              this.dequeueNextTransactions()
          }
          )
      }
      transactionIsIndependentOfRunningTransactions(e) {
          for (let t of this.executingTransactions)
              if (e.independentOf(t) === !1)
                  return !1;
          return !0
      }
      async executeTransactionBatch(e) {
          if (e.length === 0)
              return;
          this.executingTransactions = this.executingTransactions.concat(e);
          let t = new $X(e,this.graphQLClient);
          try {
              if (await t.execute() === BX.offlined) {
                  this.handleBatchOfflined(e, t.getOfflineDelayMs());
                  return
              }
          } catch (t) {
              if (Jo(t)) {
                  let n = t?.metaData?.rateLimitResult?.duration ?? oZ;
                  this.handleBatchOfflined(e, n);
                  return
              }
          }
          for (let t of e)
              this.executingTransactions.splice(this.executingTransactions.indexOf(t), 1),
              await this.database.deleteTransaction(t.id),
              (!this.lastSyncId || (t.syncIdNeededForCompletion ?? 0) > this.lastSyncId) && this.completedButUnsyncedTransactions.push(t);
          this.outstandingTransactionCountChanged(),
          this.dequeueNextTransactions()
      }
      resumeAfterRateLimit() {
          this.rateLimitResumeTimer &&= (window.clearTimeout(this.rateLimitResumeTimer),
          void 0),
          this.rateLimitedUntil = void 0,
          this.dequeueNextTransactions()
      }
      isRateLimited() {
          return this.rateLimitedUntil ? Date.now() >= this.rateLimitedUntil ? (this.resumeAfterRateLimit(),
          !1) : !0 : !1
      }
      outstandingTransactionCountChanged() {
          this._onTransactionCountChange.fire(this.queuedTransactions.length + this.executingTransactions.length),
          this.queuedTransactions.length || this.executingTransactions.length ? this.checkInterval ||= window.setInterval(this.handleTimedRecheck, 2e3) : this.checkInterval &&= (window.clearInterval(this.checkInterval),
          void 0)
      }
      scheduleRateLimitResume(e) {
          let t = Math.max(e, b.SECOND)
            , n = Date.now()
            , r = n + t;
          return this.rateLimitedUntil = Math.max(this.rateLimitedUntil ?? 0, r),
          Math.max(this.rateLimitedUntil - n, 0)
      }
      handleBatchOfflined(e, t) {
          if (this.executingTransactions = this.executingTransactions.filter(t => !e.includes(t)),
          this.queuedTransactions.unshift(...e),
          this.outstandingTransactionCountChanged(),
          t === void 0)
              return;
          let n = this.scheduleRateLimitResume(br(t, 0, b.SECOND));
          if (n === 0) {
              this.resumeAfterRateLimit();
              return
          }
          this.rateLimitResumeTimer && window.clearTimeout(this.rateLimitResumeTimer),
          this.rateLimitResumeTimer = window.setTimeout( () => {
              this.rateLimitResumeTimer = void 0,
              this.rateLimitedUntil = void 0,
              this.dequeueNextTransactions()
          }
          , n)
      }
  }
}
));
async function ide(e, t) {
  let n = Ut`
  query SyncEntityCount {
    syncEntityCount {
      counts
    }
  }
`;
  return (await e.query(n, void 0, t)).syncEntityCount.counts
}
var ade = t(( () => {
  Wt()
}
)), cZ, lZ, uZ = t(( () => {
  cZ = e(te(), 1),
  zt(),
  Xp(),
  lZ = class {
      constructor(e) {
          this.nextBatch = [],
          this.handleResolve = async () => {
              let e = this.nextBatch;
              this.nextBatch = [];
              function t() {
                  let t = [];
                  Mt( () => {
                      for (let n = 0; n < e.length; n++) {
                          let r = e[n];
                          r.promise.isPending ? t.push(r) : r.promise.error ? r.reject(r.promise.error) : r.resolve(r.mapper(r.promise.value))
                      }
                  }
                  ),
                  e = t
              }
              let n;
              this.resolvePartialIntervalTimeout && (n = window.setInterval(t, this.resolvePartialIntervalTimeout)),
              await Promise.allSettled(e.map(e => e.promise)),
              t(),
              n && clearInterval(n)
          }
          ,
          this.resolvePartialIntervalTimeout = e
      }
      addOperation(e, t) {
          this.nextBatch.length === 0 && setTimeout(this.handleResolve, 0);
          let n = e instanceof Promise ? e : Promise.resolve(e);
          return new Promise( (e, r) => {
              let i = new Jp( (e, t) => n.then(e).catch(t));
              i.catch(cZ.default),
              this.nextBatch.push({
                  promise: i,
                  mapper: t,
                  resolve: e,
                  reject: r
              })
          }
          )
      }
  }
}
)), dZ, fZ = t(( () => {
  Es(),
  dZ = class {
      static #e = this.onLoadingDone = new Ts
  }
}
)), pZ, ode = t(( () => {
  uZ(),
  pZ = class {
      constructor(e) {
          this.batchedMapper = new lZ(e)
      }
      addOperation(e) {
          return this.batchedMapper.addOperation(e, e => e)
      }
  }
}
)), mZ, sde = t(( () => {
  mZ = class {
      constructor(e) {
          this.ttl = e,
          this.store = new Map,
          this.timeouts = new Map
      }
      set(e, t) {
          this.store.set(e, t),
          this.resetTimeout(e)
      }
      get(e) {
          let t = this.store.get(e);
          return t !== void 0 && this.resetTimeout(e),
          t
      }
      getOrSet(e, t) {
          let n = this.store.get(e);
          return n === void 0 && (n = t(),
          this.set(e, n)),
          n
      }
      resetTimeout(e) {
          let t = this.timeouts.get(e);
          t && clearTimeout(t);
          let n = setTimeout( () => {
              this.store.delete(e),
              this.timeouts.delete(e)
          }
          , this.ttl);
          this.timeouts.set(e, n)
      }
  }
}
)), hZ, gZ, cde = t(( () => {
  hZ = e(te(), 1),
  ss(),
  OY(),
  ro(),
  TY(),
  Yr(),
  zn(),
  lo(),
  ws(),
  gZ = class {
      async ensureSubscribed(e, t=!1) {
          let n = this.syncSubscriptions;
          if (!n)
              return;
          let r = e.filter(e => !wY.isSubscribed(n, e));
          if (r.length !== 0)
              if (this.syncClient.isConnected) {
                  let e = os()
                    , t = no();
                  t.catch(hZ.default),
                  this.syncSubscriptionMessagePromises.set(`syncSub_${e}`, t),
                  this.socket.send({
                      cmd: `syncSub`,
                      syncSubscriptions: r,
                      id: e
                  }),
                  await EY(t, 5 * b.SECOND)
              } else
                  await this.persistSyncSubscriptions(r),
                  t || this.broadcastChannel?.postMessage({
                      type: `syncSubscriptions`,
                      subscriptions: r
                  })
      }
      getSyncSubscriptions() {
          return this.syncSubscriptions ? [...this.syncSubscriptions] : void 0
      }
      setSyncSubscriptions(e) {
          this.syncSubscriptions = new Set(e)
      }
      [Symbol.dispose]() {
          this.socket?.onMessage.unsubscribe(this.handleMessage),
          this.broadcastChannel?.removeEventListener(`message`, this.handleBroadcastMessage)
      }
      constructor(e, t, n) {
          this.syncClient = e,
          this.database = t,
          this.socket = n,
          this.syncSubscriptionMessagePromises = new Map,
          this.handleBroadcastMessage = e => {
              let t = e.data;
              switch (t.type) {
              case `syncSubscriptions`:
                  this.ensureSubscribed(t.subscriptions, !0).catch(e => {
                      w.error(`Error handling broadcasted sync subscriptions`, e)
                  }
                  );
                  break;
              default:
                  y(t.type)
              }
          }
          ,
          this.handleMessage = e => {
              e.cmd === `syncSub` && this.handleSyncSubscriptionMessage(e)
          }
          ,
          !co.isElectron && typeof BroadcastChannel == `function` && (this.broadcastChannel = new BroadcastChannel(`sync-subscription-manager`),
          this.broadcastChannel.addEventListener(`message`, this.handleBroadcastMessage)),
          this.socket.onMessage.subscribe(this.handleMessage)
      }
      async handleSyncSubscriptionMessage(e) {
          if (e.cmd === `syncSub`) {
              if (!this.syncSubscriptions) {
                  w.error(`Sync subscriptions not set on sync client`, void 0, {
                      databaseId: this.database.id
                  });
                  return
              }
              let t = this.syncSubscriptions
                , n = e.addedSyncSubscriptions.filter(e => !t.has(e));
              n.length > 0 && (await this.persistSyncSubscriptions(n),
              this.broadcastChannel?.postMessage({
                  type: `syncSubscriptions`,
                  subscriptions: n
              }))
          }
          if (e.id) {
              let t = `${e.cmd}_${e.id}`
                , n = this.syncSubscriptionMessagePromises.get(t);
              n && (n.resolve(),
              this.syncSubscriptionMessagePromises.delete(t))
          }
      }
      async persistSyncSubscriptions(e) {
          let t = this.syncSubscriptions;
          if (!t)
              throw Error(`Sync subscriptions not enabled`);
          let n = e.filter(e => !t.has(e));
          if (n.length > 0) {
              for (let e of n)
                  t.add(e);
              let e = [...t];
              this.socket.setSyncSubscriptions(e),
              await this.database.writeTransaction({
                  metaStore: !0,
                  syncActionStore: !1
              }, async t => {
                  await t.ensureSyncSubscriptions(e)
              }
              ).catch(e => {
                  w.error(`Error persisting sync subscriptions`, e, {
                      databaseId: this.database.id
                  });
                  for (let e of n)
                      t.delete(e);
                  throw e
              }
              )
          }
      }
  }
}
)), _Z, vZ = t(( () => {
  zn(),
  Yr(),
  _Z = class {
      static getCountBucket(e, t=`k`) {
          let n = t === `k` ? 1e3 : t === `hg` ? 100 : t === `dag` ? 10 : Ln(t)
            , r = 0;
          for (; ; ) {
              let i = 2 ** r;
              if (e <= i * n || r >= 10)
                  return `${i}${t}`;
              r++
          }
      }
      static getTimeBucket(e, t) {
          let n = t === `h` ? Math.ceil(e / b.HOUR) : Ln(t)
            , r = 0;
          for (; ; ) {
              let e = 2 ** r;
              if (n <= e || r >= 12)
                  return `${e}${t}`;
              r++
          }
      }
  }
}
)), lde = n(( (e, t) => {
  (function(n, r) {
      typeof e == `object` && typeof t == `object` ? t.exports = r() : typeof define == `function` && define.amd ? define([], r) : typeof e == `object` ? e.bowser = r() : n.bowser = r()
  }
  )(e, (function() {
      return function(e) {
          var t = {};
          function n(r) {
              if (t[r])
                  return t[r].exports;
              var i = t[r] = {
                  i: r,
                  l: !1,
                  exports: {}
              };
              return e[r].call(i.exports, i, i.exports, n),
              i.l = !0,
              i.exports
          }
          return n.m = e,
          n.c = t,
          n.d = function(e, t, r) {
              n.o(e, t) || Object.defineProperty(e, t, {
                  enumerable: !0,
                  get: r
              })
          }
          ,
          n.r = function(e) {
              typeof Symbol < `u` && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                  value: `Module`
              }),
              Object.defineProperty(e, `__esModule`, {
                  value: !0
              })
          }
          ,
          n.t = function(e, t) {
              if (1 & t && (e = n(e)),
              8 & t || 4 & t && typeof e == `object` && e && e.__esModule)
                  return e;
              var r = Object.create(null);
              if (n.r(r),
              Object.defineProperty(r, `default`, {
                  enumerable: !0,
                  value: e
              }),
              2 & t && typeof e != `string`)
                  for (var i in e)
                      n.d(r, i, function(t) {
                          return e[t]
                      }
                      .bind(null, i));
              return r
          }
          ,
          n.n = function(e) {
              var t = e && e.__esModule ? function() {
                  return e.default
              }
              : function() {
                  return e
              }
              ;
              return n.d(t, `a`, t),
              t
          }
          ,
          n.o = function(e, t) {
              return Object.prototype.hasOwnProperty.call(e, t)
          }
          ,
          n.p = ``,
          n(n.s = 90)
      }({
          17: function(e, t, n) {
              t.__esModule = !0,
              t.default = void 0;
              var r = n(18);
              t.default = function() {
                  function e() {}
                  return e.getFirstMatch = function(e, t) {
                      var n = t.match(e);
                      return n && n.length > 0 && n[1] || ``
                  }
                  ,
                  e.getSecondMatch = function(e, t) {
                      var n = t.match(e);
                      return n && n.length > 1 && n[2] || ``
                  }
                  ,
                  e.matchAndReturnConst = function(e, t, n) {
                      if (e.test(t))
                          return n
                  }
                  ,
                  e.getWindowsVersionName = function(e) {
                      switch (e) {
                      case `NT`:
                          return `NT`;
                      case `XP`:
                          return `XP`;
                      case `NT 5.0`:
                          return `2000`;
                      case `NT 5.1`:
                          return `XP`;
                      case `NT 5.2`:
                          return `2003`;
                      case `NT 6.0`:
                          return `Vista`;
                      case `NT 6.1`:
                          return `7`;
                      case `NT 6.2`:
                          return `8`;
                      case `NT 6.3`:
                          return `8.1`;
                      case `NT 10.0`:
                          return `10`;
                      default:
                          return
                      }
                  }
                  ,
                  e.getMacOSVersionName = function(e) {
                      var t = e.split(`.`).splice(0, 2).map((function(e) {
                          return parseInt(e, 10) || 0
                      }
                      ));
                      if (t.push(0),
                      t[0] === 10)
                          switch (t[1]) {
                          case 5:
                              return `Leopard`;
                          case 6:
                              return `Snow Leopard`;
                          case 7:
                              return `Lion`;
                          case 8:
                              return `Mountain Lion`;
                          case 9:
                              return `Mavericks`;
                          case 10:
                              return `Yosemite`;
                          case 11:
                              return `El Capitan`;
                          case 12:
                              return `Sierra`;
                          case 13:
                              return `High Sierra`;
                          case 14:
                              return `Mojave`;
                          case 15:
                              return `Catalina`;
                          default:
                              return
                          }
                  }
                  ,
                  e.getAndroidVersionName = function(e) {
                      var t = e.split(`.`).splice(0, 2).map((function(e) {
                          return parseInt(e, 10) || 0
                      }
                      ));
                      if (t.push(0),
                      !(t[0] === 1 && t[1] < 5))
                          return t[0] === 1 && t[1] < 6 ? `Cupcake` : t[0] === 1 && t[1] >= 6 ? `Donut` : t[0] === 2 && t[1] < 2 ? `Eclair` : t[0] === 2 && t[1] === 2 ? `Froyo` : t[0] === 2 && t[1] > 2 ? `Gingerbread` : t[0] === 3 ? `Honeycomb` : t[0] === 4 && t[1] < 1 ? `Ice Cream Sandwich` : t[0] === 4 && t[1] < 4 ? `Jelly Bean` : t[0] === 4 && t[1] >= 4 ? `KitKat` : t[0] === 5 ? `Lollipop` : t[0] === 6 ? `Marshmallow` : t[0] === 7 ? `Nougat` : t[0] === 8 ? `Oreo` : t[0] === 9 ? `Pie` : void 0
                  }
                  ,
                  e.getVersionPrecision = function(e) {
                      return e.split(`.`).length
                  }
                  ,
                  e.compareVersions = function(t, n, r) {
                      r === void 0 && (r = !1);
                      var i = e.getVersionPrecision(t)
                        , a = e.getVersionPrecision(n)
                        , o = Math.max(i, a)
                        , s = 0
                        , c = e.map([t, n], (function(t) {
                          var n = o - e.getVersionPrecision(t)
                            , r = t + Array(n + 1).join(`.0`);
                          return e.map(r.split(`.`), (function(e) {
                              return Array(20 - e.length).join(`0`) + e
                          }
                          )).reverse()
                      }
                      ));
                      for (r && (s = o - Math.min(i, a)),
                      --o; o >= s; ) {
                          if (c[0][o] > c[1][o])
                              return 1;
                          if (c[0][o] === c[1][o]) {
                              if (o === s)
                                  return 0;
                              --o
                          } else if (c[0][o] < c[1][o])
                              return -1
                      }
                  }
                  ,
                  e.map = function(e, t) {
                      var n, r = [];
                      if (Array.prototype.map)
                          return Array.prototype.map.call(e, t);
                      for (n = 0; n < e.length; n += 1)
                          r.push(t(e[n]));
                      return r
                  }
                  ,
                  e.find = function(e, t) {
                      var n, r;
                      if (Array.prototype.find)
                          return Array.prototype.find.call(e, t);
                      for (n = 0,
                      r = e.length; n < r; n += 1) {
                          var i = e[n];
                          if (t(i, n))
                              return i
                      }
                  }
                  ,
                  e.assign = function(e) {
                      for (var t, n, r = e, i = arguments.length, a = Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++)
                          a[o - 1] = arguments[o];
                      if (Object.assign)
                          return Object.assign.apply(Object, [e].concat(a));
                      var s = function() {
                          var e = a[t];
                          typeof e == `object` && e && Object.keys(e).forEach((function(t) {
                              r[t] = e[t]
                          }
                          ))
                      };
                      for (t = 0,
                      n = a.length; t < n; t += 1)
                          s();
                      return e
                  }
                  ,
                  e.getBrowserAlias = function(e) {
                      return r.BROWSER_ALIASES_MAP[e]
                  }
                  ,
                  e.getBrowserTypeByAlias = function(e) {
                      return r.BROWSER_MAP[e] || ``
                  }
                  ,
                  e
              }(),
              e.exports = t.default
          },
          18: function(e, t, n) {
              t.__esModule = !0,
              t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0,
              t.BROWSER_ALIASES_MAP = {
                  "Amazon Silk": `amazon_silk`,
                  "Android Browser": `android`,
                  Bada: `bada`,
                  BlackBerry: `blackberry`,
                  Chrome: `chrome`,
                  Chromium: `chromium`,
                  Electron: `electron`,
                  Epiphany: `epiphany`,
                  Firefox: `firefox`,
                  Focus: `focus`,
                  Generic: `generic`,
                  "Google Search": `google_search`,
                  Googlebot: `googlebot`,
                  "Internet Explorer": `ie`,
                  "K-Meleon": `k_meleon`,
                  Maxthon: `maxthon`,
                  "Microsoft Edge": `edge`,
                  "MZ Browser": `mz`,
                  "NAVER Whale Browser": `naver`,
                  Opera: `opera`,
                  "Opera Coast": `opera_coast`,
                  "Pale Moon": `pale_moon`,
                  PhantomJS: `phantomjs`,
                  Puffin: `puffin`,
                  QupZilla: `qupzilla`,
                  QQ: `qq`,
                  QQLite: `qqlite`,
                  Safari: `safari`,
                  Sailfish: `sailfish`,
                  "Samsung Internet for Android": `samsung_internet`,
                  SeaMonkey: `seamonkey`,
                  Sleipnir: `sleipnir`,
                  Swing: `swing`,
                  Tizen: `tizen`,
                  "UC Browser": `uc`,
                  Vivaldi: `vivaldi`,
                  "WebOS Browser": `webos`,
                  WeChat: `wechat`,
                  "Yandex Browser": `yandex`,
                  Roku: `roku`
              },
              t.BROWSER_MAP = {
                  amazon_silk: `Amazon Silk`,
                  android: `Android Browser`,
                  bada: `Bada`,
                  blackberry: `BlackBerry`,
                  chrome: `Chrome`,
                  chromium: `Chromium`,
                  electron: `Electron`,
                  epiphany: `Epiphany`,
                  firefox: `Firefox`,
                  focus: `Focus`,
                  generic: `Generic`,
                  googlebot: `Googlebot`,
                  google_search: `Google Search`,
                  ie: `Internet Explorer`,
                  k_meleon: `K-Meleon`,
                  maxthon: `Maxthon`,
                  edge: `Microsoft Edge`,
                  mz: `MZ Browser`,
                  naver: `NAVER Whale Browser`,
                  opera: `Opera`,
                  opera_coast: `Opera Coast`,
                  pale_moon: `Pale Moon`,
                  phantomjs: `PhantomJS`,
                  puffin: `Puffin`,
                  qupzilla: `QupZilla`,
                  qq: `QQ Browser`,
                  qqlite: `QQ Browser Lite`,
                  safari: `Safari`,
                  sailfish: `Sailfish`,
                  samsung_internet: `Samsung Internet for Android`,
                  seamonkey: `SeaMonkey`,
                  sleipnir: `Sleipnir`,
                  swing: `Swing`,
                  tizen: `Tizen`,
                  uc: `UC Browser`,
                  vivaldi: `Vivaldi`,
                  webos: `WebOS Browser`,
                  wechat: `WeChat`,
                  yandex: `Yandex Browser`
              },
              t.PLATFORMS_MAP = {
                  tablet: `tablet`,
                  mobile: `mobile`,
                  desktop: `desktop`,
                  tv: `tv`,
                  bot: `bot`
              },
              t.OS_MAP = {
                  WindowsPhone: `Windows Phone`,
                  Windows: `Windows`,
                  MacOS: `macOS`,
                  iOS: `iOS`,
                  Android: `Android`,
                  WebOS: `WebOS`,
                  BlackBerry: `BlackBerry`,
                  Bada: `Bada`,
                  Tizen: `Tizen`,
                  Linux: `Linux`,
                  ChromeOS: `Chrome OS`,
                  PlayStation4: `PlayStation 4`,
                  Roku: `Roku`
              },
              t.ENGINE_MAP = {
                  EdgeHTML: `EdgeHTML`,
                  Blink: `Blink`,
                  Trident: `Trident`,
                  Presto: `Presto`,
                  Gecko: `Gecko`,
                  WebKit: `WebKit`
              }
          },
          90: function(e, t, n) {
              t.__esModule = !0,
              t.default = void 0;
              var r, i = (r = n(91)) && r.__esModule ? r : {
                  default: r
              }, a = n(18);
              function o(e, t) {
                  for (var n = 0; n < t.length; n++) {
                      var r = t[n];
                      r.enumerable = r.enumerable || !1,
                      r.configurable = !0,
                      `value`in r && (r.writable = !0),
                      Object.defineProperty(e, r.key, r)
                  }
              }
              t.default = function() {
                  function e() {}
                  var t, n, r;
                  return e.getParser = function(e, t) {
                      if (t === void 0 && (t = !1),
                      typeof e != `string`)
                          throw Error(`UserAgent should be a string`);
                      return new i.default(e,t)
                  }
                  ,
                  e.parse = function(e) {
                      return new i.default(e).getResult()
                  }
                  ,
                  t = e,
                  r = [{
                      key: `BROWSER_MAP`,
                      get: function() {
                          return a.BROWSER_MAP
                      }
                  }, {
                      key: `ENGINE_MAP`,
                      get: function() {
                          return a.ENGINE_MAP
                      }
                  }, {
                      key: `OS_MAP`,
                      get: function() {
                          return a.OS_MAP
                      }
                  }, {
                      key: `PLATFORMS_MAP`,
                      get: function() {
                          return a.PLATFORMS_MAP
                      }
                  }],
                  (n = null) && o(t.prototype, n),
                  r && o(t, r),
                  e
              }(),
              e.exports = t.default
          },
          91: function(e, t, n) {
              t.__esModule = !0,
              t.default = void 0;
              var r = c(n(92))
                , i = c(n(93))
                , a = c(n(94))
                , o = c(n(95))
                , s = c(n(17));
              function c(e) {
                  return e && e.__esModule ? e : {
                      default: e
                  }
              }
              t.default = function() {
                  function e(e, t) {
                      if (t === void 0 && (t = !1),
                      e == null || e === ``)
                          throw Error(`UserAgent parameter can't be empty`);
                      this._ua = e,
                      this.parsedResult = {},
                      !0 !== t && this.parse()
                  }
                  var t = e.prototype;
                  return t.getUA = function() {
                      return this._ua
                  }
                  ,
                  t.test = function(e) {
                      return e.test(this._ua)
                  }
                  ,
                  t.parseBrowser = function() {
                      var e = this;
                      this.parsedResult.browser = {};
                      var t = s.default.find(r.default, (function(t) {
                          if (typeof t.test == `function`)
                              return t.test(e);
                          if (Array.isArray(t.test))
                              return t.test.some((function(t) {
                                  return e.test(t)
                              }
                              ));
                          throw Error(`Browser's test function is not valid`)
                      }
                      ));
                      return t && (this.parsedResult.browser = t.describe(this.getUA())),
                      this.parsedResult.browser
                  }
                  ,
                  t.getBrowser = function() {
                      return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser()
                  }
                  ,
                  t.getBrowserName = function(e) {
                      return e ? String(this.getBrowser().name).toLowerCase() || `` : this.getBrowser().name || ``
                  }
                  ,
                  t.getBrowserVersion = function() {
                      return this.getBrowser().version
                  }
                  ,
                  t.getOS = function() {
                      return this.parsedResult.os ? this.parsedResult.os : this.parseOS()
                  }
                  ,
                  t.parseOS = function() {
                      var e = this;
                      this.parsedResult.os = {};
                      var t = s.default.find(i.default, (function(t) {
                          if (typeof t.test == `function`)
                              return t.test(e);
                          if (Array.isArray(t.test))
                              return t.test.some((function(t) {
                                  return e.test(t)
                              }
                              ));
                          throw Error(`Browser's test function is not valid`)
                      }
                      ));
                      return t && (this.parsedResult.os = t.describe(this.getUA())),
                      this.parsedResult.os
                  }
                  ,
                  t.getOSName = function(e) {
                      var t = this.getOS().name;
                      return e ? String(t).toLowerCase() || `` : t || ``
                  }
                  ,
                  t.getOSVersion = function() {
                      return this.getOS().version
                  }
                  ,
                  t.getPlatform = function() {
                      return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform()
                  }
                  ,
                  t.getPlatformType = function(e) {
                      e === void 0 && (e = !1);
                      var t = this.getPlatform().type;
                      return e ? String(t).toLowerCase() || `` : t || ``
                  }
                  ,
                  t.parsePlatform = function() {
                      var e = this;
                      this.parsedResult.platform = {};
                      var t = s.default.find(a.default, (function(t) {
                          if (typeof t.test == `function`)
                              return t.test(e);
                          if (Array.isArray(t.test))
                              return t.test.some((function(t) {
                                  return e.test(t)
                              }
                              ));
                          throw Error(`Browser's test function is not valid`)
                      }
                      ));
                      return t && (this.parsedResult.platform = t.describe(this.getUA())),
                      this.parsedResult.platform
                  }
                  ,
                  t.getEngine = function() {
                      return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine()
                  }
                  ,
                  t.getEngineName = function(e) {
                      return e ? String(this.getEngine().name).toLowerCase() || `` : this.getEngine().name || ``
                  }
                  ,
                  t.parseEngine = function() {
                      var e = this;
                      this.parsedResult.engine = {};
                      var t = s.default.find(o.default, (function(t) {
                          if (typeof t.test == `function`)
                              return t.test(e);
                          if (Array.isArray(t.test))
                              return t.test.some((function(t) {
                                  return e.test(t)
                              }
                              ));
                          throw Error(`Browser's test function is not valid`)
                      }
                      ));
                      return t && (this.parsedResult.engine = t.describe(this.getUA())),
                      this.parsedResult.engine
                  }
                  ,
                  t.parse = function() {
                      return this.parseBrowser(),
                      this.parseOS(),
                      this.parsePlatform(),
                      this.parseEngine(),
                      this
                  }
                  ,
                  t.getResult = function() {
                      return s.default.assign({}, this.parsedResult)
                  }
                  ,
                  t.satisfies = function(e) {
                      var t = this
                        , n = {}
                        , r = 0
                        , i = {}
                        , a = 0;
                      if (Object.keys(e).forEach((function(t) {
                          var o = e[t];
                          typeof o == `string` ? (i[t] = o,
                          a += 1) : typeof o == `object` && (n[t] = o,
                          r += 1)
                      }
                      )),
                      r > 0) {
                          var o = Object.keys(n)
                            , c = s.default.find(o, (function(e) {
                              return t.isOS(e)
                          }
                          ));
                          if (c) {
                              var l = this.satisfies(n[c]);
                              if (l !== void 0)
                                  return l
                          }
                          var u = s.default.find(o, (function(e) {
                              return t.isPlatform(e)
                          }
                          ));
                          if (u) {
                              var d = this.satisfies(n[u]);
                              if (d !== void 0)
                                  return d
                          }
                      }
                      if (a > 0) {
                          var f = Object.keys(i)
                            , p = s.default.find(f, (function(e) {
                              return t.isBrowser(e, !0)
                          }
                          ));
                          if (p !== void 0)
                              return this.compareVersion(i[p])
                      }
                  }
                  ,
                  t.isBrowser = function(e, t) {
                      t === void 0 && (t = !1);
                      var n = this.getBrowserName().toLowerCase()
                        , r = e.toLowerCase()
                        , i = s.default.getBrowserTypeByAlias(r);
                      return t && i && (r = i.toLowerCase()),
                      r === n
                  }
                  ,
                  t.compareVersion = function(e) {
                      var t = [0]
                        , n = e
                        , r = !1
                        , i = this.getBrowserVersion();
                      if (typeof i == `string`)
                          return e[0] === `>` || e[0] === `<` ? (n = e.substr(1),
                          e[1] === `=` ? (r = !0,
                          n = e.substr(2)) : t = [],
                          e[0] === `>` ? t.push(1) : t.push(-1)) : e[0] === `=` ? n = e.substr(1) : e[0] === `~` && (r = !0,
                          n = e.substr(1)),
                          t.indexOf(s.default.compareVersions(i, n, r)) > -1
                  }
                  ,
                  t.isOS = function(e) {
                      return this.getOSName(!0) === String(e).toLowerCase()
                  }
                  ,
                  t.isPlatform = function(e) {
                      return this.getPlatformType(!0) === String(e).toLowerCase()
                  }
                  ,
                  t.isEngine = function(e) {
                      return this.getEngineName(!0) === String(e).toLowerCase()
                  }
                  ,
                  t.is = function(e, t) {
                      return t === void 0 && (t = !1),
                      this.isBrowser(e, t) || this.isOS(e) || this.isPlatform(e)
                  }
                  ,
                  t.some = function(e) {
                      var t = this;
                      return e === void 0 && (e = []),
                      e.some((function(e) {
                          return t.is(e)
                      }
                      ))
                  }
                  ,
                  e
              }(),
              e.exports = t.default
          },
          92: function(e, t, n) {
              t.__esModule = !0,
              t.default = void 0;
              var r, i = (r = n(17)) && r.__esModule ? r : {
                  default: r
              }, a = /version\/(\d+(\.?_?\d+)+)/i;
              t.default = [{
                  test: [/googlebot/i],
                  describe: function(e) {
                      var t = {
                          name: `Googlebot`
                      }
                        , n = i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/opera/i],
                  describe: function(e) {
                      var t = {
                          name: `Opera`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/opr\/|opios/i],
                  describe: function(e) {
                      var t = {
                          name: `Opera`
                      }
                        , n = i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/SamsungBrowser/i],
                  describe: function(e) {
                      var t = {
                          name: `Samsung Internet for Android`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/Whale/i],
                  describe: function(e) {
                      var t = {
                          name: `NAVER Whale Browser`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/PaleMoon/i],
                  describe: function(e) {
                      var t = {
                          name: `Pale Moon`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/(?:PaleMoon)[\s/](\d+(?:\.\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/MZBrowser/i],
                  describe: function(e) {
                      var t = {
                          name: `MZ Browser`
                      }
                        , n = i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/focus/i],
                  describe: function(e) {
                      var t = {
                          name: `Focus`
                      }
                        , n = i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/swing/i],
                  describe: function(e) {
                      var t = {
                          name: `Swing`
                      }
                        , n = i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/coast/i],
                  describe: function(e) {
                      var t = {
                          name: `Opera Coast`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/opt\/\d+(?:.?_?\d+)+/i],
                  describe: function(e) {
                      var t = {
                          name: `Opera Touch`
                      }
                        , n = i.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/yabrowser/i],
                  describe: function(e) {
                      var t = {
                          name: `Yandex Browser`
                      }
                        , n = i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/ucbrowser/i],
                  describe: function(e) {
                      var t = {
                          name: `UC Browser`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/Maxthon|mxios/i],
                  describe: function(e) {
                      var t = {
                          name: `Maxthon`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/epiphany/i],
                  describe: function(e) {
                      var t = {
                          name: `Epiphany`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/puffin/i],
                  describe: function(e) {
                      var t = {
                          name: `Puffin`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/sleipnir/i],
                  describe: function(e) {
                      var t = {
                          name: `Sleipnir`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/k-meleon/i],
                  describe: function(e) {
                      var t = {
                          name: `K-Meleon`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/micromessenger/i],
                  describe: function(e) {
                      var t = {
                          name: `WeChat`
                      }
                        , n = i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/qqbrowser/i],
                  describe: function(e) {
                      var t = {
                          name: /qqbrowserlite/i.test(e) ? `QQ Browser Lite` : `QQ Browser`
                      }
                        , n = i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/msie|trident/i],
                  describe: function(e) {
                      var t = {
                          name: `Internet Explorer`
                      }
                        , n = i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/\sedg\//i],
                  describe: function(e) {
                      var t = {
                          name: `Microsoft Edge`
                      }
                        , n = i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/edg([ea]|ios)/i],
                  describe: function(e) {
                      var t = {
                          name: `Microsoft Edge`
                      }
                        , n = i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/vivaldi/i],
                  describe: function(e) {
                      var t = {
                          name: `Vivaldi`
                      }
                        , n = i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/seamonkey/i],
                  describe: function(e) {
                      var t = {
                          name: `SeaMonkey`
                      }
                        , n = i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/sailfish/i],
                  describe: function(e) {
                      var t = {
                          name: `Sailfish`
                      }
                        , n = i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/silk/i],
                  describe: function(e) {
                      var t = {
                          name: `Amazon Silk`
                      }
                        , n = i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/phantom/i],
                  describe: function(e) {
                      var t = {
                          name: `PhantomJS`
                      }
                        , n = i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/slimerjs/i],
                  describe: function(e) {
                      var t = {
                          name: `SlimerJS`
                      }
                        , n = i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
                  describe: function(e) {
                      var t = {
                          name: `BlackBerry`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/(web|hpw)[o0]s/i],
                  describe: function(e) {
                      var t = {
                          name: `WebOS Browser`
                      }
                        , n = i.default.getFirstMatch(a, e) || i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/bada/i],
                  describe: function(e) {
                      var t = {
                          name: `Bada`
                      }
                        , n = i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/tizen/i],
                  describe: function(e) {
                      var t = {
                          name: `Tizen`
                      }
                        , n = i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/qupzilla/i],
                  describe: function(e) {
                      var t = {
                          name: `QupZilla`
                      }
                        , n = i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/firefox|iceweasel|fxios/i],
                  describe: function(e) {
                      var t = {
                          name: `Firefox`
                      }
                        , n = i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/electron/i],
                  describe: function(e) {
                      var t = {
                          name: `Electron`
                      }
                        , n = i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/MiuiBrowser/i],
                  describe: function(e) {
                      var t = {
                          name: `Miui`
                      }
                        , n = i.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/chromium/i],
                  describe: function(e) {
                      var t = {
                          name: `Chromium`
                      }
                        , n = i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/chrome|crios|crmo/i],
                  describe: function(e) {
                      var t = {
                          name: `Chrome`
                      }
                        , n = i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/GSA/i],
                  describe: function(e) {
                      var t = {
                          name: `Google Search`
                      }
                        , n = i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: function(e) {
                      var t = !e.test(/like android/i)
                        , n = e.test(/android/i);
                      return t && n
                  },
                  describe: function(e) {
                      var t = {
                          name: `Android Browser`
                      }
                        , n = i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/playstation 4/i],
                  describe: function(e) {
                      var t = {
                          name: `PlayStation 4`
                      }
                        , n = i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/safari|applewebkit/i],
                  describe: function(e) {
                      var t = {
                          name: `Safari`
                      }
                        , n = i.default.getFirstMatch(a, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/.*/i],
                  describe: function(e) {
                      var t = e.search(`\\(`) === -1 ? /^(.*)\/(.*) / : /^(.*)\/(.*)[ \t]\((.*)/;
                      return {
                          name: i.default.getFirstMatch(t, e),
                          version: i.default.getSecondMatch(t, e)
                      }
                  }
              }],
              e.exports = t.default
          },
          93: function(e, t, n) {
              t.__esModule = !0,
              t.default = void 0;
              var r, i = (r = n(17)) && r.__esModule ? r : {
                  default: r
              }, a = n(18);
              t.default = [{
                  test: [/Roku\/DVP/],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
                      return {
                          name: a.OS_MAP.Roku,
                          version: t
                      }
                  }
              }, {
                  test: [/windows phone/i],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
                      return {
                          name: a.OS_MAP.WindowsPhone,
                          version: t
                      }
                  }
              }, {
                  test: [/windows /i],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e)
                        , n = i.default.getWindowsVersionName(t);
                      return {
                          name: a.OS_MAP.Windows,
                          version: t,
                          versionName: n
                      }
                  }
              }, {
                  test: [/Macintosh(.*?) FxiOS(.*?)\//],
                  describe: function(e) {
                      var t = {
                          name: a.OS_MAP.iOS
                      }
                        , n = i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/macintosh/i],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, `.`)
                        , n = i.default.getMacOSVersionName(t)
                        , r = {
                          name: a.OS_MAP.MacOS,
                          version: t
                      };
                      return n && (r.versionName = n),
                      r
                  }
              }, {
                  test: [/(ipod|iphone|ipad)/i],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, `.`);
                      return {
                          name: a.OS_MAP.iOS,
                          version: t
                      }
                  }
              }, {
                  test: function(e) {
                      var t = !e.test(/like android/i)
                        , n = e.test(/android/i);
                      return t && n
                  },
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e)
                        , n = i.default.getAndroidVersionName(t)
                        , r = {
                          name: a.OS_MAP.Android,
                          version: t
                      };
                      return n && (r.versionName = n),
                      r
                  }
              }, {
                  test: [/(web|hpw)[o0]s/i],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e)
                        , n = {
                          name: a.OS_MAP.WebOS
                      };
                      return t && t.length && (n.version = t),
                      n
                  }
              }, {
                  test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || i.default.getFirstMatch(/\bbb(\d+)/i, e);
                      return {
                          name: a.OS_MAP.BlackBerry,
                          version: t
                      }
                  }
              }, {
                  test: [/bada/i],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
                      return {
                          name: a.OS_MAP.Bada,
                          version: t
                      }
                  }
              }, {
                  test: [/tizen/i],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
                      return {
                          name: a.OS_MAP.Tizen,
                          version: t
                      }
                  }
              }, {
                  test: [/linux/i],
                  describe: function() {
                      return {
                          name: a.OS_MAP.Linux
                      }
                  }
              }, {
                  test: [/CrOS/],
                  describe: function() {
                      return {
                          name: a.OS_MAP.ChromeOS
                      }
                  }
              }, {
                  test: [/PlayStation 4/],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
                      return {
                          name: a.OS_MAP.PlayStation4,
                          version: t
                      }
                  }
              }],
              e.exports = t.default
          },
          94: function(e, t, n) {
              t.__esModule = !0,
              t.default = void 0;
              var r, i = (r = n(17)) && r.__esModule ? r : {
                  default: r
              }, a = n(18);
              t.default = [{
                  test: [/googlebot/i],
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.bot,
                          vendor: `Google`
                      }
                  }
              }, {
                  test: [/huawei/i],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/(can-l01)/i, e) && `Nova`
                        , n = {
                          type: a.PLATFORMS_MAP.mobile,
                          vendor: `Huawei`
                      };
                      return t && (n.model = t),
                      n
                  }
              }, {
                  test: [/nexus\s*(?:7|8|9|10).*/i],
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.tablet,
                          vendor: `Nexus`
                      }
                  }
              }, {
                  test: [/ipad/i],
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.tablet,
                          vendor: `Apple`,
                          model: `iPad`
                      }
                  }
              }, {
                  test: [/Macintosh(.*?) FxiOS(.*?)\//],
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.tablet,
                          vendor: `Apple`,
                          model: `iPad`
                      }
                  }
              }, {
                  test: [/kftt build/i],
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.tablet,
                          vendor: `Amazon`,
                          model: `Kindle Fire HD 7`
                      }
                  }
              }, {
                  test: [/silk/i],
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.tablet,
                          vendor: `Amazon`
                      }
                  }
              }, {
                  test: [/tablet(?! pc)/i],
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.tablet
                      }
                  }
              }, {
                  test: function(e) {
                      var t = e.test(/ipod|iphone/i)
                        , n = e.test(/like (ipod|iphone)/i);
                      return t && !n
                  },
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/(ipod|iphone)/i, e);
                      return {
                          type: a.PLATFORMS_MAP.mobile,
                          vendor: `Apple`,
                          model: t
                      }
                  }
              }, {
                  test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.mobile,
                          vendor: `Nexus`
                      }
                  }
              }, {
                  test: [/Nokia/i],
                  describe: function(e) {
                      var t = i.default.getFirstMatch(/Nokia\s+([0-9]+(\.[0-9]+)?)/i, e)
                        , n = {
                          type: a.PLATFORMS_MAP.mobile,
                          vendor: `Nokia`
                      };
                      return t && (n.model = t),
                      n
                  }
              }, {
                  test: [/[^-]mobi/i],
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.mobile
                      }
                  }
              }, {
                  test: function(e) {
                      return e.getBrowserName(!0) === `blackberry`
                  },
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.mobile,
                          vendor: `BlackBerry`
                      }
                  }
              }, {
                  test: function(e) {
                      return e.getBrowserName(!0) === `bada`
                  },
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.mobile
                      }
                  }
              }, {
                  test: function(e) {
                      return e.getBrowserName() === `windows phone`
                  },
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.mobile,
                          vendor: `Microsoft`
                      }
                  }
              }, {
                  test: function(e) {
                      var t = Number(String(e.getOSVersion()).split(`.`)[0]);
                      return e.getOSName(!0) === `android` && t >= 3
                  },
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.tablet
                      }
                  }
              }, {
                  test: function(e) {
                      return e.getOSName(!0) === `android`
                  },
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.mobile
                      }
                  }
              }, {
                  test: function(e) {
                      return e.getOSName(!0) === `macos`
                  },
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.desktop,
                          vendor: `Apple`
                      }
                  }
              }, {
                  test: function(e) {
                      return e.getOSName(!0) === `windows`
                  },
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.desktop
                      }
                  }
              }, {
                  test: function(e) {
                      return e.getOSName(!0) === `linux`
                  },
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.desktop
                      }
                  }
              }, {
                  test: function(e) {
                      return e.getOSName(!0) === `playstation 4`
                  },
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.tv
                      }
                  }
              }, {
                  test: function(e) {
                      return e.getOSName(!0) === `roku`
                  },
                  describe: function() {
                      return {
                          type: a.PLATFORMS_MAP.tv
                      }
                  }
              }],
              e.exports = t.default
          },
          95: function(e, t, n) {
              t.__esModule = !0,
              t.default = void 0;
              var r, i = (r = n(17)) && r.__esModule ? r : {
                  default: r
              }, a = n(18);
              t.default = [{
                  test: function(e) {
                      return e.getBrowserName(!0) === `microsoft edge`
                  },
                  describe: function(e) {
                      if (/\sedg\//i.test(e))
                          return {
                              name: a.ENGINE_MAP.Blink
                          };
                      var t = i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
                      return {
                          name: a.ENGINE_MAP.EdgeHTML,
                          version: t
                      }
                  }
              }, {
                  test: [/trident/i],
                  describe: function(e) {
                      var t = {
                          name: a.ENGINE_MAP.Trident
                      }
                        , n = i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: function(e) {
                      return e.test(/presto/i)
                  },
                  describe: function(e) {
                      var t = {
                          name: a.ENGINE_MAP.Presto
                      }
                        , n = i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: function(e) {
                      var t = e.test(/gecko/i)
                        , n = e.test(/like gecko/i);
                      return t && !n
                  },
                  describe: function(e) {
                      var t = {
                          name: a.ENGINE_MAP.Gecko
                      }
                        , n = i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }, {
                  test: [/(apple)?webkit\/537\.36/i],
                  describe: function() {
                      return {
                          name: a.ENGINE_MAP.Blink
                      }
                  }
              }, {
                  test: [/(apple)?webkit/i],
                  describe: function(e) {
                      var t = {
                          name: a.ENGINE_MAP.WebKit
                      }
                        , n = i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
                      return n && (t.version = n),
                      t
                  }
              }],
              e.exports = t.default
          }
      })
  }
  ))
}
)), yZ, bZ, xZ = t(( () => {
  yZ = e(lde(), 1),
  lo(),
  bZ = class {
      static get browserNameAndVersion() {
          return co.isElectron ? `Linear.app ${co.bridge.version}` : `${this.browser.getBrowserName()} ${this.browser.getBrowserVersion()}`
      }
      static get browserName() {
          return this.browser.getBrowserName()
      }
      static get os() {
          let e = this.browser.getOSName()
            , t = this.browser.getOSVersion();
          return e === `macOS` && t === `10.15.7` ? `${e} ${t}+` : `${e} ${t}`
      }
      static get platform() {
          return this.browser.getPlatformType()
      }
      static get browser() {
          return yZ.default.getParser(window.navigator.userAgent)
      }
  }
}
)), SZ, CZ, wZ, TZ, ude = t(( () => {
  SZ = e(Ce(), 1),
  zn(),
  vZ(),
  Yr(),
  nm(),
  ws(),
  Ho(),
  xZ(),
  bR(),
  Qp(),
  N(),
  CZ = class {
      static #e = this.constructorName = `TransientModelRemoval`;
      scheduleModelRemoval(e, t, n, r, i) {
          let a = `${t}|${n}`
            , o = this.scheduled.get(a);
          o ? (o.syncId = o.syncId || Math.min(o.syncId ?? 1 / 0, r),
          o.options?.only && !i?.only ? delete o.options.only : o.options?.only && i?.only && (o.options.only = [...new Set([...o.options.only, ...i.only])])) : this.scheduled.set(a, {
              type: e,
              syncId: r,
              options: i
          })
      }
      trackPacket(e) {
          switch (e.action) {
          case `A`:
          case `D`:
              break;
          case `B`:
          case `G`:
          case `S`:
              break;
          case `I`:
          case `V`:
          case `U`:
          case `C`:
              let t = `${e.modelName}|${e.modelId}`
                , n = this.upserts.get(t);
              n ? n.push(e) : this.upserts.set(t, [e]);
              break;
          default:
              y(e)
          }
      }
      async applyRemovalsToDatabase(e) {
          if (this.appliedRemovals.includes(`database`))
              throw Error(`Cannot apply deletions to database as they were already applied`);
          if (this.appliedRemovals.push(`database`),
          this.scheduled.size === 0)
              return;
          this.used = !0;
          let t = performance.now();
          this.actionsStats.applyCount += 1,
          await this.applyRemovalsToDatabaseInner(e),
          this.timeSpentMs += performance.now() - t
      }
      applyRemovalsToSyncClient() {
          if (this.appliedRemovals.includes(`syncClient`))
              throw Error(`Cannot apply deletions to sync client as they were already applied`);
          this.appliedRemovals.push(`syncClient`);
          let e = performance.now();
          this.applyRemovalsToSyncClientInner(),
          this.timeSpentMs += performance.now() - e
      }
      get removedModelIds() {
          return this.removedModelIdsMap
      }
      reportPerformance() {
          if (!this.used)
              return;
          let e = Math.round(performance.now() * 100) / 100;
          w.debug(`[PRF] ${e}ms: Transient removal took ${this.timeSpentMs}ms`);
          let t = _Z.getCountBucket(this.removedModelIdsMap.size, `dag`);
          Vo.distribution(`performance.span`, this.timeSpentMs, {
              span: `transient-removal`,
              countBucket: t,
              partOfBootstrap: this.partOfBootstrap ? `true` : `false`
          }),
          (this.timeSpentMs > 3 * b.SECOND || this.actionsStats.remove > 50) && w.remote(`Transient removal time breakdown`, {
              removeCount: this.actionsStats.remove,
              applyCount: this.actionsStats.applyCount,
              durationMs: this.timeSpentMs,
              breakdown: Object.fromEntries(Object.entries(this.timeSpentBreakdown).sort( ([,e], [,t]) => t.time - e.time)),
              browser: bZ.browserNameAndVersion,
              partOfBootstrap: this.partOfBootstrap ?? !1,
              newTransientRemoval: !0
          })
      }
      constructor(e, t) {
          this.syncClient = e,
          this.partOfBootstrap = t,
          this.scheduled = new Map,
          this.upserts = new Map,
          this.currentApplyScheduledIds = new Set,
          this.actions = {
              remove: new Map,
              setNull: new Map,
              setArray: new Map
          },
          this.removedModelIdsMap = new Map,
          this.appliedRemovals = [],
          this.used = !1,
          this.timeSpentMs = 0,
          this.timeSpentBreakdown = {},
          this.actionsStats = {
              remove: 0,
              applyCount: 0
          }
      }
      getGroupedScheduledRemovals() {
          this.currentApplyScheduledIds.clear();
          let e = new Map;
          for (let[t,{type: n, syncId: r, options: i}] of this.scheduled) {
              let[a,o] = t.split(`|`);
              this.currentApplyScheduledIds.add(o);
              let s = e.get(a);
              s ? s.push({
                  type: n,
                  modelId: o,
                  parent: void 0,
                  syncId: r,
                  options: i
              }) : e.set(a, [{
                  type: n,
                  modelId: o,
                  parent: void 0,
                  syncId: r,
                  options: i
              }])
          }
          return e
      }
      async applyRemovalsToDatabaseInner(e) {
          let t = new wZ(this.getGroupedScheduledRemovals());
          for (let {modelClass: n, removals: r} of t) {
              await this.amendModelRemovalsWithDatabaseDependents(e, n, r);
              for (let t of r)
                  t.executed || !(`modelId`in t) || ((!t.options?.only || t.options.only.includes(n.modelName)) && !this.wasUpsertedAfter(n.modelName, t.modelId, t.syncId) && (n.modelName === `User` && t.parent && w.remote(`Transiently removing user`, {
                      user: {
                          id: t.modelId
                      },
                      parentId: t.parent.id
                  }),
                  e.delete(n.modelName, t.modelId),
                  t.syncId && t.parent && e.addSyncPacket({
                      id: t.syncId,
                      action: t.type === `archival` ? `A` : `D`,
                      modelName: n.modelName,
                      modelId: t.modelId
                  }),
                  this.trackRemoval(t.modelId, t.syncId),
                  this.actions.remove.set(`${n.modelName}-${t.modelId}`, {
                      id: t.modelId,
                      modelClass: n,
                      type: t.type,
                      syncId: t.syncId,
                      parent: t.parent
                  })),
                  t.executed = !0)
          }
      }
      async amendModelRemovalsWithDatabaseDependents(e, t, n) {
          let r = t.modelName
            , i = new TZ(r,n);
          for (let {type: a, dependency: o, dependencyRemovals: s} of i) {
              let i = a === `deletion` ? o.deleteType : o.archiveType
                , c = [...s.keys()]
                , l = performance.now();
              await e.iterate(r, {
                  key: o.property,
                  values: c
              }, e => {
                  let a = e.value[o.property];
                  if (Array.isArray(a)) {
                      let c;
                      for (let e of a) {
                          let t = s.get(e);
                          t && (!c || t.syncId > c.syncId) && (c = t)
                      }
                      if (!c)
                          return;
                      let l = a.filter(t => {
                          let n = s.get(t);
                          return n ? this.wasReAddedToArrayAfter(r, e.value.id, o.property, t, n.syncId) : !0
                      }
                      );
                      i === `CASCADE` && l.length === 0 ? (this.actions.setArray.delete(`${e.value.id}-${o.property}`),
                      this.currentApplyScheduledIds.has(e.value.id) || (n.push({
                          type: c.type,
                          modelId: e.value.id,
                          parent: c.parent,
                          syncId: c.syncId,
                          options: c.options
                      }),
                      this.currentApplyScheduledIds.add(e.value.id))) : (this.actions.setArray.set(`${e.value.id}-${o.property}`, {
                          id: e.value.id,
                          property: o.property,
                          value: l,
                          syncId: c.syncId,
                          modelClass: t
                      }),
                      e.update({
                          ...e.value,
                          [o.property]: l
                      }))
                  } else {
                      let c = s.get(a);
                      if (!c)
                          return;
                      i === `CASCADE` ? this.currentApplyScheduledIds.has(e.value.id) || (this.currentApplyScheduledIds.add(e.value.id),
                      n.push({
                          type: c.type,
                          modelId: e.value.id,
                          parent: c.parent,
                          syncId: c.syncId,
                          options: c.options
                      })) : this.wasUpdatedAfter(r, e.value.id, o.property, c.syncId) || (this.actions.setNull.set(`${e.value.id}-${o.property}`, {
                          id: e.value.id,
                          property: o.property,
                          syncId: c.syncId,
                          modelClass: t
                      }),
                      e.update({
                          ...e.value,
                          [o.property]: void 0
                      }))
                  }
              }
              ),
              this.trackTimeSpent(`IndexDB-FindByIndexedKey-${r}-${o.property}`, l)
          }
      }
      applyRemovalsToSyncClientInner() {
          let e = new wZ(this.getGroupedScheduledRemovals());
          for (let {modelClass: t, removals: n} of e) {
              this.amendModelRemovalsToSyncClient(t, n);
              for (let e of n) {
                  if (e.executed || !(`modelId`in e))
                      continue;
                  let n = this.syncClient.findById(t, e.modelId);
                  n && (!e.options?.only || e.options.only.includes(t.modelName)) && !this.wasUpsertedAfter(t.modelName, e.modelId, e.syncId) && (this.trackRemoval(e.modelId, e.syncId),
                  this.removeModelFromSyncClient(e.type, n, e.parent)),
                  this.actions.remove.delete(`${t.modelName}-${e.modelId}`),
                  e.executed = !0
              }
          }
          for (let[e,{id: t, syncId: n, type: r, modelClass: i, parent: a}] of this.actions.remove) {
              this.actions.remove.delete(e);
              let o = this.syncClient.findById(i, t);
              o && (this.trackRemoval(t, n),
              this.removeModelFromSyncClient(r, o, a))
          }
          for (let[e,{id: t, property: n, modelClass: r}] of this.actions.setNull) {
              this.actions.setNull.delete(e);
              let i = this.syncClient.findById(r, t);
              i && (i[n] = void 0)
          }
          for (let[e,{id: t, property: n, value: r, modelClass: i}] of this.actions.setArray) {
              this.actions.setArray.delete(e);
              let a = this.syncClient.findById(i, t);
              a && (a[n] = r)
          }
      }
      amendModelRemovalsToSyncClient(e, t) {
          let n = e.modelName
            , r = new TZ(n,t);
          for (let {type: i, dependency: a, dependencyRemovals: o} of r) {
              let r = i === `deletion` ? a.deleteType : a.archiveType
                , s = performance.now();
              for (let i of this.syncClient.allModelsOfTypeGen(e, yR.allModels)) {
                  let e = i[a.property];
                  if (Array.isArray(e)) {
                      let n;
                      for (let t of e) {
                          let e = o.get(t);
                          e && (!n || e.syncId > n.syncId) && (n = e)
                      }
                      if (!n)
                          continue;
                      let s = e.filter(e => !o.has(e));
                      r === `CASCADE` && s.length === 0 ? this.currentApplyScheduledIds.has(i.id) || (t.push({
                          type: n.type,
                          modelId: i.id,
                          parent: n.parent,
                          syncId: n.syncId,
                          options: n.options
                      }),
                      this.currentApplyScheduledIds.add(i.id)) : i[a.property] = s
                  } else {
                      let s = o.get(e);
                      if (!s)
                          continue;
                      r === `CASCADE` ? this.currentApplyScheduledIds.has(i.id) || (t.push({
                          type: s.type,
                          modelId: i.id,
                          parent: s?.parent,
                          syncId: s?.syncId,
                          options: s?.options
                      }),
                      this.currentApplyScheduledIds.add(i.id)) : this.wasUpdatedAfter(n, i.id, a.property, s.syncId) || (i[a.property] = void 0)
                  }
              }
              this.trackTimeSpent(`Memory-FindByIndexedKey-${n}`, s)
          }
      }
      removeModelFromSyncClient(e, t, n) {
          if (e === `deletion`)
              this.syncClient.deleteModel(t);
          else if (e === `archival`) {
              if (n && n.id !== t.id) {
                  let e = em.getModelClass(n.modelName);
                  t.archivedAt = (e ? this.syncClient.findById(e, n.id) : void 0)?.archivedAt || t.archivedAt || new Date
              } else
                  t.archivedAt = t.archivedAt || new Date;
              this.syncClient.archiveModel(t)
          } else
              throw new Rn(e)
      }
      wasUpsertedAfter(e, t, n) {
          let r = `${e}|${t}`;
          return this.upserts.get(r)?.some(e => e.id > n) ?? !1
      }
      wasUpdatedAfter(e, t, n, r) {
          let i = `${e}|${t}`
            , a = this.upserts.get(i);
          return a ? a.some(e => e.id > r && e.data?.[n] != null) : !1
      }
      wasReAddedToArrayAfter(e, t, n, r, i) {
          let a = `${e}|${t}`
            , o = this.upserts.get(a);
          return o ? o.some(e => e.id > i && Array.isArray(e.data?.[n]) && (e.data?.[n])?.includes(r)) : !1
      }
      trackRemoval(e, t) {
          let n = this.removedModelIdsMap.get(e);
          (n === void 0 || n < t) && this.removedModelIdsMap.set(e, t),
          n === void 0 && (this.actionsStats.remove += 1)
      }
      trackTimeSpent(e, t) {
          this.timeSpentBreakdown[e] ||= {
              times: 0,
              time: 0
          },
          this.timeSpentBreakdown[e].times += 1,
          this.timeSpentBreakdown[e].time += performance.now() - t
      }
  }
  ,
  M([Zp.trace(`startup`)], CZ.prototype, `applyRemovalsToDatabase`, null),
  M([Zp.trace(`startup`)], CZ.prototype, `applyRemovalsToSyncClient`, null),
  wZ = class {
      processNext(e, t=!1) {
          t && this.modelNames.includes(e) || this.modelNames.push(e)
      }
      constructor(e) {
          this.removalsPerModel = e,
          this.loopCount = 0,
          this.modelNames = [...em.dependencyOrder()].reverse()
      }
      next() {
          if (++this.loopCount > 1e3)
              throw Error(`Too many loops in DependencyIterator`);
          for (; ; ) {
              if (this.previousModelClass && this.previousPerModelRemovals) {
                  for (let e of this.previousPerModelRemovals) {
                      if (!(`modelId`in e))
                          continue;
                      let t = em.dependenciesOfModel(this.previousModelClass.modelName);
                      for (let n of t) {
                          let t = n.model.modelName === this.previousModelClass.modelName ? this.previousPerModelRemovals : this.removalsPerModel.get(n.model.modelName);
                          t || (t = [],
                          this.removalsPerModel.set(n.model.modelName, t)),
                          t.push({
                              type: e.type,
                              indexedKey: {
                                  dependency: n,
                                  keyValue: e.modelId
                              },
                              parent: {
                                  modelName: this.previousModelClass.modelName,
                                  id: e.modelId
                              },
                              syncId: e.syncId,
                              options: e.options
                          }),
                          n.model.modelName !== this.previousModelClass.modelName && this.processNext(n.model.modelName, !0)
                      }
                  }
                  let e = this.previousPerModelRemovals.filter(e => !e.executed);
                  this.removalsPerModel.set(this.previousModelClass.modelName, e),
                  e.length && this.processNext(this.previousModelClass.modelName)
              }
              this.previousModelClass = void 0,
              this.previousPerModelRemovals = void 0;
              let e = this.modelNames.pop();
              if (e === void 0)
                  return {
                      done: !0,
                      value: void 0
                  };
              let t = em.getModelClass(e);
              if (!t)
                  continue;
              let n = (this.removalsPerModel.get(e) || []).filter(e => !e.executed);
              if (n.length !== 0)
                  return this.previousModelClass = t,
                  this.previousPerModelRemovals = n,
                  {
                      done: !1,
                      value: {
                          modelClass: t,
                          removals: n
                      }
                  }
          }
      }
      [Symbol.iterator]() {
          return this
      }
  }
  ,
  TZ = class {
      constructor(e, t) {
          this.modelName = e,
          this.loopCount = 0;
          let n = this.getIndexedRemovals(t);
          n.length === 0 && (this.groupedPerIndexKey = []),
          this.groupedPerIndexKey = Object.values((0,
          SZ.default)(n, e => e.type + `|` + e.indexedKey.dependency.property))
      }
      next() {
          if (++this.loopCount > 1e3)
              throw Error(`Too many loops in IndexKeyRemovalsIterator`);
          for (; ; ) {
              let e = this.groupedPerIndexKey.pop();
              if (!e)
                  break;
              if (e.length !== 0)
                  return {
                      done: !1,
                      value: {
                          type: e[0].type,
                          dependency: e[0].indexedKey.dependency,
                          dependencyRemovals: e.reduce( (e, t) => (t.executed = !0,
                          e.set(t.indexedKey.keyValue, t),
                          e), new Map)
                      }
                  }
          }
          return {
              done: !0,
              value: void 0
          }
      }
      [Symbol.iterator]() {
          return this
      }
      getIndexedRemovals(e) {
          return e.filter(e => `indexedKey`in e)
      }
  }
}
)), EZ, dde = t(( () => {
  EZ = [`Issue`, `Project`]
}
)), DZ, OZ, kZ = t(( () => {
  DZ = e(Ce(), 1),
  dde(),
  ho(),
  nX(),
  Tm(),
  ai(),
  es(),
  MY(),
  OZ = class extends tX {
      static async supportedPacket(e, t) {
          let n = [`I`, `A`, `D`, `G`, `S`]
            , r = t.filter(e => `modelName`in e && EZ.includes(e.modelName) && (e.action === `V` || !n.includes(e.action)))
            , i = new Set;
          for (let e = 0; e < r.length; e++)
              e % 5e3 == 0 && await ri(0),
              i.add(r[e].modelName);
          let a = {};
          await e.readTransaction({
              metaStore: !1,
              syncActionStore: !1,
              stores: Array.from(i)
          }, async e => {
              for (let t = 0; t < r.length; t++) {
                  let n = r[t];
                  if (n.action === `V` || a[n.modelId] !== void 0)
                      continue;
                  let i = await e.get(n.modelName, n.modelId);
                  i && (a[n.modelId] = i)
              }
          }
          );
          let o = [];
          for (let t = 0; t < r.length; t++) {
              t % 5e3 == 0 && await ri(0);
              let n = r[t];
              if (n.action === `V`) {
                  o.push(n);
                  continue
              }
              let i = wm.transientPartialIndexedKeysOfModel(n.modelName);
              if (i.length === 0)
                  continue;
              let s = a[n.modelId];
              if (!s)
                  continue;
              let c = i.map( ({indexedKey: e, dependency: t, partialIndexInfo: r}) => {
                  if (!n.data[e] || (s[e] ?? void 0) === (n.data[e] ?? void 0))
                      return;
                  let i = r ? wm.createPartialIndex(r, n.data[e] + ``) : {
                      value: `${e}-${n.data[e]}`,
                      isSyncGroupRoot: !1
                  };
                  return {
                      modelName: t.model.modelName,
                      newPartialIndex: i
                  }
              }
              ).concrete();
              c.length !== 0 && (await Promise.all(c.map(async t => e.objectStoreReady(t.modelName) === !0 ? !1 : await e.hasModelsForPartialIndexes(t.modelName, [t.newPartialIndex])))).some(e => e) && o.push(n)
          }
          return o
      }
      constructor(e, t=!1, n=0) {
          super({
              batchInterval: 50,
              maxBatchedRequests: 1e3
          }),
          this.graphQLClient = e,
          this.includeDependent = t,
          this.retries = n
      }
      async handleBatch(e) {
          let t = (0,
          DZ.default)(e.map(e => e.request), e => e.modelName)
            , n = [];
          try {
              await Promise.all(Object.entries(t).map(async ([e,t]) => {
                  let r = await this.graphQLClient.restModelsStream(`/sync/dependents`, {
                      retry: {
                          times: this.retries,
                          delayMs: e => (e + 1) * 500,
                          retryOnRatelimit: !0
                      },
                      method: `POST`,
                      body: JSON.stringify({
                          modelName: e,
                          identifiers: t.map(e => e.identifier),
                          firstSyncId: this.graphQLClient.getFirstSyncId(),
                          includeDependent: this.includeDependent
                      })
                  })
                    , i = r.syncActions || []
                    , a = jY.applyDeltaSyncOnModelObjectCollection(r.models, i.reverse());
                  n.push(...a)
              }
              ))
          } catch (e) {
              if (Wo(e))
                  return await mo.logoutCurrentUserAccount(`Fetching dependents failed`, e),
                  {
                      result: []
                  };
              throw e
          }
          for (let t of e)
              t.resolve(void 0);
          return {
              result: n
          }
      }
      serializeRequest(e) {
          return `${e.modelName}-${e.identifier}`
      }
  }
}
)), AZ, fde = t(( () => {
  AZ = class {
      constructor() {
          this.modelTypeToIdMap = {}
      }
      get(e, t) {
          return this.modelTypeToIdMap[e]?.get(t)
      }
      unsafeGet(e) {
          for (let t in this.modelTypeToIdMap) {
              let n = this.modelTypeToIdMap[t].get(e);
              if (n)
                  return n
          }
      }
      add(e) {
          if (!e.modelName)
              throw Error(`Model has no model name`);
          if (!e.id)
              throw Error(`Model has no id`);
          this.getOrCreateMapForType(e.modelName).set(e.id, e)
      }
      has(e, t) {
          return this.modelTypeToIdMap[e]?.has(t) ?? !1
      }
      delete(e, t) {
          return this.modelTypeToIdMap[e]?.delete(t) ?? !1
      }
      *getAllModels() {
          for (let e in this.modelTypeToIdMap)
              yield*this.modelTypeToIdMap[e].values()
      }
      clear() {
          this.modelTypeToIdMap = {}
      }
      getOrCreateMapForType(e) {
          return this.modelTypeToIdMap[e] || (this.modelTypeToIdMap[e] = new Map),
          this.modelTypeToIdMap[e]
      }
  }
}
)), jZ, MZ, NZ, PZ, FZ, IZ, LZ, RZ, pde = t(( () => {
  jZ = e(ne(), 1),
  zt(),
  MZ = e(te(), 1),
  pX(),
  zn(),
  Zv(),
  Yr(),
  ir(),
  OY(),
  to(),
  L_(),
  TY(),
  Xn(),
  _X(),
  As(),
  sy(),
  ws(),
  F(),
  nm(),
  es(),
  cX(),
  KZ(),
  bR(),
  LX(),
  rde(),
  HX(),
  xX(),
  Es(),
  Ho(),
  ade(),
  uZ(),
  ni(),
  fZ(),
  $J(),
  Qp(),
  AY(),
  Xp(),
  Tm(),
  om(),
  ai(),
  MY(),
  KX(),
  ode(),
  sde(),
  Ih(),
  cde(),
  ng(),
  ude(),
  RY(),
  kZ(),
  fde(),
  PY(),
  N(),
  NZ = b.MINUTE * 2,
  PZ = b.MINUTE * 4,
  FZ = 30 * b.SECOND,
  IZ = 5,
  LZ = b.MINUTE,
  RZ = class {
      static #e = this.constructorName = `SyncClient`;
      get onDatabaseVersionChange() {
          return this._onDatabaseVersionChange
      }
      get onBootstrap() {
          return this._onBootstrap
      }
      get onTransactionCountChange() {
          return this.transactionQueue.onTransactionCountChange
      }
      get onTransactionQueued() {
          return this.transactionQueue.onTransactionQueued
      }
      get onArchive() {
          return this._onArchive
      }
      get onArchiveUpdate() {
          return this._onArchiveUpdate
      }
      get onUnarchive() {
          return this._onUnarchive
      }
      get onSyncGroupsChanged() {
          return this._onSyncGroupsChanged
      }
      get onDatabaseUnavailable() {
          return this.database.onDatabaseUnavailable
      }
      get onInvalidateRejectedHydrations() {
          return this._onInvalidateRejectedHydrations
      }
      invalidateRejectedHydrations() {
          this._onInvalidateRejectedHydrations.fire()
      }
      get onSavingStoreCountChange() {
          return this.database.onSavingStoreCountChange
      }
      get shouldResetOnError() {
          return this._shouldResetOnError
      }
      get bootstrappedAt() {
          return this.database.bootstrappedAt
      }
      get isConnected() {
          return this.socket.status === IX.connected
      }
      constructor(e, t, n, r) {
          this._onDatabaseVersionChange = new Ts,
          this._onBootstrap = new Ts,
          this._onArchive = new Ts,
          this._onArchiveUpdate = new Ts,
          this._onUnarchive = new Ts,
          this._onSyncGroupsChanged = new Ts({
              maxObservers: 0
          }),
          this._onInvalidateRejectedHydrations = new Ts({
              maxObservers: 0
          }),
          this._shouldResetOnError = !1,
          this.isDatabaseInitialized = !1,
          this.didStartSyncing = !1,
          this.lastSyncId = 0,
          this.backendDatabaseVersion = 0,
          this.modelLookup = new AZ,
          this.archivedModelLookup = new AZ,
          this.temporaryModelLookup = new AZ,
          this.modelClassToModelLookup = {},
          this.modelClassToArchivedModelLookup = {},
          this.modelClassToTemporaryModelLookup = {},
          this.syncWaitQueue = new bX,
          this.reconnectionAttempts = [],
          this.hasLoggedReconnectionError = !1,
          this.deltaSyncFailures = 0,
          this.queuedMessages = [],
          this.hydrationLoadStore = new mZ(b.MINUTE),
          this.hydrationModelCreatorBatch = new lZ(200),
          this.hydrateModelPromiseCache = new Map,
          this.hydrateArchivedModelPromiseCache = new Map,
          this.nonExistingPlaceholderModels = new Set,
          this.addModelToArchiveCollections = Ft(e => {
              let t = this.modelLookup.has(e.modelName, e.id);
              this.removeModelFromLiveCollections(e),
              this.archivedModelLookup.has(e.modelName, e.id) || (this.archivedModelLookup.add(e),
              this.modelClassToArchivedModelLookup[e.modelName].add(e),
              t && this._onArchive.fire(e))
          }
          ),
          this.removeModelFromArchiveCollections = Ft(e => {
              this.archivedModelLookup.has(e.modelName, e.id) && (this.archivedModelLookup.delete(e.modelName, e.id),
              this.modelClassToArchivedModelLookup[e.modelName].delete(e),
              this._onUnarchive.fire(e))
          }
          ),
          this.updateLock = new fX,
          this.addNewSyncGroupsToDatabase = (e, t) => {
              let {syncGroups: n, models: r, lastSyncId: i} = e;
              if (n.length !== 0) {
                  w.network(`Adding sync groups ${n.join(`, `)} models to database. Loading ${r.length} models.`),
                  NY.syncGroupsAdded(n, r.length, i);
                  for (let e of r) {
                      if (!e.id)
                          continue;
                      let {__class: n, ...r} = e;
                      if (!em.getModelClass(n)) {
                          w.info(`Could not find model class for model type ${n}`);
                          continue
                      }
                      t.put(n, r)
                  }
              }
          }
          ,
          this.addNewSyncGroupsToClient = (e, t) => {
              let {syncGroups: n, models: r, lastSyncId: i} = e;
              if (n.length === 0)
                  return;
              w.network(`Adding sync groups ${n.join(`, `)} models to memory. Loading ${r.length} models.`);
              let a = [];
              for (let e of r) {
                  if (!e.id)
                      continue;
                  let n = e.__class
                    , r = em.getModelClass(n);
                  if (!r) {
                      w.info(`Could not find model class for model type ${n}`);
                      continue
                  }
                  let o = this.getInMemoryModel(n, e.id);
                  if (o) {
                      o.isArchivedNonObservable && (this.removeModelFromArchiveCollections(o),
                      this.addModelToLiveCollections(o),
                      t.set(o, i)),
                      o.updateFromData(e, {
                          dataContainsAllProperties: !0
                      });
                      continue
                  }
                  let s = new r(!1);
                  s.id = e.id,
                  this.addModelToLiveCollections(s),
                  a.push([s, e]),
                  t.set(s, i)
              }
              for (let e of a)
                  e[0].updateFromInitialData(e[1])
          }
          ,
          this.applyEphemeralMap = Ft(e => {
              let {modelId: t, modelName: n, key: r, changes: i} = e
                , a = this.getInMemoryModel(n, t);
              if (a && a.modelName === n && r in a) {
                  let e = a[r] ?? {}
                    , o = a.properties[r];
                  if (!o || o.type !== tm.ephemeralProperty || o.ephemeralType !== `map`) {
                      w.debug(`Property ${r} is not an ephemeral map on model ${n} ${t}`);
                      return
                  }
                  if (!a.ephemeralSubscribed)
                      return;
                  let s = i.updates ?? {};
                  for (let t in s)
                      e.set(t, (o.serializer ?? Nh).deserialize(s[t]), !0);
                  for (let t of i.removeKeys ?? [])
                      e.delete(t, !0)
              }
          }
          ),
          this.applyEphemeralPrimitive = Ft(e => {
              let {modelId: t, modelName: n, values: r} = e
                , i = this.getInMemoryModel(n, t);
              if (i && i.modelName === n) {
                  if (!i.ephemeralSubscribed)
                      return;
                  i.updateFromData(r)
              }
          }
          ),
          this.startObservability = Ft( () => {
              At(this, {
                  modelClassToModelLookup: Vt,
                  modelClassToArchivedModelLookup: Vt,
                  modelClassToTemporaryModelLookup: Vt,
                  waitForSync: Ft,
                  temporarilyAdd: Ft,
                  temporarilyRemove: Ft,
                  startSyncing: Ft,
                  addModel: Ft,
                  archiveModel: Ft,
                  deleteModel: Ft,
                  deleteModelAndDependencies: Ft
              })
          }
          ),
          this.store = e,
          this.graphQLClient = t,
          this.database = new iX(this.graphQLClient,r),
          this.socket = n,
          this.syncSubscriptionManager = new gZ(this,this.database,this.socket),
          this.batchModelLoader = r.batchModelLoader,
          this.transactionQueue = new sZ(this.graphQLClient,this),
          this.deltaSyncReceivedPromise = new Jp(e => {
              this.deltaSyncReceivedResolver = e
          }
          ).then( () => {
              w.setDeltaSyncReceived()
          }
          );
          for (let e of em.getModelNames())
              this.modelClassToModelLookup[e] = new Set,
              this.modelClassToArchivedModelLookup[e] = new Set,
              this.modelClassToTemporaryModelLookup[e] = new Set;
          this.socket.onSyncMessage.subscribe(async e => {
              try {
                  if (this.store.syncProgress === GZ.initial) {
                      w.info(`Queuing sync message during bootstrap`, {
                          lastSyncId: e.lastSyncId,
                          packetCount: e.sync?.length || 0,
                          currentSyncId: this.lastSyncId,
                          syncProgress: this.store.syncProgress,
                          queueLength: this.queuedMessages.length
                      }),
                      this.queuedMessages.push(e);
                      return
                  }
                  await this.applyDelta(e.sync, e.lastSyncId)
              } catch {
                  this.socket.restart()
              }
          }
          ),
          this.socket.onEphemeralMap.subscribe(e => {
              this.applyEphemeralMap(e)
          }
          ),
          this.socket.onEphemeralPrimitive.subscribe(e => {
              this.applyEphemeralPrimitive(e)
          }
          ),
          this.socket.onMessage.subscribe(async e => {
              e.cmd === `refresh` ? (w.remote(`Refresh issued`),
              await this.refreshClient(`refresh-cmd`, e)) : e.cmd === `cacheSyncId` && this.database.cleanupSyncActionStore(e.syncId)
          }
          ),
          this.batchModelLoader.setSyncClient(this, this.database, this.syncSubscriptionManager),
          this._onInvalidateRejectedHydrationsAutoInterval = setInterval( () => {
              this._onInvalidateRejectedHydrations.fire()
          }
          , FZ)
      }
      [Symbol.dispose]() {
          clearInterval(this._onInvalidateRejectedHydrationsAutoInterval),
          this.syncSubscriptionManager[Symbol.dispose]()
      }
      add(e, t) {
          if (this.findById(e.modelClass, e.id, {
              excludeTemporaryModels: !0
          }))
              throw Error(`Model ${e.id} already exists and cannot be added`);
          e.createdAt ||= new Date;
          let n = this.transactionQueue.create(e, t);
          return this.handleTransactionOffline(n, t?.offlineError),
          n.result().catch(n => {
              this.handleTransactionError(e, t?.errorToastTitle ?? `Creation failed`, n, {
                  ...t,
                  defaultMessage: `An unknown error occurred creating your data and changes have been rolled back.`
              })
          }
          ),
          n
      }
      temporarilyAdd(e) {
          this.temporaryModelLookup.add(e),
          this.modelClassToTemporaryModelLookup[e.modelName].add(e)
      }
      isModelTemporarilyPersisted(e) {
          return this.temporaryModelLookup.has(e.modelName, e.id)
      }
      temporarilyRemove(e) {
          this.temporaryModelLookup.delete(e.modelName, e.id),
          this.modelClassToTemporaryModelLookup[e.modelName].delete(e)
      }
      update(e, t) {
          let n = this.transactionQueue.update(e, t);
          return e.isArchivedNonObservable && this._onArchiveUpdate.fire(e),
          this.handleTransactionOffline(n, t?.offlineError),
          n.result().catch(n => {
              this.handleTransactionError(e, t?.errorToastTitle ?? `Update failed`, n, {
                  ...t,
                  defaultMessage: `An unknown error occurred updating your data and changes have been rolled back.`
              })
          }
          ),
          n
      }
      archive(e, t) {
          if (e.archivedAt ||= new Date,
          !this.findById(e.modelClass, e.id, {
              excludeTemporaryModels: !0
          }))
              return this.deleteModel(e),
              new GX(e);
          let n = this.transactionQueue.archive(e);
          return this.handleTransactionOffline(n, t?.offlineError),
          n.result().catch(n => {
              this.handleTransactionError(e, `Archiving failed`, n, {
                  ...t,
                  defaultMessage: `An unknown error occurred archiving your data and changes have been rolled back.`
              })
          }
          ),
          n
      }
      unarchive(e, t) {
          e.archivedAt &&= void 0;
          let n = this.transactionQueue.unarchive(e, t?.transactionOptions);
          return this.handleTransactionOffline(n, t?.offlineError),
          n.result().catch(n => {
              this.handleTransactionError(e, `Restoring failed`, n, {
                  ...t,
                  defaultMessage: `An unknown error occurred restoring your data and changes have been rolled back.`
              })
          }
          ),
          n
      }
      delete(e, t) {
          if (this.temporarilyRemove(e),
          e.archivedAt ||= new Date,
          !this.findById(e.modelClass, e.id, {
              excludeTemporaryModels: !0
          }))
              return this.deleteModel(e),
              new GX(e);
          let n = this.transactionQueue.delete(e, t);
          return this.handleTransactionOffline(n, t?.offlineError),
          n.result().catch(e => {
              t?.suppressErrorToast || new oy(ay.error,t?.errorToastTitle ?? `Deleting failed`,Uo(e, `An unknown error occurred deleting your data and changes have been rolled back.`)).show()
          }
          ),
          n
      }
      sendEphemeralMap(e, t, n) {
          let r = {
              cmd: `ephm`,
              modelId: e.id,
              modelName: e.modelName,
              key: t,
              changes: n
          };
          w.network(`Sending ephemeral map`, r),
          this.socket.send(r)
      }
      sendEphemeralPrimitive(e, t) {
          let n = {
              cmd: `ephp`,
              modelId: e.id,
              modelName: e.modelName,
              values: t
          };
          w.network(`Sending ephemeral primitive`, n),
          this.socket.send(n)
      }
      sendEphemeralSubscribe(e) {
          let t = {
              cmd: `ephs`,
              action: `subscribe`,
              modelId: e.id,
              modelName: e.modelName
          };
          w.network(`Sending ephemeral subscribe`, t),
          this.socket.send(t)
      }
      sendEphemeralUnsubscribe(e) {
          let t = {
              cmd: `ephs`,
              action: `unsubscribe`,
              modelId: e.id,
              modelName: e.modelName
          };
          w.network(`Sending ephemeral unsubscribe`, t),
          this.socket.send(t)
      }
      findById(e, id, n) {
          let modelname = e.modelName;
          if (!modelname) {
              w.error(`Model name is undefined in findById`, void 0, {
                  id: id
              });
              return
          }
          let i = this.modelLookup.get(modelname, id) ?? this.archivedModelLookup.get(modelname, id) ?? (n?.excludeTemporaryModels ? void 0 : this.temporaryModelLookup.get(modelname, id));
          if (i !== void 0)
              return i.observePropertyChanges(),
              i;
          if (e.loadStrategy === rm.placeholder && this.store.isBootstrapped)
              return this.createPlaceholderModel(e, id)
      }
      findArchivedByIdentifier(e, t, n) {
          let r = this.findById(e, t);
          if (r && (r.dependenciesRequireLoading === !1 || n?.excludeDependencies === !0) && n?.forceLoadDependencies !== !0)
              return new Jp(r);
          let i = `${e.modelName}-${t}-${n?.excludeDependencies ?? !1}`
            , a = this.hydrateArchivedModelPromiseCache.get(i);
          if (a)
              return a;
          let o = new Jp(async (r, i) => {
              try {
                  let i = await this.graphQLClient.restModelsStream(`/sync/archived_model?modelClass=${e.modelName}&identifier=${t}&excludeDependencies=${n?.excludeDependencies ?? !1}`)
                    , a = jY.applyDeltaSyncOnModelObjectCollection(i.models, i.syncActions?.reverse() ?? []);
                  r(this.applyArchiveResponse({
                      archive: a,
                      totalCount: i.metadata.totalCount,
                      databaseVersion: i.metadata.databaseVersion,
                      includesDependencies: i.metadata.includesDependencies
                  }).find(t => t instanceof e))
              } catch (e) {
                  i(e)
              }
          }
          );
          return this.hydrateArchivedModelPromiseCache.set(i, o),
          o.catch(MZ.default).finally( () => {
              this.hydrateArchivedModelPromiseCache.delete(i)
          }
          ),
          o
      }
      allModelsOfType(e, t) {
          let n = () => Array.from(this.modelClassToArchivedModelLookup[e.modelName]) || []
            , r = () => Array.from(this.modelClassToModelLookup[e.modelName]) || []
            , i = () => Array.from(this.modelClassToTemporaryModelLookup[e.modelName]) || [];
          switch (t) {
          case yR.noTempModels:
              return [...r(), ...n()];
          case yR.noArchivedModels:
              return [...r(), ...i()];
          case yR.onlyArchivedModels:
              return n();
          case yR.onlyRegularModels:
              return r();
          case yR.allModels:
              return [...r(), ...i(), ...n()];
          default:
              new Rn(t)
          }
          return []
      }
      *allModelsOfTypeGen(e, t) {
          if (t !== yR.onlyArchivedModels && this.modelClassToModelLookup[e.modelName])
              for (let t of this.modelClassToModelLookup[e.modelName])
                  yield t;
          if ((t === yR.allModels || t === yR.noArchivedModels) && this.modelClassToTemporaryModelLookup[e.modelName])
              for (let t of this.modelClassToTemporaryModelLookup[e.modelName])
                  yield t;
          if ((t === yR.allModels || t === yR.noTempModels || t === yR.onlyArchivedModels) && this.modelClassToArchivedModelLookup[e.modelName])
              for (let t of this.modelClassToArchivedModelLookup[e.modelName])
                  yield t
      }
      loadAllModelData(e) {
          return this.database.getAllModelData(e.modelName)
      }
      modelCountInDatabase(e) {
          return this.database.getModelCount(e.modelName)
      }
      modelCountInMemory(e) {
          return this.modelClassToModelLookup[e.modelName].size
      }
      modelCountsInMemory() {
          let e = {};
          for (let[t,n] of Object.entries(this.modelClassToModelLookup))
              n.size > 0 && (e[t] = n.size);
          return e
      }
      localStoreReady(e) {
          return this.database.objectStoreReady(e.modelName)
      }
      hydrateModel(e, t, n) {
          let r = this.findById(e, t);
          if (r)
              return new Jp(r);
          let i = this.hydrateModelPromiseCacheKey(t, n?.onlyIfLocallyAvailable ?? !1)
            , a = n?.onlyIfLocallyAvailable ? this.hydrateModelPromiseCache.get(this.hydrateModelPromiseCacheKey(t, !1)) ?? this.hydrateModelPromiseCache.get(this.hydrateModelPromiseCacheKey(t, !0)) : this.hydrateModelPromiseCache.get(this.hydrateModelPromiseCacheKey(t, !1));
          if (a !== void 0)
              return a || new Jp(void 0);
          let o = e.loadStrategy === rm.explicitlyRequested
            , s = new Jp(async (r, i) => {
              try {
                  let a = o ? `needs_network_hydration` : await this.database.getModelDataById(e.modelName, t, n);
                  if (a === void 0)
                      return r(void 0);
                  if (a === `needs_network_hydration`) {
                      if (n?.onlyIfLocallyAvailable)
                          return r(void 0);
                      if (this.store.developerOptions && await this.applyNetworkDeveloperOptions(),
                      this.partialModelLoadedInFull(e)) {
                          if (n?.customNetworkHydration?.())
                              return i(Error(`Custom network hydration is not supported for models loaded in full`));
                          await this.batchModelLoader.addRequest({
                              modelClass: e,
                              id: t
                          }),
                          ri(1).then( () => this.batchModelLoader.addRequest({
                              modelClass: e,
                              skipCreatingModelsInMemory: !0
                          }))
                      } else {
                          let r = [{
                              modelClass: e,
                              id: t,
                              skipSavingModelsInDatabase: o
                          }]
                            , i = n?.customNetworkHydration?.() || r;
                          await Promise.all(i.map(e => this.batchModelLoader.addRequest(e)))
                      }
                      return r(this.findById(e, t))
                  }
                  return r(await this.hydrationModelCreatorBatch.addOperation(a, t => {
                      let n = this.database.storeIsCached(e.modelName);
                      return this.createHydratedModels(e, [t], {
                          dontCloneData: !n
                      })[0]
                  }
                  ))
              } catch (e) {
                  i(e)
              }
          }
          );
          return this.hydrateModelPromiseCache.set(i, s),
          s.then(e => (e ? this.hydrateModelPromiseCache.delete(i) : this.hydrateModelPromiseCache.set(i, null),
          e)).catch(e => {
              throw e
          }
          )
      }
      async hydrateModelsByIndexedKey(e, t, n) {
          let r = await this.hydrationLoadStore.getOrSet(e.modelName, () => new pZ(b.SECOND)).addOperation(this.database.getModelDataByIndexedKey(e, t, n));
          if (r === `needs_network_hydration`) {
              if (n?.onlyIfLocallyAvailable)
                  return !1;
              if (this.store.developerOptions && await this.applyNetworkDeveloperOptions(),
              this.partialModelLoadedInFull(e)) {
                  if (n?.customNetworkHydration?.())
                      throw Error(`Custom network hydration is not supported for models loaded in full`);
                  let r = {
                      modelClass: e,
                      skipCreatingModelsInMemory: !0
                  };
                  await this.batchModelLoader.addRequest(r);
                  let i = await this.database.getModelDataByIndexedKey(e, t);
                  if (i === `needs_network_hydration`)
                      throw Error(`Failed to load models after network full load`);
                  return this.hydrationModelCreatorBatch.addOperation(i, t => this.createHydratedModels(e, t, {
                      skipUpdateOfExistingModels: !0
                  }))
              }
              let r = [{
                  modelClass: e,
                  indexedKey: t.key,
                  keyValue: t.value.toString(),
                  coveringPartialIndexes: t.coveringPartialIndexes
              }]
                , i = n?.customNetworkHydration?.() || r;
              return await Promise.all(i.map(e => this.batchModelLoader.addRequest(e))),
              !0
          }
          return this.hydrationModelCreatorBatch.addOperation(r, t => {
              let n = this.database.storeIsCached(e.modelName);
              return this.createHydratedModels(e, t, {
                  dontCloneData: !n
              })
          }
          )
      }
      async hydrateLocalModelsByIds(e, t) {
          let n = this.database.getModelDataByIds(e.modelName, t);
          return await this.hydrationModelCreatorBatch.addOperation(n, t => {
              let n = this.database.storeIsCached(e.modelName);
              return this.createHydratedModels(e, t, {
                  dontCloneData: !n
              })
          }
          )
      }
      async initializeDatabase(e) {
          this.isDatabaseInitialized = !0;
          try {
              await Qa.executeWithRetries({
                  maxRetries: 1,
                  backoff: 0,
                  beforeRetry: e => w.info(`Retrying initializing database after error.`, {
                      error: e
                  })
              }, async () => this.database.open(e))
          } catch (e) {
              let t = await this.logStorageEstimates();
              w.withEnabledLogging( () => {
                  let n = e instanceof DY ? `Timeout opening database` : t?.isStorageProblem ? `Error opening database due to storage problem` : `Error opening database`;
                  w.error(n, e, {
                      storage: t
                  })
              }
              );
              let n = e instanceof Error ? e.message.includes(`bucket data directory`) : !1
                , r = rr.isChrome && e instanceof Error && e.message.includes(`Internal error opening backing store`);
              throw new $o({
                  type: `bootstrap error`,
                  message: `error opening database`,
                  userError: !0,
                  userPresentableMessage: `Could not save data to local database${t?.isStorageProblem === !0 ? ` since it looks like you've run out of disk space` : n || r ? ` since you've unfortunately run into a known Chromium bug` : ``}. If you have remaining space on your system and are not browsing in private mode, this error will usually resolve after quitting and restarting your browser. If you continue to see this error after a browser restart, please ${r ? `try installing our desktop app or` : ``} contact us at support@linear.app.`
              })
          }
          this.logStorageEstimates()
      }
      async bootstrap(e) {
          let {userId: t, userAccountId: n} = e;
          this.userId = t,
          this.userAccountId = n,
          w.network(`Bootstrap starting`, {
              currentSyncId: this.lastSyncId,
              syncProgress: this.store.syncProgress
          });
          let r = this.database.requiredBootstrap()
            , i = r.type === sX.partial ? this.fetchDelta(r.lastSyncId, void 0, r.type).catch( () => {}
          ) : void 0;
          this._onBootstrap.fire(r.type),
          await this.applyBootstrapDelayDeveloperOptions();
          let a = await this.database.bootstrap();
          this.firstSyncId = a.firstSyncId ?? a.lastSyncId,
          this.lastSyncId = a.lastSyncId,
          this.backendDatabaseVersion = a.backendDatabaseVersion,
          this.userSyncGroups = {
              all: new Set(a.userSyncGroups?.all ?? []),
              optimized: new Set(a.userSyncGroups?.optimized ?? [])
          },
          a.syncSubscriptions && this.syncSubscriptionManager.setSyncSubscriptions(a.syncSubscriptions);
          try {
              w.network(`Bootstrapping. Last sync id is ${this.lastSyncId}. Backend DB version is ${this.backendDatabaseVersion}`);
              let t = await this.database.getAllInitialHydratedModelData(e)
                , n = []
                , r = []
                , o = new Set;
              if (Zp.trace(`startup`, `SyncClient.bootstrap.constructModels`, () => {
                  for (let e of Object.keys(t))
                      for (let i of t[e]) {
                          let t = em.getModelClass(e);
                          if (!t) {
                              w.info(`Could not find model class for model type '${i.__modelName}'.`);
                              continue
                          }
                          let a = i.id
                            , s = this.modelLookup.get(t.modelName, a)
                            , c = s ?? new t(!1);
                          c.id = a,
                          s && o.add(a),
                          n.push(c),
                          r.push(i)
                      }
              }
              ),
              n.length === 0)
                  return {
                      success: !1,
                      type: a.type
                  };
              if (kY.addStartupSpanTag(`models.count`, n.length),
              Zp.trace(`startup`, `SyncClient.bootstrap.updateModels`, () => {
                  for (let e of n)
                      this.addModelToLiveCollections(e);
                  let e = 0;
                  Gh( () => {
                      for (let t of n)
                          o.has(t.id) ? t.updateFromData(r[e++]) : t.updateFromInitialData(r[e++]);
                      for (let e of n)
                          e.attachToReferencedProperties()
                  }
                  )
              }
              ),
              w.network(`Got ${n.length} stored models.`),
              this.startObservability(),
              await this.transactionQueue.loadPersistedTransactions(this.database).catch(e => {
                  w.error(`Error loading persisted transactions`, e)
              }
              ),
              a.syncDeltaPackets?.length) {
                  await this.database.flush();
                  let e = a.syncDeltaPackets.filter(e => e.action !== `S`);
                  await this.applyDelta(e, a.lastSyncId, a.type)
              }
              if (QJ)
                  return {
                      success: !0,
                      type: a.type
                  };
              let s = await this.store.requireDeltaSyncAtStartup();
              return (s || a.syncDeltaPackets?.length) && (kY.addStartupSpanTag(`waitingForDelta`, !0),
              Vo.increment(`bootstrap.waiting.delta`)),
              s ? (await this.database.flush(),
              await this.startSyncing(a.type, i, a.regionName),
              this.transactionQueue.confirmPersistedTransactions()) : (this._shouldResetOnError = a.type === sX.partial,
              dZ.onLoadingDone.subscribeOnce(async () => {
                  this.store.isBootstrapAborted || (await this.database.flush(),
                  await this.startSyncing(a.type, i, a.regionName),
                  this.transactionQueue.confirmPersistedTransactions(),
                  this._shouldResetOnError = !1)
              }
              )),
              {
                  success: !0,
                  type: a.type
              }
          } catch (e) {
              return this.store.isBootstrapAborted ? {
                  success: !1,
                  type: a.type,
                  error: new $a(`Bootstrap aborted`)
              } : (w.error(`Error bootstrapping from local db`, e),
              await (this.userId ? eg.deleteDatabaseForUserId(this.userId) : eg.deleteAllDatabases()),
              {
                  success: !1,
                  type: a.type,
                  error: e
              })
          }
      }
      disconnect() {
          w.network(`Disconnecting from the sync server.`),
          this.socket && this.socket.disconnect(),
          this.database.close(`disconnected`)
      }
      disconnectWebSocket() {
          this.socket.disconnect()
      }
      async reconnectWebSocket(e) {
          let {onlyIfDisconnected: t=!1} = e ?? {};
          return this.isDatabaseInitialized ? await this.database.isOpenAndHealthy() === !1 ? (w.debug(`Cannot reconnect websocket: database connection is not healthy`),
          !1) : !this.didStartSyncing || this.socket.status === IX.connected && t ? !0 : (this.trackReconnectionAttempt(),
          this.socket.status === IX.connected ? this.socket.restart() : this.socket.reconnect(),
          !0) : !0
      }
      async waitForSync() {
          await this.socket.ping()
      }
      startSyncing(e, t, n) {
          return this.didStartSyncing = !0,
          new Promise(r => {
              this.socket.connect({
                  url: Jn.SOCKET_SERVER_URL || `ws://localhost:8090`,
                  userId: this.userId || ``,
                  userAccountId: this.userAccountId || ``,
                  syncSubscriptions: this.syncSubscriptionManager.getSyncSubscriptions(),
                  databaseId: this.database.id,
                  regionName: n,
                  handshakeCallback: async i => {
                      if (this.store.isBootstrapAborted)
                          return !1;
                      if (i.refresh)
                          return await this.refreshClient(`handshake`, {
                              cmd: `refresh`,
                              resetDatabase: !0,
                              reloadClient: !0
                          }),
                          !1;
                      let a = this.socket.connectionId
                        , o = this.lastSyncId;
                      try {
                          let e = await this.database.getMetadata();
                          o = e.lastSyncId,
                          this.setFirstSyncId(e.firstSyncId ?? e.lastSyncId)
                      } catch {}
                      let s = i.sync;
                      if (!s)
                          return w.error(`No sync data in handshake message`),
                          !1;
                      let c = Math.min(this.lastSyncId, o)
                        , l = s.lastSyncId
                        , u = s.lastSequentialSyncId ?? s.lastSyncId;
                      if (c < l) {
                          w.network(`Client is not up to date, replaying`, {
                              fromSyncId: c,
                              toSyncId: l
                          });
                          try {
                              if (t) {
                                  w.network(`Applying already requested delta packets`, {
                                      fromSyncId: o
                                  });
                                  let n = await t;
                                  if (n?.delta.length) {
                                      let t = Math.min(u, n.metadata.lastSequentialSyncId, n.delta.at(-1).id);
                                      await this.applyDelta(n.delta, t, e),
                                      c = t
                                  }
                              }
                              if (c < l) {
                                  w.network(`Requesting delta packets`, {
                                      fromSyncId: c,
                                      toSyncId: l
                                  });
                                  let {delta: t} = await this.fetchDelta(c, l, e);
                                  await this.applyDelta(t, u, e)
                              }
                              this.deltaSyncFailures = 0
                          } catch (e) {
                              return this.store.isBootstrapAborted || (e instanceof $o && e.flags?.reSyncRequired === !0 ? (this.userId ? await eg.deleteDatabaseForUserId(this.userId) : await eg.deleteAllDatabases(),
                              ks.forceRefresh(`delta-sync-too-big`),
                              await new Promise(MZ.default)) : Jo(e) ? (w.error(`Continuosly failed to apply delta sync because of ratelimits`, e),
                              this.store.disconnectFromBackendWithBootstrapError(e)) : Wo(e) ? (this.userId ? await eg.deleteDatabaseForUserId(this.userId) : await eg.deleteAllDatabases(),
                              ks.forceRefresh(`delta-sync-authentication-error`),
                              await new Promise(MZ.default)) : (this.deltaSyncFailures++,
                              Go(e) || w.error(`Failed to apply delta sync`, e, {
                                  deltaSyncFailures: this.deltaSyncFailures
                              }),
                              this.deltaSyncFailures > 3 && (Go(e) ? this.store.disconnectFromBackendWithBootstrapError(new $o({
                                  ...e,
                                  userPresentableMessage: `It looks like Linear servers are not reachable. Please check your internet connection and try again.`
                              })) : (w.error(`Continuously failing to apply delta sync`, e),
                              this.userId ? await eg.deleteDatabaseForUserId(this.userId) : await eg.deleteAllDatabases(),
                              ks.forceRefresh(`many-delta-sync-failures`),
                              await new Promise(MZ.default))))),
                              !1
                          }
                      }
                      if (this.socket.connectionId !== a)
                          return !1;
                      let d = s.userSyncGroups
                        , f = d?.all ?? []
                        , p = d?.optimized ?? [];
                      return (!this.userSyncGroups || !(0,
                      jZ.default)([...this.userSyncGroups.all], f) || !(0,
                      jZ.default)([...this.userSyncGroups.optimized], p)) && (this.userSyncGroups = {
                          all: new Set(f),
                          optimized: new Set(p)
                      },
                      await this.database.writeTransaction({
                          metaStore: !0,
                          syncActionStore: !1,
                          stores: []
                      }, async e => {
                          this.persistUserSyncGroups(e)
                      }
                      ),
                      NY.userSyncGroupsChanged({
                          all: f,
                          optimized: p
                      })),
                      this.checkDatabaseVersionChange(s.databaseVersion),
                      s.regionName && n !== s.regionName && await this.database.writeTransaction({
                          metaStore: !0,
                          syncActionStore: !1,
                          stores: []
                      }, async e => {
                          e.setRegionName(s.regionName)
                      }
                      ),
                      this.deltaSyncReceivedResolver(),
                      r(),
                      !0
                  }
              })
          }
          )
      }
      async resetLocalDatabase() {
          return this.database.resetDatabase()
      }
      async deleteLocalDatabase() {
          return this.database.deleteDatabase()
      }
      addModel(e) {
          return e.isArchivedNonObservable || this.modelLookup.has(e.modelName, e.id) ? !1 : (this.addModelToLiveCollections(e),
          !0)
      }
      archiveModel(e) {
          iX.shouldLogModelAction(e.modelName, `archive`) && w.debug(`Archiving model in sync client`, {
              modelName: e.modelName,
              id: e.id
          }),
          e.detachFromReferencedProperties(),
          this.addModelToArchiveCollections(e)
      }
      deleteModel(e) {
          iX.shouldLogModelAction(e.modelName, `delete`) && w.debug(`Deleting model from sync client`, {
              modelName: e.modelName,
              id: e.id
          }),
          Mt( () => {
              e.detachFromReferencedProperties(),
              this.removeModelFromArchiveCollections(e),
              this.removeModelFromLiveCollections(e),
              e.archivedAt ||= new Date,
              e.permanentlyDeleted = !0
          }
          )
      }
      async deleteModelAndDependencies(e, t, n) {
          let r = new CZ(this);
          t ? (r.scheduleModelRemoval(`deletion`, e.modelName, e.id, this.lastSyncId, n),
          await r.applyRemovalsToDatabase(t)) : await this.database.writeTransaction({
              metaStore: !1,
              syncActionStore: !0
          }, async t => {
              r.scheduleModelRemoval(`deletion`, e.modelName, e.id, this.lastSyncId, n),
              await r.applyRemovalsToDatabase(t)
          }
          ),
          Mt( () => {
              r.applyRemovalsToSyncClient()
          }
          )
      }
      getInMemoryModel(e, t) {
          return this.modelLookup.get(e, t) ?? this.archivedModelLookup.get(e, t) ?? this.temporaryModelLookup.get(e, t)
      }
      cancelTransaction(e) {
          this.transactionQueue.cancelTransaction(e)
      }
      transactionsForModel(e) {
          return this.transactionQueue.transactionsForModel(e)
      }
      async waitUntilSyncId(e) {
          QJ || this.lastSyncId >= e || await this.syncWaitQueue.wait(e)
      }
      applyArchiveResponse(e) {
          let t = typeof e.archive == `string` ? JSON.parse(e.archive) : e.archive;
          return this.checkDatabaseVersionChange(e.databaseVersion),
          this.createModelsFromData(t, {
              dependenciesRequireLoading: t => t.isArchived && !e.includesDependencies.includes(t.id)
          })
      }
      applyModelData(e) {
          return this.createModelsFromData(e)
      }
      async reSyncModel(e, t) {
          em.getModelClass(e) && await this.updateLock.runExclusive(async () => {
              let n = new OZ(this.graphQLClient,!0,2)
                , r = n.allProcessedResult();
              n.addRequest({
                  modelName: e,
                  identifier: t
              }).catch( () => {}
              );
              let i = (await r).flatMap(e => e).filter(e => em.getModelClass(e.__class));
              this.createModelsFromData(i),
              await this.database.writeTransaction({
                  metaStore: !1,
                  syncActionStore: !1
              }, Ft(e => {
                  for (let t of i) {
                      let {__class: n, ...r} = t;
                      e.put(n, r)
                  }
              }
              ))
          }
          )
      }
      async loadPartialModels(e, t, n) {
          let r = Array.isArray(e) ? e : [e]
            , i = t === void 0 ? void 0 : Array.isArray(t) ? t : [t];
          if (r.length === 0 || i?.length === 0)
              return;
          let a = [];
          for (let e of r)
              if (i)
                  for (let t of i)
                      await this.database.hasModelsForPartialIndexes(e.modelName, [wm.createPartialIndex({
                          modelClass: e,
                          syncGroup: t
                      })]) || a.push({
                          modelClass: e,
                          syncGroup: t,
                          skipCreatingModelsInMemory: n?.skipAddingToMemory
                      });
              else {
                  if (await this.database.hasModelsForPartialIndexes(e.modelName, [wm.createPartialIndex({
                      modelClass: e
                  })]))
                      continue;
                  a.push({
                      modelClass: e,
                      skipCreatingModelsInMemory: n?.skipAddingToMemory
                  })
              }
          a.length !== 0 && await Promise.all(a.map(e => this.batchModelLoader.addRequest(e)))
      }
      async hasModelsForPartialIndexes(e, t, n) {
          return this.database.hasModelsForPartialIndexes(e, t, n)
      }
      async removeLoadedPartialIndexes(e, t) {
          return this.database.removeLoadedPartialIndexes(e, t)
      }
      async statistics() {
          let e = await ide(this.graphQLClient)
            , t = await this.database.statistics()
            , n = new Set
            , r = []
            , i = 0
            , a = {
              models: {},
              syncSubscriptions: {
                  count: 0,
                  duplicatesCount: 0,
                  duplicates: []
              }
          };
          for (let o in t) {
              let s = o
                , c = t[o].partialIndexValues;
              if (c)
                  for (let e of c) {
                      let t = wY.create(s, e);
                      n.has(t) ? r.push(`${s}:${e}`) : n.add(t),
                      i++
                  }
              a.models[s] = {
                  inMemory: 0,
                  inLocalDatabase: t[o]?.count || 0,
                  inRemoteDatabase: e[o] || 0,
                  partialIndexValues: c,
                  isReady: t[o].isReady
              }
          }
          a.syncSubscriptions.count = n.size,
          a.syncSubscriptions.duplicatesCount = i - n.size,
          a.syncSubscriptions.duplicates = r;
          for (let e of this.modelLookup.getAllModels())
              a.models[e.modelName] && (a.models[e.modelName].inMemory += 1);
          return a
      }
      async localStatistics() {
          let e = await this.database.statistics()
            , t = new Set
            , n = []
            , r = 0
            , i = {
              models: {},
              syncSubscriptions: {
                  count: 0,
                  duplicatesCount: 0,
                  duplicates: []
              }
          };
          for (let a in e) {
              let o = a
                , s = e[a].partialIndexValues;
              if (s)
                  for (let e of s) {
                      let i = wY.create(o, e);
                      t.has(i) ? n.push(`${o}:${e}`) : t.add(i),
                      r++
                  }
              i.models[o] = {
                  inMemory: 0,
                  inLocalDatabase: e[a]?.count || 0,
                  partialIndexValues: s,
                  isReady: e[a].isReady
              }
          }
          i.syncSubscriptions.count = t.size,
          i.syncSubscriptions.duplicatesCount = r - t.size,
          i.syncSubscriptions.duplicates = n;
          for (let e of this.modelLookup.getAllModels())
              i.models[e.modelName] && (i.models[e.modelName].inMemory += 1);
          return i
      }
      getLastSyncId() {
          return this.lastSyncId
      }
      getFirstSyncId() {
          return this.firstSyncId
      }
      getUserSyncGroups() {
          if (this.userSyncGroups)
              return {
                  all: [...this.userSyncGroups.all],
                  optimized: [...this.userSyncGroups.optimized]
              }
      }
      setUserSyncGroups(e) {
          this.userSyncGroups = {
              all: new Set(e.all),
              optimized: new Set(e.optimized)
          }
      }
      loadModelDataForDebug(e, t) {
          return typeof t == `string` ? this.database.getModelDataById(e.modelName, t, {
              onlyIfLocallyAvailable: !0
          }) : this.database.getModelDataByIndexedKey(e, t)
      }
      createModelsFromData(e, t) {
          return Gh( () => {
              let n = []
                , r = e.map(e => {
                  let r = em.getModelClass(e.__class);
                  if (r) {
                      let i = this.findById(r, e.id);
                      if (i)
                          return t?.dontUpdateExistingModels !== !0 && i.updateFromData(e, {
                              dataContainsAllProperties: !0
                          }),
                          i;
                      let a = this.createModel(r, e, {
                          dontCloneData: t?.dontCloneData
                      });
                      return n.push(a),
                      a
                  } else {
                      w.info(`Could not find model class for ${e.__class}`);
                      return
                  }
              }
              ).concrete();
              for (let e of r)
                  t?.dependenciesRequireLoading?.(e) && (e.dependenciesRequireLoading = !0),
                  e.attachToReferencedProperties();
              for (let e of n)
                  this.store.delayedRelationManager.resolveDelayedRelation(e);
              return r
          }
          )
      }
      async forceSetLastSyncId(e) {
          await this.database.writeTransaction({
              metaStore: !0,
              syncActionStore: !0
          }, async t => {
              this.lastSyncId = e,
              t.setLastSyncId(this.lastSyncId)
          }
          )
      }
      hydrateModelPromiseCacheKey(e, t) {
          return `${e}${t ? `-localOnly` : ``}`
      }
      setFirstSyncId(e) {
          this.firstSyncId = e,
          this.graphQLClient.setFirstSyncId(e)
      }
      trackReconnectionAttempt() {
          if (this.hasLoggedReconnectionError)
              return;
          let e = Date.now();
          this.reconnectionAttempts = this.reconnectionAttempts.filter(t => e - t < LZ),
          this.reconnectionAttempts.push(e),
          this.reconnectionAttempts.length > IZ && (this.hasLoggedReconnectionError = !0,
          w.error(`Client made too many reconnection attempts`, void 0, {
              attempts: this.reconnectionAttempts.length,
              windowMs: LZ,
              maxAllowed: IZ
          }))
      }
      async processQueuedMessages() {
          let e = 0;
          for (; this.queuedMessages.length > 0; ) {
              if (e >= 10) {
                  w.remote(`Too many iterations processing queued sync messages, aborting to avoid infinite loop`, {
                      queueLength: this.queuedMessages.length,
                      syncProgress: this.store.syncProgress,
                      iterations: e
                  });
                  return
              }
              w.info(`Processing queued sync messages after bootstrap`, {
                  queueLength: this.queuedMessages.length,
                  syncProgress: this.store.syncProgress
              });
              let t = [...this.queuedMessages];
              this.queuedMessages = [];
              for (let e of t)
                  try {
                      await this.applyDelta(e.sync, e.lastSyncId)
                  } catch (t) {
                      w.error(`Failed to process queued sync message`, {
                          error: t,
                          lastSyncId: e.lastSyncId
                      }),
                      this.socket.restart();
                      return
                  }
              w.remote(`Successfully processed all queued sync messages`, {
                  processedCount: t.length,
                  iterations: e
              }),
              e++
          }
      }
      handleTransactionOffline(e, t) {
          t && e.result().then(n => {
              n === BX.offlined && (e.cancel(),
              new oy(ay.error,`You are offline`,t).show())
          }
          )
      }
      async fetchDelta(e, t, n) {
          let r = await LY.fetchDeltaPackets(this.graphQLClient, e, t, {
              syncSubscriptions: this.syncSubscriptionManager.getSyncSubscriptions(),
              bootstrapType: n
          });
          return n === sX.full && (r.delta = r.delta.filter(e => e.action !== `S`)),
          w.network(`Received ${r.delta.length} delta packets`, {
              fromSyncId: e,
              toSyncId: t,
              length: r.delta.length
          }),
          r
      }
      createModel(e, t, n) {
          let r = this.findById(e, t.id);
          if (r && n?.skipUpdateOfExistingModels)
              return r;
          let i = r || new e(!1);
          return i.store = this.store,
          r ? i.updateFromData(t, {
              dataContainsAllProperties: !0,
              dontCloneData: n?.dontCloneData
          }) : i.updateFromInitialData(t, {
              dontCloneData: n?.dontCloneData
          }),
          i.isArchivedNonObservable ? this.addModelToArchiveCollections(i) : (this.hydrateModelPromiseCache.delete(this.hydrateModelPromiseCacheKey(i.id, !1)),
          this.hydrateModelPromiseCache.delete(this.hydrateModelPromiseCacheKey(i.id, !0)),
          this.addModelToLiveCollections(i)),
          i
      }
      createPlaceholderModel(e, t) {
          if (!this.nonExistingPlaceholderModels.has(t))
              return Gh( () => {
                  let n = new e(!1);
                  if (!n.updateForPlaceholder)
                      throw Error(`Incorrect loading strategy 'placeholder' for non-placeholder model ${e.modelName}`);
                  return n.id = t,
                  n.store = this.store,
                  this.addModelToLiveCollections(n),
                  n.updateForPlaceholder(),
                  n.attachToReferencedProperties(),
                  n.startHydratingPlaceholderModel().then(e => {
                      !e && n.isPlaceholder ? (this.nonExistingPlaceholderModels.add(t),
                      this.deleteModel(n)) : e && this.nonExistingPlaceholderModels.delete(t)
                  }
                  ).catch(e => {
                      n.isPlaceholder && (w.error(`Error hydrating placeholder model`, e, {
                          modelId: n.id,
                          modelName: n.modelName
                      }),
                      this.deleteModel(n))
                  }
                  ),
                  n.observePropertyChanges(),
                  this.store.delayedRelationManager.resolveDelayedRelation(n),
                  n
              }
              )
      }
      addModelToLiveCollections(e) {
          this.removeModelFromArchiveCollections(e),
          this.modelLookup.has(e.modelName, e.id) || (this.modelLookup.add(e),
          this.modelClassToModelLookup[e.modelName].add(e))
      }
      removeModelFromLiveCollections(e) {
          this.modelLookup.has(e.modelName, e.id) && (this.modelLookup.delete(e.modelName, e.id),
          this.modelClassToModelLookup[e.modelName].delete(e))
      }
      checkDatabaseVersionChange(e) {
          this.backendDatabaseVersion !== e && (this.backendDatabaseVersion < e && setTimeout( () => {
              this._onDatabaseVersionChange.fire()
          }
          , NZ + Math.random() * PZ),
          this.backendDatabaseVersion = e,
          this.database.setBackendDatabaseVersion(this.backendDatabaseVersion))
      }
      async applyDelta(e, t, n) {
          e.length !== 0 && await this.updateLock.runExclusive(async () => {
              let r = this.lastSyncId;
              w.network(`Processing ${e.length} sync packets. Last sync is ${t}`, {
                  updates: e.slice(0, 200)
              });
              let {updatedUserSyncGroups: i, loadedSyncGroups: a, perPacketRemovedSyncGroups: o} = await jY.getDeltaSyncGroupChanges(this.syncSubscriptionManager, this.database, this.userSyncGroups, e)
                , s = []
                , c = await OZ.supportedPacket(this.database, e);
              if (c.length > 0) {
                  let e = new OZ(this.graphQLClient,!1,3)
                    , t = e.allProcessedResult();
                  for (let t of c)
                      w.network(`Loading dependencies for ${t.modelName} with id ${t.modelId}`),
                      e.addRequest({
                          modelName: t.modelName,
                          identifier: t.modelId
                      }).catch( () => {}
                      );
                  s = (await t).flatMap(e => e).filter(e => em.getModelClass(e.__class))
              }
              await this.database.writeTransaction({
                  metaStore: !0,
                  syncActionStore: !0
              }, async c => {
                  a && this.addNewSyncGroupsToDatabase(a, c),
                  i && (w.network(`Persisting new user sync groups ${[...i.all].join(`, `)}`),
                  this.userSyncGroups = i,
                  this.persistUserSyncGroups(c));
                  for (let e of s) {
                      let {__class: t, ...n} = e;
                      c.put(t, n)
                  }
                  let l = new CZ(this,!!n);
                  for (let t of e)
                      switch (c.addSyncPacket(t),
                      l.trackPacket(t),
                      t.action) {
                      case `I`:
                      case `V`:
                      case `U`:
                          c.put(t.modelName, t.data),
                          this.transactionQueue.modelUpserted(t.modelId);
                          break;
                      case `C`:
                          let e = await c.get(t.modelName, t.modelId);
                          e ? (Object.assign(e, t.data),
                          c.put(t.modelName, e)) : w.error(`Did not have model for C packet`, void 0, {
                              id: t.modelId,
                              modelName: t.modelName
                          });
                          break;
                      case `B`:
                          await c.iterate(t.modelName, {
                              key: t.data.indexedKey,
                              values: [t.data.operation.oldKeyValue]
                          }, e => {
                              let n = e.value;
                              n && jY.shouldApplyBulkOperationToValue({
                                  ...n,
                                  __class: t.modelName
                              }, t.data) && c.put(t.modelName, {
                                  ...n,
                                  [t.data.indexedKey]: jY.applyBulkOperationToValue(t.data.operation, n[t.data.indexedKey])
                              })
                          }
                          );
                          break;
                      case `A`:
                          l.scheduleModelRemoval(`archival`, t.modelName, t.modelId, t.id);
                          break;
                      case `D`:
                          l.scheduleModelRemoval(`deletion`, t.modelName, t.modelId, t.id);
                          break;
                      case `G`:
                      case `S`:
                          let n = o.get(t.id);
                          n?.length && await this.removeSyncGroups(n, l, t.id);
                          break;
                      default:
                      }
                  await l.applyRemovalsToDatabase(c),
                  Mt( () => {
                      let r = new Map;
                      a && this.addNewSyncGroupsToClient(a, r);
                      for (let t of e)
                          switch (t.action) {
                          case `I`:
                          case `V`:
                          case `U`:
                              let e = em.getModelClass(t.modelName);
                              if (e) {
                                  let i = this.findById(e, t.data.id);
                                  if (i)
                                      i.isArchivedNonObservable && (t.action === `I` || n) && (i.archivedAt = void 0,
                                      this.removeModelFromArchiveCollections(i),
                                      this.addModelToLiveCollections(i),
                                      r.set(i, t.id));
                                  else {
                                      let n;
                                      try {
                                          n = this.createModel(e, t.data)
                                      } catch (e) {
                                          throw w.error(`Error creating model from sync packet`, e, {
                                              packetId: t.id,
                                              modelId: t.modelId,
                                              modelName: t.modelName
                                          }),
                                          e
                                      }
                                      r.set(n, t.id)
                                  }
                              } else
                                  Jn.IS_PRODUCTION_ENV || w.error(`Could not map model name '${t.modelName}' to a model class`);
                              break;
                          case `A`:
                              let i = em.getModelClass(t.modelName);
                              if (i) {
                                  let e = this.findById(i, t.modelId);
                                  e && t.data && e.updateFromData(t.data, {
                                      dataContainsAllProperties: !0
                                  })
                              } else
                                  Jn.IS_PRODUCTION_ENV || w.error(`Could not map model name '${t.modelName}' to a model class`);
                              break;
                          case `D`:
                              break;
                          case `G`:
                          case `S`:
                              break;
                          default:
                          }
                      let u = l.removedModelIds;
                      for (let[e,t] of r) {
                          let n = u.get(e.id);
                          n !== void 0 && n >= t && r.delete(e)
                      }
                      Gh( () => {
                          for (let[e] of r)
                              this.hydrateModelPromiseCache.delete(this.hydrateModelPromiseCacheKey(e.id, !1)),
                              this.hydrateModelPromiseCache.delete(this.hydrateModelPromiseCacheKey(e.id, !0)),
                              e.attachToReferencedProperties(),
                              this.store.delayedRelationManager.resolveDelayedRelation(e)
                      }
                      ),
                      s.length && this.createModelsFromData(s);
                      for (let n of e)
                          switch (n.action) {
                          case `I`:
                          case `V`:
                          case `U`:
                          case `C`:
                              let e = em.getModelClass(n.modelName);
                              if (e) {
                                  let r = this.findById(e, n.modelId);
                                  r && (r.updateFromData(n.data, {
                                      dataContainsAllProperties: n.action !== `C`
                                  }),
                                  this.transactionQueue.rebaseTransactions(r, t))
                              } else
                                  Jn.IS_PRODUCTION_ENV || w.error(`Could not map model name '${n.modelName}' to a model class`);
                              break;
                          case `B`:
                              Gh( () => {
                                  let e = em.getModelClass(n.modelName);
                                  if (e)
                                      for (let t of this.allModelsOfTypeGen(e, yR.allModels))
                                          jY.shouldApplyBulkOperationToValue(t, n.data) && t.updateFromData({
                                              [n.data.indexedKey]: jY.applyBulkOperationToValue(n.data.operation, t[n.data.indexedKey])
                                          }, {
                                              dataContainsAllProperties: !1
                                          })
                              }
                              );
                              break;
                          default:
                          }
                      l.applyRemovalsToSyncClient(),
                      l.reportPerformance(),
                      this.lastSyncId = Math.max(this.lastSyncId, t),
                      c.setLastSyncId(this.lastSyncId),
                      (a || o?.size) && (this.setFirstSyncId(this.lastSyncId),
                      c.setFirstSyncId(this.lastSyncId)),
                      this.syncWaitQueue.progressQueue(this.lastSyncId),
                      i && this._onSyncGroupsChanged.fire(),
                      c.commit()
                  }
                  ),
                  n && NY.deltaSync(r, this.lastSyncId, e.length, n),
                  i && NY.userSyncGroupsChanged(i)
              }
              ).catch(e => {
                  throw NY.deltaSyncFailure(e, r, this.lastSyncId, this.deltaSyncFailures + 1),
                  w.error(`Error applying sync response`, e),
                  e
              }
              )
          }
          )
      }
      async removeSyncGroups(e, t, n) {
          if (e.length !== 0) {
              w.network(`Removing sync groups ${e.join(`, `)} at sync id ${n}`),
              NY.syncGroupsRemoved(e, n);
              for (let r of e) {
                  let e = this.getInMemoryModel(`Team`, r);
                  e && H.includes(this.userSyncGroups?.all ?? [], H.adminAccess) ? t.scheduleModelRemoval(`deletion`, e.modelName, e.id, n, {
                      only: [`Attachment`, `Comment`, `Cycle`, `CustomView`, `DocumentContent`, `Facet`, `Favorite`, `Issue`, `IssueProgressSnapshot`, `IssueHistory`, `Project`, `ProjectUpdate`, `ViewPreferences`, `TriageResponsibility`, `ViewPreferences`]
                  }) : H.isConstant(r) || t.scheduleModelRemoval(`deletion`, `Team`, r, n),
                  (H.equals(r, H.adminAccess) || H.equals(r, H.fullMemberAccess) || H.equals(r, H.privateTeamSettingsAccess)) && (w.remote(`Resetting due to admin/fullMember/privateTeamSettings access group change`),
                  await this.resetLocalDatabase().finally(async () => {
                      ks.forceRefresh(`admin-access-group-change`),
                      await new Promise(MZ.default)
                  }
                  ))
              }
          }
      }
      handleTransactionError(e, t, n, r) {
          n instanceof $o && n.flags?.reSyncRequired ? Vo.increment(`sync.error.re_sync_needed`, {
              error: n.message
          }) : n instanceof $o && n.flags?.entityDeleted ? (w.error(`Client modified an deleted entity`, n),
          this.deleteModelAndDependencies(e)) : r.suppressErrorToast || new oy(ay.error,t,Uo(n, r.defaultMessage),{
              link: n instanceof $o && n.userError ? void 0 : {
                  to: qg,
                  label: `Check if Linear is having issues`,
                  external: !0
              }
          }).show()
      }
      createHydratedModels(e, t, n) {
          return Gh( () => {
              let r = t.map(t => this.createModel(e, t, n));
              for (let e of r)
                  e.attachToReferencedProperties(),
                  e.observePropertyChanges(),
                  this.store.delayedRelationManager.resolveDelayedRelation(e);
              return r
          }
          )
      }
      persistUserSyncGroups(e) {
          if (this.userSyncGroups) {
              let t = {
                  all: [...this.userSyncGroups.all],
                  optimized: [...this.userSyncGroups.optimized]
              };
              e.setUserSyncGroups(t)
          }
      }
      async logStorageEstimates() {
          if (!navigator.storage || !navigator.storage.estimate) {
              w.info(`Storage estimate not supported`);
              return
          }
          try {
              let e = await navigator.storage.estimate()
                , t = e.quota ? (e.usage ?? 0) / e.quota * 100 : 100
                , n = ((e.quota ?? 0) - (e.usage ?? 0)) / 1024 / 1024
                , r = e.usage === 0x10000000000000000;
              return w.info(`Storage estimate in MB`, {
                  storage: {
                      quota: (e.quota ?? 0) / 1024 / 1024,
                      remaining: n,
                      percentageUsed: t,
                      isStorageProblem: r
                  }
              }),
              {
                  ...e,
                  isStorageProblem: r
              }
          } catch (e) {
              w.info(`Storage estimate error`, e);
              return
          }
      }
      partialModelLoadedInFull(e) {
          return e.loadStrategy === rm.partial && e.partialLoadMode === im.full
      }
      async applyNetworkDeveloperOptions() {
          if (this.store.developerOptions?.pingTime && await ri(this.store.developerOptions.pingTime),
          this.store.developerOptions?.failPercentage && Math.random() * 100 < this.store.developerOptions.failPercentage)
              throw Error(`Failed hydration because of developer option failure settings`)
      }
      async applyBootstrapDelayDeveloperOptions() {
          let e = this.store.developerOptions?.delayBootstrap;
          e && await new Promise(t => {
              let n = () => {
                  i !== void 0 && self.document.removeEventListener(`keydown`, i),
                  t()
              }
                , r = setTimeout( () => {
                  n()
              }
              , e)
                , i = e => {
                  e.key === `Escape` && (r && clearTimeout(r),
                  n())
              }
              ;
              self.document.addEventListener(`keydown`, i)
          }
          )
      }
      async refreshClient(e, t) {
          let n = Number(ei.get(`lastRefreshCmdExec`)) || 0;
          Date.now() - n > b.HOUR && (ei.set(`lastRefreshCmdExec`, Date.now().toString()),
          t.resetDatabase && (await this.resetLocalDatabase(),
          ks.forceRefresh(`${e}-cmd-reset-database`)),
          t.reloadClient && setTimeout( () => {
              Jn.PREVIEW_BUILD ? window.location.href = `https://linear.app` : (ks.refreshWhenReady(hX.normal, e),
              setTimeout( () => {
                  ks.forceRefresh(`${e}-forced`)
              }
              , b.MINUTE))
          }
          , t.reloadDelay || 0))
      }
  }
  ,
  M([Zp.trace(`startup`)], RZ.prototype, `startSyncing`, null),
  M([Zp.trace(`startup`)], RZ.prototype, `fetchDelta`, null),
  M([Zp.trace(`startup`)], RZ.prototype, `applyDelta`, null)
}
)), zZ, mde = t(( () => {
  zt(),
  nm(),
  zZ = class {
      constructor(e) {
          this.targetToRelationshipLookup = {},
          this.delayedRelationObserverMap = Vt.map(),
          this.store = e
      }
      addDelayedRelation(e, t, n) {
          let r = this.getMapKey(t, n)
            , i = this.getMapKey(e.modelName, e.id);
          this.targetToRelationshipLookup[r] === void 0 ? this.targetToRelationshipLookup[r] = new Set([i]) : this.targetToRelationshipLookup[r].add(i)
      }
      addDelayedObserver(e, t) {
          let n = this.getMapKey(e, t);
          Mt( () => {
              this.delayedRelationObserverMap.set(n, !0)
          }
          ),
          this.delayedRelationObserverMap.get(n)
      }
      resolveDelayedRelation(e) {
          let t = this.getMapKey(e.modelName, e.id)
            , n = this.targetToRelationshipLookup[t];
          if (n)
              for (let e of n) {
                  let[t,n] = this.parseMapKey(e)
                    , r = em.getModelClass(t);
                  if (r) {
                      let e = this.store.findById(r, n);
                      e && e.attachToReferencedProperties()
                  }
              }
          this.delayedRelationObserverMap.delete(t)
      }
      getMapKey(e, t) {
          return `${e}:${t}`
      }
      parseMapKey(e) {
          let t = e.split(`:`);
          if (t.length !== 2)
              throw Error(`Invalid delayed relation manager map key: ${e}`);
          return t
      }
  }
}
)), BZ, VZ, hde = t(( () => {
  zt(),
  Gy(),
  ws(),
  BZ = 100,
  VZ = class {
      get nextUndoOperation() {
          return this.undoQueue[this.undoQueue.length - 1]
      }
      get nextRedoOperation() {
          return this.redoQueue[this.redoQueue.length - 1]
      }
      constructor(e) {
          this.transactionQueuedSignal = e,
          this.undoQueue = [],
          this.redoQueue = [],
          At(this, {
              addOperation: Ft
          })
      }
      async addOperation(e, t, n) {
          let r = [];
          function i(e) {
              e.options?.preventUndo || r.push(e)
          }
          this.transactionQueuedSignal.subscribe(i);
          try {
              let a = await t();
              return this.transactionQueuedSignal.unsubscribe(i),
              r.length && (this.undoQueue.push({
                  name: e,
                  location: this.getLocationWithSelectedItemKeys(n?.selectedItemKeys),
                  time: new Date,
                  transactions: r
              }),
              this.redoQueue.splice(0, this.redoQueue.length),
              this.undoQueue.length > BZ && this.undoQueue.shift()),
              a
          } catch (e) {
              this.transactionQueuedSignal.unsubscribe(i),
              w.error(`addOperation error`, e);
              return
          }
      }
      addCustomOperation(e, t, n, r) {
          this.undoQueue.push({
              name: e,
              location: this.getLocationWithSelectedItemKeys(r?.selectedItemKeys),
              time: new Date,
              transactions: [],
              customCallbacks: {
                  undo: t,
                  redo: n
              }
          }),
          this.redoQueue.splice(0, this.redoQueue.length),
          this.undoQueue.length > BZ && this.undoQueue.shift()
      }
      async undo() {
          let e = this.undoQueue.pop();
          if (e) {
              let t = {
                  ...e,
                  transactions: e.transactions.reverse().map(e => e.undoTransaction()),
                  time: new Date
              };
              return t.customCallbacks && await t.customCallbacks.undo(),
              this.redoQueue.push(t),
              {
                  operation: e,
                  transactions: t.transactions
              }
          }
          return {
              operation: e,
              transactions: []
          }
      }
      async redo() {
          let e = this.redoQueue.pop();
          if (e) {
              let t = {
                  ...e,
                  transactions: e.transactions.map(e => e.undoTransaction()),
                  time: new Date
              };
              t.customCallbacks && await t.customCallbacks.redo(),
              this.undoQueue.push(t)
          }
          return e
      }
      getLocationWithSelectedItemKeys(e) {
          let t = Wy.location;
          return {
              ...t,
              state: {
                  ...t.state,
                  undoSelectedItemKeys: e ?? []
              }
          }
      }
  }
}
));
async function gde(e, t) {
  return e.query(Ut`
    query Flags($releaseChannelOverride: ReleaseChannel) {
      flags(releaseChannelOverride: $releaseChannelOverride) {
        userId
        flags
      }
    }
  `, {
      releaseChannelOverride: t
  }, {
      dontLog: !0
  })
}
var _de = t(( () => {
  Wt()
}
)), HZ, UZ = t(( () => {
  ro(),
  OY(),
  Yr(),
  pi(),
  ho(),
  ws(),
  es(),
  _de(),
  HZ = class e {
      static async init(t, n, r) {
          this.instance && this.instance.stop(),
          this.instance = new e(t,n,r),
          await this.instance.ensureLoaded()
      }
      static async changeReleaseChannelOverride(e) {
          if (!this.instance)
              throw Error(`FlagsSync not initialized`);
          fi.setReleaseOverrideChannel(this.instance.userId, e);
          let t = {
              cmd: `flagsReevaluate`,
              releaseChannelOverride: e
          };
          this.instance.socket.send(t);
          let n = no();
          this.instance.featureFlagsPromises.add(n),
          await EY(n, 5 * b.SECOND).finally( () => {
              this.instance?.featureFlagsPromises.delete(n)
          }
          )
      }
      constructor(e, t, n) {
          this.socket = e,
          this.client = t,
          this.userId = n,
          this.ensureLoaded = async () => {
              if (fi.hasMissingFlags(this.userId) === !1) {
                  fi.ensureLoaded(this.userId);
                  return
              }
              try {
                  let {flags: e} = await gde(this.client, fi.getReleaseChannelOverride(this.userId));
                  for (let {userId: t, flags: n} of e)
                      fi.setFlags(t, n),
                      fi.ensureLoaded(t)
              } catch (e) {
                  if (qo(e) && e.userError === !0 || w.error(`Error loading flags`, e),
                  Wo(e)) {
                      await mo.logoutCurrentUserAccount(`Fetching flags failed`, e);
                      return
                  }
                  this.errorLoadingUserFlags.add(this.userId)
              }
          }
          ,
          this.reportEvaluation = e => {
              try {
                  this.socket.send(e)
              } catch (t) {
                  w.error(`Error sending flag evaluated command`, t, {
                      flag: e.flag
                  })
              }
          }
          ,
          this.handleMessage = e => {
              if (e.cmd === `featureFlags`) {
                  fi.setFlags(e.userId, e.flags),
                  fi.ensureLoaded(this.userId),
                  this.errorLoadingUserFlags.delete(e.userId);
                  for (let e of this.featureFlagsPromises)
                      e.resolve()
              }
          }
          ,
          this.errorLoadingUserFlags = new Set,
          this.featureFlagsPromises = new Set,
          e.onMessage.subscribe(this.handleMessage),
          fi.registerReportEvaluationFnc(this.reportEvaluation)
      }
      stop() {
          this.socket.onMessage.unsubscribe(this.handleMessage),
          fi.unregisterReportEvaluationFnc(this.reportEvaluation)
      }
  }
}
)), WZ, GZ, KZ = t(( () => {
  zt(),
  Lo(),
  Ga(),
  to(),
  lo(),
  As(),
  nm(),
  es(),
  pde(),
  LX(),
  KX(),
  Vh(),
  ws(),
  ni(),
  cX(),
  mde(),
  hde(),
  bR(),
  UZ(),
  WZ = class {
      static #e = this.constructorName = `SyncedStore`;
      get socketStatus() {
          return this.socket.status
      }
      get onSocketConnect() {
          return this.socket.onConnect
      }
      get onSocketDisconnect() {
          return this.socket.onDisconnect
      }
      get onMessage() {
          return this.socket.onMessage
      }
      get onDatabaseVersionChange() {
          return this.syncClient.onDatabaseVersionChange
      }
      get onArchive() {
          return this.syncClient.onArchive
      }
      get onUnarchive() {
          return this.syncClient.onUnarchive
      }
      get onArchiveUpdate() {
          return this.syncClient.onArchiveUpdate
      }
      get onTransactionQueued() {
          return this.syncClient.onTransactionQueued
      }
      get onDatabaseUnavailable() {
          return this.syncClient.onDatabaseUnavailable
      }
      get onInvalidateRejectedHydrations() {
          return this.syncClient.onInvalidateRejectedHydrations
      }
      get hasLocalTransactions() {
          return this.localTransactions.length > 0
      }
      get isBootstrapAborted() {
          return this.bootstrapAbortController.signal.aborted
      }
      invalidateRejectedHydrations() {
          this.syncClient.invalidateRejectedHydrations()
      }
      constructor(e, t) {
          this.outstandingTransactionCount = 0,
          this.savingStoreCount = 0,
          this.syncProgress = GZ.initial,
          this.syncError = void 0,
          this.connectionError = void 0,
          this.bootstrapAbortController = new AbortController,
          this.setSyncProgress = Ft(e => {
              this.syncProgress = e
          }
          ),
          this.setSyncError = Ft(e => {
              this.syncError = e
          }
          ),
          this.setConnectionError = Ft(e => {
              this.connectionError = e
          }
          ),
          this.localTransactions = [],
          this.modelsWithEphemeralSubscriptions = new Set,
          this.handleTransactionCountChange = Ft(e => {
              this.outstandingTransactionCount = e
          }
          ),
          this.handleSavingStoreCountChange = Ft(e => {
              this.savingStoreCount = e
          }
          ),
          this._developerOptions = ei.get(`StoreDeveloperOptions`),
          this.graphQLClient = e,
          this.options = t,
          this.socket = new FX(co.isElectron ? Po.desktop : Po.web),
          this.delayedRelationManager = new zZ(this),
          this.syncClient = new RZ(this,this.graphQLClient,this.socket,this.options),
          this.undoQueue = new VZ(this.onTransactionQueued),
          this.batchModelLoader = t.batchModelLoader,
          this.onSocketDisconnect.subscribe(async e => {
              switch (e) {
              case Wa.rebootstrapRequired:
                  await this.resetLocalDatabase(),
                  ks.forceRefresh(`socket-closed-rebootstrap-required`);
                  break;
              case Wa.unknownAbbreviation:
                  w.error(`Client sent an unknown abbreviation`);
                  break;
              case Wa.notPartOfCollabDocument:
                  w.error(`Client sent a message to a collab document that they're not part of`);
                  break;
              default:
              }
          }
          ),
          this.onSocketConnect.subscribe( () => {
              for (let e of this.modelsWithEphemeralSubscriptions)
                  this.sendEphemeralSubscribe(e)
          }
          ),
          At(this, {
              syncProgress: Vt,
              syncError: Vt,
              connectionError: Vt,
              outstandingTransactionCount: Vt,
              savingStoreCount: Vt,
              bootstrap: Ft,
              disconnectFromBackend: Ft,
              disconnectFromBackendWithBootstrapError: Ft
          })
      }
      async mutate(e, t, n) {
          let r = n ? Object.keys(n).map(e => `${e}: ${JSON.stringify(n[e])}`).join(`, `) : void 0
            , i = Lh(e.modelName)
            , a = `mutation { ${t}${r ? `( ${r} )` : ``} { ${i} { id } lastSyncId }}`
            , o = await this.graphQLClient.mutate(a)
            , {id: s} = o[t][i]
            , c = o[t].lastSyncId;
          if (await this.syncClient.waitUntilSyncId(c),
          s)
              return this.findById(e, s)
      }
      findById(e, t, n) {
          return this.syncClient.findById(e, t, n)
      }
      findArchivedByIdentifier(e, t, n) {
          return this.syncClient.findArchivedByIdentifier(e, t, n)
      }
      applyArchiveResponse(e) {
          return this.syncClient.applyArchiveResponse(e)
      }
      applyModelData(e) {
          return this.syncClient.applyModelData(e)
      }
      async findByIdAsync(e, t) {
          return this.syncClient.findById(e, t) || (await this.waitForSync(),
          this.syncClient.findById(e, t))
      }
      allModelsOfType(e, t=yR.noArchivedModels) {
          return this.syncClient.allModelsOfType(e, t)
      }
      async modelCountInDatabase(e) {
          return this.syncClient.modelCountInDatabase(e)
      }
      modelCountInMemory(e) {
          return this.syncClient.modelCountInMemory(e)
      }
      localStoreReady(e) {
          return this.syncClient.localStoreReady(e)
      }
      hydrateModel(e, t, n) {
          return this.syncClient.hydrateModel(e, t, n)
      }
      hydrateModels(e, t, n) {
          return this.syncClient.hydrateModelsByIndexedKey(e, t, n)
      }
      hydrateLocalModelsByIds(e, t) {
          return this.syncClient.hydrateLocalModelsByIds(e, t)
      }
      async resetLocalDatabase() {
          return this.syncClient.resetLocalDatabase()
      }
      async deleteLocalDatabase() {
          return this.syncClient.deleteLocalDatabase()
      }
      async bootstrap({userId: e, userAccountId: t, organizationId: n}) {
          await HZ.init(this.socket, this.graphQLClient, e);
          let r = {
              userId: e,
              userAccountId: t,
              organizationId: n,
              modelSchemaHash: em.schemaHash
          };
          this.syncClient.onTransactionCountChange.subscribe(this.handleTransactionCountChange),
          this.syncClient.onSavingStoreCountChange.subscribe(this.handleSavingStoreCountChange);
          try {
              let e = performance.now();
              return w.network(`Initializing database`, {
                  props: r
              }),
              await this.syncClient.initializeDatabase(r),
              this.isBootstrapAborted ? {
                  success: !1,
                  type: sX.local,
                  error: new $a(`Bootstrap aborted`)
              } : (w.network(`Initializing database completed`, {
                  durationMs: performance.now() - e
              }),
              await this.syncClient.bootstrap(r))
          } catch (e) {
              return {
                  success: !1,
                  type: sX.local,
                  error: e
              }
          }
      }
      disconnectFromBackend() {
          this.setSyncProgress(GZ.stopped),
          this.syncClient.disconnect(),
          this.bootstrapAbortController.abort()
      }
      disconnectFromBackendWithBootstrapError(e) {
          let t = Jo(e);
          this.setSyncProgress(t ? GZ.ratelimited : GZ.bootstrapError),
          this.setSyncError(e),
          this.syncClient.disconnect(),
          this.bootstrapAbortController.abort()
      }
      disconnectWebSocket() {
          this.syncClient.disconnectWebSocket()
      }
      async reconnectWebSocket(e) {
          return await this.syncClient.reconnectWebSocket(e)
      }
      async waitForSync() {
          return this.socketStatus === IX.connected ? (await this.syncClient.waitForSync(),
          !0) : !1
      }
      save(e, t=!1, n) {
          return this.saveForLocalTransaction(e, n) ? new GX(e) : (e.shouldSetUpdatedAt && (e.updatedAt = new Date),
          this.syncClient.findById(e.modelClass, e.id, {
              excludeTemporaryModels: !0
          }) ? (e.beforeSave(!1),
          this.syncClient.update(e, n)) : (e.beforeSave(!0),
          this.removeTemporarily(e),
          t ? (e.createdAt = new Date,
          e.prepareForAdd(),
          e.observePropertyChanges(),
          this.syncClient.add(e, n)) : new GX(e)))
      }
      addTemporarily(e) {
          return this.syncClient.temporarilyAdd(e)
      }
      removeTemporarily(e) {
          this.syncClient.temporarilyRemove(e)
      }
      archive(e, t) {
          return this.syncClient.archive(e, t)
      }
      unarchive(e, t) {
          return this.syncClient.unarchive(e, t)
      }
      delete(e, t) {
          return this.deleteForLocalTransaction(e) ? new GX(e) : this.syncClient.delete(e, t)
      }
      trash(e) {
          return e.trashed = !0,
          this.deleteForLocalTransaction(e) ? new GX(e) : e.isArchived ? e.save() : this.syncClient.delete(e)
      }
      sendEphemeralMap(e, t, n) {
          if (e.persistedOnBackend)
              return this.syncClient.sendEphemeralMap(e, t, n)
      }
      sendEphemeralPrimitive(e, t) {
          if (e.persistedOnBackend)
              return this.syncClient.sendEphemeralPrimitive(e, t)
      }
      sendEphemeralSubscribe(e) {
          e.persistedOnBackend && (this.syncClient.sendEphemeralSubscribe(e),
          this.modelsWithEphemeralSubscriptions.add(e))
      }
      sendEphemeralUnsubscribe(e) {
          e.persistedOnBackend && (this.syncClient.sendEphemeralUnsubscribe(e),
          this.modelsWithEphemeralSubscriptions.delete(e))
      }
      registerLocalTransaction(e) {
          this.localTransactions.push(e)
      }
      localTransactionsForModel(e) {
          return this.localTransactions.filter(t => t.hasModel(e))
      }
      unregisterLocalTransaction(e) {
          this.localTransactions = this.localTransactions.filter(t => t !== e)
      }
      sendCommand(e, t) {
          this.socket.send(e, t)
      }
      set developerOptions(e) {
          e ? ei.set(`StoreDeveloperOptions`, e) : ei.remove(`StoreDeveloperOptions`),
          this._developerOptions = e
      }
      get developerOptions() {
          return this._developerOptions
      }
      get hasDeveloperOptions() {
          return this._developerOptions ? Object.values(this._developerOptions).some(e => !!e) : !1
      }
      get isPreBootstrapRendering() {
          return !this.isBootstrapped && !!this.pageDataPreloader.preBootstrapModel
      }
      async requireDeltaSyncAtStartup() {
          return !1
      }
      getLastSyncId() {
          return this.syncClient.getLastSyncId()
      }
      transactionsForModel(e) {
          return this.syncClient.transactionsForModel(e)
      }
      get isBootstrapped() {
          return this.syncProgress !== GZ.initial
      }
      isModelTemporarilyPersisted(e) {
          return this.syncClient.isModelTemporarilyPersisted(e)
      }
      modelIsInTransaction(e) {
          return this.localTransactions.some(t => t.hasModel(e))
      }
      deleteForLocalTransaction(e) {
          let t = !1;
          return this.localTransactions.forEach(n => {
              (n.hasModel(e) || n.hasReferenceToModel(e)) && (n.deleteLocally(e),
              t = !0)
          }
          ),
          t
      }
      saveForLocalTransaction(e, t) {
          if (this.modelIsInTransaction(e))
              return t && this.localTransactions.filter(t => t.hasModel(e)).forEach(n => n.modelSavedLocally(e, t)),
              !0;
          let n = this.localTransactions.filter(t => t.hasReferenceToModel(e));
          return n.length ? (n.pop()?.addReferencedModel(e, t),
          !0) : !1
      }
  }
  ,
  GZ = function(e) {
      return e[e.initial = 0] = `initial`,
      e[e.syncing = 1] = `syncing`,
      e[e.stopped = 2] = `stopped`,
      e[e.ratelimited = 3] = `ratelimited`,
      e[e.bootstrapError = 4] = `bootstrapError`,
      e[e.noTeams = 5] = `noTeams`,
      e
  }({})
}
)), qZ, vde = t(( () => {
  ro(),
  Yr(),
  Ho(),
  qZ = class {
      static request(e, t) {
          let {name: n, timeout: r} = e
            , i = no();
          if (!navigator.locks?.request)
              return t().then(i.resolve).catch(i.reject),
              i;
          let a, o = Date.now(), s = !1, c = new AbortController;
          if (navigator.locks.request(n, {
              signal: c.signal
          }, async () => {
              if (s)
                  return;
              s = !0,
              a && clearInterval(a),
              Vo.distribution(`weblock.wait`, Date.now() - o, {
                  lockName: n
              });
              let e = Date.now();
              await t().then(i.resolve).catch(i.reject).finally( () => {
                  Vo.distribution(`weblock.duration`, Date.now() - e, {
                      lockName: n
                  })
              }
              )
          }
          ).catch(e => {
              s || i.reject(e)
          }
          ),
          r) {
              let e = Date.now()
                , o = 5
                , l = () => {
                  if (s) {
                      a && clearInterval(a);
                      return
                  }
                  let u = Date.now() - e;
                  u >= r() ? (s = !0,
                  clearInterval(a),
                  c.abort(),
                  t().then(i.resolve).catch(i.reject),
                  Vo.increment(`weblock.timeout`, {
                      lockName: n
                  })) : o < 100 && u > 5 * b.SECOND ? (o = 100,
                  clearInterval(a),
                  a = setInterval(l, o)) : o < 1e3 && u > 1 * b.MINUTE && (o = 1e3,
                  clearInterval(a),
                  a = setInterval(l, o))
              }
              ;
              a = setInterval(l, o)
          }
          return i
      }
  }
}
)), JZ, YZ, yde = t(( () => {
  JZ = e(ee(), 1),
  Yr(),
  ro(),
  ed(),
  TY(),
  zn(),
  Xn(),
  nm(),
  nX(),
  ai(),
  MY(),
  ws(),
  Qp(),
  Tm(),
  kZ(),
  RY(),
  N(),
  YZ = class extends tX {
      constructor(e) {
          super({
              batchInterval: 10,
              maxBatchedRequests: 500
          }),
          this.isBatchSyncRequestEntry = e => !this.isSyncGroupRequestEntry(e) && !this.isInFullRequestEntry(e),
          this.isSyncGroupRequestEntry = e => `syncGroup`in e.request,
          this.isInFullRequestEntry = e => !(`id`in e.request) && !(`indexedKey`in e.request) && !(`syncGroup`in e.request),
          this.graphQLClient = e
      }
      addRequest(e) {
          return super.addRequest(e)
      }
      async loadModelById(e, t, n) {
          let r = new OZ(this.graphQLClient,n?.includeDependent,2)
            , i = r.allProcessedResult();
          r.addRequest({
              modelName: e,
              identifier: t
          }).catch( () => {}
          );
          let a = (await i).flatMap(e => e).filter(e => em.getModelClass(e.__class));
          if (a.length)
              return this.handleLoadedModels(a, []).result[0]
      }
      setSyncClient(e, t, n) {
          this.syncClient = e,
          this.database = t,
          this.syncSubscriptionManager = n
      }
      async handleBatch(e) {
          let t = e.filter(this.isBatchSyncRequestEntry)
            , n = e.filter(this.isSyncGroupRequestEntry)
            , r = e.filter(this.isInFullRequestEntry)
            , i = await Promise.all([this.loadFullModels(r), this.loadPartialModels(n), this.loadSyncBatch(t)])
            , a = []
            , o = [];
          for (let e of i)
              a = a.concat(e.result),
              e.fullyPersisted && o.push(e.fullyPersisted);
          return {
              result: a,
              fullyPersisted: o.length ? Promise.all(o) : void 0
          }
      }
      serializeRequest(e) {
          let t = e.modelClass.modelName;
          return `id`in e ? `${t}_${wm.createPartialIndex(e).value}` : `syncGroup`in e ? `${t}_syncId_${wm.createPartialIndex(e).value}` : `indexedKey`in e ? e.coveringPartialIndexes?.length ? [`${t}_partial_${wm.createPartialIndex(e).value}`, ...e.coveringPartialIndexes.map(e => `${t}_partial_${e.value}`)] : `${t}_partial_${wm.createPartialIndex(e).value}` : `${t}_all_${wm.createPartialIndex(e).value}`
      }
      async loadSyncBatch(e) {
          if (e.length === 0)
              return {
                  result: []
              };
          let {syncSubscriptions: t} = this.parseSyncBatchSyncSubscriptions(e);
          t.length && await this.syncSubscriptionManager?.ensureSubscribed(t);
          let n = await this.graphQLClient.restModelsStream(`/sync/batch`, {
              retry: {
                  times: 2,
                  delayMs: (e, t) => t ? br(t, 0, b.SECOND) : (e + 1) * 250,
                  retryOnRatelimit: !0,
                  retryAllErrors: !0
              },
              method: `POST`,
              body: JSON.stringify({
                  firstSyncId: this.graphQLClient.getFirstSyncId(),
                  requests: e.map(e => ({
                      ...(0,
                      JZ.default)(e.request, [`id`, `indexedKey`, `keyValue`]),
                      modelName: e.request.modelClass.modelName
                  }))
              })
          })
            , r = n.syncActions || []
            , i = jY.applyDeltaSyncOnModelObjectCollection(n.models, r.reverse())
            , a = e.every(e => !!e.request.skipCreatingModelsInMemory)
            , o = e.every(e => !!e.request.skipSavingModelsInDatabase);
          return a && o && (a = !1,
          o = !1),
          this.handleLoadedModels(i, e, {
              skipCreatingModelsInMemory: a,
              skipSavingModelsInDatabase: o
          })
      }
      parseSyncBatchSyncSubscriptions(e) {
          let t = [];
          for (let n of e) {
              let e = wm.createPartialIndex(n.request).value;
              if (`id`in n.request) {
                  let r = wY.create(n.request.modelClass.modelName, e);
                  t.includes(r) || t.push(r)
              } else if (`indexedKey`in n.request) {
                  let r = wY.create(n.request.modelClass.modelName, e);
                  t.includes(r) || t.push(r)
              } else
                  y(n.request)
          }
          return {
              syncSubscriptions: t
          }
      }
      async loadPartialModels(e) {
          if (e.length === 0)
              return {
                  result: []
              };
          let t = this.syncClient
            , n = this.syncSubscriptionManager;
          if (!t || !n) {
              w.error(`Sync client or sync subscription manager not correctly set on BatchModelLoader`);
              for (let t of e)
                  t.resolve(void 0);
              return {
                  result: []
              }
          }
          let r = {};
          for (let t of e) {
              let e = t.request.modelClass.modelName;
              e && (await this.database?.hasModelsForPartialIndexes(e, [wm.createPartialIndex(t.request)]) || (r[e] = (r[e] || []).concat(t.request.syncGroup)))
          }
          let i = []
            , a = {};
          for (let[e,t] of $u(r)) {
              let n = t.join(`,`);
              if (a[n])
                  a[n].modelName.add(e);
              else {
                  let r = {
                      modelName: new Set([e]),
                      syncGroups: new Set(t)
                  };
                  i.push(r),
                  a[n] = r
              }
          }
          let o = await Promise.all(i.map(async e => {
              let t = [];
              for (let n of e.modelName)
                  for (let r of e.syncGroups) {
                      let e = em.getModelClass(n)
                        , i = wm.createPartialIndex({
                          modelClass: e,
                          syncGroup: r
                      }).value;
                      t.push(wY.create(n, i))
                  }
              return await n.ensureSubscribed(t),
              await this.database?.loadPartialModels([...e.modelName], [...e.syncGroups]).then(e => e?.data ?? []).catch(t => {
                  throw w.error(`Partial load models query error`, t, {
                      modelNames: [...e.modelName]
                  }),
                  t
              }
              )
          }
          ))
            , s = e.every(e => e.request.skipCreatingModelsInMemory === !0)
            , c = o.concrete().reduce( (e, t) => e.concat(t), []);
          return this.handleLoadedModels(c, e, {
              skipCreatingModelsInMemory: s
          })
      }
      async loadFullModels(e) {
          if (e.length === 0)
              return {
                  result: []
              };
          let t = this.syncClient
            , n = this.syncSubscriptionManager;
          if (!t || !n) {
              w.error(`Sync client or sync subscription manager not correctly set on BatchModelLoader`);
              for (let t of e)
                  t.resolve(void 0);
              return {
                  result: []
              }
          }
          let r = new Set;
          for (let t of e) {
              let e = t.request.modelClass.modelName;
              e && (await this.database?.hasModelsForPartialIndexes(e, [wm.createPartialIndex(t.request)]) || r.add(e))
          }
          let i;
          if (r.size) {
              await n.ensureSubscribed([...r].map(e => wY.create(e)));
              let e = t.getUserSyncGroups();
              e ||= (w.warning(`User sync groups not set on sync client, fetching from server`),
              await LY.fetchUserSyncGroups(this.graphQLClient)),
              i = await this.database?.loadPartialModels([...r], e).then(e => e?.data ?? []).catch(e => {
                  throw w.error(`Partial load models query error`, e, {
                      modelNames: [...r]
                  }),
                  e
              }
              )
          }
          let a = e.every(e => e.request.skipCreatingModelsInMemory === !0)
            , o = e.filter(e => e.request.onSavedToDatabase);
          return this.handleLoadedModels(i ?? [], e, {
              skipCreatingModelsInMemory: a,
              fullyLoaded: !0,
              onSavedToDatabase: o.length ? e => {
                  for (let t of o)
                      t.request.onSavedToDatabase(e)
              }
              : void 0
          })
      }
      handleLoadedModels(e, t, n) {
          if (n?.skipCreatingModelsInMemory && n?.skipSavingModelsInDatabase)
              throw Error(`Cannot skip creating models in memory and saving models in database at the same time`);
          let r = this.database
            , i = this.syncClient;
          if (!i) {
              w.error(`Sync client or database not correctly set on BatchModelLoader`);
              for (let e of t)
                  e.resolve(void 0);
              return {
                  result: []
              }
          }
          if (Jn.IS_PRODUCTION_ENV)
              w.network(`Batch loaded models`, {
                  count: e.length
              });
          else if (Jn.DEBUG_LOG_EXPAND_BATCH_LOAD) {
              let n = t.map(e => e.request.modelClass.modelName).reduce( (e, t) => Math.max(e, t.length), 0);
              w.network(`Batch loaded ${e.length} models:\n   ${t.map(e => {
                  let t = e.request.modelClass.modelName;
                  return `id`in e.request ? `${t.padEnd(n)} -> id ${e.request.id}` : `indexedKey`in e.request ? `${t.padEnd(n)} -> indexed key ${e.request.indexedKey} ${e.request.keyValue}` : `syncGroup`in e.request ? `${t.padEnd(n)} -> sync group ${e.request.syncGroup}` : ``
              }
              ).join(`
 `)}`)
          } else
              w.network(`Batch loaded ${e.length} models ${t.map(e => e.request.modelClass.modelName).distinct().join(`,`)}`, t.map(e => e.request));
          let a = no();
          r && !n?.skipSavingModelsInDatabase ? this.saveToDatabase(r, e, t, n?.fullyLoaded ?? !1).then( () => {
              this.saveToDatabaseDone(t, n),
              a.resolve()
          }
          ).catch(async r => {
              w.error(`Error persisting batch loaded models`, r, {
                  modelData: e,
                  entries: t
              }),
              this.saveToDatabaseDone(t, n, r),
              a.reject(Error(`Error persisting batch loaded models`))
          }
          ) : (this.saveToDatabaseDone(t, n),
          a.resolve());
          let o = [];
          n?.skipCreatingModelsInMemory || (o = i.createModelsFromData(e, {
              dontUpdateExistingModels: !0
          }));
          let s = {};
          for (let e of o)
              s[e.id] = e;
          for (let e of t)
              e.request.skipCreatingModelsInMemory || (`id`in e.request ? e.resolve(s[e.request.id]) : e.resolve(void 0));
          return {
              result: o,
              fullyPersisted: a.then(async () => {
                  await ri(1e3)
              }
              )
          }
      }
      async saveToDatabase(e, t, n, r) {
          if (r) {
              let r = t.groupBy(`__class`);
              for (let[t,n] of r) {
                  let r = n.map(e => {
                      let {__class: t, ...n} = e;
                      return n
                  }
                  );
                  e.setModelData(t, r)
              }
              for (let t of n) {
                  let n = t.request.modelClass.modelName;
                  r.has(n) || e.setModelData(n, [])
              }
              await ri(1);
              let i = n.map(e => e.request.modelClass.modelName);
              await e.flush({
                  modelNames: i,
                  clearStore: !1
              });
              return
          }
          await ri(1);
          let i = new Set;
          for (let e of t)
              i.add(e.__class);
          await (await e.writeTransaction({
              metaStore: !1,
              syncActionStore: !1,
              stores: [...i]
          }, e => {
              for (let n of t) {
                  let {__class: t, ...r} = n;
                  e.add(t, r)
              }
          }
          )).writeComplete,
          await Promise.all(n.map(t => {
              let n = t.request;
              return e.setPartialIndexForModel(n.modelClass.modelName, wm.createPartialIndex(n).value)
          }
          ).concrete())
      }
      saveToDatabaseDone(e, t, n) {
          for (let t of e)
              t.request.skipCreatingModelsInMemory && t.resolve(void 0);
          t?.onSavedToDatabase?.(n)
      }
  }
  ,
  M([Zp.trace(`network`)], YZ.prototype, `loadSyncBatch`, null),
  M([Zp.trace(`network`)], YZ.prototype, `handleLoadedModels`, null)
}
)), XZ, ZZ, QZ, $Z, bde = t(( () => {
  Yr(),
  ws(),
  Lq(),
  ai(),
  XZ = 5e4,
  ZZ = 30 * b.SECOND,
  QZ = 30 * b.SECOND,
  $Z = class {
      constructor(e) {
          this.organization = e,
          this.startMonitoring()
      }
      async startMonitoring() {
          for (; ; )
              await this.checkMemory() && await ri(b.SECOND),
              await ri(QZ)
      }
      async checkMemory() {
          if (this.organization.store.syncClient.modelCountInMemory(Y) > XZ) {
              let e = this.organization.accessibleTeams.map(e => ({
                  team: e,
                  lastAccessed: e.issues.lastAccessedAt
              })).filter(e => e.lastAccessed !== void 0 && !e.team.issues.isBeingAccessed);
              if (e.length === 0)
                  return;
              let t = new Date(Date.now() - ZZ), n;
              for (let r of e)
                  r.lastAccessed && r.lastAccessed < t && (t = r.lastAccessed,
                  n = r.team);
              if (n)
                  return w.remote(`Purging issues for team`, {
                      team: n.id
                  }),
                  await n.issues.deHydrate(),
                  !0
          }
          return !1
      }
  }
}
)), eQ, xde = t(( () => {
  ws(),
  nm(),
  om(),
  es(),
  cX(),
  ai(),
  eQ = class e {
      static async start(t, n, r, i) {
          if (n)
              try {
                  await new e(t,n,r,i).startPreload()
              } catch (e) {
                  (!Go(e) || !e?.message?.includes(`Error while handling cacheable bootstrap request`)) && w.warning(`Error preloading data for small workspace`, {
                      error: e
                  })
              }
      }
      constructor(e, t, n, r) {
          this.syncClient = e,
          this.organization = t,
          this.bootstrapType = n,
          this.options = r
      }
      async startPreload() {
          if (this.bootstrapType !== sX.full && this.bootstrapType !== sX.partial)
              return;
          let e = this.fullyPreloadPartialModels();
          e.length && (await ri(this.options?.delay ?? 0),
          await this.syncClient.loadPartialModels(e, void 0, {
              skipAddingToMemory: !0
          }))
      }
      fullyPreloadPartialModels() {
          let t = this.organization.approximateIssueCount
            , n = em.getModelClasses(rm.partial).filter(t => !e.NEVER_FULL_LOAD.includes(t.modelName))
            , r = [];
          for (let e of n)
              e.modelName === `Issue` || e.modelName === `Attachment` ? t < 500 && r.push(e) : e.modelName === `DocumentContent` ? t < 4e3 && r.push(e) : t < 2e4 && r.push(e);
          return r
      }
      static #e = this.NEVER_FULL_LOAD = [`Comment`, `Customer`, `Emoji`, `ExternalEntityRelation`, `IssueHistory`, `IssueImport`, `ProjectHistory`, `Webhook`]
  }
}
)), tQ, nQ, rQ, iQ = t(( () => {
  Yr(),
  ro(),
  Os(),
  ws(),
  tQ = 1.5 * b.MINUTE,
  nQ = class {
      static async startMonitor() {
          this.registered || [`/auth/`, `/connect/`].some(e => window.location.pathname.startsWith(e)) || (this.registered = !0,
          await Ds.waitUntilVisible(),
          await this.monitorForAppStuck())
      }
      static pause(e) {
          this.paused.push(e),
          e.finally( () => {
              this.paused = this.paused.filter(t => t !== e)
          }
          )
      }
      static loadingDone() {
          this.timeoutPromise.resolve()
      }
      static async monitorForAppStuck() {
          let e = 0
            , t = setInterval( () => {
              this.paused.length > 0 || (e += b.SECOND,
              e > tQ && (this.timeoutPromise.reject(Error()),
              clearInterval(t)))
          }
          , b.SECOND);
          try {
              await this.timeoutPromise,
              clearInterval(t)
          } catch {
              if (self.document.documentElement.classList.contains(`error`))
                  return;
              let e = {
                  navigationSpan: performance.getEntriesByType(`navigation`)[0],
                  measureSpans: performance.getEntriesByType(`measure`),
                  resourceSpans: performance.getEntriesByType(`resource`),
                  "client.downlink": navigator.connection?.downlink?.toString() || `unknown`,
                  timestamp: performance.now(),
                  dynamicImportChunksFailed: rQ,
                  bodyClassList: Array.from(self.document.body.classList).join(`, `)
              };
              rQ.length > 0 ? w.info(`App loading timeout (dynamic imports failed)`, e) : w.warning(`App loading timeout`, e)
          }
      }
      static #e = this.timeoutPromise = no();
      static #t = this.paused = [];
      static #n = this.registered = !1
  }
  ,
  rQ = [],
  window.addEventListener(`vite:preloadError`, e => {
      let t = e.payload;
      if (!t)
          return;
      let n = t.message.match(/https:\/\/.*\/(.*).js/)?.[1]?.split(`.`)[0] || `unknown`;
      w.info(`Failed loading dynamic import (${navigator.onLine ? `online` : `offline`})`, {
          message: t.message,
          chunk: n
      }),
      rQ.push(n)
  }
  )
}
)), aQ, oQ = t(( () => {
  aQ = function(e) {
      return e[e.none = 0] = `none`,
      e[e.network = 1] = `network`,
      e[e.all = 2] = `all`,
      e
  }({})
}
)), sQ, cQ, lQ, Sde = t(( () => {
  ir(),
  iU(),
  Lq(),
  ai(),
  ws(),
  oQ(),
  Tm(),
  es(),
  sQ = 5e4,
  cQ = 2e5,
  lQ = class e {
      static async start(t, n) {
          try {
              await new e(t,n).startStreaming()
          } catch (e) {
              Go(e) || w.warning(`Error streaming issues for all teams`, {
                  error: e
              })
          }
      }
      constructor(e, t) {
          this.syncClient = e,
          this.options = t
      }
      async startStreaming() {
          if (rr.isMobile)
              return;
          await ri(this.options?.delay ?? 500);
          let e = q.store.user
            , t = e?.organization;
          if (!t || (t.store.developerOptions?.disablePreEmptivePreloading || 0) >= aQ.network || (await q.store.waitForSync(),
          q.store.user !== e))
              return;
          let n = t.approximateIssueCount > sQ ? e.teams.elements : t.accessibleTeams.elements;
          n.sortBy(t => t.userIsMember(e) ? 0 : 1);
          let r = await Promise.all(n.map(async e => this.syncClient.hasModelsForPartialIndexes(Y.modelName, [wm.createPartialIndex({
              modelClass: Y,
              syncGroup: e.id
          })])));
          n = n.filter( (e, t) => !r[t]);
          for (let e of n)
              if (t.accessibleTeams.elements.includes(e)) {
                  if (await this.syncClient.modelCountInDatabase(Y) >= cQ)
                      return;
                  await this.syncClient.loadPartialModels(Y, e.id, {
                      skipAddingToMemory: !0
                  })
              }
      }
  }
}
)), uQ, Cde = t(( () => {
  Xt(),
  zt(),
  Vg(),
  qa(),
  ws(),
  Lq(),
  iU(),
  nm(),
  Xp(),
  uQ = class {
      constructor(e, t, n) {
          this.preloadedModelObjectsByKey = {},
          this.preloadedModelIds = new Set,
          this.preloadErrorIdsLogged = new Set,
          this.stopped = !1,
          this.hasReSynced = !1,
          this.store = e,
          this.graphQLClient = t;
          let r = Yt({
              path: Rg.issue
          }, n);
          r && r.params.issueId && this.graphQLClient.onClientReady.subscribeOnce( () => {
              let e = r.params.issueId;
              e && this.registerPreload(Y, e)
          }
          )
      }
      getLoadedData(e, t) {
          let n = this.keyForModel(e, t)
            , r = this.preloadedModelObjectsByKey[n];
          return r && delete this.preloadedModelObjectsByKey[n],
          r
      }
      async loadDataForPreBootstrapRendering(e) {
          let {rootModel: t, identifier: n, pathname: r} = e
            , i = await this.getLoadedData(t, n);
          if (this.store.isBootstrapped)
              return w.debug(`[ROU] Pre-bootstrap: Skipping preloading as store is bootstrapped`),
              null;
          if (i && i.length > 0)
              this.setupStoreForPreBootstrapRendering(i);
          else if (!this.preBootstrapModel)
              return null;
          if (t.modelName === `Issue`) {
              let e = Ka(n) ? this.store.findById(Y, n) : this.store.findIssueByIdentifier(n, {
                  includePreviousIdentifiers: !0,
                  verboseLog: !0
              });
              return e ? (this.preBootstrapModel = {
                  modelName: `Issue`,
                  id: e.id,
                  pathname: r
              },
              e) : (w.warning(`Pre-bootstrap: Issue not found in preloaded data`, {
                  identifier: n,
                  preloadedModelObjects: i?.reduce( (e, t) => (e[t.__class] || (e[t.__class] = []),
                  e[t.__class].push(t.id),
                  e), {})
              }),
              null)
          } else
              throw Error(`Unsupported root model: ${t.modelName}`)
      }
      async reSyncPreloadedModel(e) {
          if (this.preBootstrapModel) {
              let {modelName: t, id: n} = this.preBootstrapModel
                , r = {
                  modelName: t,
                  id: n,
                  error: e
              };
              this.hasReSynced ? w.info(`Pre-bootstrap: skipping additional re-sync`, r) : (this.hasReSynced = !0,
              e instanceof Error && !e.message.includes(`failed due to network error`) && w.warning(`Pre-bootstrap: re-sync after error`, r),
              await this.store.syncClient.reSyncModel(t, n))
          }
      }
      get isOnPreBootstrapRenderPath() {
          return this.preBootstrapModel?.pathname === window.location.pathname
      }
      stop() {
          this.stopped = !0,
          this.preloadedModelObjectsByKey = {},
          this.preloadedModelIds.clear(),
          this.preloadErrorIdsLogged.clear()
      }
      shouldLogPreloadError(e, t) {
          return e.modelName === `IssueHistory` || !this.preloadedModelIds.has(e.id) || this.preloadErrorIdsLogged.has(t) ? !1 : (this.preloadErrorIdsLogged.add(t),
          !0)
      }
      async preloadPageModels(e, t) {
          let n = e.modelName;
          try {
              return (await this.graphQLClient.restModelsStream(`/sync/preload_page_models?page=${n}&identifier=${t}&type=full`, {
                  retry: {
                      times: 2,
                      delayMs: e => (e + 1) * 500,
                      retryOnRatelimit: !0
                  },
                  method: `GET`
              })).models.filter(e => em.getModelClass(e.__class))
          } catch (e) {
              return w.info(`Error caught in PageDataPreloader`, {
                  error: e,
                  modelName: n,
                  identifier: t
              }),
              []
          }
      }
      keyForModel(e, t) {
          return e.modelName + `_` + t
      }
      registerPreload(e, t) {
          this.stopped || (this.preloadedModelObjectsByKey[this.keyForModel(e, t)] = Jp.create( (n, r) => {
              this.preloadPageModels(e, t).then(n, r)
          }
          ))
      }
      setupStoreForPreBootstrapRendering(e) {
          this.preBootstrapModel || (this.store.syncClient.createModelsFromData(e, {
              dontUpdateExistingModels: !0,
              dependenciesRequireLoading: e => e.isArchived
          }),
          w.debug(`[ROU] Pre-bootstrap: Preloaded ${e.length} models`),
          this.preloadedModelIds = new Set(e.map(e => e.id)),
          (!this.store.organization || this.store.user.isAnonymous) && Mt( () => {
              let e = this.store.allModelsOfType(q);
              if (e.length !== 1)
                  throw w.error(`Did not find preloaded organization`, {
                      preloadedOrganizationsLength: e.length
                  }),
                  Error(`Did not find preloaded organization`);
              let t = e[0];
              if (this.store.organization = t,
              this.store.user.isAnonymous)
                  throw Error(`User anonymous after pre-bootstrap models were applied`);
              this.store.user.organization = t,
              w.setUser(this.store.user)
          }
          ))
      }
  }
}
)), dQ, fQ, wde = t(( () => {
  zt(),
  dQ = e(te(), 1),
  Ga(),
  Yr(),
  qa(),
  Ya(),
  ir(),
  to(),
  ro(),
  vne(),
  pi(),
  Xn(),
  ho(),
  lo(),
  Os(),
  As(),
  ws(),
  Ho(),
  Lq(),
  iU(),
  tH(),
  GU(),
  qJ(),
  dx(),
  fY(),
  hY(),
  SY(),
  $ue(),
  KZ(),
  bR(),
  vde(),
  ai(),
  yde(),
  fZ(),
  ni(),
  $J(),
  Qp(),
  AY(),
  MY(),
  mx(),
  bde(),
  xde(),
  iQ(),
  es(),
  cX(),
  mH(),
  Sde(),
  Cde(),
  N(),
  fQ = class extends WZ {
      get user() {
          if (this.userId)
              if (this.safeOrganization) {
                  let e = this.findById(J, this.userId);
                  if (e)
                      return e;
                  w.info(`Store.user was not found by ID`, {
                      userId: this.userId,
                      syncProgress: this.syncProgress,
                      currentUserId: this.userId,
                      usersLength: this.allModelsOfType(J).length
                  })
              } else
                  w.info(`Store.user requested before organization was set`, {
                      userId: this.userId
                  });
          if (this.anonymousUser)
              return this.anonymousUser;
          let e = new J;
          return e.name = `Anonymous`,
          e.displayName = `Anonymous`,
          e.organization = new q,
          e.settings = new Q,
          e.isAnonymous = !0,
          this.anonymousUser = e,
          e
      }
      constructor(e) {
          Zp.createSpanFromStart(`startup`, `prelogin`),
          e ??= new lY({
              httpURL: Jn.GRAPHQL_SERVER_HTTP
          }),
          super(e, {
              requiredModels: [K, eH, J, Q, ux, q],
              batchModelLoader: new YZ(e)
          }),
          this.settings = new dX,
          this.connectivity = new mY,
          this.connectRetryCount = 0,
          this.shouldSkipBootstrap = !1,
          this.startedBootstrap = !1,
          this.freezeHandler = () => {
              if (co.isElectron) {
                  w.info(`Page is frozen`, {
                      now: performance.now(),
                      browserName: rr.browserName
                  }),
                  this.pageResumedPromise?.resolve();
                  return
              }
              this.pageResumedPromise ??= no(),
              this.startedBootstrap && (w.info(`Page is frozen, disconnecting websocket`, {
                  now: performance.now(),
                  browserName: rr.browserName
              }),
              this.disconnectWebSocket())
          }
          ,
          this.resumeHandler = async () => {
              this.pageResumedPromise?.resolve(),
              this.pageResumedPromise = void 0,
              this.syncProgress === GZ.stopped ? (w.info(`Page is resumed, reloading Linear as sync progress is stopped`, {
                  now: performance.now()
              }),
              ks.forceRefresh(`page-resumed`)) : (w.info(`Page is resumed, reconnecting websocket`, {
                  now: performance.now()
              }),
              await this.reconnectWebSocket({
                  onlyIfDisconnected: !0
              }) ? w.info(`Page is resumed, websocket reconnected`, {
                  now: performance.now()
              }) : (w.info(`Page is resumed, but could not reconnect websocket, reloading Linear`, {
                  now: performance.now()
              }),
              ks.forceRefresh(`page-resumed`)))
          }
          ,
          this.setOrganization = Ft(e => {
              this.organization = e,
              this.user.organization = e
          }
          ),
          At(this, {
              user: Bt
          }),
          Object.defineProperty(this, `organization`, {
              writable: !0,
              configurable: !0,
              value: void 0
          }),
          w.initialize(this.socket),
          this.pushNotification = new xY(this),
          this.pageDataPreloader = new uQ(this,this.graphQLClient,window.location.pathname),
          dZ.onLoadingDone.subscribeOnce( () => {
              this.pageDataPreloader.stop()
          }
          ),
          this.socket.onAuthenticationError.subscribe( () => {
              QJ || mo.logoutCurrentUserAccount(`Authentication error`)
          }
          ),
          this.socket.onConnect.subscribe( () => {
              this.setConnectionError(void 0)
          }
          ),
          this.socket.onDisconnect.subscribe(e => {
              switch (e) {
              case Wa.authenticationError:
                  mo.logoutCurrentUserAccount(`Authentication error`);
                  break;
              case Wa.ipAddrNotAllowed:
                  this.setConnectionError(new $o({
                      type: `ip addr restricted`,
                      message: `Organization access limited to specific IP ranges`,
                      userError: !0,
                      userPresentableMessage: `Workspace access is restricted and accessible only within your private network. Please contact your workspace admin for more information.`
                  }));
                  break;
              case Wa.tooManyConnections:
                  this.setConnectionError(new $o({
                      type: `ratelimited`,
                      message: `Too many opened socket connections`,
                      userError: !0,
                      userPresentableMessage: `Looks like you have too many instances of Linear app opened`
                  }));
                  break;
              case Wa.invalidBinaryMessage:
                  let e = `Invalid binary message received, reloading`;
                  w.info(e),
                  w.remote(e),
                  ks.forceRefresh(`invalid-binary-message`);
                  break;
              default:
              }
          }
          ),
          self.document.addEventListener(`freeze`, this.freezeHandler),
          self.document.addEventListener(`resume`, this.resumeHandler),
          At(this, {
              organization: Vt,
              startBootstrap: Ft
          })
      }
      async findArchivedModels(e, t, n, r, i, a, o, s) {
          let c = await this.graphQLClient.restModelsStream(`/sync/archived_models`, {
              method: `POST`,
              body: JSON.stringify({
                  modelClass: e.modelName,
                  teamId: t,
                  customerId: s,
                  issueFilter: o,
                  trashOption: n,
                  before: i,
                  beforeId: a,
                  last: r
              })
          })
            , l = jY.applyDeltaSyncOnModelObjectCollection(c.models, c.syncActions?.reverse() ?? []);
          return {
              models: this.applyArchiveResponse({
                  archive: l,
                  totalCount: c.metadata.totalCount,
                  databaseVersion: c.metadata.databaseVersion,
                  includesDependencies: c.metadata.includesDependencies
              }).filter(t => t instanceof e),
              totalCount: c.metadata.totalCount
          }
      }
      async login(e) {
          if (this.userId)
              throw Error(`Already logged into Store`);
          this.userId = e.userId,
          this.organizationId = e.organizationId,
          this.userAccountId = e.userAccountId,
          this.graphQLClient.setUser(e),
          !co.isElectron && Ds.visible === !1 && (w.debug(`Awaiting page visibility before starting bootstrap`, {
              now: performance.now()
          }),
          await Zp.trace(`startup`, `VisibilityHelper.waitUntilVisible`, async () => {
              let e = [Ds.waitUntilVisible()];
              ei.getSession(`StoreFirstLoginSuccess`) !== !0 && e.push(Ja(500 + Math.random() * 500));
              let t = Promise.race(e);
              nQ.pause(t),
              await t
          }
          ),
          w.debug(`Page visible or wait timeout exceeded, continuing bootstrap`, {
              now: performance.now()
          })),
          this.pageResumedPromise && (w.debug(`Awaiting page resume before starting bootstrap`, {
              now: performance.now()
          }),
          nQ.pause(this.pageResumedPromise),
          await this.pageResumedPromise,
          w.debug(`Page resumed, continuing bootstrap`, {
              now: performance.now()
          })),
          this.startedBootstrap = !0,
          await Zp.trace(`startup`, `Weblock.request`, async () => {
              let e = Date.now();
              await qZ.request({
                  name: `initial-bootstrap`,
                  timeout: () => Ds.visible ? 3 * b.SECOND : 2 ** 53 - 1
              }, async () => {
                  await Zp.trace(`startup`, `Weblock.request.called`, async () => {
                      kY.addStartupSpanTag(`weblock.wait`, Date.now() - e),
                      await this.startBootstrap()
                  }
                  )
              }
              )
          }
          ),
          ei.setSession(`StoreFirstLoginSuccess`, !0)
      }
      async logout() {
          this.graphQLClient?.setUser({
              userId: void 0,
              userAccountId: void 0,
              organizationId: void 0
          })
      }
      async startBootstrap() {
          try {
              if (!this.userAccountId || !this.userId || !this.organizationId)
                  throw Error(`Trying to bootstrap anonymously`);
              if (this.isBootstrapAborted)
                  throw new $a(`Bootstrap aborted`);
              let e;
              if (this.shouldSkipBootstrap) {
                  this.setSyncProgress(GZ.stopped);
                  return
              }
              if (this.setSyncProgress(GZ.initial),
              this.setSyncError(void 0),
              Vo.setSocket(this.socket),
              this.syncClient.onBootstrap.subscribeOnce(t => {
                  e = t,
                  this.updateLoadingMessage(e)
              }
              ),
              dZ.onLoadingDone.subscribeOnce(async () => {
                  this.isBootstrapAborted || !this.safeOrganization || (Zp.trace(`startup`, `Loading done`, () => {}
                  ),
                  kY.reportStartupSpans(),
                  Jn.IS_PRODUCTION_ENV && this.developerOptions?.keepTracingAfterStartupSequence !== !0 && Zp.disable(),
                  eQ.start(this.syncClient, this.safeOrganization, e, {
                      delay: 0
                  }),
                  await fx.start(this.safeOrganization, {
                      delay: 500
                  }),
                  await lQ.start(this.syncClient, {
                      delay: 5e3
                  }),
                  new $Z(this.safeOrganization))
              }
              ),
              this.isBootstrapAborted)
                  throw new $a(`Bootstrap aborted`);
              let t = await this.bootstrap({
                  userAccountId: this.userAccountId,
                  userId: this.userId,
                  organizationId: this.organizationId
              });
              if (!t.success) {
                  if (t.error && Qa.isAbortError(t.error))
                      throw t.error;
                  if (t.error && Wo(t.error, {
                      logoutOnForbidden: !1
                  }))
                      this.bootstrapAbortController.abort(),
                      await mo.logoutCurrentUserAccount(`Connect to backend failed`, t.error);
                  else if (t.error && xne(t.error))
                      this.bootstrapAbortController.abort(),
                      await mo.unsetCurrentUser(`Not allowed to access workspace`);
                  else if (t.error && Jo(t.error)) {
                      let e = di.getValue(di.bootstrapRateLimitedRetryCount, 3);
                      if (this.connectRetryCount < e)
                          return this.connectRetryCount++,
                          await ri(Math.max(t.error.metaData?.rateLimitResult?.duration || 3 * b.SECOND, 10 * b.SECOND)),
                          this.startBootstrap();
                      this.setSyncProgress(GZ.ratelimited),
                      this.setSyncError(t.error)
                  } else
                      this.bootstrapAbortController.abort(),
                      this.setSyncProgress(GZ.bootstrapError),
                      this.setSyncError(t.error);
                  this.connectRetryCount = 0;
                  return
              }
              e = t.type;
              let n = this.allModelsOfType(q);
              if (n.length !== 1)
                  throw new $o({
                      type: `bootstrap error`,
                      message: `error loading organization`,
                      userError: !1,
                      userPresentableMessage: `Unable to load the workspace model.`
                  });
              let r = n[0];
              if (this.setOrganization(r),
              await this.syncClient.processQueuedMessages(),
              this.setSyncProgress(GZ.syncing),
              this.user.isAnonymous)
                  throw new $o({
                      type: `bootstrap error`,
                      message: `error loading user`,
                      userError: !1,
                      userPresentableMessage: `Unable to load the workspace user.`
                  });
              if (w.setUser(this.user),
              this.analytics = new po(this,this.socket),
              this.pushNotification.setUser(this.user),
              co.isElectron && co.bridge.notifyBootstrapComplete(),
              r.accessibleTeams.length === 0)
                  this.setSyncProgress(GZ.noTeams);
              else if (t.type !== sX.full && !this.dataIsValid())
                  throw new $o({
                      type: `bootstrap error`,
                      message: `invalid local data`,
                      userError: !1,
                      userPresentableMessage: `Received invalid data when loading the workspace from the local disk.`
                  });
              this.connectRetryCount = 0
          } catch (e) {
              Qa.isAbortError(e) ? this.syncError || this.setSyncError(e) : (w.error(`Error bootstrapping`, e),
              this.setSyncError(e)),
              this.setSyncProgress(GZ.bootstrapError)
          }
      }
      findIssueByIdentifier(e, t={}) {
          if (!this.safeOrganization) {
              t.verboseLog && w.debug(`findIssueByIdentifier: No organization found`);
              return
          }
          if (t.matchUUID && Ka(e)) {
              let t = this.findById(Y, e);
              return t && t.team?.organization !== this.safeOrganization ? void 0 : t
          }
          let n = e.split(`-`);
          if (n.length !== 2 || !Number(n[1])) {
              t.verboseLog && w.debug(`findIssueByIdentifier: Invalid identifier`, {
                  identifierSplit: n
              });
              return
          }
          let r = this.safeOrganization.findTeamByKey(e);
          if (!r) {
              t.verboseLog && w.debug(`findIssueByIdentifier: No team found`, {
                  identifier: e,
                  availableKeys: this.safeOrganization.accessibleTeams.flatMap(e => [e.key, e.keys.map(e => e.name)])
              });
              return
          }
          let i = Number(n[1])
            , a = this.allModelsOfType(Y, yR.allModels).find(e => e.number === i && e.team === r);
          return !a && t.includePreviousIdentifiers && (a = this.allModelsOfType(Y, yR.allModels).find(t => t.previousIdentifiers.includes(e))),
          !a && t.verboseLog && w.debug(`findIssueByIdentifier: No issue found`, {
              identifier: e,
              availableIdentifiers: this.allModelsOfType(Y, yR.allModels).flatMap(e => [e.identifier, ...e.previousIdentifiers])
          }),
          a?.observePropertyChanges(),
          a
      }
      get isAuthenticatedAndBootstrapped() {
          return this.organization !== void 0 && (this.syncProgress === GZ.syncing || this.syncProgress === GZ.stopped)
      }
      skipBootstrap() {
          this.shouldSkipBootstrap = !0
      }
      async requireDeltaSyncAtStartup() {
          if (!this.userId)
              return !0;
          let e = this.findById(J, this.userId);
          return e?.isPlaceholder && await e.resolvePlaceholder().catch(dQ.default),
          !e || e.isSuspended === !0 || e.isPlaceholder === !0 || e.showOnboarding(mo.hasMultipleWorkspaces()) === !0
      }
      [Symbol.dispose]() {
          self.document.removeEventListener(`freeze`, this.freezeHandler),
          self.document.removeEventListener(`resume`, this.resumeHandler)
      }
      get safeOrganization() {
          return this.organization
      }
      dataIsValid() {
          for (let e of this.options.requiredModels || [])
              if (this.modelCountInMemory(e) === 0)
                  return !1;
          if (this.modelCountInMemory(q) !== 1) {
              let e = this.allModelsOfType(q);
              return w.error(`User has multiple stored organizations`, void 0, {
                  organizationIds: e.map(e => e.id)
              }),
              !1
          }
          return !0
      }
      updateLoadingMessage(e) {
          let t = ``;
          (e === sX.partial || e === sX.full) && (t = e === sX.partial ? `Loading your workspace` : `Setting up ${QJ ? `Linear Demo` : `your workspace`}`);
          let n = this.developerOptions?.delayBootstrap;
          if (n && (t && (t += `<br/><br />`),
          t += `Developer option: Sleeping ${n / 1e3}s before bootstraping<br/>Hit escape to cancel`),
          t) {
              self.document.body.classList.add(`loadingText`);
              let e = self.document.getElementById(`loadingText`);
              if (!e)
                  return;
              e.innerHTML = t
          }
      }
  }
  ,
  M([Zp.trace(`startup`)], fQ.prototype, `login`, null),
  M([Zp.trace(`startup`)], fQ.prototype, `startBootstrap`, null)
}
));
function pQ() {
  return mQ || (mQ = new fQ,
  qh.store = mQ),
  mQ
}
var mQ, hQ = t(( () => {
  wde(),
  F()
}
)), gQ, Tde = t(( () => {
  Pz(),
  iz(),
  mH(),
  V(),
  F(),
  om(),
  DM(),
  N(),
  gQ = class extends Yh {
      static #e = this.loadStrategy = rm.partial;
      isProjectIntegrationsSettings() {
          return !!this.project
      }
      isTeamIntegrationsSettings() {
          return !!this.team
      }
      isCustomViewIntegrationsSettings() {
          return !!this.team
      }
  }
  ,
  M([ug( () => G, `integrationsSettings`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], gQ.prototype, `project`, void 0),
  M([ug( () => W, `integrationsSettings`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], gQ.prototype, `initiative`, void 0),
  M([ug( () => K, `integrationsSettings`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], gQ.prototype, `team`, void 0),
  M([dg( () => Az, `integrationsSettings`, {
      optional: !0,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`
  })], gQ.prototype, `customView`, void 0),
  M([R()], gQ.prototype, `slackIssueAddedToView`, void 0),
  M([R()], gQ.prototype, `slackIssueNewComment`, void 0),
  M([R()], gQ.prototype, `slackIssueStatusChangedDone`, void 0),
  M([R()], gQ.prototype, `slackIssueStatusChangedAll`, void 0),
  M([R()], gQ.prototype, `slackInitiativeUpdateCreated`, void 0),
  M([R()], gQ.prototype, `slackProjectUpdateCreated`, void 0),
  M([R()], gQ.prototype, `slackProjectUpdateCreatedToTeam`, void 0),
  M([R()], gQ.prototype, `slackProjectUpdateCreatedToWorkspace`, void 0),
  M([R()], gQ.prototype, `slackIssueAddedToTriage`, void 0),
  M([R()], gQ.prototype, `slackIssueSlaHighRisk`, void 0),
  M([R()], gQ.prototype, `slackIssueSlaBreached`, void 0),
  gQ = M([mg(`IntegrationsSettings`)], gQ)
}
)), _Q, vQ = t(( () => {
  _Q = function(e) {
      return e.pending = `pending`,
      e.completed = `completed`,
      e.failed = `failed`,
      e
  }({})
}
)), yQ, Ede = t(( () => {
  vQ(),
  V(),
  Ih(),
  F(),
  om(),
  Lq(),
  N(),
  yQ = class extends qh {
      static #e = this.loadStrategy = rm.partial;
      static #t = this.partialLoadMode = im.regular
  }
  ,
  M([dg( () => Y, `summary`, {
      optional: !1,
      nullable: !1,
      indexed: !0,
      persistence: `createOnly`,
      trait: `useForPartialIndex`
  })], yQ.prototype, `issue`, void 0),
  M([R({
      serializer: Mh,
      shallowObservation: !0,
      default: {}
  })], yQ.prototype, `content`, void 0),
  M([R({
      persistence: `none`
  })], yQ.prototype, `evalLogId`, void 0),
  M([R({
      persistence: `none`,
      default: _Q.completed
  })], yQ.prototype, `generationStatus`, void 0),
  M([R({
      serializer: Ah,
      persistence: `none`,
      default: () => new Date
  })], yQ.prototype, `generatedAt`, void 0),
  yQ = M([mg(`Summary`)], yQ)
}
));
function Dde() {
  bQ.forEach(e => {
      try {
          new e
      } catch {}
  }
  )
}
var bQ, Ode = t(( () => {
  Bl(),
  JU(),
  kg(),
  jH(),
  oU(),
  AV(),
  uU(),
  XB(),
  lB(),
  Pz(),
  FB(),
  ZR(),
  WB(),
  aB(),
  sB(),
  dB(),
  bB(),
  _H(),
  PR(),
  AR(),
  _R(),
  ex(),
  NH(),
  _M(),
  KA(),
  Iy(),
  HA(),
  bH(),
  cx(),
  ox(),
  DM(),
  lj(),
  RA(),
  rB(),
  Tde(),
  Xb(),
  Lq(),
  TH(),
  QU(),
  Rj(),
  kH(),
  pq(),
  Aq(),
  rM(),
  sj(),
  sR(),
  IL(),
  FH(),
  YL(),
  iU(),
  WH(),
  KH(),
  FV(),
  iz(),
  vx(),
  hR(),
  tj(),
  UM(),
  cU(),
  $H(),
  mH(),
  tH(),
  rH(),
  gx(),
  Wz(),
  Hz(),
  GU(),
  qJ(),
  FA(),
  sH(),
  lH(),
  dH(),
  dx(),
  fR(),
  hU(),
  AM(),
  xM(),
  VR(),
  zR(),
  MV(),
  TA(),
  qk(),
  $k(),
  Uj(),
  Ij(),
  TU(),
  lM(),
  VU(),
  RU(),
  KB(),
  Sj(),
  Oj(),
  Qb(),
  XH(),
  Ede(),
  yM(),
  nU(),
  bA(),
  oM(),
  eM(),
  Zj(),
  bQ = [qU, BU, LU, Og, AH, GB, aU, Dj, xj, kV, tU, lU, YB, cB, Az, MB, XR, UB, iB, oB, uB, yB, gH, Fj, mU, NR, kR, gR, kM, $b, MH, gM, GA, Fy, VA, yH, BR, RR, jV, wU, sx, ax, W, vM, cj, LA, nB, gQ, Yb, Y, wH, ZU, Lj, OH, zl, fq, kq, nM, oj, XL, FL, PH, JL, q, UH, GH, Hj, PV, G, ej, _x, mR, dR, HM, U, Kk, yA, Qk, aM, $j, Xj, yQ, sU, bM, cM, Zb, QH, YH, K, eH, nH, hx, Uz, Vz, J, Q, NA, oH, cH, uH, ux]
}
)), xQ, SQ, CQ = t(( () => {
  ni(),
  xQ = `desktopTabs`,
  (function(e) {
      function t(e) {
          return `${xQ}:${e}`
      }
      e.getKey = t;
      function n() {
          ei.removeAllWithCondition(e => e.startsWith(xQ))
      }
      e.clearAll = n
  }
  )(SQ ||= {})
}
)), wQ, TQ, EQ, DQ, OQ = t(( () => {
  zt(),
  ni(),
  wQ = `recencyRegistry`,
  TQ = 5,
  EQ = {
      Issue: TQ * 4,
      Project: TQ * 2,
      Document: TQ * 2,
      IssueLabel: TQ * 2,
      CustomView: TQ * 2,
      Dashboard: TQ * 2,
      Initiative: TQ,
      Cycle: TQ,
      User: TQ,
      AiConversation: TQ * 2,
      PullRequest: TQ * 2,
      search: TQ * 2,
      aiPanelPrompt: TQ * 2
  },
  DQ = class {
      constructor(e) {
          this.user = e,
          this.recentItems = {},
          this.recentItems = ei.get(this.localStorageKey) || {},
          At(this, {
              recentItems: Vt.deep,
              track: Ft,
              clear: Ft,
              clearOfType: Ft,
              deleteRecordOfType: Ft
          })
      }
      trackModel(e) {
          this.track(e.modelName, e.id)
      }
      track(e, t) {
          let n = (this.recentItems[e] || []).concat([])
            , r = n.findIndex(e => e.id === t)
            , i = r > -1 ? n[r] : {
              id: t,
              n: 0
          };
          r > -1 && n.splice(r, 1),
          i.n += 1,
          i.lastViewedTimestamp = Date.now(),
          n.unshift(i);
          let a = this.maxRecentPerType(e);
          n.length > a && n.splice(0, a),
          this.recentItems[e] = n,
          ei.set(this.localStorageKey, this.recentItems)
      }
      scores(e) {
          let t = this.recentOfModel(e)
            , n = this.maxRecentPerType(e.modelName);
          return t.map( (e, t) => ({
              id: e.id,
              score: (n - t + e.n) * .1
          })).sortBy(e => -e.score)
      }
      score(e) {
          let t = this.scores(e.constructor).find(t => t.id === e.id);
          return t ? t.score : 0
      }
      recentOfModel(e) {
          let t = e.modelName;
          return t ? this.recent(t) : []
      }
      recent(e) {
          return this.recentItems[e] || []
      }
      getRecentByTime(e, t, n=[]) {
          let r = this.recent(e)
            , i = Date.now();
          return r.filter(e => e.lastViewedTimestamp && i - e.lastViewedTimestamp < t && !n.includes(e.id)).sort( (e, t) => (t.lastViewedTimestamp ?? 0) - (e.lastViewedTimestamp ?? 0))
      }
      clear() {
          this.recentItems = {},
          ei.remove(this.localStorageKey)
      }
      static clearAll() {
          ei.removeAllWithCondition(e => e.startsWith(wQ))
      }
      clearOfType(e) {
          this.recentItems[e] && (this.recentItems[e] = [],
          ei.set(this.localStorageKey, this.recentItems))
      }
      deleteRecordOfType(e, t) {
          this.deleteItem(e, t)
      }
      get localStorageKey() {
          return `${wQ}:${this.user.id}`
      }
      maxRecentPerType(e) {
          return EQ[e] || TQ
      }
      deleteItem(e, t) {
          if (this.recentItems[e] && this.recentItems[e].length > 0) {
              let n = this.recentItems[e].findIndex(e => e.id === t);
              n !== -1 && (this.recentItems[e].splice(n, 1),
              ei.set(this.localStorageKey, this.recentItems))
          }
      }
  }
}
));
function kde(e) {
  mo.register(e.applicationStore),
  ks.register(e.refreshManager),
  co.register(e.electron),
  Ds.register(e.visibilityHelper),
  Xl.register(e.alertDialog),
  oy.register(e.toast),
  oA.register(e.diffComputer),
  Dde()
}
function Ade(e) {
  Wy.register(e)
}
async function jde(e) {
  await pQ().login(e)
}
async function Mde() {
  await pQ().logout()
}
async function Nde() {
  let e = (await kt( () => import(`./LocalDraftIssueCreate.CYOv6Dpa.js`), __vite__mapDeps([7, 8, 9, 4]), import.meta.url).catch( () => {}
  ))?.LocalDraftIssueCreate
    , t = pQ()
    , n = t.organization ? t.user : void 0;
  n?.settings?.clearAll(),
  fi.clearAll(n?.isSuperuser || !1),
  e?.clearAll(),
  SQ.clearAll(),
  DQ.clearAll()
}
var kQ = t(( () => {
  pi(),
  hQ(),
  ho(),
  Os(),
  Zl(),
  lo(),
  As(),
  Gy(),
  sy(),
  Ode(),
  sA(),
  CQ(),
  OQ(),
  Ot()
}
)), AQ, jQ = t(( () => {
  ws(),
  Es(),
  AQ = class {
      static get onVisible() {
          return this.init(),
          this._onVisible
      }
      static get onHide() {
          return this.init(),
          this._onHide
      }
      static get visible() {
          return self.document.visibilityState === `visible`
      }
      static get hasBeenHiddenDuringSession() {
          return this._hasBeenHiddenDuringSession
      }
      static waitUntilVisible() {
          return new Promise(e => {
              if (this.visible)
                  return e();
              this.onVisible.subscribeOnce(e)
          }
          )
      }
      static init() {
          this.initialized || (this.initialized = !0,
          self.document.addEventListener(`visibilitychange`, () => {
              this.visible ? (this._onVisible.fire(),
              w.debug(`Application visibility: visible`)) : (this._hasBeenHiddenDuringSession = !0,
              this._onHide.fire(),
              w.debug(`Application visibility: hidden`))
          }
          ))
      }
      static #e = this.initialized = !1;
      static #t = this._onVisible = new Ts;
      static #n = this._onHide = new Ts({
          maxObservers: 100
      });
      static #r = this._hasBeenHiddenDuringSession = !this.visible
  }
}
)), MQ, NQ, PQ, FQ = t(( () => {
  Yr(),
  _X(),
  ws(),
  $J(),
  jQ(),
  MQ = class {
      static refreshWhenReady(e, t, n=b.SECOND) {
          let r = this._tryImmediateRefresh(e, t, n);
          return r.length > 0 ? (w.info(`A refresh was blocked and scheduled for later`, {
              level: e,
              reasons: r
          }),
          this.requested[e] === void 0 && (this.requested[e] = t),
          !1) : !0
      }
      static tryImmediateRefresh(e, t, n=b.SECOND) {
          let r = this._tryImmediateRefresh(e, t, n);
          return r.length > 0 ? (w.info(`An immediate refresh was blocked`, {
              level: e,
              reasons: r
          }),
          !1) : !0
      }
      static forceRefresh(e, t=0) {
          this._refresh(`forced`, e, t)
      }
      static blockRefresh(e, t) {
          let n = this.idCounter++;
          this.blocked[e].push([n, t]);
          let r = () => {
              let t = this.blocked[e].findIndex(e => e[0] === n);
              t >= 0 && (this.blocked[e].splice(t, 1),
              this.trigger())
          }
          ;
          return () => {
              setTimeout(r, 500)
          }
      }
      static initAutoRefresh() {
          if (this.autoRefreshInitialized)
              return;
          this.autoRefreshInitialized = !0;
          let e = AQ.visible
            , t = t => {
              e = t,
              a = 0
          }
            , n = AQ.visible ? this.blockRefresh(hX.background, `visible`) : void 0;
          AQ.onVisible.subscribe( () => {
              t(!0),
              n ??= this.blockRefresh(hX.background, `visible`)
          }
          ),
          AQ.onHide.subscribe( () => {
              t(!1),
              n?.(),
              n = void 0
          }
          ),
          window.addEventListener(`focus`, () => t(!0), !1),
          window.addEventListener(`blur`, () => t(!1), !1);
          let r;
          window.addEventListener(`online`, () => {
              r?.(),
              r = void 0
          }
          , !1),
          window.addEventListener(`offline`, () => {
              r ??= this.blockRefresh(hX.important, `offline`)
          }
          , !1);
          let i = 0
            , a = 0
            , o = b.MINUTE;
          setInterval( () => {
              i += o,
              e || (a += o),
              i > NQ && a > PQ && this.tryImmediateRefresh(hX.background, `stale-client`, b.SECOND)
          }
          , o)
      }
      static #e = this.autoRefreshInitialized = !1;
      static #t = this.refreshing = !1;
      static #n = this.idCounter = 0;
      static #r = this.blocked = {
          [hX.background]: [],
          [hX.normal]: [],
          [hX.important]: []
      };
      static #i = this.requested = {
          [hX.background]: void 0,
          [hX.normal]: void 0,
          [hX.important]: void 0
      };
      static trigger() {
          for (let e = gX.length - 1; e >= 0; --e) {
              let t = gX[e]
                , n = this.requested[t];
              if (n !== void 0) {
                  this._tryImmediateRefresh(t, n, b.SECOND);
                  return
              }
          }
      }
      static _tryImmediateRefresh(e, t, n) {
          if (QJ)
              return [`demo`];
          let r = [];
          for (let t = gX.indexOf(e); t < gX.length; ++t)
              r.push(...this.blocked[gX[t]].map(e => e[1]));
          return r.length === 0 && this._refresh(e, t, n),
          r
      }
      static _refresh(e, t, n) {
          this.refreshing || (this.refreshing = !0,
          w.info(`RefreshManager reloading the page`, {
              level: e,
              delay: n,
              reason: t
          }),
          w.persistBreadcrumbs(),
          setTimeout( () => window.location.reload(), Math.max(0, n)))
      }
  }
  ,
  NQ = 24 * b.HOUR,
  PQ = 15 * b.MINUTE
}
)), IQ, LQ, RQ = t(( () => {
  IQ = e(En()),
  c$(),
  LQ = () => !(!s$.isElectron || typeof s$.bridge.version != `string` || !(0,
  IQ.default)(s$.bridge.version, `1.18.0`))
}
));
function Pde() {
  let[e,t] = BQ.useState(s$.isFullScreen())
    , n = BQ.useCallback( () => t(!0), [])
    , r = BQ.useCallback( () => t(!1), []);
  return BQ.useEffect( () => (QQ.subscribe(n),
  $Q.subscribe(r),
  () => {
      QQ.unsubscribe(n),
      $Q.unsubscribe(r)
  }
  ), []),
  e
}
function zQ(e) {
  if (tr) {
      let t = s$.bridge.version;
      if (typeof t == `string` && rr.isMac) {
          let n = 11;
          return e && (n = e.marginTop + Math.floor((e.height - 16) / 2)),
          (0,
          HQ.default)(t, `1.18.0`) ? {
              x: 17,
              y: n,
              contentHeaderHeight: 57
          } : (0,
          HQ.default)(t, `1.14.0`) ? {
              x: 14,
              y: 18,
              contentHeaderHeight: 53
          } : {
              x: 12,
              y: 16,
              contentHeaderHeight: 49
          }
      }
  }
}
var BQ, VQ, HQ, UQ, WQ, GQ, KQ, qQ, JQ, YQ, XQ, ZQ, QQ, $Q, e$, t$, n$, r$, i$, a$, o$, s$, c$ = t(( () => {
  BQ = e(ht()),
  VQ = e(hte()),
  HQ = e(En()),
  zt(),
  ir(),
  nr(),
  Es(),
  pi(),
  ws(),
  RQ(),
  UQ = new Ts,
  WQ = new Ts,
  GQ = new Ts,
  KQ = new Ts,
  qQ = new Ts,
  JQ = new Ts,
  YQ = new Ts,
  XQ = new Ts,
  ZQ = new Ts,
  QQ = new Ts,
  $Q = new Ts,
  e$ = new Ts,
  t$ = new Ts,
  n$ = new Ts,
  r$ = new Ts,
  i$ = new Ts,
  a$ = new Ts,
  o$ = class {
      constructor({x: e, y: t, contentHeaderHeight: n}) {
          this.x = 0,
          this.y = 0,
          this.contentHeaderHeight = 0,
          this.x = e,
          this.y = t,
          this.contentHeaderHeight = n,
          Nt(this)
      }
  }
  ,
  s$ = class e {
      static #e = this.isElectron = tr;
      static initialize() {
          if (e.isElectron) {
              e.bridge.onDesktopRedirect( (e, t) => UQ.fire({
                  route: e,
                  forceSameTab: t
              })),
              e.bridge.onNewIssue( () => GQ.fire()),
              e.bridge.onNewProject( () => KQ.fire()),
              e.bridge.onNewTab(e => YQ.fire(e)),
              e.bridge.onOpenPreferences( () => qQ.fire()),
              e.bridge.onSetAlwaysShowTabBar(e => JQ.fire(e)),
              e.bridge.onContactForm(e => XQ.fire(e)),
              e.bridge.onHelpCenter(e => ZQ.fire(e)),
              e.bridge.onCheckUrl(async (e, t, n) => !!WQ.fire({
                  url: e,
                  userId: t,
                  open: n ?? !1
              })[0]),
              e.bridge.onEnterFullScreen( () => QQ.fire()),
              e.bridge.onLeaveFullScreen( () => $Q.fire()),
              e.bridge.onQuitRequested( () => e$.fire()),
              e.bridge.onCloseTabRequested( () => t$.fire()),
              e.bridge.onCloseWindowRequested( () => n$.fire()),
              e.bridge.onReloadRequested( () => r$.fire()),
              e.bridge.onDownloadComplete(e => i$.fire(e)),
              e.bridge.onUpdateAvailable( (e, t) => a$.fire({
                  version: e,
                  isUserInitiated: t
              })),
              e.bridge.onCheckFlagOrConfig(async (e, t) => {
                  let {defaultValue: n, type: r} = t;
                  if (r === `featureFlag`) {
                      let {value: t} = await fi.waitForFlagOrConfig(e, {
                          type: `featureFlag`
                      });
                      return w.info(`Returning feature flag value`, {
                          name: e,
                          flagValue: t
                      }),
                      t
                  } else {
                      let {value: t} = await fi.waitForFlagOrConfig(e, {
                          defaultValue: n,
                          type: `dynamicConfig`
                      });
                      return w.info(`Returning dynamic config value`, {
                          name: e,
                          configValue: t
                      }),
                      t
                  }
              }
              );
              let t = zQ();
              this.trafficLightPosition = t ? new o$({
                  x: t.x,
                  y: t.y,
                  contentHeaderHeight: t.contentHeaderHeight
              }) : void 0
          }
      }
      static installUpdate() {
          e.bridge.installUpdate()
      }
      static transparentSidebarAvailable() {
          return e.isElectron && rr.isMac && typeof e.bridge.version == `string` && (0,
          VQ.default)(e.bridge.version, `1.5.3`)
      }
      static isFullScreen() {
          return e.isElectron && (e.bridge.isFullScreen() ?? !1)
      }
      static get hasNewDesktopQuitCloseRefreshBehaviour() {
          return e.isElectron && `onQuitRequested`in e.bridge
      }
      static #t = this.bridge = new Proxy(window.ElectronBridge || {},{
          get(e, t) {
              return t in e ? e[t] : () => {}
          }
      });
      static updateTrafficLightPosition(t) {
          if (typeof e.bridge.version == `string` && (0,
          HQ.default)(e.bridge.version, `1.24.0`)) {
              let n = zQ(t?.topContainerSize);
              n && (Mt( () => {
                  this.trafficLightPosition ? (this.trafficLightPosition.x = n.x,
                  this.trafficLightPosition.y = n.y,
                  this.trafficLightPosition.contentHeaderHeight = n.contentHeaderHeight) : this.trafficLightPosition = new o$({
                      x: n.x,
                      y: n.y,
                      contentHeaderHeight: n.contentHeaderHeight
                  })
              }
              ),
              e.bridge.updateTrafficLightPosition({
                  x: n.x,
                  y: n.y
              }))
          }
      }
  }
  ,
  s$.initialize()
}
)), l$, u$ = t(( () => {
  l$ = {
      small: 420,
      default: 480,
      medium: 562,
      large: 700,
      xlarge: 860,
      xxlarge: 1020
  }
}
)), d$, f$ = t(( () => {
  ws(),
  Es(),
  u$(),
  d$ = class e {
      static show(t, n) {
          return e.onBeforeShow.fire(),
          new Promise(r => {
              let i = {
                  content: t,
                  resolve: r,
                  originalOnResult: t.props.onResult,
                  options: n,
                  key: e.key++
              };
              e.presentDialog ? e.presentDialog(i) : (w.error(`Tried to show a dialog before DialogPresenter was mounted`),
              r(void 0))
          }
          )
      }
      static #e = this.onBeforeShow = new Ts;
      static #t = this.widths = l$;
      static #n = this.key = 0
  }
}
));
function p$(e) {
  return t => {
      e.forEach(e => {
          typeof e == `function` ? e(t) : e != null && (e.current = t)
      }
      )
  }
}
var m$ = t(( () => {}
)), h$, g$, _$, v$ = t(( () => {
  h$ = e(ht()),
  m$(),
  Fg(),
  ws(),
  g$ = 9e3,
  _$ = class {
      static protectedLoadable(e, t) {
          let n, r;
          function i() {
              if (n)
                  return n;
              let i = e().then(e => (r = t.resolveComponent(e),
              {
                  default: r
              })).catch(e => {
                  throw e
              }
              );
              return n = i,
              i
          }
          let a = h$.lazy(i)
            , o = h$.forwardRef(function(e, n) {
              let i = h$.useRef(r ?? a)
                , o = h$.useRef(null)
                , s = p$([n, o]);
              return h$.useEffect( () => {
                  if (t.fadeIn) {
                      if (t.fadeIn && !o.current) {
                          w.warning(`[ComponentLoader] If you want to fade in the lazy-loaded component, it must be wrapped in forwardRef and assign that ref to the container you want to fade.`);
                          return
                      }
                      o.current.classList.add(`suspenseFadeIn`)
                  }
              }
              , []),
              h$.createElement(i.current, t.fadeIn ? {
                  ...e,
                  ref: s
              } : n ? {
                  ...e,
                  ref: n
              } : e)
          })
            , s = e.toString();
          if (s = s.match(/\/(([^\/]+\/)?[^\/]+)\.(tsx?|js)/)?.[1] ?? s,
          t.loadAtStartupForPath) {
              let e = Array.isArray(t.loadAtStartupForPath) ? t.loadAtStartupForPath : [{
                  path: t.loadAtStartupForPath
              }];
              for (let t of e)
                  this.componentsToLoadBasedOnURL[t.path] || (this.componentsToLoadBasedOnURL[t.path] = []),
                  this.componentsToLoadBasedOnURL[t.path].push({
                      name: s,
                      preload: i,
                      exact: t.exact
                  })
          }
          if (t.preloadOrder !== `skip`) {
              let e = t.preloadOrder === `last` ? g$ : t.preloadOrder;
              e = e > g$ ? g$ : e,
              this.componentsToLoadAtStartup[e] || (this.componentsToLoadAtStartup[e] = []),
              this.componentsToLoadAtStartup[e].push({
                  preload: i,
                  name: s
              })
          }
          return o.preload = i,
          o
      }
      static async preloadComponentsForPath(e) {
          let t = [];
          for (let n in this.componentsToLoadBasedOnURL)
              try {
                  if (Pg({
                      path: n,
                      end: !1
                  }, e))
                      for (let r of this.componentsToLoadBasedOnURL[n])
                          (!r.exact || Pg({
                              path: n,
                              end: !0
                          }, e)) && t.push(r)
              } catch {}
          for (let e of t) {
              if (navigator.onLine === !1) {
                  w.info(`Skipping preloading path loadable as client is offline`);
                  return
              }
              let {name: t, preload: n} = e;
              try {
                  let e = performance.now();
                  await n(),
                  w.verbose( () => ({
                      message: `Preloaded path loadable`,
                      metaData: {
                          name: t,
                          duration: Math.round(performance.now() - e)
                      }
                  }))
              } catch (e) {
                  w.info(`Failed preloading path loadable`, {
                      name: t,
                      error: e
                  })
              }
          }
      }
      static getComponentsToLoadAtStartup() {
          return this.componentsToLoadAtStartup
      }
      static #e = this.componentsToLoadBasedOnURL = {};
      static #t = this.componentsToLoadAtStartup = {}
  }
}
)), y$, b$, x$, S$, C$ = t(( () => {
  ht(),
  f$(),
  v$(),
  y$ = e(f()),
  Ot(),
  b$ = function(e) {
      return e.confirm = `confirm`,
      e.cancel = `cancel`,
      e.reject = `reject`,
      e
  }({}),
  x$ = class {
      constructor(e) {
          this.props = {
              confirmButtonType: `primary`,
              showCancelButton: !0,
              ...e,
              onResult: () => {}
          }
      }
      show() {
          return new Promise(e => {
              let t = ``
                , n = e => `[data-type="${e}"]`;
              this.props.confirmPromptText && (t = n(`confirmPromptText`)),
              t ||= n(b$.confirm),
              d$.show((0,
              y$.jsx)(S$, {
                  ...this.props
              }), {
                  focusTrapOptions: {
                      initialFocus: t,
                      delayInitialFocus: !0
                  },
                  width: this.props.width
              }).then(t => {
                  e(t === void 0 ? b$.cancel : t)
              }
              )
          }
          )
      }
  }
  ,
  S$ = _$.protectedLoadable( () => kt( () => import(`./ConfirmationDialog.IE4b0J8q.js`), __vite__mapDeps([10, 11, 3, 4, 5, 6]), import.meta.url), {
      preloadOrder: 10,
      resolveComponent: e => e.ConfirmationDialogShouldBeLazyLoaded
  })
}
)), w$, T$ = t(( () => {
  w$ = class {
      static reactNodeToString(e, t=``) {
          if (!e)
              return ``;
          if (typeof e == `string`)
              return e;
          if (typeof e == `number`)
              return e.toString();
          if (Array.isArray(e))
              return e.map(e => this.reactNodeToString(e)).join(t);
          let n = e.props;
          return n && n.children ? this.reactNodeToString(n.children, t) : ``
      }
  }
}
)), E$ = t(( () => {
  bte()
}
));
function Fde(e) {
  let t = A$(e);
  return window.matchMedia(t).matches
}
var D$, O$, k$, A$, j$, M$, N$ = t(( () => {
  E$(),
  D$ = function(e) {
      return e.phone = `phone`,
      e.tablet = `tablet`,
      e.laptop = `laptop`,
      e.normal = `normal`,
      e.large = `large`,
      e.xlarge = `xlarge`,
      e
  }({}),
  O$ = {
      phone: 640,
      tablet: 768,
      laptop: 1024,
      normal: 1025,
      large: 1400,
      xlarge: 1800
  },
  k$ = D$.laptop,
  A$ = e => {
      switch (e) {
      case D$.phone:
          return `(max-width: ${O$.phone}px)`;
      case D$.tablet:
          return `(max-width: ${O$.tablet}px)`;
      case D$.laptop:
          return `(max-width: ${O$.laptop}px)`;
      case D$.large:
          return `(min-width: ${O$.large}px)`;
      case D$.xlarge:
          return `(min-width: ${O$.xlarge}px)`;
      default:
          return `(min-width: ${O$.normal}px)`
      }
  }
  ,
  j$ = e => yte(A$(e)),
  M$ = () => {
      let e = j$(D$.phone)
        , t = j$(D$.tablet)
        , n = j$(D$.laptop)
        , r = j$(D$.large)
        , i = j$(D$.xlarge);
      return e ? D$.phone : t ? D$.tablet : n ? D$.laptop : i ? D$.xlarge : r ? D$.large : D$.normal
  }
}
)), P$, F$ = t(( () => {
  P$ = () => typeof window > `u` || window.CSS === void 0 ? `RGB` : window.CSS.supports(`color`, `lch(0% 0 0)`) ? `LCH` : window.CSS.supports(`color`, `color(display-p3 0 0 0)`) ? `P3` : `RGB`
}
));
function I$(e) {
  return parseFloat(e.toFixed(3))
}
function L$(e) {
  return e >= B$ ? e : e + (B$ - e) ** V$
}
function R$(e, t, n) {
  return Math.max(t, Math.min(n, e))
}
var z$, B$, V$, H$ = t(( () => {
  F$(),
  (function(e) {
      let t = e.HEX_REGEX_LOOSE = /#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?/i
        , n = e.HEX_REGEX = RegExp(`^${t.source}$`, `i`)
        , r = e.HEX_REGEX_SMALL_LOOSE = /#?([a-f\d])([a-f\d])([a-f\d])/i
        , i = e.HEX_REGEX_SMALL = RegExp(`^${r.source}$`, `i`)
        , a = e.HEX_REGEX_STRICT = /^#([a-f\d]{6}|[a-f\d]{3})$/i
        , o = e.LCH_REGEX_LOOSE = /lch\((\d{1,3}(?:\.\d+)?)\% (\d{1,3}(?:\.\d+)?) (\d{1,3}(?:\.\d+)?)(?: \/ ([1|0](?:\.\d+)?)?)?\)/i
        , s = e.LCH_REGEX = RegExp(`^${o.source}$`, `i`)
        , c = e.P3_REGEX_LOOSE = /color\(display-p3 (\d{1,3}(?:\.\d+)?)\ (\d{1,3}(?:\.\d+)?) (\d{1,3}(?:\.\d+)?)\)/i
        , l = e.P3_REGEX = RegExp(`^${c.source}$`, `i`)
        , u = e.ANY_COLOR_REGEX_LOOSE = RegExp(`(?:${t.source})|(?:${o.source})|(?:${c.source})`, `i`)
        , d = e.ANY_COLOR_REGEX = RegExp(`^${u.source}$`, `i`)
        , f = [.3457 / .3585, 1, .2958 / .3585];
      function p(e, [t,n,r,i]) {
          return e === `LCH` ? `lch(${I$(t)}% ${I$(n)} ${I$(r)}${i === void 0 ? `` : ` / ` + I$(i)})` : e === `P3` ? de([t, n, r, i]) : se([t, n, r, i])
      }
      e.toCss = p;
      function m(e) {
          let t = n.exec(e);
          if (t ?? (t = i.exec(e),
          t && (t[1] += t[1],
          t[2] += t[2],
          t[3] += t[3])),
          t) {
              let e = z$.rgbToLch([parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)]);
              return t[4] && !/ff/i.test(t[4]) && (e[3] = parseInt(t[4], 16) / 255),
              e
          } else {
              let t = s.exec(e);
              if (t) {
                  let e = [parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3])];
                  return t[4] && t[4] !== `1` && (e[3] = parseFloat(t[4])),
                  e
              } else {
                  let t = l.exec(e);
                  if (t)
                      return me([parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3])])
              }
          }
          return [0, 0, 0]
      }
      e.fromCss = m;
      function h(e, t, n) {
          return z$.toCss(n ?? P$(), z$.adjustTo(z$.fromCss(e), {
              a: t
          }))
      }
      e.cssWithAlpha = h;
      function g(e) {
          let[t,n,r] = e;
          return [t - n * .075 > 65 ? 0 : 100, Math.min(n / 2, n), r]
      }
      e.getTextColor = g;
      function _(e, t) {
          let[n,r,i] = Oe(e)
            , [a,o,s] = Oe(t)
            , c = Math.sqrt(r * r + i * i)
            , l = Math.sqrt(o * o + s * s)
            , u = n < 16 ? .511 : .040975 * n / (1 + .01765 * n)
            , d = .0638 * c / (1 + .0131 * c) + .638
            , f = c < 1e-6 ? 0 : Math.atan2(i, r) * 180 / Math.PI;
          for (; f < 0; )
              f += 360;
          for (; f >= 360; )
              f -= 360;
          let p = f >= 164 && f <= 345 ? .56 + Math.abs(.2 * Math.cos(Math.PI * (f + 168) / 180)) : .36 + Math.abs(.4 * Math.cos(Math.PI * (f + 35) / 180))
            , m = c * c * c * c
            , h = Math.sqrt(m / (m + 1900))
            , g = d * (h * p + 1 - h)
            , _ = n - a
            , ee = c - l
            , te = r - o
            , ne = i - s
            , re = te * te + ne * ne - ee * ee
            , ie = _ / (1 * u)
            , ae = ee / (3 * d)
            , oe = g;
          return Math.sqrt(ie * ie + ae * ae + re / (oe * oe))
      }
      e.deltaE = _;
      function ee(e, t) {
          let n = .027, r = e[0] / 100, i = t[0] / 100, a, o, s, c = L$(r), l = L$(i), u = l > c;
          return Math.abs(l - c) < 5e-4 ? o = 0 : u ? (a = l ** .56 - c ** .57,
          o = a * 1.14) : (a = l ** .65 - c ** .62,
          o = a * 1.14),
          s = Math.abs(o) < .1 ? 0 : o > 0 ? o - n : o + n,
          Math.abs(s * 100)
      }
      e.apcaContrast = ee;
      function te(e, t, n=38) {
          return ee(e, t) > n
      }
      e.sufficientContrastForText = te;
      function ne(e) {
          return e[0] > 50
      }
      e.isBright = ne;
      function re(e, t) {
          let[n,r,i,a=1] = e;
          return [R$(n + (t.l ?? 0), 0, 100), R$(r + (t.c ?? 0), 0, 132), R$(i + (t.h ?? 0), 0, 360), R$(a + (t.a ?? 0), 0, 1)]
      }
      e.adjust = re;
      function ie(e, t) {
          let[n,r,i,a=1] = e;
          return [R$(t.l ?? n, 0, 100), R$(t.c ?? r, 0, 132), R$(t.h ?? i, 0, 360), R$(t.a ?? a, 0, 1)]
      }
      e.adjustTo = ie;
      function ae(e, t, n) {
          let r = e[3] ?? 1
            , i = t[3] ?? 1
            , [a,o,s] = Ee(Oe(e))
            , [c,l,u] = Ee(Oe(t))
            , [d,f,p] = De(Te([a * (1 - n) + n * c, o * (1 - n) + n * l, s * (1 - n) + n * u]));
          return [R$(d, 0, 100), R$(f, 0, 132), R$(p, 0, 360), (r + i) / 2]
      }
      e.mix = ae;
      function oe(e, t, n) {
          return z$.toCss(P$(), z$.mix(z$.fromCss(e), z$.fromCss(t), n))
      }
      e.mixCss = oe;
      function se(e) {
          let t = he(e).map(e => e.toString(16).split(`.`)[0]).map(e => e.length === 1 ? `0` + e : e)
            , n = e[3] !== void 0 && e[3] !== 1 ? ce((e[3] * 255).toString(16).split(`.`)[0]) : ``;
          return `#${t[0]}${t[1]}${t[2]}${n}`
      }
      e.lchToRgbString = se;
      function ce(e) {
          return e.length === 1 ? `0` + e : e
      }
      function le(e, n) {
          switch (n.format) {
          case `hex`:
              switch (n.level) {
              case `loose`:
                  return t.test(e);
              case `small`:
                  return i.test(e);
              default:
                  return a.test(e)
              }
          case `p3`:
              return l.test(e);
          case `lch`:
              return s.test(e);
          default:
              return d.test(e)
          }
      }
      e.isValidColor = le;
      function ue(e) {
          return n.test(e) ? e : se(m(e))
      }
      e.cssToRgb = ue;
      function de(e) {
          let t = fe(e);
          return `color(display-p3 ${t[0]} ${t[1]} ${t[2]}${e[3] === void 0 ? `` : ` / ${e[3].toString(10)}`})`
      }
      function fe(e) {
          return Se(Ce(Ee(Oe(e)))).map(_e).map(e => R$(e, 0, 1))
      }
      function pe(e) {
          return De(Te(we(ye(Ae(e)))))
      }
      e.rgbToLch = pe;
      function me(e) {
          return De(Te(we(be(Ae(e)))))
      }
      function he(e) {
          return v(Oe(e))
      }
      function ge([[e,t,n],[r,i,a],[o,s,c]], [l,u,d]) {
          return [e * l + t * u + n * d, r * l + i * u + a * d, o * l + s * u + c * d]
      }
      let v = e => e[0] === 100 && e[1] === 0 && e[2] === 0 ? [255, 255, 255] : ve(xe(Ce(Ee(e)))).map(e => R$(e, 0, 255));
      function _e(e) {
          let t = e < 0 ? -1 : 1
            , n = Math.abs(e);
          return n > .0031308 ? t * (1.055 * n ** (1 / 2.4) - .055) : 12.92 * e
      }
      function ve(e) {
          return e.map(e => 255 * _e(e))
      }
      function ye(e) {
          return ge([[.41239079926595934, .357584339383878, .1804807884018343], [.21263900587151027, .715168678767756, .07219231536073371], [.01933081871559182, .11919477979462598, .9505321522496607]], e)
      }
      function be(e) {
          return ge([[.4865709486482162, .26566769316909306, .1982172852343625], [.2289745640697488, .6917385218365064, .079286914093745], [0, .04511338185890264, 1.043944368900976]], e)
      }
      function xe(e) {
          return ge([[3.2409699419045226, -1.537383177570094, -.4986107602930034], [-.9692436362808796, 1.8759675015077202, .04155505740717559], [.05563007969699366, -.20397695888897652, 1.0569715142428786]], e)
      }
      function Se(e) {
          return ge([[2.493496911941425, -.9313836179191239, -.40271078445071684], [-.8294889695615747, 1.7626640603183463, .023624685841943577], [.03584583024378447, -.07617238926804182, .9568845240076872]], e)
      }
      function Ce(e) {
          return ge([[.9554734527042182, -.023098536874261423, .0632593086610217], [-.028369706963208136, 1.0099954580058226, .021041398966943008], [.012314001688319899, -.020507696433477912, 1.3303659366080753]], e)
      }
      function we(e) {
          return ge([[1.0479298208405488, .022946793341019088, -.05019222954313557], [.029627815688159344, .990434484573249, -.01707382502938514], [-.009243058152591178, .015055144896577895, .7518742899580008]], e)
      }
      function Te(e) {
          let t = e.map( (e, t) => e / f[t]).map(e => e > .008856451679035631 ? Math.cbrt(e) : (903.2962962962963 * e + 16) / 116);
          return [116 * t[1] - 16, 500 * (t[0] - t[1]), 200 * (t[1] - t[2])]
      }
      function Ee(e) {
          let t = 24389 / 27
            , n = 216 / 24389
            , r = [];
          return r[1] = (e[0] + 16) / 116,
          r[0] = e[1] / 500 + r[1],
          r[2] = r[1] - e[2] / 200,
          [r[0] ** 3 > n ? r[0] ** 3 : (116 * r[0] - 16) / t, e[0] > t * n ? ((e[0] + 16) / 116) ** 3 : e[0] / t, r[2] ** 3 > n ? r[2] ** 3 : (116 * r[2] - 16) / t].map( (e, t) => e * f[t])
      }
      function De(e) {
          let t = Math.atan2(e[2], e[1]) * 180 / Math.PI;
          return [e[0], Math.sqrt(e[1] ** 2 + e[2] ** 2), t >= 0 ? t : t + 360, 1]
      }
      function Oe(e) {
          return [e[0], e[1] * Math.cos(e[2] * Math.PI / 180), e[1] * Math.sin(e[2] * Math.PI / 180)]
      }
      function ke(e) {
          let t = e < 0 ? -1 : 1
            , n = Math.abs(e);
          return n < .04045 ? e / 12.92 : t * ((n + .055) / 1.055) ** 2.4
      }
      function Ae(e) {
          return e.map(e => ke(e / 255))
      }
  }
  )(z$ ||= {}),
  B$ = .022,
  V$ = 1.414
}
)), U$, W$ = t(( () => {
  U$ = function(e) {
      return e[e.elevated = 10] = `elevated`,
      e[e.stickyBar = 30] = `stickyBar`,
      e[e.detailsPaneBackdrop = 80] = `detailsPaneBackdrop`,
      e[e.detailsPane = 90] = `detailsPane`,
      e[e.sidebarBackdrop = 95] = `sidebarBackdrop`,
      e[e.sidebar = 96] = `sidebar`,
      e[e.modalBackdrop = 100] = `modalBackdrop`,
      e[e.proTip = 200] = `proTip`,
      e[e.slideOverBackdrop = 249] = `slideOverBackdrop`,
      e[e.slideOver = 250] = `slideOver`,
      e[e.fastCreate = 300] = `fastCreate`,
      e[e.popoverBackdrop = 400] = `popoverBackdrop`,
      e[e.popover = 500] = `popover`,
      e[e.devToolbar = 550] = `devToolbar`,
      e[e.commandMenu = 600] = `commandMenu`,
      e[e.peek = 650] = `peek`,
      e[e.dialog = 700] = `dialog`,
      e[e.popoverBackdropInDialog = 705] = `popoverBackdropInDialog`,
      e[e.popoverInDialog = 706] = `popoverInDialog`,
      e[e.toast = 800] = `toast`,
      e[e.dndDragLayer = 1e3] = `dndDragLayer`,
      e[e.tooltip = 1100] = `tooltip`,
      e[e.skipToContent = 1200] = `skipToContent`,
      e
  }({})
}
)), G$, K$, q$, J$, Y$, X$, Z$, Q$, $$, e1, t1, n1 = t(( () => {
  N$(),
  H$(),
  ir(),
  W$(),
  G$ = e => `@media (max-width: ${e}px)`,
  K$ = e => `@media (min-width: ${e}px)`,
  q$ = {
      phone: G$(O$.phone),
      tablet: G$(O$.tablet),
      laptop: G$(O$.laptop),
      normal: K$(O$.laptop + 1),
      large: K$(O$.large),
      xlarge: K$(O$.xlarge)
  },
  J$ = rr.isPureTouchDevice ? `active` : `hover`,
  Y$ = e => t => t.theme.color[e],
  X$ = e => t => t.theme.baseTheme?.color[e] ?? t.theme.color[e],
  Z$ = (e, t) => `var(--font-${e}${t ? `,${t}` : ``})`,
  Q$ = e => t => t.theme[t1[e]],
  $$ = e => `var(--speed-${e})`,
  e1 = (e, t, n) => r => {
      let i = z$.fromCss(r.theme.color[e])
        , a = z$.fromCss(r.theme.color[t])
        , o = z$.mix(i, a, n);
      return z$.toCss(r.theme.colorFormat, o)
  }
  ,
  t1 = {
      low: `shadowLow`,
      medium: `shadowMedium`,
      high: `shadowHigh`,
      page: `shadowPage`,
      inset: `shadowInset`
  }
}
)), r1 = t(( () => {
  n1()
}
)), i1, a1, o1, s1 = t(( () => {
  WK(),
  i1 = [`column`, `reverse`, `center`, `align`, `alignSelf`, `justify`, `auto`, `grow`, `shrink`, `wrap`, `inline`, `disabled`, `gap`, `wrapGap`, `overflowHidden`, `noMinWidth`, `noMinHeight`],
  a1 = HK(`div`).withConfig({
      shouldForwardProp: e => !i1.includes(e)
  })([`display:`, `;flex:`, `;flex-direction:`, `;align-items:`, `;justify-content:`, `;`, `;`, `;`, `;`, `;`, `;`, `;`, `;`, `;`, `;`, `;`], ({inline: e}) => e ? `inline-flex` : `flex`, ({auto: e}) => e ? `1 1 auto` : `initial`, ({column: e, reverse: t}) => e ? t ? `column-reverse` : `column` : t ? `row-reverse` : `row`, ({align: e}) => e, ({justify: e}) => e, ({center: e}) => e === !0 ? `align-items: center; justify-content: center;` : ``, ({grow: e}) => typeof e == `number` ? `flex-grow: ${e};` : ``, ({shrink: e}) => typeof e == `number` ? `flex-shrink: ${e};` : ``, ({wrap: e}) => e ? `flex-wrap: wrap;` : ``, ({alignSelf: e}) => e ? `align-self: ${e};` : ``, ({overflowHidden: e}) => e ? `overflow: hidden;` : ``, ({gap: e}) => typeof e == `number` ? `gap: ${e}px` : ``, ({wrapGap: e, column: t}) => typeof e == `number` ? `${t ? `column` : `row`}-gap: ${e}px` : ``, ({noMinWidth: e}) => e ? `min-width: 0px` : ``, ({noMinHeight: e}) => e ? `min-height: 0px` : ``),
  o1 = HK.div([`display:flex;flex:auto;`])
}
));
function c1(e, t, n, r, i=!0) {
  return `
${i ? `position: relative;` : ``}
&::before {
  position: absolute;
  content: "";
  top: -${e}px;
  right: -${t ?? e}px;
  left: -${r ?? e}px;
  bottom: -${n ?? e}px;
}
`
}
function l1(e) {
  return `var(--font-size-${e})`
}
function u1(e) {
  return `var(--font-weight-${e})`
}
function d1(e) {
  return `${m1()} solid ${e}`
}
function f1(e, t=`solid`) {
  return n => `${b1 ? `0.5` : `1`}px ${t} ${p1(e)(n)}`
}
function p1(e) {
  return t => `${t.theme.color[b1 ? `${e}Thin` : `${e}`]}`
}
function Ide() {
  return b1 ? .5 : 1
}
function m1() {
  return b1 ? `0.5px` : `1px`
}
function Lde() {
  return .13
}
function Rde() {
  return `13vh`
}
function zde(e) {
  return `
transition: 300ms;
transition-property: ${e};
transition-timing-function: cubic-bezier(0.43, 0.07, 0.59, 0.94);
`
}
function Bde(e, t) {
  return n => DG([`position:relative;&::after{content:"";position:absolute;top:-3px;left:-3px;right:-3px;bottom:-3px;border:`, ` dashed `, `;pointer-events:none;border-radius:`, `px;}`], m1(), n.theme.color[e], t + 2)
}
var h1, g1, _1, v1, y1, b1, x1, S1, C1, w1, T1 = t(( () => {
  WK(),
  H$(),
  h1 = () => `
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
`,
  g1 = e => `
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: ${e};
overflow: hidden;
overflow-wrap: anywhere;
`,
  _1 = () => `
-ms-overflow-style: none !important;  // IE 10+
overflow: -moz-scrollbars-none !important;  // Firefox
scrollbar-width: none !important; // Firefox
&::-webkit-scrollbar {
  display: none;
}
`,
  v1 = () => `
 appearance: none;
 background: none;
 border: none;
 padding: 0;
 margin: 0;
 font: inherit;
 color: inherit;
 -webkit-tap-highlight-color: transparent;
`,
  y1 = () => `
user-select: none;
appearance: none;
background: none;
border: none;
padding: 0;
margin: 0;
font: inherit;
-webkit-tap-highlight-color: transparent;
`,
  b1 = typeof window < `u` && window.matchMedia?.(`only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi)`).matches || !1,
  x1 = e => t => z$.toCss(t.theme.colorFormat, z$.adjustTo(z$.fromCss(e ? t.theme.focusColor : t.theme.color.labelMuted), {
      a: e ? .4 : .2
  })),
  S1 = DG([`outline-offset:calc(-1 * var(--focus-ring-width));`]),
  C1 = DG([`outline:var(--focus-ring-outline);`]),
  w1 = e => e.isDark ? DG([`background:linear-gradient(180deg,`, ` 0%,`, ` 50%);`], e.color.bgBase, e.color.bgSub) : DG([`background:`, `;`], e.color.bgBase)
}
));
function E1(e) {
  let t = `normal`
    , n = u1(`normal`)
    , r = ``
    , i = ``;
  return (e.endsWith(`Plus`) || e === `title2` || e === `title3`) && (n = u1(e === `regularPlus` ? `semibold` : `medium`),
  (e === `smallPlus` || e === `regularPlus`) && (r = `& b {
      font-weight: ${u1(`bold`)};
     }`)),
  e === `regular` || e === `regularPlus` ? t = k1 : e === `title2` ? t = `2rem` : e === `title1` && (t = `2.875rem`),
  (e === `title2` || e === `title3`) && (i = `-0.01rem`),
  DG([`line-height:`, `;font-size:`, `;font-weight:`, `;`, ` `, ``], t, l1(e), n, r, i ? `letter-spacing: ${i};` : ``)
}
var D1, O1, k1, A1 = t(( () => {
  WK(),
  Tn(),
  T1(),
  n1(),
  D1 = l1,
  O1 = HK(`span`).withConfig({
      shouldForwardProp: e => ![`selectable`, `color`, `variant`, `wrap`].includes(e) && wn(e)
  }).attrs(e => ({
      variant: e.variant ?? `regular`,
      align: e.align ?? `left`,
      selectable: e.selectable ?? !1,
      truncate: e.truncate ?? !1
  }))([`font-style:normal;line-height:normal;font-weight:normal;`, ` `, `;`, `;`, `;`, `;`, `;color:`, `;& b{font-weight:`, `;color:`, `;}`, ` `, `;`, `;`, `;`], e => e.align ? `text-align: ${e.align};` : ``, e => typeof e.truncate == `number` ? g1(e.truncate) : e.truncate ? h1() : ``, e => e.nowrap ? `white-space: nowrap;` : ``, e => e.overflowWrap ? `overflow-wrap: ${e.overflowWrap};` : ``, e => e.transform ? `text-transform: ${e.transform};` : ``, e => e.wrap ? `text-wrap: ${e.wrap};` : ``, e => e.color === `currentColor` ? `currentColor` : e.theme.color[e.color || `labelTitle`], u1(`medium`), Y$(`labelBase`), e => E1(e.variant ?? `regular`), e => e.selectable ? `user-select: text;` : ``, e => e.tabularNums ? `font-variant-numeric: tabular-nums;` : ``, e => e.fontFamily === `display` ? `
        font-weight: ${u1(`semibold`)};
        font-family: ${Z$(`display`)};
        font-feature-settings: "calt";
        font-variation-settings: "opsz" 32;

        .redesign-enabled & {
          font-weight: 550;
          font-variation-settings: "opsz" 28;
        }
      ` : e.fontFamily === `monospace` ? `font-family: ${Z$(`monospace`)};` : ``),
  k1 = `1.4375rem`
}
));
function j1(e) {
  return (0,
  M1.jsx)(XK, {
      ...e,
      children: (0,
      M1.jsx)(`svg`, {
          children: (0,
          M1.jsx)(`path`, {
              d: `M2.96967 2.96967C3.26256 2.67678 3.73744 2.67678 4.03033 2.96967L8 6.939L11.9697 2.96967C12.2626 2.67678 12.7374 2.67678 13.0303 2.96967C13.3232 3.26256 13.3232 3.73744 13.0303 4.03033L9.061 8L13.0303 11.9697C13.2966 12.2359 13.3208 12.6526 13.1029 12.9462L13.0303 13.0303C12.7374 13.3232 12.2626 13.3232 11.9697 13.0303L8 9.061L4.03033 13.0303C3.73744 13.3232 3.26256 13.3232 2.96967 13.0303C2.67678 12.7374 2.67678 12.2626 2.96967 11.9697L6.939 8L2.96967 4.03033C2.7034 3.76406 2.6792 3.3474 2.89705 3.05379L2.96967 2.96967Z`
          })
      })
  })
}
var M1, N1 = t(( () => {
  ht(),
  QK(),
  M1 = e(f(), 1)
}
));
function P1(e) {
  return (0,
  F1.jsx)(XK, {
      ...e,
      children: (0,
      F1.jsx)(`svg`, {
          children: (0,
          F1.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M8 15C11.866 15 15 11.866 15 8C15 4.13401 11.866 1 8 1C4.13401 1 1 4.13401 1 8C1 11.866 4.13401 15 8 15ZM6.53033 5.46967C6.23744 5.17678 5.76256 5.17678 5.46967 5.46967C5.17678 5.76256 5.17678 6.23744 5.46967 6.53033L6.93934 8L5.46967 9.46967C5.17678 9.76256 5.17678 10.2374 5.46967 10.5303C5.76256 10.8232 6.23744 10.8232 6.53033 10.5303L8 9.06066L9.46967 10.5303C9.76256 10.8232 10.2374 10.8232 10.5303 10.5303C10.8232 10.2374 10.8232 9.76256 10.5303 9.46967L9.06066 8L10.5303 6.53033C10.8232 6.23744 10.8232 5.76256 10.5303 5.46967C10.2374 5.17678 9.76256 5.17678 9.46967 5.46967L8 6.93934L6.53033 5.46967Z`
          })
      })
  })
}
var F1, I1 = t(( () => {
  ht(),
  QK(),
  F1 = e(f(), 1)
}
));
function L1(e) {
  return (0,
  R1.jsx)(XK, {
      noFill: !0,
      ...e,
      children: (0,
      R1.jsx)(`svg`, {
          children: (0,
          R1.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M8 15C11.866 15 15 11.866 15 8C15 4.13401 11.866 1 8 1C4.13401 1 1 4.13401 1 8C1 11.866 4.13401 15 8 15ZM11.7836 6.42901C12.0858 6.08709 12.0695 5.55006 11.7472 5.22952C11.4248 4.90897 10.9186 4.9263 10.6164 5.26821L7.14921 9.19122L5.3315 7.4773C5.00127 7.16593 4.49561 7.19748 4.20208 7.54777C3.90855 7.89806 3.93829 8.43445 4.26852 8.74581L6.28032 10.6427C6.82041 11.152 7.64463 11.1122 8.13886 10.553L11.7836 6.42901Z`
          })
      })
  })
}
var R1, z1 = t(( () => {
  ht(),
  QK(),
  R1 = e(f(), 1)
}
));
function B1(e) {
  let {variant: t, interval: n=200, ...r} = e
    , i = 3.5
    , a = .3
    , o = wG()
    , s = Y1[t]
    , c = s[0].length
    , l = s.length * n
    , u = i * (c - 1) + 2
    , d = (e, n) => `grid-dot-${e}-${n}-${t}`;
  return (0,
  U1.jsxs)(U1.Fragment, {
      children: [(0,
      U1.jsx)(W1, {
          styles: H1.useMemo( () => {
              let e = ``;
              for (let t = 0; t < c; t++)
                  for (let n = 0; n < c; n++) {
                      let r = d(t, n)
                        , i = Vde({
                          frames: s,
                          row: t,
                          col: n,
                          litOpacity: 1,
                          unlitOpacity: a
                      });
                      e += `\n@keyframes ${r} {${i}\n}`,
                      e += `\n.${r} { animation: ${r} ${l}ms steps(1, end) infinite; }`
                  }
              return e
          }
          , [s, c, 1, a, l, t])
      }, `${t}-style`), (0,
      U1.jsx)(`svg`, {
          width: u,
          height: u,
          viewBox: `0 0 ${u} ${u}`,
          xmlns: `http://www.w3.org/2000/svg`,
          ...r,
          fill: `none`,
          children: Array.from({
              length: c * c
          }).map( (e, t) => {
              let n = Math.floor(t / c)
                , s = t % c;
              return (0,
              U1.jsx)(`circle`, {
                  className: d(n, s),
                  cx: 1 + s * i,
                  cy: 1 + n * i,
                  r: 1,
                  fill: r.fill ?? o.color.labelBase,
                  opacity: a
              }, t)
          }
          )
      }, t)]
  })
}
function Vde(e) {
  let {frames: t, row: n, col: r, litOpacity: i, unlitOpacity: a} = e
    , o = t.length
    , s = ``;
  for (let e = 0; e < o; e++) {
      let c = e / o * 100
        , l = (e + 1) / o * 100
        , u = t[e][n][r];
      s += `\n      ${c}% { opacity: ${u ? i : a}; }`,
      s += `\n      ${l}% { opacity: ${u ? i : a}; }`
  }
  return s
}
function V1(e) {
  return e[0].split(`
`).map(e => e.trim()).filter(e => e.length > 0).map(e => e.split(/\s+/).map(e => e === ``))
}
var H1, U1, W1, G1, K1, q1, J1, Y1, X1 = t(( () => {
  H1 = e(ht(), 1),
  WK(),
  U1 = e(f(), 1),
  W1 = kG([``, ``], ({styles: e}) => e),
  G1 = [V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`],
  K1 = [V1`
      
      
      
      
      
  `, V1`
      
      
      
      
      
  `, V1`
      
      
      
      
      
  `, V1`
      
      
      
      
      
  `, V1`
      
      
      
      
      
  `, V1`
      
      
      
      
      
  `, V1`
      
      
      
      
      
  `, V1`
      
      
      
      
      
  `, V1`
      
      
      
      
      
  `, V1`
      
      
      
      
      
  `, V1`
      
      
      
      
      
  `, V1`
      
      
      
      
      
  `],
  q1 = [V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `],
  J1 = [V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `],
  Y1 = {
      scope: K1,
      upDown: q1,
      pong: G1,
      blowOut: [V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `],
      ufo: [V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `, V1`
        
        
        
        
        
    `],
      down: J1,
      zap: [V1`
        
        
        
        
        
  `],
      hourglass: [V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`],
      stats: [V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
    `],
      cat: [V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
        
        
        
        
        
  `, V1`
      
      
      
      
      
  `],
      agent: [V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`, V1`
      
      
      
      
      
`]
  }
}
));
function Z1(e) {
  let {progress: t, "aria-label": n, ...r} = e
    , i = wG()
    , a = 3.5
    , o = .3;
  a * 4 + 2;
  let s = Q1.useId()
    , c = Q1.useMemo( () => `grid-loader-progress-pulse-${s.replace(/[^a-zA-Z0-9_-]/g, `-`)}`, [s])
    , l = Number.isNaN(t) ? 0 : Math.min(Math.max(t, 0), 1)
    , u = Math.floor(l * 25)
    , d = u > 0 && u < 25
    , f = d ? u - 1 : -1
    , p = n ?? `Progress ${Math.round(l * 100)}%`;
  return (0,
  $1.jsxs)(`svg`, {
      width: r.width ?? 16,
      height: r.height ?? 16,
      viewBox: `0 0 16 16`,
      xmlns: `http://www.w3.org/2000/svg`,
      role: `img`,
      "aria-label": p,
      ...r,
      children: [d ? (0,
      $1.jsx)(`style`, {
          children: `@keyframes ${c} {0%, 49.999% { opacity: 1; } 50%, 100% { opacity: ${o}; }}`
      }) : null, Array.from({
          length: 25
      }).map( (e, t) => {
          let n = Math.floor(t / 5)
            , s = t % 5
            , l = t < u;
          return (0,
          $1.jsx)(`circle`, {
              cx: 1 + s * a,
              cy: 1 + n * a,
              r: 1,
              fill: r.fill ?? i.color.labelBase,
              opacity: l ? 1 : o,
              style: t === f ? {
                  animation: `${c} 600ms linear infinite`
              } : void 0
          }, `${n}-${s}`)
      }
      )]
  })
}
var Q1, $1, e0 = t(( () => {
  Q1 = e(ht(), 1),
  WK(),
  $1 = e(f(), 1)
}
));
function t0(e) {
  let {menuTheme: t, children: n} = e
    , r = wG()
    , i = e.elevation === -1 ? r.subTheme() : t ? r.menuTheme() : r.elevatedTheme();
  return e.elevation === 2 ? i = i.elevatedTheme() : e.elevation === 3 ? i = i.elevatedTheme().elevatedTheme() : e.elevation === 0 && (i = r.baseTheme || r),
  (0,
  n0.jsx)(TG, {
      theme: i,
      children: n
  })
}
var n0, r0 = t(( () => {
  ht(),
  WK(),
  n0 = e(f(), 1)
}
)), i0, a0, o0, s0 = t(( () => {
  ht(),
  u(),
  WK(),
  r0(),
  T1(),
  n1(),
  i0 = e(f(), 1),
  a0 = function({disableFocusRing: e, ...t}) {
      return (0,
      i0.jsx)(t0, {
          menuTheme: !0,
          children: (0,
          i0.jsx)(o0, {
              "data-disable-focus-ring": e,
              ...t
          })
      })
  }
  ,
  o0 = HK(s.div)([`background-color:`, `;border:`, `;&:focus,&:focus-visible{outline:none;&[data-disable-focus-ring="true"]{box-shadow:none;}}`], Y$(`bgBase`), f1(`bgBorderSolid`))
}
));
function c0(e) {
  return (0,
  l0.jsx)(XK, {
      ...e,
      children: (0,
      l0.jsx)(`svg`, {
          children: (0,
          l0.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M8 15C11.866 15 15 11.866 15 8C15 4.13401 11.866 1 8 1C4.13401 1 1 4.13401 1 8C1 11.866 4.13401 15 8 15ZM8 4C7.44772 4 7 4.44772 7 5C7 5.55228 7.44772 6 8 6C8.55228 6 9 5.55228 9 5C9 4.44772 8.55228 4 8 4ZM8 7C7.44772 7 7 7.44772 7 8V11C7 11.5523 7.44772 12 8 12C8.55228 12 9 11.5523 9 11V8C9 7.44772 8.55228 7 8 7Z`
          })
      })
  })
}
var l0, u0 = t(( () => {
  ht(),
  QK(),
  l0 = e(f(), 1)
}
)), d0, Hde = t(( () => {
  d0 = class e {
      static get _base() {
          let e = [`Attachment`, `Blockquote`, `Calendar`, `Checklist`, `CodeBlock`, `Comment`, `CreditCard`, `CustomView`, `Favorite`, `Folder`, `Home`, `Inbox`, `Initiative`, `Label`, `Link`, `Lock`, `Refresh`, `Search`, `Send`, `Subscribe`, `Team`];
          return {
              only: e,
              extended: {},
              all: [...e]
          }
      }
      static get _brands() {
          let e = [`GitHub`, `GitLab`, `Meta`, `OpenAI`];
          return {
              only: e,
              extended: {},
              all: [...e]
          }
      }
      static get _decorative() {
          let e = `Accessibility.Africa.Ai.AiApp.AiDocument.AiWriting.AirTag.Airplane.Alarm.AlarmClock.AlarmDelete.Alert.AmericanFootBall.Anchor.Android.Anonymous.Apple.Asia.Asterisk.Astronaut.Australia.Auth0.Bandage.Bank.BarChart.BarGraph.Basket.Basketball.Battery.Bed.Bike.Binocular.Bitcoin.Bluetooth.Bolt.Bones.Book.BookOpen.Bookmark.Boombox.BowlingBall.Box.BoxOpen.Brain.Brick.Briefcase.Brush.Bucket.Bug.Burger.Bus.Calculator.Camera.CameraAi.Car.CarPool.Cart.Chart.Chat.ChatLine.Chemist.Chip.Chrome.Circle.ClickButton.Clock.ClockOutline.ClothHanger.Cloud.Coffee.Comodore.Compass.Computer.Cone.Connected.ConstructionBarrier.Conversation.Cookie.Crane.Cross.Crown.CrystalBall.Cube.Dashboard.Database.DesignTools.DesktopWindow.Dice.Dino.Direction.Discord.Dna.Dollar.DollarBill.Dumbbell.Edge.Education.ElectricPlug.Email.EmptyCircle.Eraser.Etherum.Euro.Europe.ExclamationMark.Extinguisher.Face.FaceFlatSmile.FaceHeartEyes.FaceId.FaceMask.FaceMonocle.FaceStarEyes.FaceSunglasses.FaceSurprise.FaceTired.FaceTongue.Factory.Feather.Figma.Fire.Firefox.Flag.Flashlight.FloppyDisk.Flower.FootPrint.Garage.Gears.Golf.GooglePlay.Hack.Health.Hear.Heart.Home.Hourglass.Image.Intercom.Jersey.Joystick.Judge.Ladder.Leaf.LightBulb.Linear.LinearAi.LockerRoom.Mac.MacOS.MagicWand.Magnet.Mask.Megaphone.Mic.MilitaryTruck.MobilePhone.Modem.MoneyStack.Moon.Mountain.MovingStaircase.MusicKey.MusicTape.Network.NorthAmerica.NotePad.Notified.Notion.OnePassword.Page.Paint.PalmTree.Phone.PieChart.Pills.Pin.PingPong.Pizza.Pointer.PokerCard.Policy.Present.Process.Project.QuestionMark.Radar.Ramen.Rank.Recycle.Report.Resolved.ResolvedChat.Robot.Rocket.Routing.Runner.SafetyKit.ScatterPlot.Scissors.Search.Sentry.Server.Shield.Ship.Shop.Shrug.Sign.Signature.Skull.Slack.SmallLock.SoccerBall.Solana.Sound.SoundMuted.SouthAmerica.Spaces.Speaker.Spreadsheet.Stadium.Starred.Stopwatch.Storm.Subgroup.Subscribe.Sun.Surfer.Tablet.Taxi.TeeShirt.TennisBall.Terminal.TextBlock.TextParagraph.ThumbsDown.ThumbsUp.Tower.TrafficLight.Train.Tram.Trash.Tree.Umbrella.UnhappyFace.Union.Users.Video.ViewFinder.VisionPro.Wall.Watch.WindTurbine.World.Wrench.Write.WritingAI.Zapier.Zendesk`.split(`.`)
            , t = [`Attachment`, `Blockquote`, `Calendar`, `Checklist`, `CodeBlock`, `Comment`, `CreditCard`, `CustomView`, `Favorite`, `Folder`, `Inbox`, `Initiative`, `Label`, `Link`, `Lock`, `Refresh`, `Send`, `Team`]
            , n = [`GitHub`, `GitLab`, `Meta`, `OpenAI`];
          return {
              only: e,
              extended: {
                  base: t,
                  brands: n
              },
              all: [...e, ...t, ...n]
          }
      }
      static #e = this.base = {
          all: {
              array: e._base.all,
              set: new Set(e._base.all)
          }
      };
      static #t = this.brands = {
          all: {
              array: e._brands.all,
              set: new Set(e._brands.all)
          }
      };
      static #n = this.decorative = {
          only: {
              array: e._decorative.only,
              set: new Set(e._decorative.only)
          },
          extended: {
              base: {
                  array: e._decorative.extended.base,
                  set: new Set(e._decorative.extended.base)
              },
              brands: {
                  array: e._decorative.extended.brands,
                  set: new Set(e._decorative.extended.brands)
              }
          },
          all: {
              array: e._decorative.all,
              set: new Set(e._decorative.all)
          }
      }
  }
}
)), f0, p0, m0, Ude = t(( () => {
  ht(),
  WK(),
  f0 = e(f(), 1),
  p0 = e => {
      let {$color: t, ...n} = e
        , r = wG()
        , i = t && t in r.color ? r.color[t] : t === `brand` ? void 0 : t
        , a = {
          ...e.style,
          "--icon-color": i
      };
      return (0,
      f0.jsx)(`svg`, {
          ...n,
          fill: e.fill ?? i,
          style: a,
          children: e.children
      })
  }
  ,
  m0 = () => {
      let e = wG();
      return (0,
      f0.jsxs)(f0.Fragment, {
          children: [(0,
          f0.jsx)(`stop`, {
              offset: `0%`,
              stopColor: e.color.labelTitle
          }, `0`), (0,
          f0.jsx)(`stop`, {
              offset: `100%`,
              stopColor: e.color.labelMuted
          }, `1`)]
      })
  }
}
));
function h0(e) {
  let {icon: t, setName: n, size: r=16, width: i, height: a, viewBox: o=`0 0 16 16`, color: s=`labelMuted`, blurGradient: c, style: l={}, noFill: u=!1, className: d, ...f} = e, p;
  if (typeof r == `string`)
      try {
          p = aW(r)
      } catch {}
  else
      p = r;
  let m = t;
  `variant`in e && e.variant && (m = `${t}--${String(e.variant)}`);
  let h = u || s === `brand` ? void 0 : s
    , g = s === `gradient-x` || s === `gradient-y`
    , _ = g0.useId();
  return (0,
  _0.jsx)(p0, {
      ...f,
      className: eW(d, {
          "color-override": s === `brand`
      }),
      style: {
          ...l,
          ...g && {
              overflow: `visible`
          }
      },
      width: i ?? p ?? r,
      height: a ?? p ?? r,
      viewBox: o,
      role: `img`,
      focusable: `false`,
      "aria-hidden": `aria-hidden`in f ? f[`aria-hidden`] : `aria-label`in f ? void 0 : !0,
      xmlns: `http://www.w3.org/2000/svg`,
      fill: g ? `url(#${_}-gradient)` : void 0,
      $color: h,
      children: g ? (0,
      _0.jsxs)(_0.Fragment, {
          children: [(0,
          _0.jsx)(`g`, {
              opacity: c ? `0.15` : `0`,
              filter: `url(#${_}-filter0)`,
              style: {
                  transition: `opacity 0.2s ease-in-out`
              },
              children: (0,
              _0.jsx)(`use`, {
                  href: `#${m}`
              })
          }), (0,
          _0.jsx)(`g`, {
              opacity: c ? `0.3` : `0`,
              filter: `url(#${_}-filter1)`,
              style: {
                  transition: `opacity 0.2s ease-in-out`
              },
              children: (0,
              _0.jsx)(`use`, {
                  href: `#${m}`
              })
          }), (0,
          _0.jsx)(`use`, {
              href: `#${m}`
          }), (0,
          _0.jsxs)(`defs`, {
              children: [(0,
              _0.jsxs)(`filter`, {
                  id: `${_}-filter0`,
                  x: `-50%`,
                  y: `-50%`,
                  width: `200%`,
                  height: `200%`,
                  filterUnits: `userSpaceOnUse`,
                  colorInterpolationFilters: `sRGB`,
                  children: [(0,
                  _0.jsx)(`feFlood`, {
                      floodOpacity: `0`,
                      result: `BackgroundImageFix`
                  }), (0,
                  _0.jsx)(`feBlend`, {
                      mode: `normal`,
                      in: `SourceGraphic`,
                      in2: `BackgroundImageFix`,
                      result: `shape`
                  }), (0,
                  _0.jsx)(`feGaussianBlur`, {
                      stdDeviation: `4`,
                      result: `effect1_foregroundBlur_425_75660`
                  })]
              }), (0,
              _0.jsxs)(`filter`, {
                  id: `${_}-filter1`,
                  x: `-50%`,
                  y: `-50%`,
                  width: `200%`,
                  height: `200%`,
                  filterUnits: `userSpaceOnUse`,
                  colorInterpolationFilters: `sRGB`,
                  children: [(0,
                  _0.jsx)(`feFlood`, {
                      floodOpacity: `0`,
                      result: `BackgroundImageFix`
                  }), (0,
                  _0.jsx)(`feBlend`, {
                      mode: `normal`,
                      in: `SourceGraphic`,
                      in2: `BackgroundImageFix`,
                      result: `shape`
                  }), (0,
                  _0.jsx)(`feGaussianBlur`, {
                      stdDeviation: `2`,
                      result: `effect1_foregroundBlur_425_75660`
                  })]
              }), (0,
              _0.jsx)(`linearGradient`, {
                  id: `${_}-gradient`,
                  x1: `0`,
                  y1: `0`,
                  x2: s === `gradient-x` ? `1` : `0`,
                  y2: s === `gradient-y` ? `1` : `0`,
                  children: (0,
                  _0.jsx)(m0, {})
              })]
          })]
      }) : (0,
      _0.jsx)(`use`, {
          href: `#${m}`
      })
  })
}
var g0, _0, Wde = t(( () => {
  g0 = e(ht(), 1),
  tW(),
  oW(),
  Ude(),
  _0 = e(f(), 1)
}
));
function v0(e) {
  let {icon: t, variant: n, ...r} = e;
  return Gde(t) ? (0,
  b0.jsx)(h0, {
      setName: `Base`,
      icon: t,
      ...r
  }) : Kde(t) ? (0,
  b0.jsx)(h0, {
      setName: `Brands`,
      icon: t,
      ...r
  }) : d0.decorative.only.set.has(t) ? (0,
  b0.jsx)(h0, {
      setName: `Decorative`,
      icon: t,
      variant: n,
      ...r
  }) : (0,
  b0.jsx)(h0, {
      setName: `Base`,
      icon: `CustomView`,
      ...r
  })
}
function Gde(e) {
  return d0.decorative.extended.base.set.has(e)
}
function Kde(e) {
  return d0.decorative.extended.brands.set.has(e)
}
function qde(e) {
  return function(t) {
      return (0,
      b0.jsx)(v0, {
          ...t,
          icon: e
      })
  }
}
function y0(e) {
  return d0.decorative.all.set.has(e)
}
var b0, x0 = t(( () => {
  ht(),
  Hde(),
  Wde(),
  b0 = e(f(), 1)
}
)), S0, C0, w0 = t(( () => {
  S0 = e(ht(), 1),
  C0 = S0.createContext({
      debuggingEnabled: !1,
      onTooltipActivated: () => null,
      currentActivationReason: null
  })
}
)), T0, E0, D0, O0 = t(( () => {
  T0 = e(ht(), 1),
  E0 = e(ve(), 1),
  D0 = e => {
      let[t,n] = T0.useState([0, 0]);
      return T0.useEffect( () => {
          let t = (e, t) => {
              n([e, t])
          }
            , r = (0,
          E0.default)(e => {
              t(e.clientX, e.clientY)
          }
          , 50)
            , i = (0,
          E0.default)(e => {
              e.touches.length > 0 && t(e.touches[0].clientX, e.touches[0].clientY)
          }
          , 50);
          return window.addEventListener(`mousemove`, r),
          e?.handleTouch && window.addEventListener(`touchmove`, i),
          () => {
              r.cancel(),
              window.removeEventListener(`mousemove`, r),
              e?.handleTouch && (i.cancel(),
              window.removeEventListener(`touchmove`, i))
          }
      }
      , []),
      t
  }
}
));
function k0(e) {
  let {parentRef: t, triggerSelector: n, ...r} = e
    , [i,a] = j0.useState(!0)
    , o = j0.useRef(void 0)
    , s = D0()
    , c = j0.useMemo( () => {
      let e = t.current?.getBoundingClientRect();
      return e ? Jde(e, s) : void 0
  }
  , [s[0], s[1]]);
  return j0.useEffect( () => {
      if (n) {
          if (i)
              return o.current = setTimeout( () => {
                  A0(n, s) || a(!1)
              }
              , 150),
              () => {
                  clearTimeout(o.current)
              }
              ;
          A0(n, s) && a(!0)
      }
  }
  , [i, s]),
  c === void 0 || !i || s[0] === 0 && s[1] === 0 ? null : (0,
  M0.jsx)(`div`, {
      ...r,
      style: c
  })
}
function A0(e, t) {
  let n = self.document.querySelector(e)?.getBoundingClientRect();
  if (n) {
      let[e,r] = t;
      return e >= n.x && e <= n.x + n.width && r >= n.y && r <= n.y + n.height
  } else
      return !1
}
function Jde(e, t) {
  let[n,r] = t
    , {left: i, right: a, top: o, bottom: s, width: c, height: l} = e
    , u = {
      position: `absolute`
  }
    , d = n < i ? i - n : 0
    , f = n > a ? n - a : 0
    , p = r < o ? o - r : 0
    , m = r > s ? r - s : 0
    , h = d !== 0 || f !== 0
    , g = p !== 0 || m !== 0;
  if (!h && !g)
      return;
  d > 0 ? (u.left = `-${d}px`,
  u.width = `${c + d}px`) : f > 0 ? (u.right = `-${f}px`,
  u.width = `${c + f}px`) : (u.left = 0,
  u.right = 0),
  p > 0 ? (u.top = `-${p}px`,
  u.height = `${l + p}px`) : m > 0 ? (u.bottom = `-${m}px`,
  u.height = `${l + m}px`) : (u.top = 0,
  u.bottom = 0);
  let _ = d + c + f, ee = p + l + m, te = d + (n - i), ne = p + (r - o), re = te / _ * 100, ie = ne / ee * 100, ae = d / _ * 100, oe = (d + c) / _ * 100, se = p / ee * 100, ce = (p + l) / ee * 100, le;
  return le = h && g ? n < i && r < o ? `polygon(
      ${re}% ${ie}%,
      ${ae}% ${ce}%,
      ${ae}% ${se}%,
      ${oe}% ${se}%
    )` : n > a && r < o ? `polygon(
      ${re}% ${ie}%,
      ${oe}% ${ce}%,
      ${oe}% ${se}%,
      ${ae}% ${se}%
    )` : n < i && r > s ? `polygon(
      ${re}% ${ie}%,
      ${ae}% ${se}%,
      ${ae}% ${ce}%,
      ${oe}% ${ce}%
    )` : `polygon(
      ${re}% ${ie}%,
      ${oe}% ${se}%,
      ${oe}% ${ce}%,
      ${ae}% ${ce}%
    )` : h ? n < i ? `polygon(
      ${re}% ${ie}%,
      ${ae}% ${se}%,
      ${ae}% ${ce}%
    )` : `polygon(
      ${re}% ${ie}%,
      ${oe}% ${se}%,
      ${oe}% ${ce}%
    )` : r < o ? `polygon(
      ${re}% ${ie}%,
      ${ae}% ${se}%,
      ${oe}% ${se}%
    )` : `polygon(
      ${re}% ${ie}%,
      ${ae}% ${ce}%,
      ${oe}% ${ce}%
    )`,
  u.clipPath = le,
  u
}
var j0, M0, N0 = t(( () => {
  j0 = e(ht(), 1),
  O0(),
  M0 = e(f(), 1)
}
));
function P0(e) {
  let t = F0.useRef(e);
  return e !== t.current && (t.current = e),
  t
}
var F0, I0 = t(( () => {
  F0 = e(ht(), 1)
}
));
function L0(e) {
  switch (e) {
  case `top-start`:
      return `0 100%`;
  case `top-end`:
      return `100% 100%`;
  case `bottom-start`:
      return `0 0`;
  case `bottom-end`:
      return `100% 0`;
  case `right-start`:
      return `0 0`;
  case `right-end`:
      return `0 100%`;
  case `left-start`:
      return `100% 0`;
  case `left-end`:
      return `100% 100%`;
  case `top`:
      return `50% 100%`;
  case `right`:
      return `0 50%`;
  case `bottom`:
      return `50% 0`;
  case `left`:
      return `100% 50%`;
  default:
      return `0 0`
  }
}
var R0 = t(( () => {}
)), z0, B0, V0, H0, U0, W0, G0, K0 = t(( () => {
  jn(),
  z0 = {
      name: `maxSize`,
      enabled: !0,
      phase: `main`,
      requiresIfExists: [`offset`, `preventOverflow`, `flip`, `discreteMaxHeight`],
      fn({state: e, name: t, options: n}) {
          let r = Ste(e, n)
            , {x: i, y: a} = e.modifiersData.preventOverflow ?? {
              x: 0,
              y: 0
          }
            , {width: o, height: s} = e.rects.popper
            , [c,l] = e.placement.split(`-`)
            , u = c === `top` || c === `bottom`
            , d = c === `left` ? `left` : `right`
            , f = c === `top` ? `top` : `bottom`
            , p = s - r.top - r.bottom
            , m = o - r.left - r.right
            , h = Math.min(s - r[f] - a, p)
            , g = Math.min(o - r[d] - i, m)
            , _ = h
            , ee = g;
          u ? ee = l ? Math.min(g, m) : m : _ = l ? Math.min(h, p) : p;
          let te = Array.isArray(e.modifiersData.discreteMaxHeight) ? e.modifiersData.discreteMaxHeight : void 0;
          if (te) {
              for (let e = 1; e < te.length; e++)
                  if (_ < te[e]) {
                      _ = te[e - 1];
                      break
                  }
          }
          e.modifiersData[t] = {
              width: ee,
              height: _
          }
      }
  },
  B0 = `--popper-max-height`,
  V0 = `--popper-overflow`,
  H0 = {
      name: `applyMaxSize`,
      enabled: !0,
      phase: `beforeWrite`,
      requires: [`maxSize`],
      requiresIfExists: [`alwaysApplyMaxSize`],
      fn({state: e}) {
          let {height: t} = e.modifiersData.maxSize
            , n = Array.isArray(e.modifiersData.discreteMaxHeight)
            , r = e.modifiersData.alwaysOverflow;
          e.rects.popper.height < t && !e.modifiersData.alwaysApplyMaxSize || (e.styles.popper.maxHeight = t,
          e.elements.popper.style.setProperty(B0, t + `px`),
          e.elements.popper.style.setProperty(V0, n && !r ? `hidden` : `hidden auto`))
      }
  },
  U0 = {
      name: `alwaysOverflow`,
      enabled: !0,
      phase: `beforeWrite`,
      fn({state: e, name: t}) {
          e.modifiersData[t] = !0
      }
  },
  W0 = {
      name: `alwaysApplyMaxSize`,
      enabled: !0,
      phase: `beforeWrite`,
      fn({state: e, name: t}) {
          e.modifiersData[t] = !0
      }
  },
  G0 = e => ({
      name: `discreteMaxHeight`,
      enabled: !0,
      phase: `beforeMain`,
      fn({state: t, name: n}) {
          t.modifiersData[n] = e
      }
  })
}
));
function q0({targetRef: e, popoverRef: t, initiallyOpen: n, options: r}) {
  let[i,a] = Y0.useState(Z0.closed)
    , [o,s] = Y0.useState(r?.placement ?? `top-start`)
    , c = Y0.useRef(null)
    , l = Y0.useRef(!0)
    , u = Y0.useRef(void 0)
    , d = Y0.useRef(0)
    , f = Y0.useCallback( () => {
      l.current && (r?.onOpen?.(),
      a(Z0.open))
  }
  , [r?.onOpen])
    , p = Y0.useCallback( () => {
      l.current && a(e => e === Z0.closed ? e : Z0.closing)
  }
  , [])
    , m = P0(i)
    , h = Y0.useCallback( () => {
      l.current && (a(Z0.closed),
      m.current !== Z0.closed && r?.onClose?.(),
      m.current = Z0.closed)
  }
  , [r?.onClose])
    , g = () => {
      u.current?.disconnect(),
      u.current = void 0,
      d.current = 0
  }
  ;
  return Y0.useLayoutEffect( () => {
      if (i === Z0.closed)
          c.current?.destroy(),
          c.current = null,
          g(),
          s(r?.placement ?? `top-start`);
      else if (!c.current && e.current && t.current) {
          let {onFirstUpdate: n, observeMutations: i} = r ?? {};
          c.current = xte(e.current, t.current, {
              placement: o,
              strategy: r?.strategy ?? `fixed`,
              modifiers: J0(o, r),
              onFirstUpdate(e) {
                  n?.(e),
                  e.placement && s(e.placement)
              }
          }),
          i && (d.current = 0,
          u.current = new ResizeObserver(async () => {
              typeof i == `number` && d.current >= i || (d.current++,
              await c.current?.update())
          }
          ),
          u.current.observe(t.current))
      }
  }
  , [i]),
  Y0.useLayoutEffect( () => {
      c.current && c.current.setOptions({
          placement: o,
          modifiers: J0(o, r)
      })
  }
  , [o]),
  Y0.useEffect( () => {
      let e = e2( () => {
          h()
      }
      );
      return l.current = !0,
      n && f(),
      () => {
          e(),
          g(),
          l.current = !1
      }
  }
  , []),
  Y0.useLayoutEffect( () => {
      r?.placement && s(r.placement)
  }
  , [r?.placement]),
  Y0.useLayoutEffect( () => {
      if (i !== Z0.open)
          return;
      let e = requestAnimationFrame( () => {
          c.current && t.current && (t.current.style.removeProperty(`--popper-max-height`),
          t.current.style.maxHeight = ``,
          c.current.update())
      }
      );
      return () => cancelAnimationFrame(e)
  }
  , [i]),
  Y0.useEffect( () => {
      let e = window.visualViewport
        , n = e ?? window
        , r = !1
        , i = () => {
          r || (r = !0,
          requestAnimationFrame( () => {
              r = !1,
              m.current === Z0.open && c.current && t.current && (t.current.style.removeProperty(`--popper-max-height`),
              t.current.style.maxHeight = ``,
              c.current.update())
          }
          ))
      }
      ;
      return n.addEventListener(`resize`, i, {
          passive: !0
      }),
      e?.addEventListener(`scroll`, i, {
          passive: !0
      }),
      window.addEventListener(`orientationchange`, i, {
          passive: !0
      }),
      () => {
          n.removeEventListener(`resize`, i),
          e?.removeEventListener(`scroll`, i),
          window.removeEventListener(`orientationchange`, i)
      }
  }
  , []),
  {
      onShow: f,
      onHide: p,
      ref: c,
      popoverProps: {
          lifecycle: i,
          onClosed: h,
          transformOrigin: L0(c.current?.state.placement ?? o),
          placement: o
      }
  }
}
function J0(e, t) {
  let {modifiers: n} = t ?? {}
    , r = Yde(e, t?.placement ?? `top-start`, n?.find(e => e.name === `offset`) ?? {
      name: `offset`,
      options: {
          offset: [0, 4]
      }
  })
    , i = (n ?? []).filter(e => e.name !== `offset`);
  return i.push(r),
  t?.maxSizeModifier === `never` || (t?.maxSizeModifier === `always` && i.push(W0),
  i.push({
      ...z0,
      options: Object.assign({
          padding: 16
      }, t?.maxSizeOptions)
  }, H0)),
  i.push({
      name: `hide`,
      enabled: t?.hideWithTarget !== !1
  }),
  i
}
function Yde(e, t, n) {
  if (e === t || !n.options?.offset?.[0])
      return n;
  let r = {
      name: `offset`,
      options: {
          offset: [-n.options.offset[0], n.options.offset[1]]
      }
  };
  switch (t) {
  case `bottom-end`:
  case `top-end`:
      switch (e) {
      case `bottom-start`:
      case `top-start`:
          return r;
      default:
          break
      }
      break;
  case `bottom-start`:
  case `top-start`:
      switch (e) {
      case `bottom-end`:
      case `top-end`:
          return r;
      default:
          break
      }
      break;
  default:
      break
  }
  return n
}
var Y0, X0, Z0, Q0, $0, e2, t2, n2 = t(( () => {
  Y0 = e(ht(), 1),
  jn(),
  WK(),
  I0(),
  R0(),
  K0(),
  X0 = 4,
  DG([`[data-popper-reference-hidden] &{opacity:0 !important;pointer-events:none;}`]),
  Z0 = function(e) {
      return e[e.closed = 0] = `closed`,
      e[e.open = 1] = `open`,
      e[e.closing = 2] = `closing`,
      e
  }({}),
  Q0 = 0,
  $0 = new Map,
  e2 = e => {
      let t = Q0++;
      return $0.set(t, e),
      () => $0.delete(t)
  }
  ,
  t2 = () => {
      $0.forEach(e => e())
  }
}
)), r2, i2, a2 = t(( () => {
  r2 = e(ht(), 1),
  i2 = r2.createContext(0)
}
)), o2, s2 = t(( () => {
  o2 = {
      linear: e => e,
      quadOut: e => e * (2 - e),
      quadIn: e => e * e,
      quadInOut: e => e < .5 ? 2 * e * e : -1 + (4 - 2 * e) * e,
      cubicOut: e => {
          let t = e - 1;
          return t * t * t + 1
      }
      ,
      cubicIn: e => e * e * e,
      cubicInOut: e => e < .5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1
  }
}
)), c2, l2, u2, d2 = t(( () => {
  WK(),
  nr(),
  c2 = `electron-disable-drag`,
  l2 = (e=!1) => tr ? DG([`html:not(.`, `) &{-webkit-app-region:drag;`, `}`], c2, e ? DG([`& > *{-webkit-app-region:no-drag;}`]) : ``) : ``,
  u2 = () => tr ? DG([`-webkit-app-region:no-drag;`]) : ``
}
));
function f2() {
  let[e,t] = p2.useState(Xde);
  return p2.useEffect( () => {
      let e = window.matchMedia(m2)
        , n = () => {
          t(e.matches)
      }
      ;
      return e.addEventListener?.(`change`, n),
      () => {
          e.removeEventListener?.(`change`, n)
      }
  }
  , []),
  e
}
function Xde() {
  return typeof window > `u` ? !1 : window.matchMedia(m2).matches
}
var p2, m2, h2 = t(( () => {
  p2 = e(ht(), 1),
  m2 = `(prefers-reduced-motion: reduce)`
}
));
function g2(e) {
  let {type: t, zIndex: n, position: r, style: i, ...a} = e;
  return t === `transparent` ? (0,
  y2.jsx)(_2, {
      style: {
          ...i,
          zIndex: n,
          position: r,
          backgroundColor: `transparent`
      },
      ...a
  }) : (0,
  y2.jsx)(Zde, {
      ...e
  })
}
function Zde(e) {
  let {show: t, zIndex: n, style: r={}, type: i=`default`, animation: a=`default`, position: o=`absolute`} = e
    , s = f2()
    , c = 0;
  switch (i) {
  case `almost-transparent`:
      c = .05;
      break;
  case `semi-transparency`:
      c = .5;
      break;
  default:
      c = .95;
      break
  }
  let l = a === `quick` ? 2 : 1;
  return p(t, {
      config: (e, t, n) => ({
          duration: n === `leave` ? 280 / l : 400 / l,
          easing: o2.quadOut
      }),
      from: {
          opacity: 0
      },
      enter: {
          opacity: c
      },
      leave: {
          opacity: 0
      },
      immediate: s
  })( (t, i) => i ? (0,
  y2.jsx)(_2, {
      ...e,
      style: {
          ...t,
          ...r,
          zIndex: n,
          position: o
      }
  }) : null)
}
function _2(e) {
  let {show: t, zIndex: n, onClick: r, style: i, type: a, position: o, ...s} = e
    , c = v2.useContext(i2);
  return tr ? (0,
  y2.jsxs)(b2, {
      style: i,
      ...s,
      children: [(0,
      y2.jsx)(S2, {
          style: {
              height: c
          }
      }), (0,
      y2.jsx)(x2, {
          onClick: r,
          style: {
              height: `calc(100% - ${c}px)`
          }
      })]
  }) : (0,
  y2.jsx)(b2, {
      style: i,
      onClick: r,
      ...s
  })
}
var v2, y2, b2, x2, S2, C2 = t(( () => {
  v2 = e(ht(), 1),
  u(),
  WK(),
  a2(),
  nr(),
  s2(),
  d2(),
  h2(),
  n1(),
  y2 = e(f(), 1),
  b2 = HK(s.div)([`top:0px;left:0px;right:0px;bottom:0px;overflow:auto;background-color:`, `;will-change:opacity;`], Y$(`bgModalOverlay`)),
  x2 = HK.div([``, ``], u2()),
  S2 = HK.div([`pointer-events:all;`, `;`], l2(!0))
}
)), w2, T2, E2 = t(( () => {
  w2 = e(ht(), 1),
  T2 = w2.createContext(!1)
}
));
function D2() {
  return O2.useContext(T2)
}
var O2, k2 = t(( () => {
  O2 = e(ht(), 1),
  E2()
}
)), A2, j2, M2 = t(( () => {
  A2 = () => {
      let {activeElement: e} = window.document;
      return e ? j2(e) : !1
  }
  ,
  j2 = e => e === null || e instanceof HTMLTextAreaElement || e.contentEditable === `true` || e instanceof HTMLInputElement && ![`checkbox`, `radio`, `button`, `submit`, `reset`].includes(e.type) && !e.disabled
}
)), N2, P2, F2, I2 = t(( () => {
  N2 = e(ht(), 1),
  zt(),
  M2(),
  P2 = N2.createContext(null),
  F2 = class {
      constructor() {
          this.handleEvent = e => {
              let t = this.listenersForEventType(e.type)
                , n = e.target && j2(e.target);
              Mt( () => {
                  for (let r of t) {
                      if (e.defaultPrevented === !0 || e.target instanceof HTMLElement && e.target.hasAttribute(`data-prevent-global-listener`))
                          break;
                      (!n || r.runWithInputElementFocus) && r.callback(e)
                  }
              }
              )
          }
          ,
          this.keydownListeners = [],
          this.keyupListeners = []
      }
      addListeners(e, ...t) {
          for (let n of t)
              this.listenersForEventType(e).unshift(n);
          return () => {
              for (let n of t) {
                  let t = this.listenersForEventType(e).indexOf(n);
                  this.listenersForEventType(e).splice(t, 1)
              }
          }
      }
      attachGlobalEventListeners() {
          self.document.body.addEventListener(`keydown`, this.handleEvent),
          self.document.body.addEventListener(`keyup`, this.handleEvent)
      }
      removeGlobalEventListeners() {
          self.document.body.removeEventListener(`keydown`, this.handleEvent),
          self.document.body.removeEventListener(`keyup`, this.handleEvent)
      }
      listenersForEventType(e) {
          return e === `keydown` ? this.keydownListeners : e === `keyup` ? this.keyupListeners : []
      }
  }
}
)), L2, R2, Qde = t(( () => {
  L2 = e(ht(), 1),
  I2(),
  R2 = () => {
      let e = (0,
      L2.useContext)(P2);
      if (!e)
          throw Error(`Trying to call useKeyboardEventListeners outside KeyboardEventListenersContext`);
      return e
  }
}
));
function z2(e) {
  return `nativeEvent`in e ? e.nativeEvent instanceof KeyboardEvent : e instanceof KeyboardEvent
}
var B2, V2, H2, U2, W2 = t(( () => {
  B2 = e(ht(), 1),
  Qde(),
  V2 = e => typeof e == `function` ? e : typeof e == `string` ? t => t.key === e : e ? () => !0 : () => !1,
  H2 = (e, t, n, r) => {
      let i = R2()
        , a = B2.useMemo( () => V2(e), [e])
        , o = B2.useMemo( () => t ? [{
          callback: e => {
              z2(e) && a(e) && t(e)
          }
          ,
          runWithInputElementFocus: r?.runWithInputElementFocus || !1
      }] : [], [t, r?.runWithInputElementFocus])
        , s = B2.useMemo( () => n ? [{
          callback: e => {
              z2(e) && a(e) && n(e)
          }
          ,
          runWithInputElementFocus: r?.runWithInputElementFocus || !1
      }] : [], [n, r?.runWithInputElementFocus]);
      B2.useEffect( () => i.addListeners(`keydown`, ...o), [o]),
      B2.useEffect( () => i.addListeners(`keyup`, ...s), [s])
  }
  ,
  U2 = e => {
      let {targetKey: t, onKeyDown: n, onKeyUp: r, runWithInputElementFocus: i} = e;
      return H2(t, n, r, {
          runWithInputElementFocus: i
      }),
      null
  }
}
)), G2, K2, q2, J2, Y2 = t(( () => {
  G2 = e(ht(), 1),
  Nn(),
  On(),
  K2 = e(f(), 1),
  q2 = G2.createContext(null),
  J2 = Dn(function(e) {
      return (0,
      K2.jsx)(Mn, {
          node: G2.useContext(q2)?.current,
          children: e.children
      })
  })
}
)), X2, Z2, Q2 = t(( () => {
  X2 = class e {
      static isModKey(e, t=!1) {
          return t ? Z2() ? e.key === `Meta` : e.key === `Control` : Z2() ? e.metaKey : e.ctrlKey
      }
      static isComposing(e) {
          return `isComposing`in e && e.isComposing || `nativeEvent`in e && e.nativeEvent.isComposing || e.keyCode === 229
      }
      static isKey(t, n) {
          let r = e.isComposing(t);
          return t.key === n && !r
      }
      static isEscape(t) {
          return e.isKey(t, `Escape`)
      }
      static isEnter(t) {
          return e.isKey(t, `Enter`)
      }
      static isSpace(t) {
          return e.isKey(t, ` `)
      }
      static hasAnyModifier(e) {
          return e.ctrlKey || e.shiftKey || e.metaKey || e.altKey
      }
      static get systemModKeyText() {
          return Z2() ? `` : `Ctrl`
      }
      static get systemAltKeyText() {
          return Z2() ? `` : `Alt`
      }
  }
  ,
  Z2 = () => typeof window < `u` && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform)
}
));
function $2() {
  let e = D2();
  return {
      zIndexContainer: e ? U$.popoverInDialog : U$.popover,
      zIndexBackdrop: e ? U$.popoverBackdropInDialog : U$.popoverBackdrop
  }
}
function $de(e) {
  let {lifecycle: t, onClosed: n, children: i, enterDelay: a=0, exitDelay: o=0, immediate: c, initiallyImmediate: l, onRequestClose: u=t4.default, transformOrigin: d, component: f=s.div, wrapperComponent: p, style: m} = e
    , h = f2()
    , g = p
    , _ = P0(t)
    , ee = e4.useRef(!1)
    , te = e4.useRef(!1);
  ee.current === !1 && t === Z0.open && (te.current = !0),
  e4.useEffect( () => {
      t === Z0.closing && !ee.current && n?.()
  }
  , [t]);
  let ne = h || c || l && !te.current
    , re = r({
      config: {
          tension: t === Z0.closing ? 2e3 : 1500,
          friction: 100,
          precision: .01
      },
      from: {
          opacity: 0,
          scale: .98
      },
      to: t === Z0.open ? {
          opacity: 2,
          scale: 1
      } : t === Z0.closing ? {
          opacity: 0,
          scale: .98
      } : {},
      delay: t === Z0.open ? a : o,
      immediate: ne,
      onRest: () => {
          _.current === Z0.closing ? (n?.(),
          ee.current = !1) : _.current === Z0.open && (ee.current = !0)
      }
  })
    , ie = (0,
  n4.jsx)(f, {
      style: {
          opacity: re.opacity,
          transform: d ? re.scale.to(e => `scale(${e})`) : void 0,
          transformOrigin: d,
          pointerEvents: t === Z0.open ? void 0 : `none`,
          maxHeight: `var(${B0})`,
          overflow: `var(${V0})`,
          ...m
      },
      children: i({
          requestClose: u
      })
  });
  return g ? (0,
  n4.jsx)(g, {
      children: ie
  }) : ie
}
var e4, t4, n4, r4, i4, a4, o4 = t(( () => {
  e4 = e(ht(), 1),
  Nn(),
  u(),
  WK(),
  t4 = e(te(), 1),
  m$(),
  C2(),
  d2(),
  I0(),
  k2(),
  W2(),
  h2(),
  Y2(),
  Q2(),
  n2(),
  K0(),
  W$(),
  n4 = e(f(), 1),
  r4 = function(e) {
      let {lifecycle: t, disableClickAway: n=!1, disablePointerEvents: r=!1, disableEscape: i=!1, disableEventBoundary: a=!1, onRequestClose: o, contextualPortal: s, zIndex: c} = e
        , {zIndexContainer: l, zIndexBackdrop: u} = $2()
        , d = t === Z0.open ? e => {
          e.preventDefault(),
          o?.() || e.stopPropagation()
      }
      : void 0
        , f = e4.useRef(null)
        , p = p$([e.ref, f])
        , m = t === Z0.closed
        , [h,g] = e4.useState(void 0)
        , _ = e4.useMemo( () => ({
          maxHeight: h
      }), [h]);
      if (e4.useEffect( () => {
          let e = f.current;
          if (!e)
              return () => {}
              ;
          function t() {
              if (!e)
                  return;
              let t = e.style.getPropertyValue(B0);
              if (t) {
                  let e = parseFloat(t);
                  g(Number.isFinite(e) ? e : void 0)
              }
          }
          t();
          let n = new MutationObserver(e => {
              e.length > 0 && t()
          }
          );
          return n.observe(e, {
              attributeFilter: [`style`]
          }),
          () => {
              n.disconnect(),
              g(void 0)
          }
      }
      , [m]),
      m)
          return null;
      let ee = e => {
          `key`in e && e.key === `Escape` || a || e.stopPropagation()
      }
      ;
      return (0,
      n4.jsxs)(s ? J2 : Mn, {
          children: [i === !1 && d ? (0,
          n4.jsx)(U2, {
              targetKey: X2.isEscape,
              onKeyDown: d
          }) : null, n === !1 && d ? (0,
          n4.jsx)(g2, {
              "data-animated-popover-backdrop": !0,
              position: `fixed`,
              onContextMenu: d,
              type: `transparent`,
              onMouseDown: d,
              show: !0,
              zIndex: c ?? u
          }) : null, (0,
          n4.jsx)(i4, {
              onClick: ee,
              onPointerUp: ee,
              onPointerDown: ee,
              onMouseDown: ee,
              onContextMenu: ee,
              onKeyDown: ee,
              ref: p,
              $zIndex: c ?? l,
              $disablePointerEvents: r,
              "data-animated-popover-container": !0,
              children: (0,
              n4.jsx)(a4.Provider, {
                  value: _,
                  children: (0,
                  n4.jsx)($de, {
                      ...e
                  })
              })
          })]
      })
  }
  ,
  i4 = HK.div([`z-index:`, `;position:fixed;pointer-events:`, `;`, ``], e => e.$zIndex, e => e.$disablePointerEvents ? `none` : `auto`, u2()),
  a4 = e4.createContext(null)
}
)), s4 = t(( () => {
  n2(),
  o4(),
  K0()
}
));
function c4(e, t=[]) {
  return (0,
  l4.useMemo)( () => Bt(e), t).get()
}
var l4, u4 = t(( () => {
  l4 = e(ht(), 1),
  zt()
}
));
function efe(e, t) {
  Mt( () => {
      p4[e] = t
  }
  )
}
function tfe(e) {
  return p4[e]
}
var d4, f4, p4, m4 = t(( () => {
  d4 = e(ht(), 1),
  zt(),
  u4(),
  f4 = (e, t) => {
      let n = d4.useCallback(Ft(t => {
          p4[e] = t instanceof Function ? t(p4[e]) : t
      }
      ), [e]);
      return t !== void 0 && p4[e] === void 0 && n(t instanceof Function ? t() : t),
      [c4( () => p4[e], [e]), n]
  }
  ,
  p4 = Vt({})
}
)), h4, nfe = t(( () => {
  h4 = [`top`, `right`, `bottom`, `left`, `bottom-start`, `bottom-end`, `top-start`, `top-end`, `right-start`, `right-end`, `left-start`, `left-end`]
}
));
function rfe(e) {
  let {targetRef: t, popoverRef: n, interactive: r=!1, clickToOpen: i=!1, closeOnChildTooltip: a=!1, isChildTooltipActive: o=!1, transitionDelay: s, position: c=r ? `top-start` : `bottom`, onMouseEnter: l, onMouseLeave: u, onMouseDown: d, onContextMenu: f, onClick: p, onOpen: m, onClose: h, immediate: g, offset: _, observeMutations: ee, fallbackPositions: te, shouldOpen: ne= () => !0} = e
    , re = s ?? (r ? 550 : 450)
    , [ie,ae] = g4.useState(c)
    , [oe,se] = g4.useState(!1)
    , [ce,le] = g4.useState(!1)
    , ue = typeof _ == `function` ? _(ie) : _ ?? y4
    , de = g4.useRef(void 0);
  g4.useEffect( () => {
      de.current ||= os()
  }
  , []);
  let[fe,pe] = afe()
    , {onShow: me, onHide: he, popoverProps: ge, ref: v} = q0({
      targetRef: t,
      popoverRef: n,
      options: {
          strategy: `fixed`,
          onOpen: m,
          onClose: h,
          placement: c,
          observeMutations: ee,
          maxSizeOptions: {
              padding: x4
          },
          modifiers: [{
              name: `position-setter`,
              enabled: !0,
              phase: `main`,
              fn({state: e}) {
                  typeof e.placement == `string` && h4.includes(e.placement) ? ae(e.placement) : ae(c)
              }
          }, {
              name: `preventOverflow`,
              options: {
                  padding: x4
              }
          }, {
              name: `offset`,
              options: {
                  offset: r ? [0, 0] : [0, ue]
              }
          }, {
              name: `flip`,
              options: {
                  fallbackPlacements: te ?? ife(c, !!r)
              }
          }]
      }
  })
    , _e = P0(ge.lifecycle)
    , ve = P0(fe)
    , ye = P0(me)
    , be = P0(he)
    , xe = P0(ge.onClosed)
    , Se = P0(!!(a && o));
  g4.useEffect( () => {
      let e, n, r;
      if (ce)
          if (g !== `never` && (ve.current && (ve.current !== de.current || _e.current !== Z0.open) || g === !0)) {
              if (Se.current || !ne())
                  return;
              pe(de.current),
              ye.current()
          } else {
              let n = () => window.setTimeout( () => {
                  Se.current || !ne() || (pe(de.current),
                  me())
              }
              , re);
              e = n(),
              r = () => {
                  e !== void 0 && window.clearTimeout(e),
                  e = n()
              }
              ,
              t.current?.addEventListener(`mousemove`, r)
          }
      else
          fe === de.current ? be.current() : xe.current(),
          n = window.setTimeout( () => {
              Z0.open !== _e.current && ve.current === de.current && pe(e => {
                  if (e !== de.current)
                      return e
              }
              )
          }
          , 100);
      return () => {
          e !== void 0 && window.clearTimeout(e),
          n !== void 0 && window.clearTimeout(n),
          r != null && t.current?.removeEventListener(`mousemove`, r)
      }
  }
  , [ce, i]),
  g4.useEffect( () => {
      let e = !!(o && a);
      Se.current = e,
      e && we()
  }
  , [o, a]);
  let Ce = g4.useCallback(e => {
      se(!0),
      le(!0),
      l?.(e)
  }
  , [l])
    , we = g4.useCallback( () => {
      le(!1)
  }
  , [])
    , Te = g4.useCallback(e => {
      r && e.relatedTarget instanceof Node && n.current?.contains(e.relatedTarget) || (we(),
      u?.(e))
  }
  , [u])
    , Ee = g4.useCallback(e => {
      i || we(),
      d?.(e)
  }
  , [d, i])
    , De = g4.useCallback( () => {
      se(!0)
  }
  , [])
    , Oe = g4.useCallback(e => {
      i && ne() && (le(!0),
      se(!0),
      pe(de.current),
      me()),
      p?.(e)
  }
  , [i, me, p])
    , ke = g4.useMemo( () => r ? S4(ie, e => {
      e.relatedTarget instanceof Node && (n.current?.contains(e.relatedTarget) || t.current?.contains(e.relatedTarget)) || we()
  }
  , ue) : C4(), [ie, r, we])
    , Ae = fe !== void 0 && fe !== de.current
    , je = g4.useCallback( () => {
      he(),
      le(!1),
      se(!1)
  }
  , [he]);
  return {
      handleFocus: De,
      handleMouseEnter: Ce,
      handleMouseOut: Te,
      handleMouseDown: Ee,
      handleClick: Oe,
      handleKeyDown: e.onKeyDown,
      handleContextMenu: f,
      TooltipPopoverWithOffset: ke,
      hasHovered: oe,
      onHideRef: be,
      onShow: me,
      onHide: je,
      popoverProps: ge,
      shouldBeImmediate: Ae,
      currentPosition: ie,
      popperRef: v
  }
}
function ife(e, t) {
  return t ? [`top-start`, `top`, `bottom-start`, `bottom`] : e.includes(`top`) ? [`top`, `top-start`, `top-end`, `bottom`, `bottom-start`, `bottom-end`, `left`, `left-start`, `left-end`, `right`, `right-start`, `right-end`].filter(t => t !== e) : e.includes(`left`) ? [`left`, `left-start`, `left-end`, `right`, `right-start`, `right-end`, `bottom`, `bottom-start`, `bottom-end`, `top`, `top-start`, `top-end`].filter(t => t !== e) : e.includes(`right`) ? [`right`, `right-start`, `right-end`, `left`, `left-start`, `left-end`, `bottom`, `bottom-start`, `bottom-end`, `top`, `top-start`, `top-end`].filter(t => t !== e) : [`bottom`, `bottom-start`, `bottom-end`, `top`, `top-start`, `top-end`, `right`, `right-start`, `right-end`, `left`, `left-start`, `left-end`].filter(t => t !== e)
}
function afe() {
  return f4(`__usePopoverState__`)
}
var g4, _4, v4, y4, b4, x4, S4, C4, w4, T4, E4 = t(( () => {
  g4 = e(ht(), 1),
  WK(),
  ss(),
  s0(),
  m4(),
  I0(),
  nfe(),
  n2(),
  _4 = e(f(), 1),
  v4 = 450,
  y4 = 8,
  b4 = 4,
  x4 = 12,
  S4 = (e, t, n=b4) => r => {
      let {ref: i, ...a} = r;
      return (0,
      _4.jsx)(`div`, {
          style: T4(e, n),
          ref: i,
          onPointerLeave: t,
          children: (0,
          _4.jsx)(w4, {
              style: a.style,
              children: a.children
          })
      })
  }
  ,
  C4 = () => e => {
      let {ref: t, style: n, children: r} = e;
      return (0,
      _4.jsx)(w4, {
          style: n,
          ref: t,
          children: r
      })
  }
  ,
  w4 = HK(a0)([`border-radius:4px;box-shadow:`, `;&:empty{display:none;}`], e => e.theme.shadowLow),
  T4 = (e, t) => {
      switch (e) {
      case `top`:
      case `top-end`:
      case `top-start`:
          return {
              position: `relative`,
              paddingBottom: t,
              paddingTop: t
          };
      case `bottom`:
      case `bottom-end`:
      case `bottom-start`:
          return {
              position: `relative`,
              paddingTop: t,
              paddingBottom: t
          };
      case `left`:
      case `left-start`:
      case `left-end`:
          return {
              position: `relative`,
              paddingRight: t,
              paddingLeft: t
          };
      case `right`:
      case `right-start`:
      case `right-end`:
          return {
              position: `relative`,
              paddingLeft: t,
              paddingRight: t
          };
      default:
          return {}
      }
  }
}
));
function ofe(e) {
  let[t,n] = O4.useState(!0)
    , {popoverRef: r, targetRef: i} = e
    , a = r.current?.getBoundingClientRect()
    , o = i.current?.getBoundingClientRect();
  if (!t)
      return null;
  let s = {};
  if (a && o)
      switch (e.position) {
      case `top`:
      case `top-end`:
      case `top-start`:
          s = D4(a, [o.left, o.top], [o.right, o.top], `top`);
          break;
      case `bottom`:
      case `bottom-end`:
      case `bottom-start`:
          s = D4(a, [o.left, o.bottom], [o.right, o.bottom], `bottom`);
          break;
      case `left`:
      case `left-start`:
      case `left-end`:
          s = D4(a, [o.left, o.top], [o.left, o.bottom], `left`);
          break;
      case `right`:
      case `right-start`:
      case `right-end`:
          s = D4(a, [o.right, o.top], [o.right, o.bottom], `right`);
          break;
      default:
          break
      }
  return (0,
  k4.jsx)(`div`, {
      style: s,
      onPointerLeave: () => {
          n(!1)
      }
  })
}
function D4(e, t, n, r) {
  let[i,a] = t
    , [o,s] = n
    , c = {
      position: `absolute`
  };
  if (r === `left` || r === `right`) {
      let {top: t, height: n} = e;
      c.top = 0,
      c.bottom = 0,
      c.width = b4;
      let i = 100 * (a - t) / (n || 1)
        , o = 100 * (s - t) / (n || 1);
      r === `left` ? (c.right = -1 * b4,
      c.clipPath = `polygon(0 0, 100% ${i}%, 100% ${o}%, 0 100%)`) : r === `right` && (c.left = -1 * b4,
      c.clipPath = `polygon(0 ${i}%, 100% 0, 100% 100%, 0 ${o}%)`)
  } else if (r === `top` || r === `bottom`) {
      let {left: t, width: n} = e;
      c.left = 0,
      c.right = 0,
      c.height = b4;
      let a = 100 * (i - t) / (n || 1)
        , s = 100 * (o - t) / (n || 1);
      return r === `top` ? (c.bottom = -1 * b4,
      c.clipPath = `polygon(0 0, 100% 0, ${s}% 100%, ${a}% 100%)`) : r === `bottom` && (c.top = -1 * b4,
      c.clipPath = `polygon(${a}% 0, ${s}% 0, 100% 100%, 0 100%)`),
      c
  }
  return c
}
var O4, k4, sfe = t(( () => {
  O4 = e(ht(), 1),
  E4(),
  k4 = e(f(), 1)
}
)), A4, j4, M4 = t(( () => {
  WK(),
  A1(),
  s1(),
  n1(),
  A4 = {
      vertical: 5,
      horizontal: 8
  },
  j4 = HK(a1)([`padding:`, `px `, `px;font-size:`, `;max-width:520px;color:`, `;`], A4.vertical, A4.horizontal, D1(`micro`), Y$(`labelBase`))
}
));
function cfe(e) {
  let {contentFactory: t, hideShortcut: n, shortcut: r, maxWidth: i, contentStyle: a, interactive: o, triggerRef: s, absoluteChildren: c, title: l, truncateTitle: u, requestClose: d, popoverRef: f, popperRef: p, currentPosition: m} = e, h = n ? !1 : r, g = t?.({
      requestClose: d,
      popperRef: p,
      title: l,
      shortcut: h ? r : void 0
  }), _;
  return g === void 0 ? (l || h) && (_ = (0,
  P4.jsxs)(P4.Fragment, {
      children: [l ? (0,
      P4.jsx)(z4, {
          maxWidth: i,
          $truncateTitle: u,
          children: l
      }) : null, h ? r : null]
  })) : _ = typeof g == `string` ? (0,
  P4.jsxs)(P4.Fragment, {
      children: [(0,
      P4.jsx)(z4, {
          maxWidth: i,
          $truncateTitle: u,
          children: g
      }), h ? r : null]
  }) : g,
  _ === void 0 ? null : (0,
  P4.jsxs)(j4, {
      gap: 8,
      align: `center`,
      onContextMenu: e => e.stopPropagation(),
      style: a,
      children: [_, o ? (0,
      P4.jsx)(L4, {
          delay: 10,
          children: c ? (0,
          P4.jsx)(k0, {
              parentRef: f
          }) : (0,
          P4.jsx)(ofe, {
              popoverRef: f,
              targetRef: s,
              position: m
          })
      }) : null]
  })
}
var N4, P4, F4, I4, L4, R4, z4, B4, V4 = t(( () => {
  N4 = e(ht(), 1),
  WK(),
  On(),
  N0(),
  s4(),
  ir(),
  W2(),
  M2(),
  w0(),
  W$(),
  T1(),
  o4(),
  sfe(),
  E4(),
  M4(),
  P4 = e(f(), 1),
  F4 = function(e) {
      return (0,
      P4.jsx)(B4, {
          fallback: () => (0,
          P4.jsx)(P4.Fragment, {
              children: e.children
          }),
          children: (0,
          P4.jsx)(I4, {
              ...e
          })
      })
  }
  ,
  I4 = Dn(function(e) {
      let {clickToOpen: t, methodsRef: n, triggerRef: r, handlersRef: i, calculatedTitle: a, skipOptimization: o, interactive: s, isOpen: c, delayMs: l} = e
        , u = N4.useContext(C0)
        , d = N4.useRef(null)
        , {onHideRef: f, hasHovered: p, onShow: m, onHide: h, TooltipPopoverWithOffset: g, shouldBeImmediate: _, popoverProps: ee, currentPosition: te, popperRef: ne, ...re} = rfe({
          ...e,
          targetRef: r,
          popoverRef: d
      });
      N4.useEffect( () => {
          c === !0 ? m() : c === !1 && h()
      }
      , [c, m, h]),
      H2(R4, e => {
          e.target && j2(e.target) && f.current?.()
      }
      , void 0, {
          runWithInputElementFocus: !0
      }),
      N4.useEffect( () => {
          if (!(t && rr.isPureTouchDevice) || ee.lifecycle !== Z0.open)
              return;
          let e = e => {
              !d.current?.contains(e.target) && !r.current?.contains(e.target) && h()
          }
          ;
          return self.document.addEventListener(`click`, e, {
              capture: !0
          }),
          () => self.document.removeEventListener(`click`, e, {
              capture: !0
          })
      }
      , [t, rr.isPureTouchDevice, h, ee.lifecycle]);
      let ie = N4.useMemo( () => u.debuggingEnabled ? {
          ...re,
          handleMouseEnter: e => {
              re.handleMouseEnter?.(e),
              u.onTooltipActivated(typeof o == `string` ? o : `userInteraction`)
          }
          ,
          handleMouseOut: e => {
              re.handleMouseOut?.(e),
              u.onTooltipActivated(null)
          }
      } : re, [u.debuggingEnabled, u, re]);
      return N4.useImperativeHandle(n, () => ({
          hide: h,
          show: m
      }), [h, m]),
      N4.useImperativeHandle(i, () => ie, [ie]),
      (0,
      P4.jsx)(r4, {
          ref: d,
          onRequestClose: h,
          immediate: _,
          enterDelay: c === void 0 ? void 0 : l,
          disableClickAway: !0,
          component: g,
          zIndex: U$.tooltip,
          disablePointerEvents: !s,
          style: e.tooltipStyle,
          ...ee,
          children: () => (0,
          P4.jsx)(cfe, {
              ...e,
              title: a,
              requestClose: h,
              popoverRef: d,
              popperRef: ne,
              currentPosition: te
          })
      })
  }),
  L4 = e => {
      let[t,n] = N4.useState(!1);
      return N4.useEffect( () => {
          let t = setTimeout( () => n(!0), e.delay);
          return () => clearTimeout(t)
      }
      , [e.delay]),
      t ? (0,
      P4.jsx)(P4.Fragment, {
          children: e.children
      }) : null
  }
  ,
  R4 = () => !0,
  z4 = HK(`div`)([``, ` `, ` font-weight:`, `;`], e => e.$truncateTitle ? h1() : ``, e => e.maxWidth && `max-width: ${e.maxWidth}px;`, u1(`normal`)),
  B4 = class extends N4.Component {
      constructor(e) {
          super(e),
          this.state = {
              error: !1
          }
      }
      componentDidCatch() {
          this.setState({
              error: !0
          })
      }
      render() {
          return this.state.error ? this.props.fallback() : this.props.children
      }
  }
}
)), H4, U4, W4, G4, K4, q4, J4 = t(( () => {
  H4 = e(ht(), 1),
  On(),
  WK(),
  Za(),
  m$(),
  ir(),
  w0(),
  s1(),
  V4(),
  U4 = e(f(), 1),
  W4 = 400,
  G4 = Dn(function(e) {
      let {ref: t, TooltipComponent: n=F4, skipOptimization: r, onClick: i, onKeyDown: a, disableTooltipOnTouch: o=!0, isOpen: s} = e
        , c = H4.useRef(void 0)
        , l = H4.useRef(void 0)
        , u = H4.useRef(void 0)
        , d = H4.useRef(null)
        , [f,p] = H4.useState(s !== void 0 || !!r)
        , [m,h] = H4.useState(!1)
        , g = H4.useCallback( () => {
          u.current !== void 0 && clearTimeout(u.current),
          u.current = setTimeout( () => {
              r || (p(!1),
              h(!1))
          }
          , W4)
      }
      , [r])
        , _ = H4.useCallback(e => {
          u.current !== void 0 && (clearTimeout(u.current),
          u.current = void 0),
          p(!0),
          l.current = e
      }
      , [])
        , ee = H4.useCallback( () => {
          u.current !== void 0 && (clearTimeout(u.current),
          u.current = void 0),
          p(!1),
          h(!1)
      }
      , [])
        , te = H4.useCallback(e => {
          let t = self.document.getElementById(`root`);
          !e.target.contains(e.relatedTarget) && t?.contains(e.relatedTarget) && g()
      }
      , []);
      H4.useEffect( () => () => {
          u.current !== void 0 && (clearTimeout(u.current),
          u.current = void 0)
      }
      , [r]),
      H4.useEffect( () => {
          if (!m)
              return;
          let e = l.current
            , t = c.current;
          e?.nativeEvent instanceof FocusEvent ? t?.handleFocus?.(e) : e?.nativeEvent instanceof MouseEvent && t?.handleMouseEnter?.(e),
          l.current = void 0
      }
      , [m]);
      let ne = [`aria-label`, `role`, `tabIndex`, `className`].filter(t => typeof e[t] == `string` || typeof e[t] == `number`);
      ne.push(`style`);
      let re = Object.fromEntries(Object.entries(e).filter( ([e]) => ne.includes(e) || e.startsWith(`data-`)))
        , ie = Object.fromEntries(Object.entries(e).filter( ([e]) => i1.includes(e)))
        , ae = Xa(e.title, {
          hasHovered: m
      })
        , oe = !e.clickToOpen && o && rr.isPureTouchDevice
        , se = e.disabled || oe
        , ce = H4.useMemo( () => se || s !== void 0 ? {
          onClick: i,
          onKeyDown: a
      } : m ? {
          onFocus: e => c.current?.handleFocus?.(e),
          onPointerEnter: e => c.current?.handleMouseEnter?.(e),
          onPointerLeave: e => c.current?.handleMouseOut?.(e),
          onPointerDown: e => c.current?.handleMouseDown?.(e),
          onContextMenu: e => c.current?.handleContextMenu?.(e),
          onClick: e => c.current?.handleClick?.(e),
          onKeyDown: e => c.current?.handleKeyDown?.(e),
          onBlur: te
      } : {
          onPointerEnter: _,
          onPointerLeave: ee,
          onPointerDown: _,
          onFocus: _,
          onClick: i,
          onKeyDown: a,
          onBlur: ee
      }, [se, s, i, a, m, _, ee, te]);
      return (0,
      U4.jsxs)(U4.Fragment, {
          children: [(0,
          U4.jsx)(K4, {
              ...re,
              ...e.as ? {} : ie,
              ...e.triggerProps,
              ...ce,
              noAriaLabel: e.noAriaLabel,
              onAuxClick: e.onAuxClick,
              as: e.as ?? e.triggerProps?.as,
              isOptimized: !m && !f,
              ref: p$([d, t]),
              tooltipTitle: typeof ae == `string` ? ae : void 0,
              triggerDisabled: e.triggerDisabled,
              children: e.children
          }), f && !se ? (0,
          U4.jsx)(n, {
              ...e,
              handlersRef: e => {
                  e && (c.current = e,
                  h(!0))
              }
              ,
              calculatedTitle: ae,
              onMouseLeave: t => {
                  e.onMouseLeave?.(t),
                  g()
              }
              ,
              onMouseEnter: t => {
                  e.onMouseEnter?.(t),
                  clearTimeout(u.current)
              }
              ,
              triggerRef: d
          }) : null]
      })
  }),
  K4 = e => {
      let {isOptimized: t, tooltipTitle: n, children: r, as: i=a1, triggerDisabled: a, noAriaLabel: o, ...s} = e
        , c = wG()
        , l = H4.useContext(C0)
        , u = r
        , d = []
        , f = H4.isValidElement(r)
        , p = o ? void 0 : e[`aria-label`] ?? n;
      f && p && !r.props[`aria-label`] && d.push([`aria-label`, p]),
      f && a && d.push([`disabled`, !0]),
      f && d.length > 0 && (u = H4.cloneElement(r, Object.fromEntries(d)));
      let m = l.debuggingEnabled ? {
          ...e.style,
          outlineOffset: `-0.5px`,
          outline: `1px ${t ? `dashed` : `solid`} ${t ? c.color.purpleBg : c.color.purpleBaseHover}`
      } : e.style;
      return (0,
      U4.jsx)(q4, {
          ...s,
          as: i,
          children: u,
          "aria-label": f ? void 0 : p,
          style: m,
          "data-disabled": e.triggerDisabled ? `true` : void 0
      })
  }
  ,
  q4 = HK.div([`& > button[disabled]{pointer-events:none;}`])
}
)), Y4, X4, lfe = t(( () => {
  Y4 = e(ht(), 1),
  X4 = () => {
      let[e,t] = Y4.useState(!1);
      return {
          isChildTooltipActive: e,
          childTooltipProps: {
              onOpen: () => t(!0),
              onClose: () => t(!1)
          }
      }
  }
}
)), Z4 = t(( () => {
  J4(),
  M4(),
  V4(),
  lfe()
}
)), Q4, $4, e3, t3 = t(( () => {
  ht(),
  WK(),
  A1(),
  n1(),
  d2(),
  Q4 = e(f()),
  $4 = e => (0,
  Q4.jsx)(e3, {
      type: `button`,
      onKeyDown: e.onClick === void 0 ? void 0 : t => {
          t.key === `Enter` && !t.metaKey && !t.shiftKey && !t.ctrlKey && !t.altKey && (e.onClick?.(t),
          t.preventDefault(),
          t.stopPropagation())
      }
      ,
      ...e
  }),
  e3 = HK(`button`)([``, ` color:`, `;user-select:none;cursor:var(--pointer);display:inline;background:transparent;margin:0;padding:0;border:0;border-radius:2px;text-align:left;transition-property:color;transition-duration:`, `;&:hover{transition-duration:`, `;}&:`, `,&:`, ` `, `{color:`, `;}& svg,& `, `{transition-property:color,fill;transition-duration:`, `;}&:hover svg,&:hover `, `{transition-duration:`, `;}`], u2(), Y$(`labelLink`), $$(`highlightFadeOut`), $$(`highlightFadeIn`), J$, J$, O1, Y$(`labelTitle`), O1, $$(`highlightFadeOut`), O1, $$(`highlightFadeIn`))
}
)), n3, r3 = t(( () => {
  n3 = function(e) {
      return e[e.info = 0] = `info`,
      e[e.success = 1] = `success`,
      e[e.warning = 2] = `warning`,
      e[e.error = 3] = `error`,
      e[e.tip = 4] = `tip`,
      e[e.process = 5] = `process`,
      e
  }({})
}
));
function i3(e) {
  if (Array.isArray(e)) {
      if (e.length === 0)
          return e;
      let[t,...n] = e;
      return [{
          ...t,
          divider: !0
      }, ...n]
  }
  return {
      ...e,
      divider: !0
  }
}
function a3() {
  return ++c3
}
function ufe(e) {
  return e !== void 0 && `id`in e
}
var o3, s3, c3, l3, u3, d3 = t(( () => {
  o3 = (e, t) => ({
      ...e,
      name: t
  }),
  s3 = (e, t) => ({
      ...e,
      keyboardShortcut: t
  }),
  c3 = 0,
  l3 = function(e) {
      return e.auto = `auto`,
      e.zero = `zero`,
      e
  }({}),
  u3 = {
      minSearchInputLength: 2
  }
}
));
function f3(e) {
  return (0,
  p3.jsx)(XK, {
      ...e,
      children: (0,
      p3.jsx)(`svg`, {
          children: (0,
          p3.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M1.32698 2.63803C1 3.27976 1 4.11984 1 5.8V10.2C1 11.8802 1 12.7202 1.32698 13.362C1.6146 13.9265 2.07354 14.3854 2.63803 14.673C3.27976 15 4.11984 15 5.8 15H10.2C11.8802 15 12.7202 15 13.362 14.673C13.9265 14.3854 14.3854 13.9265 14.673 13.362C15 12.7202 15 11.8802 15 10.2V5.8C15 4.11984 15 3.27976 14.673 2.63803C14.3854 2.07354 13.9265 1.6146 13.362 1.32698C12.7202 1 11.8802 1 10.2 1H5.8C4.11984 1 3.27976 1 2.63803 1.32698C2.07354 1.6146 1.6146 2.07354 1.32698 2.63803ZM10.8272 10.8354C10.7574 10.9052 10.6855 10.972 10.6119 11.0356L4.96436 5.38807C5.028 5.31448 5.09476 5.24265 5.16465 5.17276C6.72833 3.60908 9.26356 3.60908 10.8272 5.17276C12.3909 6.73644 12.3909 9.27167 10.8272 10.8354ZM4.6101 5.86502L10.135 11.3899C9.95994 11.5007 9.77818 11.5966 9.59151 11.6776L4.32236 6.40849C4.40338 6.22182 4.49929 6.04006 4.6101 5.86502ZM8.9709 11.8882L4.11177 7.0291C4.05264 7.26564 4.01538 7.50652 4 7.74854L8.25146 12C8.49348 11.9846 8.73436 11.9474 8.9709 11.8882ZM4.03909 8.61883L7.38117 11.9609C6.56983 11.8355 5.78964 11.4603 5.16465 10.8354C4.53966 10.2104 4.16447 9.43017 4.03909 8.61883Z`
          })
      })
  })
}
var p3, m3 = t(( () => {
  ht(),
  QK(),
  p3 = e(f(), 1)
}
)), h3, g3 = t(( () => {
  cn(),
  h3 = new Lee(`fileUploadPlugin`)
}
));
function _3(e, t) {
  if (!e || !t)
      return;
  let n = y3.get(e);
  n && y3.set(t, n)
}
function dfe(e) {
  return new Promise(t => {
      if (rr.isSafari) {
          t(void 0);
          return
      }
      try {
          let n = self.document.createElement(`video`);
          n.muted = !0,
          n.preload = `auto`;
          let r = () => {
              let e = n.videoWidth
                , r = n.videoHeight;
              if (!e || !r) {
                  a(),
                  t(void 0);
                  return
              }
              let i = self.document.createElement(`canvas`);
              i.width = e,
              i.height = r;
              let o = i.getContext(`2d`);
              if (!o) {
                  a(),
                  t(void 0);
                  return
              }
              o.drawImage(n, 0, 0, e, r);
              try {
                  let e = i.toDataURL(`image/jpeg`, .8);
                  a(),
                  t(e)
              } catch {
                  a(),
                  t(void 0)
              }
          }
            , i = () => {
              a(),
              t(void 0)
          }
            , a = () => {
              n.removeEventListener(`loadeddata`, r),
              n.removeEventListener(`error`, i)
          }
          ;
          n.addEventListener(`loadeddata`, r, {
              once: !0
          }),
          n.addEventListener(`error`, i, {
              once: !0
          }),
          n.src = e
      } catch {
          t(void 0)
      }
  }
  )
}
var v3, y3, b3 = t(( () => {
  ir(),
  v3 = class e {
      static MAX_ENTRIES = 10;
      map = new Map;
      get(e) {
          if (e)
              return this.map.get(e)
      }
      set(t, n) {
          if (!this.map.has(t) && this.map.size >= e.MAX_ENTRIES) {
              let e = this.map.keys().next().value;
              e !== void 0 && this.map.delete(e)
          }
          this.map.set(t, n)
      }
      delete(e) {
          e && this.map.delete(e)
      }
  }
  ,
  y3 = new v3
}
)), x3, S3 = t(( () => {
  x3 = class {
      static inMemoryStore = new Map;
      static set(e, t, n) {
          if (n === void 0)
              return this.inMemoryStore.set(t, e),
              !0;
          try {
              let r = this.getEditorData();
              return r[`${t}-${n}`] = e,
              this.saveEditorData(r)
          } catch {
              return !1
          }
      }
      static get(e, t) {
          return t === void 0 ? this.inMemoryStore.get(e) : this.getEditorData()[`${e}-${t}`]
      }
      static remove(e, t) {
          if (t === void 0)
              return this.inMemoryStore.delete(e);
          let n = `${e}-${t}`
            , r = this.getEditorData();
          return n in r ? (delete r[n],
          this.saveEditorData(r)) : !1
      }
      static clearInMemoryStore() {
          this.inMemoryStore.clear()
      }
      static EDITOR_KEY = `Editor`;
      static getEditorData() {
          try {
              let e = localStorage.getItem(this.EDITOR_KEY);
              return e ? JSON.parse(e) : {}
          } catch {
              return {}
          }
      }
      static saveEditorData(e) {
          try {
              return localStorage.setItem(this.EDITOR_KEY, JSON.stringify(e)),
              !0
          } catch {
              return !1
          }
      }
  }
}
)), C3, w3 = t(( () => {
  S3(),
  C3 = class {
      static STORAGE_NAMESPACE = `uploads-attribution`;
      static STORAGE_ID = `v1`;
      static MAX_AGE_MS = 1440 * 60 * 1e3;
      static now() {
          return Date.now()
      }
      static read() {
          let e = x3.get(this.STORAGE_NAMESPACE, this.STORAGE_ID) ?? {
              byUploadId: {}
          };
          return {
              byUploadId: e.byUploadId ?? {},
              activeByUploadId: e.activeByUploadId ?? {},
              lastCleanupAt: e.lastCleanupAt
          }
      }
      static write(e) {
          x3.set(e, this.STORAGE_NAMESPACE, this.STORAGE_ID)
      }
      static cleanupIfNeeded(e) {
          let t = this.now();
          if (e.lastCleanupAt && t - e.lastCleanupAt < 300 * 1e3)
              return e;
          let n = t - this.MAX_AGE_MS
            , r = {
              byUploadId: {},
              activeByUploadId: {},
              lastCleanupAt: t
          };
          for (let[t,i] of Object.entries(e.byUploadId))
              i > n && (r.byUploadId[t] = i);
          for (let[t,i] of Object.entries(e.activeByUploadId ?? {}))
              i > n && (r.activeByUploadId[t] = i);
          return this.write(r),
          r
      }
      static recordStart(e) {
          let t = this.now()
            , n = this.cleanupIfNeeded(this.read());
          e.uploadId && (n.byUploadId[e.uploadId] = t),
          this.write({
              ...n,
              lastCleanupAt: t
          })
      }
      static markActive(e) {
          let t = this.read()
            , n = {
              ...t.activeByUploadId ?? {}
          };
          n[e] = this.now(),
          this.write({
              ...t,
              activeByUploadId: n
          })
      }
      static clearActive(e) {
          let t = this.read();
          if (t.activeByUploadId && e in t.activeByUploadId) {
              let n = {
                  ...t.activeByUploadId
              };
              delete n[e],
              this.write({
                  ...t,
                  activeByUploadId: n
              })
          }
      }
      static clearUpload(e) {
          if (!e)
              return;
          let t = this.read()
            , n = {
              byUploadId: {
                  ...t.byUploadId
              },
              activeByUploadId: {
                  ...t.activeByUploadId ?? {}
              },
              lastCleanupAt: t.lastCleanupAt
          };
          delete n.byUploadId[e],
          n.activeByUploadId && delete n.activeByUploadId[e],
          this.write(n)
      }
      static isActiveGlobal(e, t=5e3) {
          if (!e)
              return !1;
          let n = this.read().activeByUploadId?.[e];
          return typeof n == `number` && this.now() - n <= t
      }
      static isLocal(e) {
          let t = this.cleanupIfNeeded(this.read())
            , n = this.now() - this.MAX_AGE_MS;
          return !!(e.uploadId && t.byUploadId[e.uploadId] && t.byUploadId[e.uploadId] > n)
      }
      static getUploadTimestampMsFromId(e) {
          if (!e)
              return;
          let t = String(e)
            , n = (t.startsWith(`Symbol(`) && t.endsWith(`)`) ? t.slice(7, -1) : t).match(/upload-(\d+)-/);
          if (n && n[1]) {
              let e = Number(n[1]);
              return Number.isFinite(e) ? e : void 0
          }
      }
  }
}
)), T3, E3 = t(( () => {
  g3(),
  b3(),
  Uy(),
  w3(),
  T3 = class e {
      static instance = new e;
      subscribers = new Map;
      activeUploadIds = new Set;
      cachedData = new Map;
      unloadHandlerAttached = !1;
      updateCachedData(e, t) {
          let n = this.cachedData.get(e);
          n ? this.cachedData.set(e, {
              ...n,
              ...t
          }) : this.cachedData.set(e, t)
      }
      attachUnloadHandlerIfNeeded() {
          if (this.unloadHandlerAttached || typeof self > `u`)
              return;
          let e = () => {
              for (let e of this.activeUploadIds)
                  C3.clearActive(e)
          }
          ;
          self.addEventListener(`beforeunload`, e),
          self.addEventListener(`pagehide`, e),
          this.unloadHandlerAttached = !0
      }
      computeInsertPos(e, t) {
          let n = e.resolve(t)
            , r = n.parent;
          return r.type.name === `paragraph` && r.content.size === 0 ? n.before(n.depth) : n.pos
      }
      onProgress(e, t) {
          this.updateCachedData(e, {
              progress: t
          }),
          this.subscribers.get(e)?.forEach(e => e.onProgress?.(t)),
          C3.markActive(e)
      }
      onUrlLoaded(e, t) {
          this.updateCachedData(e, {
              assetUrl: t
          }),
          this.subscribers.get(e)?.forEach(e => e.onUrlLoaded?.(t)),
          C3.markActive(e)
      }
      onPreviewInfoLoaded(e, t) {
          this.updateCachedData(e, {
              previewInfo: t
          }),
          this.subscribers.get(e)?.forEach(e => e.onPreviewInfoLoaded?.(t)),
          C3.markActive(e)
      }
      onFinished(e) {
          this.subscribers.get(e)?.forEach(e => e.onFinished?.()),
          C3.clearUpload(e),
          this.activeUploadIds.delete(e),
          this.cachedData.delete(e)
      }
      subscribe(e, t) {
          this.subscribers.set(e, [...this.subscribers.get(e) ?? [], t]);
          let {previewInfo: n, assetUrl: r, progress: i} = this.cachedData.get(e) ?? {};
          i !== void 0 && t.onProgress?.(i),
          n && t.onPreviewInfoLoaded?.(n),
          r && t.onUrlLoaded?.(r)
      }
      registerActiveUpload(e) {
          this.activeUploadIds.add(e),
          C3.markActive(e),
          this.attachUnloadHandlerIfNeeded()
      }
      isRegistered(e) {
          return this.activeUploadIds.has(e)
      }
      unregisterActiveUpload(e) {
          C3.isActiveGlobal(e) || (this.activeUploadIds.delete(e),
          this.cachedData.delete(e),
          C3.clearActive(e))
      }
      isUploadActive(e) {
          return C3.isActiveGlobal(e)
      }
      getCachedProgress(e) {
          return this.cachedData.get(e)?.progress
      }
      hasActiveUploads() {
          return this.activeUploadIds.size > 0
      }
      insertEntriesAndSerialize(e) {
          let {state: t, entries: n} = e
            , r = t.tr;
          for (let {uploadId: e, extension: i, attributes: a, position: o, assetUrl: s, metadataId: c} of n) {
              let n = i?.name
                , l = a ?? {}
                , u = i?.assetUrlAttribute
                , d = u ? l[u] : void 0;
              if (u && s && (l[u] = s),
              c && (l.metadataId = c),
              !n)
                  continue;
              let f = t.schema.nodes[n];
              if (!f)
                  continue;
              i?.name === `video` && d && s && _3(d, s);
              let p = null;
              if (r.doc.descendants( (t, n) => t.attrs && t.attrs.uploadId === e ? (p = n,
              !1) : !0),
              p !== null) {
                  let e = r.doc.nodeAt(p);
                  if (e) {
                      let t = {
                          ...e.attrs,
                          ...l,
                          uploadState: `finished`
                      };
                      r = r.setNodeMarkup(p, e.type, t)
                  }
              } else {
                  let e = r.mapping.map(o)
                    , t = f.create(l)
                    , n = this.computeInsertPos(r.doc, e);
                  r = r.insert(n, t)
              }
              h3 && (r = r.setMeta(h3, {
                  type: `finished`,
                  uploadId: e
              }))
          }
          return t.apply(r).doc.toJSON()
      }
      removeSubscribers(e) {
          for (let[t] of e)
              this.subscribers.delete(t),
              this.cachedData.delete(t)
      }
      async enqueue({state: e, currentlyUploading: t=new Map, onEnqueued: n, onSuccess: r, onFailure: i}) {
          if (!t || t.size === 0) {
              r(e.doc.toJSON());
              return
          }
          n?.();
          let a = Array.from(t.entries()).map( ([e,t]) => ({
              uploadId: e,
              promise: t.resolver
          }));
          try {
              let n = await Promise.all(a.map(e => e.promise))
                , i = a.map( ({uploadId: e}, r) => {
                  let i = t.get(e);
                  if (!i)
                      throw Error(`Could not retrieve data for uploaded file`);
                  let a = n[r];
                  if (!a || !a?.url)
                      throw Error(`Could not retrieve url for uploaded file`);
                  return {
                      uploadId: e,
                      extension: i.extension,
                      attributes: i.attributes,
                      position: i.position,
                      assetUrl: a.url,
                      metadataId: a.metadataId
                  }
              }
              ).sort( (e, t) => t.position - e.position);
              await Promise.all(i.map(async e => {
                  if (e.extension?.preloadAsset)
                      try {
                          await e.extension.preloadAsset(e.assetUrl)
                      } catch {}
              }
              )),
              i.forEach( ({uploadId: e}) => this.onFinished(e)),
              await new Promise(e => setTimeout(e, 200));
              let o = By(this.insertEntriesAndSerialize({
                  state: e,
                  entries: i
              }));
              this.removeSubscribers(t),
              i.forEach( ({uploadId: e}) => this.unregisterActiveUpload(e)),
              r(o)
          } catch (n) {
              Array.from(t.entries()).forEach( ([e,t]) => {
                  t.abortController && !t.abortController.signal.aborted && t.abortController.abort(`automatic`),
                  this.unregisterActiveUpload(e)
              }
              ),
              this.removeSubscribers(t),
              i(By(e.doc.toJSON()), n)
          }
      }
  }
}
)), D3, O3 = t(( () => {
  D3 = class {
      static downloadFile(e, t) {
          let n = self.document.createElement(`a`)
            , r = new URL(e);
          r.searchParams.append(`download`, `true`),
          n.setAttribute(`href`, r.toString()),
          n.setAttribute(`download`, t ?? ``),
          n.setAttribute(`target`, `_self`),
          n.style.visibility = `hidden`,
          self.document.body.appendChild(n),
          this._isDownloading = !0,
          n.click(),
          this._isDownloading = !1,
          self.document.body.removeChild(n)
      }
      static downloadLocalFile(e) {
          let t = self.document.createElement(`a`)
            , n = URL.createObjectURL(e);
          t.href = n,
          t.download = e.name,
          self.document.body.appendChild(t),
          t.click(),
          self.document.body.removeChild(t),
          window.URL.revokeObjectURL(n)
      }
      static get isDownloading() {
          return this._isDownloading
      }
      static #e = this._isDownloading = !1
  }
}
)), k3, A3, j3 = t(( () => {
  ir(),
  k3 = rr.isPureTouchDevice ? 36 : 28,
  A3 = `activeSidebarLinkPath`
}
));
function M3(e, t) {
  let n = P3.useRef(!1);
  P3.useImperativeHandle(t, () => ({
      async disable(e) {
          if (n.current = !0,
          e)
              try {
                  await e()
              } catch (e) {
                  throw n.current = !1,
                  e
              }
      },
      enable() {
          n.current = !1
      }
  })),
  hfe(e, n),
  gfe(e, n)
}
function ffe() {
  pfe(),
  mfe(),
  _fe()
}
function pfe() {
  let e = P3.useContext(H3)
    , t = Zt()
    , [,n] = f4(A3);
  P3.useEffect( () => {
      if (!s$.hasNewDesktopQuitCloseRefreshBehaviour)
          return;
      function r(r, i, a) {
          return o => {
              if (a?.()) {
                  r(o);
                  return
              }
              let s = e.resolveBlockers({
                  type: `unload`,
                  reason: i,
                  currentLocation: t
              });
              s ? s$.bridge.confirm(s).then(e => {
                  e ? r(o) : n(void 0)
              }
              ) : r(o)
          }
      }
      let i = () => {
          X3.instance.tabs.length > 1 ? X3.instance.closeTab(X3.instance.activeTabId) : s$.bridge.closeWindow()
      }
        , a = () => !!(rr.isMac && X3.instance.tabs.length <= 1)
        , o = r(e => {
          let t = e?.detail?.href;
          if (t)
              window.location.href = t;
          else
              throw Error(`Missing href in workspace-switch event`)
      }
      , `workspace-switch`)
        , s = r( () => s$.bridge.quit(), `quit`)
        , c = r( () => s$.bridge.closeWindow(), `close-window`, () => rr.isMac)
        , l = r(i, `close-tab`, a)
        , u = r(i, `close-tab`, a)
        , d = r( () => s$.bridge.reload(), `reload`);
      return window.addEventListener(`workspace-switch`, o),
      window.addEventListener(`close-active-tab`, u),
      e$.subscribe(s),
      t$.subscribe(l),
      n$.subscribe(c),
      r$.subscribe(d),
      s$.bridge.clientLifecycleEvents(!0),
      () => {
          s$.bridge.clientLifecycleEvents(!1),
          window.removeEventListener(`workspace-switch`, o),
          window.removeEventListener(`close-active-tab`, u),
          e$.unsubscribe(s),
          t$.unsubscribe(l),
          n$.unsubscribe(c),
          r$.unsubscribe(d)
      }
  }
  , [t, e])
}
function mfe() {
  let e = P3.useContext(H3)
    , [,t] = f4(A3)
    , n = P3.useRef(void 0)
    , r = Eee(t => {
      let r = e.resolveBlockers({
          type: `navigation`,
          ...t
      });
      return t.currentLocation.pathname === t.nextLocation.pathname ? (n.current = void 0,
      !1) : r ? (I3.fire(),
      n.current = r,
      !0) : (n.current = void 0,
      !1)
  }
  );
  P3.useEffect( () => {
      r.state === `blocked` && new x$({
          title: n.current || B3,
          confirmButtonTitle: `Confirm`,
          confirmButtonType: `dangerous`
      }).show().then(async e => {
          e === b$.confirm ? r.proceed?.() : (r.reset?.(),
          t(void 0))
      }
      )
  }
  , [r.state])
}
function hfe(e, t) {
  let n = P3.useContext(H3);
  P3.useEffect( () => {
      if (!e.when || e.promptOnlyForUnload)
          return;
      let r = {
          when: e.when,
          message: e.message,
          disabled: t
      };
      return n.add(r),
      () => {
          n.remove(r)
      }
  }
  , [e.when, e.message, e.promptOnlyForUnload])
}
function gfe(e, t) {
  let n = Zt()
    , r = P3.useContext(H3);
  P3.useEffect( () => {
      if (!s$.hasNewDesktopQuitCloseRefreshBehaviour || !e.when || !e.promptOnlyForUnload)
          return;
      let n = {
          when: e.when,
          message: e.message,
          disabled: t,
          promptOnlyForUnload: !0
      };
      return r.add(n),
      () => {
          r.remove(n)
      }
  }
  , [e.when, e.message, e.promptOnlyForUnload]),
  P3.useEffect( () => {
      if (s$.hasNewDesktopQuitCloseRefreshBehaviour || !e.when)
          return;
      let t = s$.isElectron ? z3(e, n) : L3(e, n);
      return window.addEventListener(`beforeunload`, t),
      () => {
          window.removeEventListener(`beforeunload`, t)
      }
  }
  , [n, e.message, e.when])
}
function N3(e, t) {
  return e ? Xa(e, t) : !1
}
function _fe() {
  M3({
      when: e => !(!T3.instance.hasActiveUploads() || e.type === `unload` && (e.reason === `close-tab` || e.reason === `close-window`)),
      message: `Files are still uploading. Do you want to leave and cancel the uploads?`,
      promptOnlyForUnload: !0
  })
}
var P3, F3, I3, L3, R3, z3, B3, V3, H3, U3 = t(( () => {
  P3 = e(ht()),
  Xt(),
  ir(),
  Za(),
  E3(),
  m4(),
  Es(),
  O3(),
  c$(),
  Z3(),
  C$(),
  FQ(),
  j3(),
  F3 = P3.forwardRef( (e, t) => (M3(e, t),
  null)),
  I3 = new Ts,
  L3 = (e, t) => n => {
      N3(e.when, {
          type: `unload`,
          currentLocation: t
      }) && !D3.isDownloading && (n.preventDefault(),
      n.returnValue = ``)
  }
  ,
  R3 = !0,
  z3 = (e, t) => n => {
      N3(e.when, {
          type: `unload`,
          currentLocation: t
      }) && R3 && `confirm`in s$.bridge && (n.preventDefault(),
      n.returnValue = !1,
      s$.bridge.confirm(e.message ?? B3).then(e => {
          if (e) {
              R3 = !1;
              let e = self.document.activeElement?.getAttribute(`href`);
              e ? window.location.href = e : MQ.forceRefresh(`beforeunload-electron-user-confirmed`)
          }
      }
      ))
  }
  ,
  B3 = `Do you want to leave this page? Changes you made may not be saved.`,
  V3 = class {
      constructor() {
          this.blockers = []
      }
      add(e) {
          this.blockers.push(e)
      }
      remove(e) {
          this.blockers = this.blockers.filter(t => t !== e)
      }
      resolveBlockers(e) {
          let t = this.blockers
            , n = [];
          for (let r of t) {
              let {when: t, message: i, disabled: a, promptOnlyForUnload: o} = r;
              a.current || o && e.type === `navigation` || N3(t, e) && n.push(i ?? B3)
          }
          return n.length && I3.fire(),
          n.length === 0 ? void 0 : n.length === 1 ? n[0] : B3
      }
  }
  ,
  H3 = P3.createContext(new V3)
}
));
function W3(e) {
  let t = Kt(e);
  return {
      pathname: t.pathname ?? ``,
      search: t.search ?? ``,
      hash: t.hash ?? ``,
      state: void 0,
      key: ``
  }
}
var G3, K3, q3, J3, Y3, X3, Z3 = t(( () => {
  Xt(),
  zt(),
  G3 = e(be()),
  m3(),
  ni(),
  CQ(),
  ws(),
  c$(),
  U3(),
  i6(),
  K3 = e(f()),
  q3 = window.location.href,
  J3 = q3.includes(`isSecondaryWindow=true`),
  Y3 = class e {
      constructor(e, t, n, r, i, a) {
          this.id = e,
          this.isNew = t,
          this._location = n,
          this.pinned = !1,
          this.parentIds = new Set,
          this.title = r ?? ``,
          this.pinnedTitle = a ?? r,
          this.rawImage = i,
          At(this, {
              id: Vt,
              _location: Vt.ref,
              title: Vt,
              pinnedTitle: Vt,
              isNew: Vt,
              rawImage: Vt.ref,
              active: Bt,
              image: Bt,
              open: Ft,
              close: Ft,
              duplicate: Ft
          })
      }
      get location() {
          return this._location
      }
      set location(e) {
          let t = {
              ...e.state
          };
          delete t.tabId,
          Mt( () => {
              this._location = {
                  pathname: e.pathname,
                  search: e.search,
                  hash: e.hash,
                  state: t,
                  key: e.key
              }
          }
          )
      }
      get active() {
          return this.id === X3.instance.activeTabId
      }
      get image() {
          return this.rawImage ?? (0,
          K3.jsx)(f3, {})
      }
      set image(e) {
          this.rawImage = e
      }
      open() {
          X3.instance.openTab(this.id)
      }
      close() {
          X3.instance.closeTab(this.id)
      }
      duplicate() {
          X3.instance.duplicateTabById(this.id)
      }
      pin() {
          X3.instance.pinTab(this.id)
      }
      unpin() {
          X3.instance.unpinTab(this.id)
      }
      clone(t) {
          return new e(t,!0,this.location,this.title,this.rawImage)
      }
  }
  ,
  X3 = class e {
      static get instance() {
          return this._instance ||= new e,
          this._instance
      }
      initialize(e) {
          if (!s$.isElectron || this.initialized)
              return;
          this.initialized = !0;
          let t = SQ.getKey(e.id)
            , n = ei.get(t) ?? {}
            , r = (e, t) => e.split(`/`)[1] === t
            , i = new URL(q3)
            , a = i.pathname !== `/${e.urlKey}` && r(i.pathname, e.urlKey)
            , o = /^\/?connect(?:\/[^/]*)*\/callback\/?$/.test(i.pathname)
            , s = t => r(t.pathname, e.urlKey) || e.previousUrlKeys.some(e => r(t.pathname, e));
          this.tabs = (J3 || o ? [] : n.tabs ?? []).filter(e => {
              let t = e.location
                , n = s(t);
              return n || w.info(`Removing invalid tab`, {
                  pathname: t.pathname
              }),
              n
          }
          ).map(t => {
              let n = t.location;
              t.path && (n = W3(t.path));
              for (let t of e.previousUrlKeys)
                  n.pathname = n.pathname.replace(RegExp(`^/${(0,
                  G3.default)(t)}/`), `/${e.urlKey}/`);
              let r = new Y3(t.id,!1,n,t.title);
              return r.pinned = t.pinned,
              r
          }
          ).sort( (e, t) => e.pinned === t.pinned ? 0 : e.pinned ? -1 : 1),
          this.activeTabId = n.activeTabId ?? this.tabs.at(0)?.id ?? 0,
          this.nextTabId = n.nextTabId ?? this.tabs.at(1)?.id ?? 1,
          a && this.addOrFocusTabFromPath({
              pathname: i.pathname,
              search: i.search,
              hash: i.hash,
              state: void 0,
              key: ``
          }),
          this.nextTabId === this.activeTabId && this.nextTabId++,
          this.closedTabs = [];
          let c = () => {
              s$.isElectron ? ei.set(t, {
                  tabs: this.tabs.map(e => ({
                      id: e.id,
                      title: e.title,
                      location: Lt(e.location),
                      pinned: e.pinned
                  })),
                  activeTabId: this.activeTabId,
                  nextTabId: this.nextTabId
              }) : ei.remove(t)
          }
          ;
          n6.instance.onLocationChange( ({location: e, navigationType: t}) => {
              if (t === `POP`) {
                  let t = e.state?.tabId;
                  t != null && Mt( () => {
                      this.activeTabId = t
                  }
                  )
              }
              Mt( () => {
                  this.tabIdClickedBeforeNavigationPrompt &&= (t === `PUSH` && this.tabIdClickedBeforeNavigationPrompt === e.state?.tabId && (this.activeTabId = this.tabIdClickedBeforeNavigationPrompt),
                  void 0)
              }
              );
              let n = this.activeTab;
              n && s(e) && (n.location = e)
          }
          ),
          jt( () => ({
              tabs: Lt(this.tabs),
              activeTabId: this.activeTabId,
              nextTabId: this.nextTabId
          }), c, {
              delay: 500,
              fireImmediately: !1
          }),
          window.addEventListener(`beforeunload`, e => {
              e.defaultPrevented || c()
          }
          ),
          I3.subscribe( () => {
              this.justDisplayedNavigationPrompt = !0
          }
          ),
          setTimeout( () => {
              this.activeTab && (s(this.activeTab.location) ? n6.instance.replace(this.activeTab.location, {
                  state: {
                      ...n6.instance.location.state,
                      tabId: this.activeTab.id
                  }
              }) : n6.instance.replace(`/${e.urlKey}`))
          }
          , 0)
      }
      get activeTab() {
          return this.tabs.find(e => e.id === this.activeTabId)
      }
      openTab(e) {
          this.justDisplayedNavigationPrompt = !1;
          let t = this.tabs.find(t => t.id === e);
          if (!t || e === this.activeTabId)
              return;
          let n = Lt(t.location);
          n6.instance.redirectTo(n, {
              state: {
                  ...n.state,
                  tabId: e
              }
          });
          let r = e => Mt( () => {
              this.activeTabId = e
          }
          )
            , i = this.activeTabId;
          r(e),
          setTimeout( () => {
              this.justDisplayedNavigationPrompt && n6.instance.location.pathname !== n.pathname && (this.tabIdClickedBeforeNavigationPrompt = this.activeTabId,
              r(i))
          }
          , 100)
      }
      duplicateTabById(e) {
          let t = this.tabs.findIndex(t => t.id === e)
            , n = this.tabs[t];
          if (!n)
              return;
          let r = n.clone(this.nextTabId++);
          this.tabs.splice(t + 1, 0, r),
          r.open()
      }
      addTabFromPath(e=``, t=!0) {
          let n = W3(e)
            , r = new Y3(this.nextTabId++,!0,n)
            , i = this.activeTab?.parentIds ?? [];
          r.parentIds = new Set([this.activeTabId, ...i]);
          let a = this.tabs.findIndex(e => e.id === this.activeTabId)
            , o = this.tabs.findIndex(e => !e.pinned)
            , s = Math.max(a + 1, o);
          for (let e = s; e <= this.tabs.length; e++) {
              if (e === this.tabs.length) {
                  this.tabs.push(r);
                  break
              }
              if (!this.tabs[e].parentIds.has(this.activeTabId)) {
                  this.tabs.splice(e, 0, r);
                  break
              }
          }
          return t && this.openTab(r.id),
          r.id
      }
      appendTab(e=``) {
          let t = W3(e)
            , n = new Y3(this.nextTabId++,!0,t);
          return Mt( () => {
              this.tabs.push(n)
          }
          ),
          this.openTab(n.id),
          n.id
      }
      addOrFocusTabFromPath(e) {
          let t = this.tabs.find(t => {
              let n = typeof e == `string` ? W3(e) : e;
              return t.location.pathname === n.pathname && t.location.hash === n.hash
          }
          );
          if (t) {
              let n = typeof e == `string` ? W3(e) : e;
              t.location.search !== n.search && (t.location = n,
              t.id === this.activeTabId && n6.instance.redirectTo(n, {
                  state: {
                      ...n.state,
                      tabId: t.id
                  }
              })),
              this.openTab(t.id)
          } else
              typeof e == `string` ? this.addTabFromPath(e) : this.addTabFromPath(e.pathname + e.search + e.hash)
      }
      reopenClosedTab() {
          let e = this.closedTabs.pop();
          if (e) {
              let {tab: t, index: n} = e;
              return Mt( () => {
                  t.isNew = !0,
                  this.tabs.splice(n, 0, t),
                  this.openTab(t.id)
              }
              ),
              t.id
          }
      }
      openTabAtIndex(e) {
          let t = Math.max(0, Math.min(e, this.tabs.length - 1))
            , n = this.tabs[t];
          n && this.openTab(n.id)
      }
      closeTab(e) {
          e === this.activeTabId && (this.tabs.length === 1 ? this.activeTabId = 0 : this.openTab(this.findNextTab(this.activeTabId)));
          let t = this.tabs.findIndex(t => t.id === e);
          if (t !== -1) {
              let e = this.tabs.splice(t, 1)[0];
              this.closedTabs.push({
                  tab: e,
                  index: t
              })
          }
      }
      pinTab(e) {
          let t = this.tabs.find(t => t.id === e);
          if (t) {
              let n = this.tabs.find(e => !e.pinned)
                , r = n ? n.id : this.tabs[0].id;
              this.reorderTabs(e, r),
              t.pinned = !0
          }
      }
      unpinTab(e) {
          let t = this.tabs.find(t => t.id === e);
          if (t) {
              let n = this.tabs.findIndex(e => !e.pinned) - 1
                , r = this.tabs[n]
                , i = r ? r.id : this.tabs[this.tabs.length - 1].id;
              this.reorderTabs(e, i),
              t.pinned = !1
          }
      }
      reorderTabs(e, t) {
          let n = this.tabs.findIndex(t => t.id === e)
            , r = this.tabs.findIndex(e => e.id === t)
            , [i] = this.tabs.splice(n, 1);
          this.tabs.splice(r, 0, i)
      }
      openNextTab({loop: e=!1, skipPinned: t=!1}) {
          let n = t ? this.tabs.filter(e => !e.pinned) : this.tabs;
          if (n.length === 0)
              return;
          let r = n[n.findIndex(e => e.id === this.activeTabId) + 1];
          if (r) {
              r.open();
              return
          }
          e && !r && n[0].open()
      }
      openPreviousTab({loop: e=!1, skipPinned: t=!1}) {
          let n = t ? this.tabs.filter(e => !e.pinned) : this.tabs;
          if (n.length === 0)
              return;
          let r = n[n.findIndex(e => e.id === this.activeTabId) - 1];
          if (r) {
              r.open();
              return
          }
          e && !r && n[n.length - 1].open()
      }
      setPageInfo(e) {
          let {id: t, title: n, image: r, pinnedTitle: i} = e
            , a = this.tabs.find(e => e.id === t);
          a && (a.title = n,
          a.pinnedTitle = i ?? n,
          r && (a.image = r))
      }
      constructor() {
          this.initialized = !1,
          this.justDisplayedNavigationPrompt = !1,
          this.tabs = [],
          this.activeTabId = 0,
          this.nextTabId = 1,
          this.closedTabs = [],
          At(this, {
              tabs: Vt,
              activeTabId: Vt,
              activeTab: Bt,
              initialize: Ft,
              openTab: Ft,
              addTabFromPath: Ft,
              closeTab: Ft,
              setPageInfo: Ft,
              reorderTabs: Ft,
              openNextTab: Ft,
              openPreviousTab: Ft,
              reopenClosedTab: Ft,
              openTabAtIndex: Ft
          })
      }
      findNextTab(e) {
          let t = this.tabs.findIndex(t => t.id === e);
          return t === -1 && (t = 0),
          t + 1 < this.tabs.length ? this.tabs[t + 1].id : this.tabs[t - 1].id
      }
  }
}
)), Q3, $3, e6, t6, n6, r6, i6 = t(( () => {
  Xt(),
  Q3 = e(ne()),
  $3 = e(l()),
  e6 = e(Te()),
  zt(),
  pi(),
  Es(),
  Z3(),
  t6 = `linear_first_location_key`,
  n6 = class e {
      static initialize(t) {
          e.privateInstance === void 0 && (e.privateInstance = new e(t))
      }
      static get instance() {
          if (e.privateInstance === void 0)
              throw Error(`Routing manager accessed before it has been initialized`);
          return e.privateInstance
      }
      static navigateExternal(e, t) {
          if (t?.useWindow)
              window.open(e, `_blank`);
          else {
              let t = self.document.createElement(`a`);
              t.href = e,
              t.target = `_blank`,
              t.rel = `noopener noreferrer`,
              t.click(),
              t.remove()
          }
      }
      static shouldShowGlobalLoaderForNavigation(t, n) {
          if (!t || !n)
              return !1;
          for (let r of r6) {
              let i = e.findMatchForPath(r, t);
              if (!i)
                  continue;
              let a = e.findMatchForPath(r, n);
              if (a && e.getCommonPatternParams(r).every(e => i.params[e] === a.params[e]))
                  return !0
          }
          return !1
      }
      constructor(e) {
          this.isInitialPath = !0,
          this.locationChangeSignal = new Ts,
          this.rafIds = [],
          this.location = e.state.location,
          this.previousLocation = void 0,
          this.navigate = e.navigate,
          this.revalidate = e.revalidate;
          let t = sessionStorage.getItem(t6);
          t ? this.firstLocationKey = t : this.setFirstLocationKey(e.state.location.key || `default`),
          e.subscribe(e => {
              if (e.navigation.state !== `idle` || Array.from(e.blockers.values()).some(e => e.state !== `unblocked`))
                  return;
              let t = this.location
                , n = e.location
                , r = () => this.locationChangeSignal.fire({
                  location: n,
                  navigationType: e.historyAction,
                  previousLocation: t
              });
              e.historyAction === `POP` ? requestAnimationFrame(r) : r()
          }
          ),
          At(this, {
              location: Vt.ref,
              previousLocation: Vt.ref,
              setLocation: Ft,
              replace: Ft,
              goBack: Ft
          })
      }
      openPage({newTab: e, path: t, options: n}) {
          e ? Object.assign(self.document.createElement(`a`), {
              target: `_blank`,
              rel: `noopener noreferrer`,
              href: t
          }).click() : this.redirectTo(t, n)
      }
      redirectTo(e, t) {
          this.rafIds.forEach(e => cancelAnimationFrame(e)),
          this.rafIds.length = 0;
          let n = X3.instance.activeTabId;
          this.rafIds.push(requestAnimationFrame( () => {
              this.rafIds.push(requestAnimationFrame( () => {
                  let r = typeof e == `string` ? e : e.pathname ?? ``
                    , i = this.cleanPath(r);
                  if (ui.isEnabled(ui.pinnedTabsFrozenUrl) && n === X3.instance.activeTabId && X3.instance.activeTab?.pinned) {
                      X3.instance.addTabFromPath(i, !0);
                      return
                  }
                  if (i.indexOf(`?`) >= 0)
                      this.navigate(i);
                  else {
                      let[n,r] = i.split(`#`)
                        , a = typeof e == `string` ? {} : e;
                      this.navigate({
                          pathname: n,
                          hash: a.hash ?? r,
                          search: a.search
                      }, {
                          state: t?.state ? (0,
                          e6.default)(t.state, e => Lt(e)) : void 0
                      })
                  }
              }
              ))
          }
          ))
      }
      replace(e, t={}) {
          let n = typeof e == `string` ? e : e.pathname ?? ``;
          n.indexOf(`?`) >= 0 ? this.navigate(this.cleanPath(n), {
              replace: !0,
              state: this.location.state
          }) : this.navigate(typeof e == `string` ? {
              pathname: this.cleanPath(n)
          } : e, {
              replace: !0,
              state: t.state ? (0,
              e6.default)(t.state, e => Lt(e)) : void 0
          })
      }
      addKeysToState(e) {
          let t = {
              ...this.location.state,
              ...e
          };
          this.navigate(this.location, {
              state: (0,
              e6.default)(t, e => Lt(e)),
              replace: !0
          })
      }
      removeKeysFromState(e) {
          this.navigate(this.location, {
              state: (0,
              $3.default)(this.location.state ?? {}, e),
              replace: !0
          })
      }
      setSearchParams(e, t) {
          let n = new URLSearchParams(this.location.search);
          for (let t in e) {
              let r = e[t];
              r != null && n.set(t, r)
          }
          this.navigate({
              ...this.location,
              search: n.toString()
          }, t)
      }
      deleteSearchParams(e, t) {
          let n = new URLSearchParams(this.location.search);
          e.forEach(e => {
              n.delete(e)
          }
          ),
          this.navigate({
              ...this.location,
              search: n.toString()
          }, t)
      }
      goBack() {
          this.navigate(-1)
      }
      backOrNavigateTo(e) {
          let t = this.cleanPath(e);
          if ((this.previousLocation ? this.cleanPath(this.previousLocation.pathname) : void 0) === t) {
              this.goBack();
              return
          }
          this.navigate(e)
      }
      onLocationChange(e) {
          return this.locationChangeSignal.subscribe(e)
      }
      setLocation(e, t) {
          this.areLocationsIdentical(e, this.location) || (this.isInitialPath = !1);
          let n = this.location.key || `default`;
          t === Cee.Replace && n === this.firstLocationKey && this.setFirstLocationKey(n),
          this.previousLocation = this.location,
          this.location = e
      }
      hasHistory() {
          return (this.location.key || `default`) !== this.firstLocationKey
      }
      areLocationsIdentical(e, t) {
          return (0,
          Q3.default)((0,
          $3.default)(e, `key`), (0,
          $3.default)(t, `key`))
      }
      isCurrentPath(e) {
          let t = this.location.pathname;
          return this.cleanPath(t) === this.cleanPath(e)
      }
      async refreshRouterAfterError() {
          await this.revalidate(),
          this.replace(this.location, {
              state: this.location.state
          })
      }
      removeQueryAndLocationState(e) {
          let t = this.location;
          if (e.length === 0)
              return;
          let n = !1
            , r = new URLSearchParams(t.search);
          for (let i of e)
              (r.has(i) || t.state?.[i] !== void 0) && (n = !0),
              r.delete(i);
          n && this.replace({
              pathname: t.pathname,
              search: r.toString()
          }, {
              state: (0,
              $3.default)(t.state, e)
          })
      }
      static findMatchForPath(e, t) {
          for (let n of e) {
              let e = Yt(n, t);
              if (e)
                  return e
          }
          return null
      }
      static getCommonPatternParams(e) {
          if (!e.length)
              return [];
          let t = /:(\w+)/g
            , n = [...e[0].matchAll(t)].map(e => e[1])
            , r = new Set(n);
          for (let n of e.slice(1)) {
              let e = new Set([...n.matchAll(t)].map(e => e[1]));
              for (let t of r)
                  e.has(t) || r.delete(t);
              if (r.size === 0)
                  break
          }
          return Array.from(r)
      }
      cleanPath(e) {
          if (e.indexOf(`://`) !== -1) {
              let t = e.split(`://`)[1].split(`/`);
              return t.shift(),
              `/` + t.join(`/`)
          }
          return e
      }
      setFirstLocationKey(e) {
          this.firstLocationKey = e,
          sessionStorage.setItem(t6, e)
      }
  }
  ,
  r6 = [[`/:orgKey/team/:teamKey/active`, `/:orgKey/team/:teamKey/backlog`, `/:orgKey/team/:teamKey/all`, `/:orgKey/team/:teamKey/view/:customViewId`, `/:orgKey/team/:teamKey/view/:customViewId/edit`, `/:orgKey/team/:teamKey/view/new`], [`/:orgKey/team/:teamKey/projects/all`, `/:orgKey/team/:teamKey/projects/view/:customViewId`, `/:orgKey/team/:teamKey/projects/view/:customViewId/edit`, `/:orgKey/team/:teamKey/projects/view/new`], [`/:orgKey/project/:projectId/:tabName?`, `/:orgKey/project/:projectId/view/:customViewId`, `/:orgKey/project/:projectId/view/:customViewId/edit`, `/:orgKey/project/:projectId/view/new`], [`/:orgKey/initiative/:initiativeId`, `/:orgKey/initiative/:initiativeId/overview`, `/:orgKey/initiative/:initiativeId/projects`, `/:orgKey/initiative/:initiativeId/updates`, `/:orgKey/initiative/:initiativeId/view/:customViewId`, `/:orgKey/initiative/:initiativeId/view/:customViewId/edit`, `/:orgKey/initiative/:initiativeId/view/new`], [`/:orgKey/projects/all`, `/:orgKey/projects/view/:customViewId`, `/:orgKey/projects/view/:customViewId/edit`, `/:orgKey/projects/view/new`]]
}
));
function a6(e) {
  return (0,
  o6.jsx)(XK, {
      ...e,
      children: (0,
      o6.jsx)(`svg`, {
          children: (0,
          o6.jsx)(`path`, {
              d: `M10.3262 4.51988C10.061 4.20167 9.58809 4.15868 9.26988 4.42385C8.95167 4.68903 8.90868 5.16195 9.17385 5.48016L10.6487 7.25L3.75 7.25C3.33579 7.25 3 7.58579 3 8C3 8.41421 3.33579 8.75 3.75 8.75H10.6488L9.17385 10.5199C8.90868 10.8381 8.95167 11.311 9.26988 11.5762C9.58809 11.8414 10.061 11.7984 10.3262 11.4802L12.8262 8.48016C13.058 8.20202 13.058 7.79802 12.8262 7.51988L10.3262 4.51988Z`
          })
      })
  })
}
var o6, s6 = t(( () => {
  ht(),
  QK(),
  o6 = e(f(), 1)
}
));
function c6(e, t, n, r, i=0, a=0, o={}) {
  if (a === t.length)
      return i === e.length ? d6 : v6;
  let s = `${i},${a}`;
  if (o[s] !== void 0)
      return o[s];
  let c = r.charAt(a), l = n.indexOf(c, i), u = 0, d, f, p, m;
  for (; l >= 0 && c.length > 0; )
      d = c6(e, t, n, r, l + 1, a + 1, o),
      d > u && (l === i ? d *= d6 : b6.test(e.charAt(l - 1)) ? (d *= p6,
      p = e.slice(i, l - 1).match(x6),
      p && i > 0 && (d *= g6 ** +p.length)) : S6.test(e.charAt(l - 1)) ? (d *= f6,
      m = e.slice(i, l - 1).match(C6),
      m && i > 0 && (d *= g6 ** +m.length)) : (d *= m6,
      i > 0 && (d *= g6 ** +(l - i))),
      d *= y6 ** +l,
      e.charAt(l) !== t.charAt(a) && (d *= _6)),
      (d < h6 && n.charAt(l - 1) === r.charAt(a + 1) || r.charAt(a + 1) === r.charAt(a) && n.charAt(l - 1) !== r.charAt(a)) && (f = c6(e, t, n, r, l + 1, a + 2, o),
      f * h6 > d && (d = f * h6)),
      d > u && (u = d),
      l = n.indexOf(c, l + 1);
  return o[s] = u,
  u
}
function l6(e) {
  return e.toLowerCase().replace(/[&+]/g, `and`).replace(C6, ` `).normalize(`NFD`).replace(/[\u0300-\u036f]/g, ``).replace(/[\u00A1-\u00BF]/g, ``)
}
var u6, d6, f6, p6, m6, h6, g6, _6, v6, y6, b6, x6, S6, C6, w6 = t(( () => {
  u6 = class {
      static score(e, t=``) {
          if (Array.isArray(e))
              return e.length === 0 ? 0 : Math.max(...e.map(e => this.score(e, t)));
          if (t === e)
              return 1;
          if (t.toLowerCase() === e.toLowerCase())
              return .9999;
          let n = t.split(` `).map(e => e.trim()).filter(e => e);
          if (n.length === 0)
              return 1;
          let r = .9998;
          if (n.length === 1) {
              let t = this.getSingleWordScore(e, n[0]);
              return t > r ? r : t
          } else {
              let i = l6(e)
                , a = this.scoreMultiWordQuery(e, i, t, n);
              return a > r ? r : a
          }
      }
      static getSingleWordScore(e, t) {
          let n = l6(e)
            , r = l6(t)
            , i = c6(e, t, n, r);
          if (r.includes(` `) === !1 && n.includes(` `)) {
              let e = n.split(` `).join(``)
                , r = this.getSingleWordScore(e, t);
              if (r > i)
                  return r
          }
          return this.applyMeaningfulMatchPenalty(i, r, n)
      }
      static scoreMultiWordQuery(e, t, n, r) {
          let i = r.map(e => l6(e))
            , a = r.map( (n, r) => {
              let a = c6(e, n, t, i[r]);
              return this.applyMeaningfulMatchPenalty(a, n, t)
          }
          )
            , o = a.filter(e => e > 0);
          if (o.length === 0)
              return 0;
          let s = a.some(e => e > 0 && e < .05) ? .3 : 1;
          if (o.length < r.length * .5 && .2 ** (r.length - o.length) < .01)
              return 0;
          let c = o.reduce( (e, t) => e * t, 1) ** (1 / o.length)
            , l = o.reduce( (e, t) => e + t, 0) / o.length
            , u = c * .3 + l * .7
            , d = 1;
          r.length > 1 && (d = this.calculateWordOrderBonus(i, t));
          let f = u * .2 ** (r.length - o.length) * d * s
            , p = f;
          if (f > .2) {
              let r = c6(e, n, t, l6(n));
              p = Math.max(r, f)
          }
          return p > 1 ? .9999 : p
      }
      static calculateWordOrderBonus(e, t) {
          let n = []
            , r = 0;
          for (let i of e) {
              let e = t.indexOf(i, r);
              e >= 0 ? (n.push(e),
              r = e + i.length) : (n.push(1 / 0),
              r = 0)
          }
          if (!n.every(e => e !== 1 / 0))
              return 1;
          let i = !0;
          for (let e = 1; e < n.length; e++)
              if (n[e] <= n[e - 1]) {
                  i = !1;
                  break
              }
          return i ? 1.12 : 1
      }
      static hasWordBoundaryMatch(e, t) {
          if (RegExp(`(^|[\\s\\-_./])${t.replace(/[.*+?^${}()|[\]\\]/g, `\\$&`)}`, `i`).test(e))
              return !0;
          if (t.length >= 2) {
              let n = e.split(/[\s\-_./]+/);
              for (let e of n)
                  if (e.toLowerCase().startsWith(t.toLowerCase()))
                      return !0
          }
          return !1
      }
      static hasSubstantialMatch(e, t) {
          if (t.length <= 3)
              return !1;
          if (e.includes(t))
              return !0;
          let n = Math.max(3, Math.ceil(t.length * .8));
          for (let r = 0; r <= t.length - n; r++) {
              let i = t.substring(r, r + n);
              if (e.includes(i))
                  return !0
          }
          return !1
      }
      static applyMeaningfulMatchPenalty(e, t, n) {
          let r = this.hasWordBoundaryMatch(n, t)
            , i = this.hasSubstantialMatch(n, t);
          return !r && !i ? e * .01 : e
      }
      static prioritize(e, t=1) {
          return e * 1.01 ** t
      }
      static deprioritize(e, t=1) {
          return e * .99 ** t
      }
  }
  ,
  d6 = 1,
  f6 = .9,
  p6 = .8,
  m6 = .17,
  h6 = .1,
  g6 = .999,
  _6 = .9999,
  v6 = .99,
  y6 = .999,
  b6 = /[\\\/_+.#"@\[\(\{&]/,
  x6 = /[\\\/_+.#"@\[\(\{&]/g,
  S6 = /[\s-]/,
  C6 = /[\s-]/g
}
)), T6, E6 = t(( () => {
  Pn(),
  T6 = class {
      constructor(e, t) {
          this.workerPool = [],
          this.workerIndex = 0,
          this.url = e;
          let n = 4;
          `hardwareConcurrency`in navigator && (n = Math.max(1, navigator.hardwareConcurrency - 1)),
          this.poolSize = Math.max(1, Math.min(t ?? n, n)),
          this.activeReferences = 0,
          this.weakReferences = new Set,
          typeof FinalizationRegistry < `u` && (this.finalizationRegistry = new FinalizationRegistry(e => {
              this.activeReferences = Math.max(0, this.activeReferences - 1),
              e && this.weakReferences.delete(e),
              this.activeReferences === 0 && this.destroy()
          }
          ))
      }
      getWorker(e) {
          let t = this.workerIndex++ % this.poolSize;
          if (t >= this.workerPool.length && this.workerPool.push(this.createWorker()),
          e && this.finalizationRegistry) {
              this.activeReferences++;
              let t = new WeakRef(e);
              this.weakReferences.add(t),
              this.finalizationRegistry.register(e, t, t)
          }
          return this.workerPool[t].api
      }
      release(e) {
          if (this.finalizationRegistry) {
              this.activeReferences = Math.max(0, this.activeReferences - 1);
              for (let t of this.weakReferences)
                  if (t.deref() === e) {
                      this.finalizationRegistry.unregister(t),
                      this.weakReferences.delete(t);
                      break
                  }
              this.activeReferences === 0 && this.workerPool.length > 0 && this.destroy()
          }
      }
      destroy() {
          if (this.workerPool.length > 0) {
              for (let e of this.workerPool)
                  e.worker.terminate();
              this.workerPool = [],
              this.workerIndex = 0,
              this.activeReferences = 0,
              this.weakReferences.clear()
          }
      }
      createWorker() {
          let e = `import ${JSON.stringify(new URL(this.url,location.origin))}`
            , t = new Blob([e],{
              type: `application/javascript`
          })
            , n = new Worker(URL.createObjectURL(t),{
              type: `module`
          });
          return {
              worker: n,
              api: Cte(n)
          }
      }
  }
}
)), D6, vfe = t(( () => {
  D6 = `` + window.__toStaticUrl(`assets/SearchScore.worker-CPAa-UDH.js`)
}
)), O6, k6, yfe = t(( () => {
  w6(),
  E6(),
  ws(),
  vfe(),
  O6 = class extends u6 {
      static async scoreAll(e, t=``) {
          let n = this.getWorker();
          try {
              if (!n)
                  throw Error(`Worker not available`);
              return await n.scoreAll(e, t)
          } catch (n) {
              return w.warning(`Worker scoreAll failed, falling back to main thread`, n),
              e.map(e => u6.score(e, t))
          }
      }
      static getWorker() {
          try {
              return k6.get().getWorker()
          } catch (e) {
              return w.warning(`Failed to acquire SearchScore worker, falling back to main thread`, e),
              null
          }
      }
  }
  ,
  k6 = class {
      static get() {
          return this.pool ||= new T6(D6,2),
          this.pool
      }
  }
}
)), A6, j6, M6, N6 = t(( () => {
  zt(),
  ir(),
  A6 = (e, t) => rr.isMac || rr.isiPad ? e : t,
  j6 = class e {
      static get() {
          return this._instance ||= new e,
          this._instance
      }
      constructor() {
          this.altKey = !1,
          this.metaKey = !1,
          this.ctrlKey = !1,
          this.modKey = !1,
          this.handleKeyEvent = e => {
              this.updateModifiers(e)
          }
          ,
          this.handleReset = () => {
              this.reset()
          }
          ,
          window.addEventListener(`keydown`, this.handleKeyEvent, !0),
          window.addEventListener(`keyup`, this.handleKeyEvent, !0),
          window.addEventListener(`blur`, this.handleReset),
          window.addEventListener(`focus`, this.handleReset),
          window.addEventListener(`paste`, this.handleReset),
          At(this, {
              altKey: Vt,
              metaKey: Vt,
              ctrlKey: Vt,
              modKey: Vt,
              updateModifiers: Ft,
              reset: Ft
          })
      }
      updateModifiers(e) {
          let t = A6(e.metaKey, e.ctrlKey);
          this.altKey = e.altKey,
          this.metaKey = e.metaKey,
          this.ctrlKey = e.ctrlKey,
          this.modKey = t
      }
      reset() {
          !this.altKey && !this.metaKey && !this.ctrlKey && !this.modKey || (this.altKey = !1,
          this.metaKey = !1,
          this.ctrlKey = !1,
          this.modKey = !1)
      }
      getState() {
          return {
              altKey: this.altKey,
              metaKey: this.metaKey,
              ctrlKey: this.ctrlKey,
              modKey: this.modKey
          }
      }
  }
  ,
  M6 = j6.get()
}
)), P6, F6 = t(( () => {
  P6 = class e {
      static #e = this.websiteRoutes = `aakash.ai.about.agent.agents.ale.android.behind-the-craft.behindthecraft.blog.brand.browser-compatibility.build.careers.carlos.change.changelog.contact.customer-requests.customers.developers.download-mobile.download.downloads.dpa.dwarkesh.enterprise.enterprises.jedcal.features.fm.for.harry.homepage.height.integrations.interfaces.ios.join-slack.lenny.lennys-list.method.mobile.open-desktop.plan.partner.partners.pricing.pragmatic.privacy.quality.readme.releases.rewind.security.startups.switch.terms.tcr.twist.unsubscribe.work-with-linear.now.20vc.asks.building.guides.jobs.linear-method.planning.release-2020-12.support.website.insights.docs`.split(`.`);
      static #t = this.websiteRouterMatchers = [RegExp(`^/(${e.websiteRoutes.join(`|`)})(/|$)`, `i`), /^\/(rss|sitemap\.xml|llms\.txt)(\/|$)/i, /^\/(static|favicon\.ico|\.well-known|robots\.txt)(\/|$)/i, /^\/(api|_next)(\/|$)/i];
      static isWebsiteRouterPath(t) {
          return e.websiteRouterMatchers.some(e => e.test(t))
      }
      static #n = this.NON_ORGANIZATION_ROOT_PATHS = [`add-account`, `api`, `auth`, `connect`, `coupon`, `invite`, `join`, `login`, `logout`, `mobile-auth`, `new`, `oauth`, `refresh`, `reset`, `signup`, `verify-email`];
      static #r = this.REDIRECTABLE_ROOT_PATHS = [`drafts`, `inbox`, `initiatives`, `dashboards`, `issue`, `my-issues`, `project`, `settings`, `team`, `welcome`, `views`, `pulse`, `my-issues`, `reviews`, `members`, `projects`, `teams`];
      static isValidOrgPath(t) {
          let n = t.startsWith(`/`) ? t : `/${t}`
            , r = n.split(`/`)[1];
          return !e.NON_ORGANIZATION_ROOT_PATHS.includes(r) && !e.REDIRECTABLE_ROOT_PATHS.includes(r) && !e.websiteRouterMatchers.some(e => e.test(n))
      }
  }
}
));
function I6(e, t=$n.CLIENT_URL || ``) {
  if (e.startsWith(`//`) && (e = `https:${e}`),
  e.startsWith(`/`) && (e = `${t}${e}`),
  !t || !e.startsWith(t))
      return !1;
  try {
      let t = new URL(e);
      return !P6.websiteRouterMatchers.some(e => e.test(t.pathname))
  } catch {
      return !1
  }
}
var L6 = t(( () => {
  F6(),
  er()
}
));
function R6(e, t) {
  if (`id`in e) {
      let n = (t.settings?.customShortcuts || []).find(t => t.actionId === e.id);
      if (n)
          return n.shortcut
  }
}
var z6, B6, V6, H6, U6, W6 = t(( () => {
  ht(),
  z6 = e(de()),
  B6 = e(_()),
  V6 = e(ee()),
  s6(),
  Za(),
  yfe(),
  N6(),
  K6(),
  L6(),
  i6(),
  d3(),
  H6 = e(f()),
  U6 = class e {
      static #e = this.DEFAULT_MIN_APPLICABILITY_SCORE = .24;
      static getTrackAttributes(e, t) {
          if (t.track === void 0)
              return;
          let n = t.track(e);
          if (n)
              return typeof n == `object` ? n : {
                  event: n,
                  properties: {}
              }
      }
      static getActionName(e, t, n={}) {
          let r = Xa(t.name, e);
          return n.hideEllipsis && (r = r.replace(``, ``)),
          r
      }
      static getParentActionLabels(t, n) {
          let r = []
            , i = n;
          for (; i.parentAction; ) {
              let n = e.getParentActionLabel(t, i);
              n && r.unshift(n),
              i = i.parentAction
          }
          return r
      }
      static getActionBreadcrumb(t, n, r, i) {
          let a = []
            , o = e.getParentActionLabels(t, r);
          o.length > 0 && a.push(...o.map(e => ({
              label: e
          })));
          let s = e.getActionName(t, r, i), c = Xa(r.label, t) ?? s, l;
          if (i.showGroupNameAsDetail) {
              let n = r.parentAction ?? r;
              l = e.getActionGroupName(t, n.group)
          }
          return !l && r.detail && (l = e.getActionDetailLabel(t, r, n)),
          a.push({
              label: c,
              detail: l
          }),
          a.filter(e => !!e.label)
      }
      static getParentActionLabel(t, n) {
          if (n.parentAction) {
              if (n.parentAction.nameAsParent === void 0)
                  return this.getActionName(t, n.parentAction, {
                      hideEllipsis: !0
                  });
              if (typeof n.parentAction.nameAsParent == `function`) {
                  let r = n.parentAction.nameAsParent(t);
                  return typeof r == `string` ? r.replace(``, ``) : e.getActionSelected(t, n) === !0 ? r.subActionSelected : r.subActionNotSelected
              }
              return typeof n.parentAction.nameAsParent == `string` ? n.parentAction.nameAsParent : e.getActionSelected(t, n) === !0 ? n.parentAction.nameAsParent.subActionSelected : n.parentAction.nameAsParent.subActionNotSelected
          }
      }
      static getActionDetailLabel(e, t, n) {
          return Xa(t.detail, e, n) || void 0
      }
      static getActionDetailControl(e, t, n) {
          return Xa(t.detailControl, e, n) || void 0
      }
      static getActionLink(e, t) {
          return Xa(t.link, e)
      }
      static redirectToActionPath(t, n, r) {
          let i = e.getActionLink(t, n);
          if (!i)
              return;
          let a = e.getKeyboardShortcut(t, n)
            , o = M6.metaKey && !a?.mod || !!r?.openInNewTab;
          if (typeof i == `string`) {
              if (!I6(i)) {
                  n6.navigateExternal(i);
                  return
              }
              let e = n6.instance.location.state;
              n6.instance.openPage({
                  path: i,
                  options: {
                      state: (0,
                      V6.default)(e, `tabId`)
                  },
                  newTab: o
              });
              return
          }
          if (typeof i.to == `string` || i.to.pathname) {
              let e = o ? void 0 : n6.instance.location.state?.tabId;
              n6.instance.openPage({
                  path: typeof i.to == `string` ? i.to : i.to.pathname ?? `.`,
                  options: {
                      state: {
                          tabId: e,
                          ...i.state
                      }
                  },
                  newTab: o
              });
              return
          }
      }
      static getActionImage(e, t) {
          if (!(t.image === !1 || t.image === null))
              return t.image ? Xa(t.image, e) : t.group?.defaultImage || (e.isContextualMenu ? void 0 : (0,
              H6.jsx)(a6, {}))
      }
      static getActionPlaceholder(t, n) {
          let r = Xa(n.subActionPlaceholder, t);
          if (t.isContextualMenu) {
              if (r)
                  return r;
              let e = Xa(n.nameAsParent, t);
              return typeof e == `object` ? `${e.subActionNotSelected}` : e ?? `Filter`
          }
          return r ?? e.getActionName(t, n)
      }
      static getActionSelected(e, t) {
          return Xa(t.selected, e)
      }
      static getKeyboardShortcut(e, t) {
          let n = R6(t, e.user);
          return n === void 0 ? Xa(t.keyboardShortcut, e) : n || void 0
      }
      static hasKeyboardShortcuts(e, t) {
          let n = R6(e, t);
          return n === void 0 ? !!(e.keyboardShortcut || e.alternativeKeyboardShortcut || e.deprecatedKeyboardShortcut) : n !== null
      }
      static scoreAction(e, t) {
          let n = this.getSearchScoreStrings(e, t)
            , r = (e.searchInput ?? ``).trim().toLowerCase()
            , i = O6.score(n.mainString, r)
            , a = O6.score(n.secondaryString, r) * .85
            , o = Math.max(i, a);
          return this.applyScoreCorrections(e, t, o, r, n)
      }
      static async scoreActionsAsync(e, t, n) {
          if (t.length === 0)
              return [];
          let r = t.map(t => this.getSearchScoreStrings(e, t))
            , i = [];
          for (let e of r)
              i.push(e.mainString, e.secondaryString);
          let a = (e.searchInput ?? ``).trim().toLowerCase()
            , o = [];
          try {
              let e = n ? new Promise( (e, t) => {
                  let r = () => {
                      n.removeEventListener(`abort`, r),
                      t(new DOMException(`Aborted`,`AbortError`))
                  }
                  ;
                  n.addEventListener(`abort`, r)
              }
              ) : void 0;
              o = await Promise.race([O6.scoreAll(i, a), e].concrete())
          } catch (e) {
              if (e instanceof DOMException && e.name === `AbortError`)
                  throw e;
              o = []
          }
          let s = Array(t.length);
          for (let n = 0; n < t.length; n++) {
              let c = r[n]
                , l = o.length === i.length ? o[n * 2] : void 0
                , u = o.length === i.length ? o[n * 2 + 1] : void 0
                , d = l !== void 0 && u !== void 0 ? Math.max(l, (u ?? 0) * .85) : Math.max(O6.score(c.mainString, a), O6.score(c.secondaryString, a) * .85);
              s[n] = this.applyScoreCorrections(e, t[n], d, a, c)
          }
          return s
      }
      static getKeywordString(e) {
          return Array.isArray(e.keywords) ? e.keywords.join(` `) : e.keywords ?? ``
      }
      static isApplicableAction(e, t) {
          return t.applicable === void 0 || t.applicable(e)
      }
      static isUnavailableDueToBootstrap(e, t) {
          return t.group?.availableDuringBootstrap && !t.availabilityDuringBootstrap ? !1 : !e.store.isBootstrapped && t.availabilityDuringBootstrap !== `available`
      }
      static getActionGroupName(e, t) {
          return Xa(t.name, e)
      }
      static joinActionGroupsWithDividers(e) {
          return e.reduce( (e, t, n) => {
              if (t.length === 0)
                  return e;
              if (n > 0 && e.length > 0) {
                  let n = t.shift();
                  n && e.push(i3(n))
              }
              return e.push(...t),
              e
          }
          , [])
      }
      static actionsMatch(e, t, n) {
          return t.group === n.group && this.getActionName(e, t) === this.getActionName(e, n) && this.getActionLink(e, t) === this.getActionLink(e, n) && this.getKeywordString(t) === this.getKeywordString(n)
      }
      static resolveActionFactories(e, t) {
          let n = [];
          if (!t)
              return n;
          for (let r of Array.isArray(t) ? t : [t])
              r instanceof G6 ? n = n.concat(r.actions) : typeof r == `function` ? n = n.concat(r(e)) : n.push(r);
          return n
      }
      static async asyncResolveActionFactories(e, t) {
          if (!t)
              return [];
          let n = (Array.isArray(t) ? t : [t]).filter(e => e instanceof G6);
          return n.length && await Promise.all(n.map(t => t.execute(e))),
          this.resolveActionFactories(e, t)
      }
      static createGroupingActions(e) {
          let t = new Map
            , n = [];
          for (let r of e)
              if (r.group.groupingAction) {
                  let e = t.get(r.group) || [];
                  t.set(r.group, [...e, r])
              } else
                  n.push(r);
          let r = [];
          for (let[e,i] of t)
              if (e.groupingAction && i.length > 0) {
                  let t = {
                      name: e.groupingAction.name,
                      image: e.groupingAction.image,
                      keywords: e.groupingAction.keywords,
                      keyboardShortcut: e.groupingAction.keyboardShortcut,
                      group: e,
                      subActions: () => i
                  };
                  r.push(t)
              } else
                  n.push(...i);
          return [...n, ...r]
      }
      static sortBySelected(t, n, r) {
          if (n.length === 0)
              return [[], {
                  order: []
              }];
          let i = n
            , a = r?.previousSortData;
          if (a && a.order.length === n.length)
              return i = (0,
              B6.default)(n, e => a.order[n.indexOf(e)]),
              a.dividerAt && (i[a.dividerAt] = i3(i[a.dividerAt])),
              [i, a];
          {
              let a = e => e === !0 || e === `partial`;
              i = (0,
              B6.default)(n, n => a(e.getActionSelected(t, n)) ? 0 : 1);
              let o = n.map(e => i.indexOf(e)), s;
              if (r?.withDivider && a(e.getActionSelected(t, i[0]))) {
                  for (let n = 1; n < i.length; n++)
                      if (!a(e.getActionSelected(t, i[n]))) {
                          i[n] = i3(i[n]),
                          s = n;
                          break
                      }
              }
              return [i, {
                  order: o,
                  dividerAt: s
              }]
          }
      }
      static getStrippedString(e) {
          let t = e.replace(/[`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, ` `);
          return e === t ? e : `${e} ${t}`
      }
      static isExactKeywordMatch(e, t) {
          let n = Array.isArray(e.keywordsExactMatch) ? e.keywordsExactMatch : e.keywordsExactMatch ? [e.keywordsExactMatch] : [];
          return n.length > 0 && n.map(e => e.toLowerCase()).includes(t)
      }
      static applyScoreCorrections(t, n, r, i, a) {
          let o = r;
          return (n.skipFilterScoring || i === a.mainString || this.isExactKeywordMatch(n, i)) && (o = 1),
          `parentAction`in n && (o -= .15),
          o < e.DEFAULT_MIN_APPLICABILITY_SCORE && i.length > 2 && (a.mainString.includes(i) ? o = e.DEFAULT_MIN_APPLICABILITY_SCORE + .1 : a.secondaryString.includes(i) && (o = e.DEFAULT_MIN_APPLICABILITY_SCORE + .05)),
          o = n.scoreOverride ? n.scoreOverride(t, o) : o,
          n.sortPriority !== void 0 && (n.sortPriority > 0 ? o >= e.DEFAULT_MIN_APPLICABILITY_SCORE && (o += n.sortPriority) : n.sortPriority < 0 && (o += n.sortPriority)),
          Number(o.toFixed(6))
      }
      static getSearchScoreStrings(t, n) {
          let r = e.getStrippedString(e.getActionName(t, n, {
              hideEllipsis: !0
          }))
            , i = e.getParentActionLabels(t, n).map(t => e.getStrippedString(t).toLowerCase())
            , a = e.getStrippedString(r)
            , o = [...i, a, this.getKeywordString(n)];
          if (r.includes(` `)) {
              let t = r.split(` `).filter(Boolean).join(``);
              t !== r && o.push(e.getStrippedString(t))
          }
          let s = ``
            , c = e.getKeyboardShortcut(t, n);
          if (c?.key) {
              let e = Array.isArray(c.key) ? c.key : [c.key];
              e.length === 1 && !Number.isNaN((0,
              z6.default)(e[0])) && (s = e[0])
          }
          return s && o.push(s),
          {
              mainString: a.toLowerCase(),
              secondaryString: o.filter(Boolean).join(` `).toLowerCase()
          }
      }
  }
}
)), G6, K6 = t(( () => {
  zt(),
  W6(),
  N(),
  G6 = class e {
      static create(t) {
          return new e(t)
      }
      get actions() {
          return this._actions
      }
      constructor(e) {
          this.generator = e,
          this._actions = [],
          this.executionIndex = 0,
          At(this)
      }
      async execute(e, t) {
          let n = ++this.executionIndex;
          this._currentExecutionContext && (this._currentExecutionContext.canceled = !0),
          this._currentExecutionContext = {
              canceled: !1,
              actionMenuContext: t
          };
          let r = this.generator(e, this._currentExecutionContext);
          if (Symbol.asyncIterator in r)
              for await(let i of r) {
                  if (n !== this.executionIndex)
                      return;
                  this.setActions(e, i, t)
              }
          else {
              let i = await r;
              if (n !== this.executionIndex)
                  return;
              this.setActions(e, i, t)
          }
      }
      setActions(e, t, n) {
          t.length === this._actions.length && this._actions.every( (n, r) => U6.actionsMatch(e, n, t[r])) || (Mt( () => {
              this._actions = t
          }
          ),
          n?.handleGeneratorActionsUpdated())
      }
  }
  ,
  M([Vt.shallow], G6.prototype, `_actions`, void 0)
}
)), q6, J6, Y6, X6, Z6, Q6, $6 = t(( () => {
  q6 = e(h()),
  J6 = e(_()),
  ir(),
  Za(),
  K6(),
  d3(),
  W6(),
  Y6 = 60,
  X6 = 10,
  Z6 = class {
      constructor(e=[]) {
          this.registeredActions = new Map,
          this.registeredActionId = 0,
          this.modifierLessKeys = new Set([`!`, `"`, `#`, `%`, `&`, `/`, `(`, `)`, `=`, `+`, `?`, `_`, `<`, `>`]),
          this.preregisteredActions = e
      }
      get allActions() {
          let e = [...this.registeredActions.entries()].map( ([,{action: e}]) => e);
          return (0,
          q6.default)([...this.preregisteredActions, ...e], `id`)
      }
      registerAction(e, t) {
          return this.registeredActionId++,
          this.registeredActions.set(this.registeredActionId, {
              action: e,
              shortcutHandler: t
          }),
          this.registeredActionId
      }
      unregisterAction(e) {
          this.registeredActions.delete(e)
      }
      applicableActions(e, t, n) {
          let r = this.getApplicableActionsDefault(e, t, n);
          if (!t.searchInput)
              return this.withCustomShortcuts(r, t.user);
          let i = this.filterAndSearchActionsSync(r, t);
          return this.withCustomShortcuts(i, t.user)
      }
      async applicableActionsAsync(e, t, n) {
          let r = this.getApplicableActionsDefault(e, t, n);
          if (!t.searchInput)
              return this.withCustomShortcuts(r, t.user);
          let i = await this.filterAndSearchActions(r, t, n?.signal);
          return this.withCustomShortcuts(i, t.user)
      }
      actionForKeyboardEvent(e, t) {
          let n = [...e.keys];
          if (n.length === 0)
              return;
          let r = this.getApplicableActionsAndSubActions(`keyboard-shortcuts`, this.allActionsForKeyboardInvoked, t, e => e.subActions && e.subActionsHaveKeyboardShortcuts ? !0 : U6.hasKeyboardShortcuts(e, t.user));
          for (r = this.withCustomShortcuts(r, t.user); n.length; ) {
              let i = r.find(r => {
                  if (e.repeat && !r.runOnRepeatKeyPress)
                      return !1;
                  let i = U6.getKeyboardShortcut(t, r);
                  return i ? this.keyboardShortcutApplicable(n, e, t, i) || r.alternativeKeyboardShortcut && this.keyboardShortcutApplicable(n, e, t, r.alternativeKeyboardShortcut) ? !0 : r.deprecatedKeyboardShortcut ? this.keyboardShortcutApplicable(n, e, t, r.deprecatedKeyboardShortcut) : !1 : !1
              }
              );
              if (i)
                  return {
                      action: i,
                      deprecationDate: i.deprecatedKeyboardShortcut && this.keyboardShortcutApplicable(n, e, t, i.deprecatedKeyboardShortcut) ? i.deprecatedKeyboardShortcut?.deprecationDate : void 0
                  };
              n.shift()
          }
      }
      shortcutHandlerForAction(e) {
          return Array.from(this.registeredActions.values()).find(t => t.action === e && t.shortcutHandler !== void 0)?.shortcutHandler
      }
      findActionById(e) {
          let t = this.allActions.find(t => `id`in t && t.id === e);
          return typeof t == `function` || t instanceof G6 ? void 0 : t
      }
      get allActionsForKeyboardInvoked() {
          return (0,
          q6.default)([...[...this.registeredActions.entries()].map( ([,{action: e}]) => e), ...this.preregisteredActions], `id`)
      }
      getApplicableActionsAndSubActions(e, t, n, r) {
          let i = [], a = new Set, o = n.searchInput ?? ``, s = o.toLocaleLowerCase(), c = o.length, l, u, d = (e, t) => {
              e.divider === !0 && (t.isSubAction ? u = e : l = e)
          }
          , f = (e, t) => {
              (t.isSubAction ? u : l) ? (i.push({
                  ...e,
                  divider: e.divider ?? !0
              }),
              t.isSubAction ? u = void 0 : l = void 0) : i.push(e)
          }
          ;
          function p(t, i) {
              if (!t.subActions)
                  return;
              if (e !== `keyboard-shortcuts`) {
                  if (t.searchSubActionsConfig?.neverInclude)
                      return;
                  let e = t.searchSubActionsConfig?.includeInRootOnlyWhenInputMatches;
                  if (n.isRootMenu && Array.isArray(e) && e.length > 0 && !e.some(e => s.includes(e)) || c < (t.searchSubActionsConfig?.minSearchInputLength ?? u3.minSearchInputLength))
                      return
              }
              let o = U6.resolveActionFactories(n, t.subActions(n));
              if (o.length)
                  for (let s of o) {
                      if (r(s) === !1) {
                          d(s, {
                              isSubAction: !0
                          });
                          continue
                      }
                      if (s.key && a.has(s.key))
                          continue;
                      if (e === `keyboard-shortcuts`) {
                          if (!U6.hasKeyboardShortcuts(s, n.user))
                              continue
                      } else if (s.hideInCommandMenu && n.isCommandMenu || s.hideInMenuRoot && n.isRootMenu && (s.hideInMenuRoot === !0 || typeof s.hideInMenuRoot == `function` && s.hideInMenuRoot?.(n) === !0))
                          continue;
                      if (!U6.isApplicableAction(n, s)) {
                          d(s, {
                              isSubAction: !0
                          });
                          continue
                      }
                      let o = {
                          ...s,
                          rootAction: i,
                          parentAction: t,
                          group: s.group.groupWhenLifted ?? s.group,
                          onlyVisibleThroughSearch: !0
                      };
                      (!o.key || !a.has(o.key)) && f(o, {
                          isSubAction: !0
                      }),
                      a.add(o.key),
                      p(o, i)
                  }
          }
          let m = U6.resolveActionFactories(n, t);
          n.isRootMenu && e !== `keyboard-shortcuts` && (m = U6.createGroupingActions(m));
          for (let t of m) {
              if (!U6.isApplicableAction(n, t)) {
                  d(t, {
                      isSubAction: !1
                  });
                  continue
              }
              if (r(t) === !1) {
                  d(t, {
                      isSubAction: !1
                  });
                  continue
              }
              (!t.key || !a.has(t.key)) && (f(t, {
                  isSubAction: !1
              }),
              a.add(t.key)),
              (c > 0 || e === `keyboard-shortcuts`) && p(t, t)
          }
          return i
      }
      getApplicableActionsDefault(e, t, n) {
          return e.length === 0 ? [] : this.getApplicableActionsAndSubActions(`default`, e, t, e => U6.isUnavailableDueToBootstrap(t, e) || e.hideInCommandMenu && t.isCommandMenu || !t.searchInput && !U6.getActionSelected(t, e) && Xa(e.onlyVisibleThroughSearch, t) === !0 ? !1 : n?.includeDisabled ? !0 : e.disabledReason === void 0 || e.disabledReason(t) === void 0)
      }
      filterAndSearchActionsSync(e, t) {
          let n = e.map(e => U6.scoreAction(t, e));
          return this.filterAndSortByScores(e, t, n)
      }
      async filterAndSearchActions(e, t, n) {
          let r = await U6.scoreActionsAsync(t, e, n);
          return this.filterAndSortByScores(e, t, r)
      }
      filterAndSortByScores(e, t, n) {
          let r = t.user.settings.debugActionsScore
            , i = []
            , a = new Map
            , o = e => {
              if (t.isRootMenu && `rootAction`in e && e.rootAction) {
                  let t = `id`in e.rootAction ? e.rootAction.id : void 0;
                  if (!t)
                      return !0;
                  let n = e.rootAction.limitSubActionsInRootMenu ?? X6
                    , r = a.get(t) ?? 0;
                  return a.set(t, r + 1),
                  !(r >= n)
              }
              return !0
          }
            , s = (e, t) => (r && (e.__debugScore = t),
          e);
          for (let t = 0; t < e.length; t++) {
              let r = e[t]
                , a = n[t] ?? 0;
              !r.skipFilterScoring && a < U6.DEFAULT_MIN_APPLICABILITY_SCORE || o(r) && i.push({
                  action: s(r, a),
                  score: a
              })
          }
          return (0,
          J6.default)(i, e => -e.score, e => e.action.group.priority(t)).map( ({action: e}) => e)
      }
      keyboardShortcutApplicable(e, t, n, r) {
          if (`deprecationDate`in r && r.deprecationDate.offsetByDays(Y6) < new Date)
              return !1;
          let i = rr.isMac || rr.isiPad
            , a = i ? r.mod : !1
            , o = i ? r.ctrl : r.mod || r.ctrl
            , s = !i && t.shift && Q6[t.lastEvent.code]
            , c = Array.isArray(r.key) ? r.key : [r.key]
            , l = c.join(`_`).toLowerCase() === e.join(`_`) || c.join(`_`).toLowerCase() === s
            , u = this.modifierLessKeys.has(c[0].toLowerCase()) && !t.meta && !t.alt && !t.ctrl
            , d = (a || !1) === t.meta && (r.alt || !1) === t.alt && (o || !1) === t.ctrl && (r.shift || !1) === t.shift;
          return c.length === e.length && l && (u || d) && (!n.focusOnTextInput || r.runWithInputFocus)
      }
      withCustomShortcuts(e, t) {
          return e.map(e => {
              let n = `id`in e ? t.settings.customShortcuts.find(t => t.actionId === e.id) : void 0;
              return n ? {
                  ...e,
                  keyboardShortcut: n.shortcut ? n.shortcut : void 0
              } : e
          }
          )
      }
  }
  ,
  Q6 = {
      Period: `.`,
      Comma: `,`,
      Quote: `'`
  }
}
)), e8, t8, n8, r8 = t(( () => {
  e8 = e(ht()),
  $6(),
  t8 = new Z6([]),
  n8 = e8.createContext(t8)
}
)), i8, a8, o8 = t(( () => {
  i8 = e(ht()),
  ws(),
  r8(),
  a8 = () => {
      let e = (0,
      i8.useContext)(n8);
      return (!e || t8 === e) && w.error(`Trying to call useActionRegistry outside ActionRegistryContext`),
      e
  }
}
));
function bfe(e, t, n) {
  let r = a8()
    , i = (0,
  s8.useRef)(null);
  (0,
  s8.useEffect)( () => {
      let a = e.current;
      if (!a)
          return;
      function o() {
          i.current ??= r.registerAction(t, n)
      }
      function s() {
          i.current != null && (r.unregisterAction(i.current),
          i.current = null)
      }
      return a.addEventListener(`mouseover`, o),
      a.addEventListener(`focusin`, o),
      a.addEventListener(`mouseleave`, s),
      a.addEventListener(`focusout`, s),
      () => {
          a.removeEventListener(`mouseover`, o),
          a.removeEventListener(`focusin`, o),
          a.removeEventListener(`mouseleave`, s),
          a.removeEventListener(`focusout`, s),
          s()
      }
  }
  , [t, n, e])
}
var s8, c8, l8 = t(( () => {
  s8 = e(ht()),
  o8(),
  c8 = (e, t) => {
      let n = a8();
      (0,
      s8.useEffect)( () => {
          if (!e)
              return;
          let r = n.registerAction(e, t);
          return () => {
              n.unregisterAction(r)
          }
      }
      , [e, t])
  }
}
)), u8, d8 = t(( () => {
  l8(),
  u8 = e => (c8(e.action, e.shortcutHandler),
  null)
}
));
function f8(e) {
  return (0,
  p8.jsx)(XK, {
      ...e,
      children: (0,
      p8.jsx)(`svg`, {
          children: (0,
          p8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M8 13.5C11.0376 13.5 13.5 11.0376 13.5 8C13.5 4.96243 11.0376 2.5 8 2.5C4.96243 2.5 2.5 4.96243 2.5 8C2.5 11.0376 4.96243 13.5 8 13.5ZM8 15C11.866 15 15 11.866 15 8C15 4.13401 11.866 1 8 1C4.13401 1 1 4.13401 1 8C1 11.866 4.13401 15 8 15Z`
          })
      })
  })
}
var p8, m8 = t(( () => {
  ht(),
  QK(),
  p8 = e(f(), 1)
}
));
function h8(e) {
  return (0,
  g8.jsx)(XK, {
      ...e,
      children: (0,
      g8.jsx)(`svg`, {
          children: (0,
          g8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M7 2C9.76142 2 12 4.23858 12 7C12 8.11012 11.6375 9.13519 11.0254 9.96484L13.7803 12.7197L13.832 12.7764C14.0723 13.0709 14.0549 13.5057 13.7803 13.7803C13.5057 14.0549 13.0709 14.0723 12.7764 13.832L12.7197 13.7803L9.96484 11.0254C9.13519 11.6375 8.11012 12 7 12C4.23858 12 2 9.76142 2 7C2 4.23858 4.23858 2 7 2ZM7 3.5C5.067 3.5 3.5 5.067 3.5 7C3.5 8.933 5.067 10.5 7 10.5C8.933 10.5 10.5 8.933 10.5 7C10.5 5.067 8.933 3.5 7 3.5Z`
          })
      })
  })
}
var g8, _8 = t(( () => {
  ht(),
  QK(),
  g8 = e(f(), 1)
}
));
function v8(e) {
  return (0,
  y8.jsx)(XK, {
      ...e,
      children: (0,
      y8.jsx)(`svg`, {
          children: (0,
          y8.jsx)(`path`, {
              d: `M8.58 1a.5.5 0 0 1 .49.42l.25 1.48a.49.49 0 0 0 .33.38c.18.059.353.132.52.22a.49.49 0 0 0 .51 0l1.22-.87a.5.5 0 0 1 .64 0l.82.82a.5.5 0 0 1 .05.64l-.87 1.22a.49.49 0 0 0 0 .51c.088.167.161.34.22.52a.49.49 0 0 0 .38.33l1.48.25a.5.5 0 0 1 .42.49v1.17a.5.5 0 0 1-.42.49l-1.48.25a.49.49 0 0 0-.38.33 3.38 3.38 0 0 1-.22.52.49.49 0 0 0 0 .51l.87 1.22a.5.5 0 0 1-.05.64l-.82.82a.5.5 0 0 1-.64.05l-1.22-.87a.49.49 0 0 0-.51 0 3.38 3.38 0 0 1-.52.22.49.49 0 0 0-.33.38l-.25 1.48a.5.5 0 0 1-.49.42H7.42a.5.5 0 0 1-.49-.42l-.25-1.52a.49.49 0 0 0-.33-.38 3.38 3.38 0 0 1-.52-.22.49.49 0 0 0-.51 0l-1.22.87a.5.5 0 0 1-.64-.05l-.82-.82a.5.5 0 0 1 0-.64l.87-1.22a.49.49 0 0 0 0-.51 3.38 3.38 0 0 1-.22-.52.49.49 0 0 0-.38-.33l-1.49-.21A.5.5 0 0 1 1 8.58V7.42a.5.5 0 0 1 .42-.49l1.48-.25a.49.49 0 0 0 .38-.33 3.38 3.38 0 0 1 .22-.52.49.49 0 0 0 0-.51L2.59 4.1a.5.5 0 0 1 0-.64l.82-.82a.5.5 0 0 1 .64 0l1.22.87a.49.49 0 0 0 .51 0 3.38 3.38 0 0 1 .52-.22.49.49 0 0 0 .33-.38l.3-1.49A.5.5 0 0 1 7.42 1h1.16ZM8 6a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z`
          })
      })
  })
}
var y8, b8 = t(( () => {
  ht(),
  QK(),
  y8 = e(f(), 1)
}
));
function x8(e) {
  return (0,
  S8.jsx)(XK, {
      ...e,
      children: (0,
      S8.jsxs)(`svg`, {
          children: [(0,
          S8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M12.5 13.5V15H3.5V13.5H12.5ZM13.5 12.5V3.5C13.5 2.94771 13.0523 2.5 12.5 2.5H3.5C2.94771 2.5 2.5 2.94772 2.5 3.5V12.5C2.5 13.0523 2.94772 13.5 3.5 13.5V15L3.24414 14.9873C2.06772 14.8677 1.13227 13.9323 1.0127 12.7559L1 12.5V3.5C1 2.20566 1.98361 1.14082 3.24414 1.0127L3.5 1H12.5L12.7559 1.0127C14.0164 1.14082 15 2.20566 15 3.5V12.5L14.9873 12.7559C14.8677 13.9323 13.9323 14.8677 12.7559 14.9873L12.5 15V13.5C13.0523 13.5 13.5 13.0523 13.5 12.5Z`
          }), (0,
          S8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M10 6C10 7.10457 9.10457 8 8 8C6.89543 8 6 7.10457 6 6C6 4.89543 6.89543 4 8 4C9.10457 4 10 4.89543 10 6Z`
          }), (0,
          S8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M11.405 12H4.59566C4.18761 12 3.88127 11.6641 4.0449 11.307C4.40693 10.5169 5.38905 9.33333 8.02449 9.33333C10.673 9.33333 11.6222 10.5286 11.9603 11.3187C12.1123 11.6738 11.8066 12 11.405 12Z`
          })]
      })
  })
}
var S8, C8 = t(( () => {
  ht(),
  QK(),
  S8 = e(f(), 1)
}
));
function w8(e) {
  return (0,
  T8.jsx)(XK, {
      ...e,
      children: (0,
      T8.jsxs)(`svg`, {
          children: [(0,
          T8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M6.93213 2.21398C7.66484 1.90793 8.49512 1.93032 9.21389 2.28028L14.28 4.74739C15.2242 5.20709 15.2441 6.55895 14.3138 7.04673L9.2874 9.6826C8.48012 10.1058 7.51988 10.1058 6.7126 9.6826L1.68618 7.04673C0.75589 6.55895 0.775786 5.20709 1.71995 4.74739L6.78611 2.28028L6.93213 2.21398ZM8.55132 3.67054C8.24643 3.52213 7.89768 3.50303 7.58179 3.61428L7.44868 3.67054L2.83947 5.91363L7.41491 8.31243C7.7819 8.50486 8.2181 8.50486 8.58509 8.31243L13.1595 5.91363L8.55132 3.67054Z`
          }), (0,
          T8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M13.9045 10.0768C14.272 9.90435 14.7242 10.0333 14.9153 10.365C15.1063 10.6966 14.9634 11.1047 14.5959 11.2772L9.49912 13.6693C8.55934 14.1102 7.44077 14.1102 6.50099 13.6693L1.40417 11.2772L1.33776 11.2428C1.01976 11.0547 0.905685 10.676 1.08483 10.365C1.26402 10.054 1.67295 9.92085 2.02626 10.0477L2.0956 10.0768L7.19241 12.468L7.38675 12.5464C7.84801 12.7022 8.36492 12.6757 8.80769 12.468L13.9045 10.0768Z`
          })]
      })
  })
}
var T8, E8 = t(( () => {
  ht(),
  QK(),
  T8 = e(f(), 1)
}
));
function D8(e) {
  return (0,
  O8.jsx)(XK, {
      ...e,
      children: (0,
      O8.jsxs)(`svg`, {
          children: [(0,
          O8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M8.57502 8C10.6434 8.00003 12.4741 9.33858 13.1014 11.3096L13.9647 14.0225C14.0902 14.4171 13.872 14.8392 13.4774 14.9648C13.0827 15.0903 12.6606 14.8721 12.535 14.4775L11.6717 11.7646C11.2426 10.416 9.99026 9.50003 8.57502 9.5H7.42462C6.00944 9.50011 4.75705 10.4161 4.32795 11.7646L3.46466 14.4775C3.33902 14.8722 2.91695 15.0904 2.52228 14.9648C2.12775 14.8392 1.90945 14.4171 2.03498 14.0225L2.89826 11.3096C3.52547 9.33861 5.35628 8.00011 7.42462 8H8.57502Z`
          }), (0,
          O8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M7.99982 1C9.5186 1 10.7498 2.23122 10.7498 3.75C10.7498 5.26878 9.5186 6.5 7.99982 6.5C6.48119 6.49982 5.24982 5.26867 5.24982 3.75C5.24982 2.23133 6.48119 1.00018 7.99982 1Z`
          })]
      })
  })
}
var O8, k8 = t(( () => {
  ht(),
  QK(),
  O8 = e(f(), 1)
}
));
function A8(e) {
  return (0,
  j8.jsx)(XK, {
      ...e,
      children: (0,
      j8.jsxs)(`svg`, {
          children: [(0,
          j8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M11.0247 12.3333C13.6728 12.3334 14.6225 13.529 14.9606 14.319C15.112 14.6739 14.806 15 14.4046 15H7.59537C7.18784 14.9997 6.8816 14.6641 7.04464 14.3073C7.40663 13.5172 8.38955 12.3333 11.0247 12.3333Z`
          }), (0,
          j8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M11 7C12.1045 7 12.9998 7.89543 12.9998 9C12.9998 10.1046 12.1045 11 11 11C9.89553 11 9.00018 10.1046 9.00018 9C9.00018 7.89543 9.89553 7 11 7Z`
          }), (0,
          j8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M10 4.25V3.75C10 3.05964 9.44036 2.5 8.75 2.5H3.75C3.05964 2.5 2.5 3.05964 2.5 3.75V13.25C2.5 13.3881 2.61193 13.5 2.75 13.5H4.25C4.66421 13.5 5 13.8358 5 14.25C5 14.6642 4.66421 15 4.25 15H2.75C1.7835 15 1 14.2165 1 13.25V3.75C1 2.23122 2.23122 1 3.75 1H8.75C10.2688 1 11.5 2.23122 11.5 3.75V4.25C11.5 4.66421 11.1642 5 10.75 5C10.3358 5 10 4.66421 10 4.25Z`
          }), (0,
          j8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M7.75 4.25C8.16421 4.25 8.5 4.58579 8.5 5C8.5 5.41421 8.16421 5.75 7.75 5.75H4.75C4.33579 5.75 4 5.41421 4 5C4 4.58579 4.33579 4.25 4.75 4.25H7.75Z`
          }), (0,
          j8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M6.5 7.25C6.91421 7.25 7.25 7.58579 7.25 8C7.25 8.41421 6.91421 8.75 6.5 8.75H4.75C4.33579 8.75 4 8.41421 4 8C4 7.58579 4.33579 7.25 4.75 7.25H6.5Z`
          }), (0,
          j8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M6.5 10.25C6.91421 10.25 7.25 10.5858 7.25 11C7.25 11.4142 6.91421 11.75 6.5 11.75H4.75C4.33579 11.75 4 11.4142 4 11C4 10.5858 4.33579 10.25 4.75 10.25H6.5Z`
          })]
      })
  })
}
var j8, M8 = t(( () => {
  ht(),
  QK(),
  j8 = e(f(), 1)
}
));
function N8(e) {
  return (0,
  P8.jsx)(XK, {
      ...e,
      children: (0,
      P8.jsx)(`svg`, {
          children: (0,
          P8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M6.5 3.25A2.25 2.25 0 0 1 5 5.372v5.256a2.25 2.25 0 1 1-1.5 0V5.372a2.25 2.25 0 1 1 3-2.122Zm-1.5 0a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Zm0 9.5a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM10.25 4v1a.75.75 0 0 1-1.28.53L7.22 3.78a.75.75 0 0 1 .043-1.1l1.75-1.496a.75.75 0 0 1 1.237.57V2.5a2.25 2.25 0 0 1 2.25 2.25v5.878a2.25 2.25 0 1 1-1.5 0V4.75a.75.75 0 0 0-.75-.75Zm1.5 9.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z`
          })
      })
  })
}
var P8, F8 = t(( () => {
  ht(),
  QK(),
  P8 = e(f(), 1)
}
));
function I8(e) {
  return (0,
  L8.jsx)(XK, {
      ...e,
      children: (0,
      L8.jsxs)(`svg`, {
          children: [(0,
          L8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M7.4145 8.3381C7.68162 7.8873 8.31838 7.8873 8.5855 8.3381L11.896 13.925C12.2589 14.5374 11.6035 15.2506 10.9879 14.9132L8.10753 13.3343C8.04032 13.2975 7.95967 13.2975 7.89247 13.3343L5.0121 14.9132C4.39652 15.2506 3.74112 14.5374 4.10401 13.925L7.4145 8.3381Z`
          }), (0,
          L8.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M13.5 8C13.5 4.96243 11.0376 2.5 8 2.5C4.96243 2.5 2.5 4.96243 2.5 8C2.5 8.96927 2.75037 9.87822 3.18945 10.668L3.38867 10.999L3.42773 11.0654C3.60231 11.4033 3.4953 11.825 3.16992 12.0371C2.84468 12.249 2.41642 12.1766 2.17773 11.8809L2.13281 11.8184L2.00195 11.6104C1.36597 10.5558 1 9.31963 1 8C1 4.13401 4.13401 1 8 1C11.866 1 15 4.13401 15 8C15 9.40749 14.5834 10.7198 13.8672 11.8184L13.8223 11.8809C13.5836 12.1766 13.1553 12.249 12.8301 12.0371C12.4831 11.8109 12.3851 11.346 12.6113 10.999L12.8105 10.668C13.2496 9.87822 13.5 8.96927 13.5 8Z`
          })]
      })
  })
}
var L8, R8 = t(( () => {
  ht(),
  QK(),
  L8 = e(f(), 1)
}
));
function z8({fill: e, stroke: t, ...n}) {
  return (0,
  B8.jsx)(`svg`, {
      width: `16`,
      height: `16`,
      viewBox: `0 0 16 16`,
      fill: `none`,
      "aria-hidden": !0,
      ...n,
      children: (0,
      B8.jsx)(`path`, {
          d: `M7.3406 2.32C7.68741 1.89333 8.31259 1.89333 8.6594 2.32L12.7903 7.402C13.0699 7.74597 13.0699 8.25403 12.7903 8.598L8.6594 13.68C8.31259 14.1067 7.68741 14.1067 7.3406 13.68L3.2097 8.598C2.9301 8.25403 2.9301 7.74597 3.2097 7.402L7.3406 2.32Z`,
          fill: e,
          stroke: t,
          strokeWidth: `2`,
          strokeLinejoin: `round`
      })
  })
}
var B8, V8 = t(( () => {
  ht(),
  B8 = e(f(), 1)
}
)), H8, U8, W8, G8 = t(( () => {
  WK(),
  H$(),
  n1(),
  T1(),
  H8 = () => e => {
      let {theme: t} = e;
      if (t.isDark)
          return `rgba(255, 255, 255, 0.075)`;
      let n = z$.fromCss(t.color.controlPrimary);
      return z$.toCss(t.colorFormat, [20, 50, n[2], .05])
  }
  ,
  U8 = DG([`font-family:`, `;font-size:0.9375em;padding:`, ` 0.25em;border-radius:0.2em;line-height:1.3;box-decoration-break:clone;background-color:`, `;box-shadow:0 0 0 `, ` `, ` inset;`], Z$(`monospace`), b1 ? `0.5px` : `0`, H8(), m1(), p1(`bgBorderSolid`)),
  W8 = HK.span([``, ``], U8)
}
)), K8, q8, J8, Y8, X8, Z8, Q8, $8, e5, t5, n5 = t(( () => {
  K8 = e(ht(), 1),
  q8 = e(be(), 1),
  J8 = e(_(), 1),
  Y8 = e(h(), 1),
  WK(),
  X8 = e(ne(), 1),
  G8(),
  Z8 = e(f(), 1),
  Q8 = K8.memo(e => {
      let {title: t=``, highlight: n=``, prefix: r=``, highlightPrefix: i=!1} = e
        , a = t5(r ? `${r}  ${t}` : t)
        , o = [];
      return Array.isArray(n) ? o = n : typeof n == `string` ? o = n.split(` `).filter(e => e.length > 0) : n instanceof RegExp && (o = [n]),
      i && o.push(RegExp(`^${(0,
      q8.default)(r)} `, `g`)),
      (0,
      Z8.jsx)(Z8.Fragment, {
          children: a.flatMap( ({content: t, type: n}, r) => {
              let i = e5(t, o, e.dimHighlights);
              return n === `code` ? (0,
              Z8.jsx)(W8, {
                  children: i
              }, r) : i
          }
          )
      })
  }
  , (e, t) => (0,
  X8.default)(e, t)),
  $8 = HK.span([`font-weight:var(--font-weight-medium);`, ``], e => e.$dim ? `opacity: 0.5;` : ``),
  e5 = (e, t, n=!1) => {
      let r = []
        , i = [];
      for (let n of t) {
          let t;
          if (typeof n == `string`)
              t = RegExp(`\\b${(0,
              q8.default)(n)}\\b`, `mgi`);
          else if (n instanceof RegExp)
              t = new RegExp(n.source,n.flags.includes(`g`) ? n.flags : n.flags + `g`);
          else
              continue;
          let i = [...e.matchAll(t)];
          i.filter(e => e.index !== void 0),
          r.push(...i)
      }
      r = (0,
      Y8.default)((0,
      J8.default)(r, [e => e.index || 0, e => -e[0].length]), e => `${e.index}-${e[0]}`);
      let a = r.map(e => e.index).filter(e => e !== null);
      if (a.length === 0)
          return [e];
      a[0] !== 0 && i.push(e.slice(0, a[0]));
      for (let[t,o] of a.entries()) {
          let s = r[t][0];
          if (i.push((0,
          Z8.jsx)($8, {
              $dim: n,
              children: e.slice(o, o + s.length)
          }, t)),
          o !== e.length - 1) {
              let n = t === a.length - 1 ? e.length : a[t + 1];
              i.push(e.slice(o + s.length, n))
          }
      }
      return i
  }
  ,
  t5 = e => {
      let t = [], n, r = (e, r) => {
          e && (n?.type === `text` && !r ? n.content += e : (n = {
              content: e,
              type: r ? `code` : `text`
          },
          t.push(n)))
      }
      , i = ``, a = !1;
      for (let t = 0; t < e.length; t++) {
          let n = e[t];
          n === "`" ? (!i && a && (i = "``"),
          r(i, a && i !== "``"),
          i = ``,
          a = !a) : i += n
      }
      return a && (i = "`" + i),
      r(i, !1),
      t
  }
}
));
function r5(e) {
  return (0,
  i5.jsx)(XK, {
      ...e,
      children: (0,
      i5.jsxs)(`svg`, {
          children: [(0,
          i5.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M7 2.5C8.11933 2.5 9.06613 3.23584 9.38477 4.25H14.75C15.1642 4.25 15.5 4.58579 15.5 5C15.5 5.41421 15.1642 5.75 14.75 5.75H9.38477C9.06613 6.76416 8.11933 7.5 7 7.5C5.88067 7.5 4.93387 6.76416 4.61523 5.75H2.25C1.83579 5.75 1.5 5.41421 1.5 5C1.5 4.58579 1.83579 4.25 2.25 4.25H4.61523C4.93387 3.23584 5.88067 2.5 7 2.5ZM7 4C6.44772 4 6 4.44772 6 5C6 5.55228 6.44772 6 7 6C7.55228 6 8 5.55228 8 5C8 4.44772 7.55228 4 7 4Z`
          }), (0,
          i5.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M10 13.5C8.88067 13.5 7.93387 12.7642 7.61523 11.75H2.25C1.83579 11.75 1.5 11.4142 1.5 11C1.5 10.5858 1.83579 10.25 2.25 10.25H7.61523C7.93387 9.23584 8.88067 8.5 10 8.5C11.1193 8.5 12.0661 9.23584 12.3848 10.25H14.75C15.1642 10.25 15.5 10.5858 15.5 11C15.5 11.4142 15.1642 11.75 14.75 11.75H12.3848C12.0661 12.7642 11.1193 13.5 10 13.5ZM10 12C10.5523 12 11 11.5523 11 11C11 10.4477 10.5523 10 10 10C9.44772 10 9 10.4477 9 11C9 11.5523 9.44772 12 10 12Z`
          })]
      })
  })
}
var i5, a5 = t(( () => {
  ht(),
  QK(),
  i5 = e(f(), 1)
}
));
function o5(e) {
  return (0,
  s5.jsx)(XK, {
      ...e,
      children: (0,
      s5.jsx)(`svg`, {
          children: (0,
          s5.jsx)(`path`, {
              fillRule: `evenodd`,
              clipRule: `evenodd`,
              d: `M12.3118 1.00155C13.0342 1.01378 13.734 1.22479 14.2552 1.74569C14.2778 1.76825 14.2992 1.79181 14.3206 1.81502C14.7934 2.32803 14.9867 2.99702 14.9984 3.68807C15.0104 4.40546 14.8306 5.1949 14.5169 5.99666C14.4587 6.14544 14.3937 6.29511 14.3255 6.44686C14.3153 6.4695 14.3057 6.49252 14.2952 6.51522C14.0734 6.99984 13.8015 7.49738 13.4847 7.99959C13.9161 8.68326 14.2654 9.35941 14.5179 10.0045C14.8314 10.806 15.0114 11.5959 14.9993 12.3131C14.987 13.0354 14.7762 13.7344 14.2552 14.2555C13.7341 14.7765 13.0352 14.9873 12.3128 14.9996C11.5956 15.0116 10.8058 14.8317 10.0042 14.5181C9.74958 14.4185 9.49156 14.3003 9.22884 14.1715C9.68636 13.856 10.1424 13.5099 10.5902 13.1353C11.26 13.3932 11.8354 13.5081 12.2874 13.5006C12.743 13.4928 13.0244 13.3651 13.1947 13.1949C13.3648 13.0246 13.4925 12.7432 13.5003 12.2877C13.508 11.8269 13.389 11.2369 13.1204 10.5504C13.0072 10.261 12.8687 9.95986 12.7074 9.65096L12.5384 9.33944C12.0887 9.91365 11.5857 10.4845 11.0345 11.0357C9.39839 12.6717 7.60167 13.8896 5.99544 14.5181C5.19372 14.8318 4.40416 15.0117 3.68685 14.9996C2.96443 14.9873 2.26558 14.7766 1.74446 14.2555V14.2535L1.74349 14.2545C1.22348 13.7335 1.01264 13.0348 1.00032 12.3131C0.988306 11.5959 1.16826 10.806 1.48177 10.0045C1.73419 9.35948 2.08269 8.68319 2.51399 7.99959C2.51149 7.99562 2.50868 7.99185 2.50618 7.98788C2.29914 7.65897 2.11157 7.33199 1.94466 7.00936C1.93701 6.9946 1.92878 6.98016 1.92122 6.96541C1.84392 6.81448 1.7725 6.66392 1.70442 6.51522C1.69395 6.49237 1.68342 6.46964 1.67317 6.44686C1.60504 6.29522 1.54092 6.14533 1.48274 5.99666C1.45773 5.93273 1.43474 5.86802 1.41145 5.80428C1.36173 5.66807 1.31419 5.53298 1.27278 5.39803C1.15129 5.00234 1.06681 4.61347 1.02669 4.23885C1.01665 4.14516 1.00959 4.05231 1.0052 3.96053C1.00082 3.86867 0.999789 3.77781 1.0013 3.68807C1.00893 3.23633 1.09338 2.79351 1.28352 2.39803C1.3595 2.24001 1.4526 2.08947 1.5638 1.94881C1.61948 1.87839 1.68026 1.81086 1.74544 1.74569C2.2667 1.22443 2.9652 1.01376 3.68782 1.00155C4.40524 0.989485 5.1946 1.16928 5.99642 1.48299C7.6027 2.11162 9.39937 3.3293 11.0355 4.96541L11.4388 5.38143C11.8334 5.8008 12.2005 6.22876 12.5374 6.65877C12.5422 6.65026 12.5473 6.64189 12.5521 6.63338C12.7805 6.22464 12.9717 5.82828 13.1195 5.45077C13.1851 5.28312 13.2412 5.12104 13.2894 4.96541C13.3151 4.88219 13.3388 4.80083 13.3597 4.72127C13.3831 4.63206 13.4028 4.54497 13.4202 4.46053C13.4773 4.18433 13.503 3.93431 13.4993 3.71346C13.4945 3.42895 13.4431 3.21229 13.3636 3.04842C13.3241 2.96713 13.2767 2.89969 13.2259 2.84237C13.2151 2.83014 13.2049 2.81649 13.1937 2.80526C13.0232 2.63566 12.7411 2.50828 12.2865 2.50057C11.8352 2.49312 11.2604 2.60694 10.5921 2.86385C10.1521 2.48866 9.7045 2.13787 9.2552 1.81502C9.50855 1.69186 9.75755 1.57916 10.0033 1.48299C10.8048 1.16939 11.5946 0.989595 12.3118 1.00155ZM3.71321 2.50057C3.33036 2.50704 3.07099 2.59826 2.89681 2.72811C2.86375 2.75315 2.83322 2.77901 2.80599 2.80623C2.63579 2.97651 2.50811 3.25792 2.50032 3.71346C2.49757 3.87893 2.51135 4.06112 2.54231 4.25838C2.57282 4.45264 2.62152 4.66112 2.68685 4.88338C2.73984 5.06387 2.80306 5.25357 2.8802 5.45077C3.03107 5.83614 3.22647 6.24199 3.46126 6.65975C3.91063 6.08604 4.41345 5.51619 4.96419 4.96541C5.20293 4.72668 5.44605 4.49726 5.69075 4.27694C6.10717 4.50854 6.54618 4.7925 6.99837 5.12166C6.67138 5.40263 6.34581 5.70489 6.02474 6.02596C5.37643 6.67432 4.80807 7.34179 4.32747 7.99959C4.80823 8.65772 5.37708 9.3265 6.02571 9.97518C6.34074 10.2902 6.6611 10.5866 6.98177 10.8629C6.51378 11.187 6.05944 11.4563 5.63313 11.6695C5.40879 11.4658 5.18448 11.255 4.96517 11.0357L4.66341 10.7271C4.64029 10.703 4.61798 10.6781 4.59505 10.6539C4.56255 10.6195 4.53049 10.5849 4.49837 10.5504C4.39953 10.4444 4.30262 10.3379 4.20735 10.231C4.19156 10.2133 4.17519 10.1961 4.1595 10.1783C3.91414 9.90098 3.68147 9.62063 3.46126 9.33944C3.22604 9.75783 3.03029 10.1645 2.87923 10.5504C2.61067 11.2369 2.49167 11.8269 2.49935 12.2877C2.50713 12.7415 2.6338 13.0235 2.80306 13.1939L2.80501 13.1949C2.97527 13.3651 3.25661 13.4928 3.71224 13.5006C4.1731 13.5083 4.76272 13.3894 5.44954 13.1207C6.73573 12.6173 8.24721 11.6324 9.68782 10.2545L9.97395 9.9742C10.6225 9.32557 11.1915 8.65767 11.6722 7.99959C11.3117 7.50627 10.9015 7.00728 10.4456 6.51522L9.97493 6.02596C8.4499 4.50094 6.82228 3.41741 5.45052 2.88045C4.7636 2.61166 4.17416 2.49285 3.71321 2.50057Z`
          })
      })
  })
}
var s5, c5 = t(( () => {
  ht(),
  QK(),
  s5 = e(f(), 1)
}
));
function l5(e) {
  let {progress: t=4, isComplete: n=!0, monochrome: r, ...i} = e
    , a = r ? void 0 : `var(--icon-color)`;
  return (0,
  u5.jsx)(XK, {
      ...i,
      children: (0,
      u5.jsxs)(`svg`, {
          fill: `none`,
          children: [(0,
          u5.jsx)(`path`, {
              style: {
                  opacity: t > 0 || r ? 1 : .4
              },
              fill: a,
              d: `M8.5 1.52v3.77c.94.18 1.72.83 2.06 1.71h3.88c.5 0 .75-.56.4-.88L9.46 1.15c-.36-.32-.96-.1-.96.37Z`
          }), (0,
          u5.jsx)(`path`, {
              style: {
                  opacity: t > 1 || r ? 1 : .4
              },
              fill: a,
              d: `M10.7 8.5a2.75 2.75 0 0 1-2.2 2.2v3.74c0 .5.6.75.96.4l5.37-5.38a.56.56 0 0 0-.4-.96h-3.72Z`
          }), (0,
          u5.jsx)(`path`, {
              style: {
                  opacity: t > 2 || r ? 1 : .4
              },
              fill: a,
              d: `M7.5 10.7a2.75 2.75 0 0 1-2.2-2.2H1.55a.56.56 0 0 0-.4.96l5.38 5.37a.56.56 0 0 0 .96-.4v-3.72Z`
          }), (0,
          u5.jsx)(`path`, {
              style: {
                  opacity: t > 3 || r ? 1 : .4
              },
              fill: a,
              d: `M5.44 7H1.56c-.5 0-.75-.56-.4-.88l5.38-4.97c.36-.32.96-.1.96.37v3.77A2.75 2.75 0 0 0 5.44 7Z`
          }), (0,
          u5.jsx)(`circle`, {
              cx: `8`,
              cy: `8`,
              r: `1.5`,
              fill: a,
              style: {
                  opacity: n || r ? 1 : .6
              }
          })]
      })
  })
}
var u5, d5 = t(( () => {
  ht(),
  QK(),
  u5 = e(f(), 1)
}
));
function f5(e) {
  return parseFloat(e.toFixed(3))
}
var p5, m5 = t(( () => {
  fp(),
  (function(e) {
      let t = e.HEX_REGEX_LOOSE = /#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?/i
        , n = e.HEX_REGEX = RegExp(`^${t.source}$`, `i`)
        , r = e.LCH_REGEX_LOOSE = /lch\((\d{1,3}(?:\.\d+)?)\% (\d{1,3}(?:\.\d+)?) (\d{1,3}(?:\.\d+)?)(?: \/ ([1|0](?:\.\d+)?)?)?\)/i
        , i = e.LCH_REGEX = RegExp(`^${r.source}$`, `i`)
        , a = e.P3_REGEX_LOOSE = /color\(display-p3 (\d{1,3}(?:\.\d+)?)\ (\d{1,3}(?:\.\d+)?) (\d{1,3}(?:\.\d+)?)\)/i
        , o = e.P3_REGEX = RegExp(`^${a.source}$`, `i`)
        , s = e.ANY_COLOR_REGEX_LOOSE = RegExp(`(?:${t.source})|(?:${r.source})|(?:${a.source})`, `i`)
        , c = e.ANY_COLOR_REGEX = RegExp(`^${s.source}$`, `i`)
        , l = [.3457 / .3585, 1, .2958 / .3585];
      function u(e, [t,n,r,i]) {
          return e === `LCH` ? `lch(${f5(t)}% ${f5(n)} ${f5(r)}${i === void 0 ? `` : ` / ` + f5(i)})` : e === `P3` ? ie([t, n, r, i]) : ee([t, n, r, i])
      }
      e.toCss = u;
      function d(e) {
          let t = n.exec(e);
          if (t) {
              let e = p5.rgbToLch([parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)]);
              return t[4] && !/ff/i.test(t[4]) && (e[3] = parseInt(t[4], 16) / 255),
              e
          } else {
              let t = i.exec(e);
              if (t) {
                  let e = [parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3])];
                  return t[4] && t[4] !== `1` && (e[3] = parseFloat(t[4])),
                  e
              } else {
                  let t = o.exec(e);
                  if (t)
                      return ce([parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3])])
              }
          }
          return [0, 0, 0]
      }
      e.fromCss = d;
      function f(e, t) {
          return p5.toCss(`RGB`, p5.adjustTo(p5.fromCss(e), {
              a: t
          }))
      }
      e.cssWithAlpha = f;
      function p(e) {
          let[t,n,r] = e;
          return [t > 50 ? 0 : 100, Math.min(10, n), r]
      }
      e.getTextColor = p;
      function m(e) {
          return e[0] > 50
      }
      e.isBright = m;
      function h(e, t) {
          let[n,r,i,a=1] = e;
          return [dp(n + (t.l ?? 0), 0, 100), dp(r + (t.c ?? 0), 0, 132), dp(i + (t.h ?? 0), 0, 360), dp(a + (t.a ?? 0), 0, 1)]
      }
      e.adjust = h;
      function g(e, t) {
          let[n,r,i,a=1] = e;
          return [dp(t.l ?? n, 0, 100), dp(t.c ?? r, 0, 132), dp(t.h ?? i, 0, 360), dp(t.a ?? a, 0, 1)]
      }
      e.adjustTo = g;
      function _(e, t, n) {
          let r = e[3] ?? 1
            , i = t[3] ?? 1
            , [a,o,s] = be(Se(e))
            , [c,l,u] = be(Se(t))
            , [d,f,p] = xe(ye([a * (1 - n) + n * c, o * (1 - n) + n * l, s * (1 - n) + n * u]));
          return [dp(d, 0, 100), dp(f, 0, 132), dp(p, 0, 360), r * (1 - n) + i * n]
      }
      e.mix = _;
      function ee(e) {
          let t = le(e).map(e => e.toString(16).split(`.`)[0]).map(e => e.length === 1 ? `0` + e : e)
            , n = e[3] !== void 0 && e[3] !== 1 ? te((e[3] * 255).toString(16).split(`.`)[0]) : ``;
          return `#${t[0]}${t[1]}${t[2]}${n}`
      }
      e.lchToRgbString = ee;
      function te(e) {
          return e.length === 1 ? `0` + e : e
      }
      function ne(e) {
          return c.test(e)
      }
      e.isValidColor = ne;
      function re(e) {
          return n.test(e) ? e : ee(d(e))
      }
      e.cssToRgb = re;
      function ie(e) {
          let t = ae(e);
          return `color(display-p3 ${t[0]} ${t[1]} ${t[2]}${e[3] === void 0 ? `` : ` / ${e[3].toString(10)}`})`
      }
      function ae(e) {
          return v(_e(be(Se(e)))).map(fe).map(e => dp(e, 0, 1))
      }
      function oe(e) {
          return xe(ye(ve(me(we(e)))))
      }
      e.rgbToLch = oe;
      function se(e, t, n, r) {
          let i = t
            , a = [];
          for (let t = 0; t < e; t++)
              i += .618033988749895,
              i %= 1,
              a[t] = ee([n * 100, r * 100, i * 360]);
          return a
      }
      e.palette = se;
      function ce(e) {
          return xe(ye(ve(he(we(e)))))
      }
      function le(e) {
          return de(Se(e))
      }
      function ue([[e,t,n],[r,i,a],[o,s,c]], [l,u,d]) {
          return [e * l + t * u + n * d, r * l + i * u + a * d, o * l + s * u + c * d]
      }
      let de = e => pe(ge(_e(be(e)))).map(e => dp(e, 0, 255));
      function fe(e) {
          let t = e < 0 ? -1 : 1
            , n = Math.abs(e);
          return n > .0031308 ? t * (1.055 * n ** (1 / 2.4) - .055) : 12.92 * e
      }
      function pe(e) {
          return e.map(e => 255 * fe(e))
      }
      function me(e) {
          return ue([[.41239079926595934, .357584339383878, .1804807884018343], [.21263900587151027, .715168678767756, .07219231536073371], [.01933081871559182, .11919477979462598, .9505321522496607]], e)
      }
      function he(e) {
          return ue([[.4865709486482162, .26566769316909306, .1982172852343625], [.2289745640697488, .6917385218365064, .079286914093745], [0, .04511338185890264, 1.043944368900976]], e)
      }
      function ge(e) {
          return ue([[3.2409699419045226, -1.537383177570094, -.4986107602930034], [-.9692436362808796, 1.8759675015077202, .04155505740717559], [.05563007969699366, -.20397695888897652, 1.0569715142428786]], e)
      }
      function v(e) {
          return ue([[2.493496911941425, -.9313836179191239, -.40271078445071684], [-.8294889695615747, 1.7626640603183463, .023624685841943577], [.03584583024378447, -.07617238926804182, .9568845240076872]], e)
      }
      function _e(e) {
          return ue([[.9554734527042182, -.023098536874261423, .0632593086610217], [-.028369706963208136, 1.0099954580058226, .021041398966943008], [.012314001688319899, -.020507696433477912, 1.3303659366080753]], e)
      }
      function ve(e) {
          return ue([[1.0479298208405488, .022946793341019088, -.05019222954313557], [.029627815688159344, .990434484573249, -.01707382502938514], [-.009243058152591178, .015055144896577895, .7518742899580008]], e)
      }
      function ye(e) {
          let t = e.map( (e, t) => e / l[t]).map(e => e > .008856451679035631 ? Math.cbrt(e) : (903.2962962962963 * e + 16) / 116);
          return [116 * t[1] - 16, 500 * (t[0] - t[1]), 200 * (t[1] - t[2])]
      }
      function be(e) {
          let t = 24389 / 27
            , n = 216 / 24389
            , r = [];
          return r[1] = (e[0] + 16) / 116,
          r[0] = e[1] / 500 + r[1],
          r[2] = r[1] - e[2] / 200,
          [r[0] ** 3 > n ? r[0] ** 3 : (116 * r[0] - 16) / t, e[0] > t * n ? ((e[0] + 16) / 116) ** 3 : e[0] / t, r[2] ** 3 > n ? r[2] ** 3 : (116 * r[2] - 16) / t].map( (e, t) => e * l[t])
      }
      function xe(e) {
          let t = Math.atan2(e[2], e[1]) * 180 / Math.PI;
          return [e[0], Math.sqrt(e[1] ** 2 + e[2] ** 2), t >= 0 ? t : t + 360, 1]
      }
      function Se(e) {
          return [e[0], e[1] * Math.cos(e[2] * Math.PI / 180), e[1] * Math.sin(e[2] * Math.PI / 180)]
      }
      function Ce(e) {
          let t = e < 0 ? -1 : 1
            , n = Math.abs(e);
          return n < .04045 ? e / 12.92 : t * ((n + .055) / 1.055) ** 2.4
      }
      function we(e) {
          return e.map(e => Ce(e / 255))
      }
  }
  )(p5 ||= {})
}
)), h5, g5, _5 = t(( () => {
  ht(),
  On(),
  WK(),
  Ud(),
  d5(),
  m5(),
  h5 = e(f()),
  g5 = Dn(function(e) {
      let {type: t, ...n} = e
        , r = wG()
        , i = {
          [Hd.dev]: 1,
          [Hd.internal]: 2,
          [Hd.partial]: 3,
          [Hd.full]: 4
      };
      return (0,
      h5.jsx)(l5, {
          progress: t ? i[t] : 0,
          isComplete: t === Hd.full,
          color: t ? p5.toCss(`RGB`, p5.adjust(p5.fromCss(r.color.purpleBase), {
              h: 10 * (i[t] - 1)
          })) : void 0,
          ...n
      })
  })
}
));
function xfe() {
  return y5(Zt().pathname)
}
function Sfe(e, t) {
  return !!(e.pathname && Yt({
      path: PF(t),
      end: !1
  }, e.pathname))
}
function Cfe(e) {
  return !!(e.pathname && e.pathname.match(S5))
}
function wfe(e, t) {
  return !!(e.pathname && Yt({
      path: NF(t),
      end: !1
  }, e.pathname))
}
function Tfe(e, t) {
  return !!(e.pathname && Yt({
      path: ZF(t),
      end: !1
  }, e.pathname) || e.state?.issueOrigin?.type === `reviews`)
}
function Efe(e, t) {
  return !!(e.pathname && Yt({
      path: $F(t),
      end: !1
  }, e.pathname) || e.state?.issueOrigin?.type === `agents`)
}
function Dfe(e) {
  return e.state?.issueOrigin?.type === `inbox`
}
function Ofe(e, t) {
  return !!(t.pathname && (Yt({
      path: nI(e, `issue`),
      end: !1
  }, t.pathname) || Yt({
      path: nI(e, `project`),
      end: !1
  }, t.pathname)))
}
function kfe(e, t) {
  return !!(t.pathname && Yt({
      path: e instanceof K ? lI(e, `views`) : RF(e),
      end: !1
  }, t.pathname))
}
function Afe(e) {
  return e.state?.issueOrigin?.type === `triage`
}
function jfe(e) {
  return e.state?.issueOrigin?.type === `search`
}
function Mfe(e) {
  return e.state?.issueOrigin != null
}
var v5, y5, b5, x5, S5, C5 = t(( () => {
  Xt(),
  Ete(),
  ML(),
  mH(),
  v5 = {
      inbox: `/:orgKey/inbox`,
      triage: `/:orgKey/team/:teamId/triage`,
      activeIssues: `/:orgKey/team/:teamId/active`,
      customers: `/:orgKey/customers`,
      customer: `/:orgKey/customer/:customerId`,
      backlog: `/:orgKey/team/:teamId/backlog`,
      allIssues: `/:orgKey/team/:teamId/all`,
      teamFacet: `/:orgKey/team/:teamId/view/:viewId`,
      board: `/:orgKey/team/:teamId/board`,
      archive: `/:orgKey/team/:teamId/archive/:archiveTab?`,
      myIssuesAssigned: `/:orgKey/my-issues/assigned`,
      myIssuesCreated: `/:orgKey/my-issues/created`,
      myIssuesSubscribed: `/:orgKey/my-issues/subscribed`,
      myIssuesActivity: `/:orgKey/my-issues/activity`,
      userProfileCreatedByUser: `/:orgKey/profiles/:userId/created`,
      userProfile: `/:orgKey/profiles/:userId`,
      cyclesList: `/:orgKey/team/:teamId/cycles`,
      cycle: `/:orgKey/team/:teamId/cycle/:cycleIdentifier`,
      projectCustomerRequests: `/:orgKey/project/:projectId/requests`,
      projectUpdates: `/:orgKey/project/:projectId/updates`,
      projectFacet: `/:orgKey/project/:projectId/view/:viewId`,
      project: `/:orgKey/project/:projectId/:tab?`,
      projectLabel: `/:orgKey/project-label/:labelName`,
      issue: `/:orgKey/issue/:issueId/:issueName?`,
      initiativeUpdates: `/:orgKey/initiative/:initiativeId/updates`,
      initiativeFacet: `/:orgKey/initiative/:initiativeId/view/:viewId`,
      initiative: `/:orgKey/initiative/:initiativeId/:tab?`,
      initiativesCompleted: `/:orgKey/initiatives/completed`,
      initiativesPlanned: `/:orgKey/initiatives/planned`,
      initiativesActive: `/:orgKey/initiatives/active`,
      initiatives: `/:orgKey/initiatives`,
      teamLabel: `/:orgKey/team/:teamId/issue-label/:labelName`,
      workspaceLabel: `/:orgKey/issue-label/:labelName`,
      customViewsList: `/:orgKey/views/:viewType?`,
      teamCustomViewsList: `/:orgKey/team/:teamKey/views/:viewType?`,
      customView: `/:orgKey/view/:viewId`,
      analytics: `/:orgKey/team/:teamId/analytics`,
      teams: `/:orgKey/teams`,
      teamProjects: `/:orgKey/team/:teamId/projects/:viewType?`,
      allProjects: `/:orgKey/projects/:viewType?`,
      pulseFollowing: `/:orgKey/pulse/following`,
      pulsePopular: `/:orgKey/pulse/popular`,
      pulseAll: `/:orgKey/pulse/all`,
      reviews: `/:orgKey/reviews`,
      review: `/:orgKey/review/:reviewId`,
      agents: `/:orgKey/agents`,
      triageSettings: `/:orgKey/settings/teams/:teamId/triage`,
      triageMemoriesSettings: `/:orgKey/settings/teams/:teamId/triage/memories`
  },
  y5 = Dte(e => {
      let[t] = Object.entries(v5).find( ([t,n]) => !!Yt({
          path: n,
          end: !1
      }, e)) || [];
      return t
  }
  ),
  b5 = e => e === `initiatives` || e === `initiativesActive` || e === `initiativesPlanned` || e === `initiativesCompleted`,
  x5 = e => e === `initiative`,
  S5 = /\/.+\/team\/[A-Z]+\/triage$/
}
));
function w5() {
  return T5.useMemo( () => {
      let e = 1.5
        , t = 14 / 2 - e / 2
        , n = Math.PI * 2 * t
        , r = n / 24;
      return {
          radius: t,
          strokeWidth: e,
          perimeter: n,
          strokeDasharray: r,
          strokeDashoffset: .5 * r
      }
  }
  , [])
}
var T5, E5, D5, O5, k5 = t(( () => {
  T5 = e(ht(), 1),
  On(),
  WK(),
  fp(),
  E5 = e(f(), 1),
  D5 = 3,
  O5 = Dn(function(e) {
      let {isNext: t, isActive: n, isPlanned: r, isCompleted: i, progress: a, noProgress: o, noCycle: s, strongColors: c, size: l=16, ...u} = e
        , d = wG()
        , {radius: f, perimeter: p, strokeWidth: m, strokeDasharray: h, strokeDashoffset: g} = w5()
        , _ = dp(.065 + (o ? 1 : a || 0) * (.935 + D5 / p), 0, 1)
        , ee = 360 * p / (p + D5);
      return (0,
      E5.jsxs)(`svg`, {
          width: l,
          height: l,
          fill: c ? d.color.labelTitle : d.color.labelMuted,
          stroke: d.color.labelFaint,
          viewBox: `0 0 16 16`,
          style: {
              overflow: `visible`
          },
          "aria-hidden": !0,
          ...u,
          children: [t ? (0,
          E5.jsx)(E5.Fragment, {
              children: (0,
              E5.jsx)(`circle`, {
                  cx: `8`,
                  cy: `8`,
                  r: f,
                  fill: `none`,
                  strokeWidth: m
              })
          }) : n ? (0,
          E5.jsxs)(E5.Fragment, {
              children: [(0,
              E5.jsx)(`circle`, {
                  transform: `rotate(${-76 + _ * ee} ${f} ${f})`,
                  cx: `8`,
                  cy: `8`,
                  r: f,
                  fill: `none`,
                  strokeWidth: m,
                  strokeDasharray: p + `px`,
                  strokeDashoffset: D5 + (p - D5) * _ + `px`,
                  style: {
                      transition: `transform 0.6s, stroke-dashoffset 0.6s`,
                      strokeLinecap: `round`,
                      transformBox: `fill-box`
                  }
              }), (0,
              E5.jsx)(`circle`, {
                  transform: `rotate(-76 ${f} ${f})`,
                  cx: `8`,
                  cy: `8`,
                  r: f,
                  fill: `none`,
                  stroke: d.color.purpleBase,
                  strokeWidth: m,
                  strokeDasharray: p + `px`,
                  strokeDashoffset: D5 + p - (p - D5) * _ + `px`,
                  style: {
                      transition: `stroke-dashoffset 0.6s`,
                      strokeLinecap: `round`,
                      transformBox: `fill-box`
                  }
              })]
          }) : null, r && (0,
          E5.jsx)(`circle`, {
              cx: `8`,
              cy: `8`,
              r: f,
              fill: `none`,
              strokeWidth: m,
              strokeDasharray: h,
              strokeDashoffset: g
          }), i && (0,
          E5.jsx)(E5.Fragment, {
              children: (0,
              E5.jsx)(`circle`, {
                  cx: `8`,
                  cy: `8`,
                  r: f,
                  fill: `none`,
                  strokeWidth: m,
                  strokeDasharray: s ? void 0 : `${p * .7}px ${p * .3}px`,
                  strokeDashoffset: s ? void 0 : `${p * .73}px`,
                  style: s ? void 0 : {
                      strokeLinecap: `round`
                  }
              })
          }), (0,
          E5.jsx)(`path`, {
              fill: i && !s ? d.color.labelFaint : n && o ? d.color.labelTitle : void 0,
              stroke: `none`,
              d: `M6.95588 5.28329L10.6901 7.43926C11.0235 7.63171 11.0235 8.11283 10.6901 8.30528L6.95588 10.4612C6.62255 10.6537 6.20588 10.4131 6.20588 10.0282L6.20588 5.71631C6.20588 5.33141 6.62255 5.09084 6.95588 5.28329Z`
          }), i && !s && (0,
          E5.jsx)(E5.Fragment, {
              children: (0,
              E5.jsx)(`path`, {
                  d: `M13.7267 9.19449C14.0115 8.89373 14.4865 8.88038 14.7872 9.16519C15.0878 9.45003 15.1003 9.92505 14.8155 10.2257L10.9825 14.2736C10.8387 14.4253 10.6379 14.5096 10.4288 14.507C10.2196 14.5043 10.021 14.4145 9.88096 14.2589L8.28233 12.4836C8.00532 12.1757 8.03026 11.7011 8.33799 11.424C8.64589 11.1469 9.1205 11.1718 9.39756 11.4796L10.4523 12.6515L13.7267 9.19449Z`,
                  stroke: `none`
              })
          })]
      })
  })
}
));
function A5(e) {
  let t = _m.isLazy(e) ? e.resolve() : e;
  if (!(t instanceof Promise))
      return t;
  let n = j5(t);
  if (n.__result__) {
      if (n.__result__.rejected)
          throw n.__result__.rejected;
      return n.__result__.resolved
  }
  throw n
}
function Nfe(e) {
  let t = !1
    , n = e.map(e => _m.isLazy(e) ? (t = !0,
  e.resolve()) : (e instanceof Promise && (t = !0),
  e));
  if (n.length === 0 || !t)
      return e;
  let r = n
    , i = r.filter(e => e instanceof Promise && e.__result__ === void 0);
  if (i.length)
      throw Promise.all(i.map(j5));
  return r.map(e => {
      if (!(e instanceof Promise))
          return e;
      if (e.__result__?.success === !1)
          throw e.__result__?.rejected;
      return e.__result__?.resolved
  }
  )
}
function j5(e) {
  return e.__cached__ || (e.__cached__ = !0,
  e.then(t => {
      e.__result__ = {
          resolved: t,
          success: !0
      }
  }
  ).catch(t => {
      e.__result__ = {
          rejected: t,
          success: !1
      }
  }
  )),
  e
}
var M5 = t(( () => {
  Sm()
}
));
function Pfe(e) {
  return (0,
  P5.jsx)(`svg`, {
      width: `16`,
      height: `16`,
      viewBox: `0 0 16 16`,
      fill: wG().color.labelMuted,
      className: e.className,
      "aria-hidden": !0,
      children: (0,
      P5.jsxs)(`svg`, {
          children: [(0,
          P5.jsx)(`path`, {
              d: `M8 1C8.41421 1 8.75 1.33579 8.75 1.75C8.75 2.16421 8.41421 2.5 8 2.5C4.96243 2.5 2.5 4.96243 2.5 8C2.5 11.0376 4.96243 13.5 8 13.5C11.0376 13.5 13.5 11.0376 13.5 8C13.5 6.23619 12.6701 4.66687 11.377 3.65918C11.0503 3.40457 10.9925 2.93313 11.2471 2.60645C11.5017 2.27972 11.9731 2.22098 12.2998 2.47559C13.9418 3.75527 15 5.75433 15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1Z`
          }), (0,
          P5.jsx)(`path`, {
              d: `M6.85547 6.1123C7.07646 5.97571 7.35255 5.96305 7.58496 6.0791L10.085 7.3291L10.1758 7.38281C10.3769 7.52151 10.5 7.75131 10.5 8C10.5 8.24869 10.3769 8.47849 10.1758 8.61719L10.085 8.6709L7.58496 9.9209C7.35255 10.0369 7.07646 10.0243 6.85547 9.8877C6.63458 9.75099 6.5 9.50981 6.5 9.25V6.75L6.50586 6.65332C6.53467 6.43131 6.66226 6.23188 6.85547 6.1123Z`
          })]
      })
  })
}
function Ffe(e) {
  let t = wG()
    , {radius: n, strokeWidth: r, strokeDasharray: i, strokeDashoffset: a} = w5();
  return (0,
  P5.jsx)(`svg`, {
      stroke: t.color.labelFaint,
      width: `16`,
      height: `16`,
      viewBox: `0 0 16 16`,
      className: e.className,
      style: {
          overflow: `visible`
      },
      "aria-hidden": !0,
      children: (0,
      P5.jsx)(`circle`, {
          cx: `8`,
          cy: `8`,
          r: n,
          fill: `none`,
          strokeWidth: r,
          strokeDasharray: i,
          strokeDashoffset: a
      })
  })
}
var N5, P5, F5, I5, L5 = t(( () => {
  N5 = e(ht()),
  On(),
  WK(),
  k5(),
  M5(),
  P5 = e(f()),
  F5 = Dn(function(e) {
      let {cycle: t, ...n} = e;
      return (0,
      P5.jsx)(N5.Suspense, {
          fallback: (0,
          P5.jsx)(O5, {
              noCycle: !t,
              isNext: !1,
              isActive: !1,
              isPlanned: t?.isPlanned ?? !1,
              isCompleted: t?.isCompleted ?? !0,
              progress: t?.progress ?? 0,
              ...n
          }),
          children: (0,
          P5.jsx)(I5, {
              cycle: t,
              ...n
          })
      })
  }),
  I5 = Dn(function(e) {
      let {cycle: t, ...n} = e;
      return A5(t?.team?.cycles.hydrate()),
      (0,
      P5.jsx)(O5, {
          noCycle: !t,
          isNext: t?.isNext ?? !1,
          isActive: t?.isActive ?? !1,
          isPlanned: t?.isPlanned ?? !1,
          isCompleted: t?.isCompleted ?? !0,
          progress: t?.progress ?? 0,
          ...n
      })
  })
}
)), $, R5, z5 = t(( () => {
  Ot(),
  $ = function(e) {
      return e.Accessibility = `Accessibility`,
      e.Africa = `Africa`,
      e.Ai = `Ai`,
      e.AiApp = `AiApp`,
      e.AiDocument = `AiDocument`,
      e.Airplane = `Airplane`,
      e.Alert = `Alert`,
      e.Anchor = `Anchor`,
      e.Android = `Android`,
      e.Apple = `Apple`,
      e.Asia = `Asia`,
      e.Astronaut = `Astronaut`,
      e.Australia = `Australia`,
      e.Bank = `Bank`,
      e.BarChart = `BarChart`,
      e.Basket = `Basket`,
      e.Battery = `Battery`,
      e.Bike = `Bike`,
      e.Binocular = `Binocular`,
      e.Bitcoin = `Bitcoin`,
      e.Bluetooth = `Bluetooth`,
      e.Bolt = `Bolt`,
      e.Book = `Book`,
      e.Bookmark = `Bookmark`,
      e.Brain = `Brain`,
      e.Briefcase = `Briefcase`,
      e.Brush = `Brush`,
      e.Bucket = `Bucket`,
      e.Bug = `Bug`,
      e.Burger = `Burger`,
      e.Calendar = `Calendar`,
      e.Camera = `Camera`,
      e.CameraAi = `CameraAi`,
      e.Car = `Car`,
      e.Cart = `Cart`,
      e.Chart = `Chart`,
      e.Chat = `Chat`,
      e.Checklist = `Checklist`,
      e.Chip = `Chip`,
      e.Clock = `Clock`,
      e.ClockOutline = `ClockOutline`,
      e.Cloud = `Cloud`,
      e.Coffee = `Coffee`,
      e.Compass = `Compass`,
      e.Computer = `Computer`,
      e.Cone = `Cone`,
      e.CreditCard = `CreditCard`,
      e.Cross = `Cross`,
      e.Crown = `Crown`,
      e.Cube = `Cube`,
      e.CustomView = `CustomView`,
      e.Dashboard = `Dashboard`,
      e.Database = `Database`,
      e.DesignTools = `DesignTools`,
      e.Direction = `Direction`,
      e.Dna = `Dna`,
      e.Dollar = `Dollar`,
      e.Education = `Education`,
      e.Email = `Email`,
      e.Etherum = `Etherum`,
      e.Euro = `Euro`,
      e.Europe = `Europe`,
      e.FaceFlatSmile = `FaceFlatSmile`,
      e.FaceHeartEyes = `FaceHeartEyes`,
      e.Face = `Face`,
      e.FaceId = `FaceId`,
      e.FaceMask = `FaceMask`,
      e.FaceMonocle = `FaceMonocle`,
      e.FaceStarEyes = `FaceStarEyes`,
      e.FaceSunglasses = `FaceSunglasses`,
      e.FaceSurprise = `FaceSurprise`,
      e.FaceTired = `FaceTired`,
      e.FaceTongue = `FaceTongue`,
      e.Feather = `Feather`,
      e.Fire = `Fire`,
      e.Flower = `Flower`,
      e.Folder = `Folder`,
      e.FootPrint = `FootPrint`,
      e.Gears = `Gears`,
      e.GitHub = `GitHub`,
      e.GitLab = `GitLab`,
      e.Heart = `Heart`,
      e.Home = `Home`,
      e.Image = `Image`,
      e.Inbox = `Inbox`,
      e.Initiative = `Initiative`,
      e.Joystick = `Joystick`,
      e.Jersey = `Jersey`,
      e.Label = `Label`,
      e.Leaf = `Leaf`,
      e.LightBulb = `LightBulb`,
      e.Link = `Link`,
      e.Lock = `Lock`,
      e.Mac = `Mac`,
      e.Mic = `Mic`,
      e.Megaphone = `Megaphone`,
      e.MobilePhone = `MobilePhone`,
      e.Modem = `Modem`,
      e.Moon = `Moon`,
      e.Mountain = `Mountain`,
      e.MusicKey = `MusicKey`,
      e.Network = `Network`,
      e.NorthAmerica = `NorthAmerica`,
      e.Page = `Page`,
      e.Paint = `Paint`,
      e.Phone = `Phone`,
      e.PieChart = `PieChart`,
      e.Pin = `Pin`,
      e.Pizza = `Pizza`,
      e.Policy = `Policy`,
      e.Present = `Present`,
      e.Project = `Project`,
      e.Radar = `Radar`,
      e.Ramen = `Ramen`,
      e.Recycle = `Recycle`,
      e.Robot = `Robot`,
      e.Rocket = `Rocket`,
      e.Routing = `Routing`,
      e.Scissors = `Scissors`,
      e.Search = `Search`,
      e.Send = `Send`,
      e.Server = `Server`,
      e.Shield = `Shield`,
      e.Ship = `Ship`,
      e.Shop = `Shop`,
      e.Sign = `Sign`,
      e.Skull = `Skull`,
      e.Solana = `Solana`,
      e.Sound = `Sound`,
      e.SouthAmerica = `SouthAmerica`,
      e.Favorite = `Favorite`,
      e.Subscribe = `Subscribe`,
      e.Sun = `Sun`,
      e.Tablet = `Tablet`,
      e.TeeShirt = `TeeShirt`,
      e.Terminal = `Terminal`,
      e.Team = `Team`,
      e.ThumbsUp = `ThumbsUp`,
      e.ThumbsDown = `ThumbsDown`,
      e.Trash = `Trash`,
      e.Tree = `Tree`,
      e.Umbrella = `Umbrella`,
      e.UnhappyFace = `UnhappyFace`,
      e.Users = `Users`,
      e.Video = `Video`,
      e.Watch = `Watch`,
      e.WindTurbine = `WindTurbine`,
      e.World = `World`,
      e.AirTag = `AirTag`,
      e.AlarmClock = `AlarmClock`,
      e.AmericanFootBall = `AmericanFootBall`,
      e.Asterisk = `Asterisk`,
      e.Bandage = `Bandage`,
      e.Basketball = `Basketball`,
      e.Bed = `Bed`,
      e.Boombox = `Boombox`,
      e.Bones = `Bones`,
      e.BookOpen = `BookOpen`,
      e.BowlingBall = `BowlingBall`,
      e.Box = `Box`,
      e.BoxOpen = `BoxOpen`,
      e.Bus = `Bus`,
      e.Calculator = `Calculator`,
      e.CarPool = `CarPool`,
      e.Chemist = `Chemist`,
      e.ClickButton = `ClickButton`,
      e.ClothHanger = `ClothHanger`,
      e.Comodore = `Comodore`,
      e.Connected = `Connected`,
      e.ConstructionBarrier = `ConstructionBarrier`,
      e.Conversation = `Conversation`,
      e.Cookie = `Cookie`,
      e.Crane = `Crane`,
      e.CrystalBall = `CrystalBall`,
      e.DesktopWindow = `DesktopWindow`,
      e.Dice = `Dice`,
      e.Dino = `Dino`,
      e.DollarBill = `DollarBill`,
      e.Dumbbell = `Dumbbell`,
      e.ElectricPlug = `ElectricPlug`,
      e.Eraser = `Eraser`,
      e.Extinguisher = `Extinguisher`,
      e.Factory = `Factory`,
      e.Flashlight = `Flashlight`,
      e.FloppyDisk = `FloppyDisk`,
      e.Garage = `Garage`,
      e.Golf = `Golf`,
      e.Hack = `Hack`,
      e.Health = `Health`,
      e.Hear = `Hear`,
      e.Hourglass = `Hourglass`,
      e.Judge = `Judge`,
      e.Ladder = `Ladder`,
      e.LockerRoom = `LockerRoom`,
      e.MacOS = `MacOS`,
      e.MagicWand = `MagicWand`,
      e.Magnet = `Magnet`,
      e.Mask = `Mask`,
      e.MilitaryTruck = `MilitaryTruck`,
      e.MoneyStack = `MoneyStack`,
      e.MovingStaircase = `MovingStaircase`,
      e.MusicTape = `MusicTape`,
      e.NotePad = `NotePad`,
      e.Notified = `Notified`,
      e.PalmTree = `PalmTree`,
      e.Pills = `Pills`,
      e.PingPong = `PingPong`,
      e.Pointer = `Pointer`,
      e.PokerCard = `PokerCard`,
      e.Process = `Process`,
      e.Rank = `Rank`,
      e.Runner = `Runner`,
      e.SafetyKit = `SafetyKit`,
      e.Shrug = `Shrug`,
      e.Signature = `Signature`,
      e.SoccerBall = `SoccerBall`,
      e.Spaces = `Spaces`,
      e.Speaker = `Speaker`,
      e.Spreadsheet = `Spreadsheet`,
      e.Stadium = `Stadium`,
      e.Storm = `Storm`,
      e.Subgroup = `Subgroup`,
      e.Surfer = `Surfer`,
      e.Taxi = `Taxi`,
      e.TennisBall = `TennisBall`,
      e.TextBlock = `TextBlock`,
      e.TextParagraph = `TextParagraph`,
      e.Tower = `Tower`,
      e.TrafficLight = `TrafficLight`,
      e.Train = `Train`,
      e.Tram = `Tram`,
      e.Union = `Union`,
      e.ViewFinder = `ViewFinder`,
      e.VisionPro = `VisionPro`,
      e.Wall = `Wall`,
      e.Wrench = `Wrench`,
      e.Write = `Write`,
      e.WritingAI = `WritingAI`,
      e.Refresh = `Refresh`,
      e.Comment = `Comment`,
      e.Attachment = `Attachment`,
      e.Blockquote = `Blockquote`,
      e.CodeBlock = `CodeBlock`,
      e.Brick = `Brick`,
      e.Meta = `Meta`,
      e.OpenAI = `OpenAI`,
      e.Linear = `Linear`,
      e.Auth0 = `Auth0`,
      e.Chrome = `Chrome`,
      e.Discord = `Discord`,
      e.Edge = `Edge`,
      e.Figma = `Figma`,
      e.Firefox = `Firefox`,
      e.Intercom = `Intercom`,
      e.Notion = `Notion`,
      e.OnePassword = `OnePassword`,
      e.Sentry = `Sentry`,
      e.Slack = `Slack`,
      e.Zapier = `Zapier`,
      e.Zendesk = `Zendesk`,
      e
  }({}),
  R5 = class e {
      static #e = this.customIconTypes = [$.Radar, $.Chip, $.Joystick, $.Battery, $.Sound, $.Cone, $.Database, $.Terminal, $.Watch, $.Clock, $.Lock, $.Compass, $.Server, $.Calendar, $.Apple, $.Android, $.Page, $.Robot, $.Chat, $.LightBulb, $.Alert, $.Mac, $.MobilePhone, $.Computer, $.Tablet, $.Cube, $.Bookmark, $.Video, $.Sign, $.Inbox, $.Subscribe, $.Email, $.Bucket, $.Label, $.Brush, $.Home, $.Camera, $.CameraAi, $.Trash, $.GitHub, $.GitLab, $.Book, $.Megaphone, $.Checklist, $.Education, $.Present, $.Umbrella, $.Feather, $.Cross, $.Gears, $.Phone, $.Image, $.Basket, $.DesignTools, $.TeeShirt, $.Link, $.Dashboard, $.CreditCard, $.Briefcase, $.Bank, $.Dollar, $.Euro, $.Bitcoin, $.Etherum, $.Solana, $.Cart, $.Shop, $.Shield, $.PieChart, $.BarChart, $.Chart, $.Crown, $.Airplane, $.Bike, $.Car, $.Ship, $.Rocket, $.Anchor, $.World, $.Asia, $.Australia, $.Europe, $.Africa, $.SouthAmerica, $.NorthAmerica, $.Pin, $.Face, $.UnhappyFace, $.ThumbsUp, $.ThumbsDown, $.Skull, $.FaceHeartEyes, $.FaceFlatSmile, $.FaceMask, $.FaceSurprise, $.FaceMonocle, $.FaceSunglasses, $.FaceStarEyes, $.FaceTongue, $.FaceTired, $.Cloud, $.Leaf, $.Tree, $.Mountain, $.Sun, $.Flower, $.Heart, $.Fire, $.Users, $.Bug, $.Recycle, $.Dna, $.Brain, $.Bolt, $.Favorite, $.Coffee, $.Accessibility, $.Burger, $.FaceId, $.FootPrint, $.Mic, $.MusicKey, $.Paint, $.Pizza, $.Ramen, $.WindTurbine, $.Modem, $.Jersey, $.Moon, $.Scissors, $.Ai, $.AiApp, $.AiDocument, $.Binocular, $.Bluetooth, $.Direction, $.Network, $.Policy, $.Routing, $.AirTag, $.AlarmClock, $.AmericanFootBall, $.Asterisk, $.Bandage, $.Basketball, $.Bed, $.Boombox, $.Bones, $.BookOpen, $.BowlingBall, $.Box, $.BoxOpen, $.Bus, $.Calculator, $.CarPool, $.Chemist, $.ClickButton, $.ClothHanger, $.Comodore, $.Connected, $.ConstructionBarrier, $.Conversation, $.Cookie, $.Crane, $.CrystalBall, $.DesktopWindow, $.Dice, $.Dino, $.DollarBill, $.Dumbbell, $.ElectricPlug, $.Eraser, $.Extinguisher, $.Factory, $.Flashlight, $.FloppyDisk, $.Garage, $.Golf, $.Hack, $.Health, $.Hear, $.Hourglass, $.Judge, $.Ladder, $.LockerRoom, $.MacOS, $.MagicWand, $.Magnet, $.Mask, $.MilitaryTruck, $.MoneyStack, $.MovingStaircase, $.MusicTape, $.NotePad, $.Notified, $.PalmTree, $.Pills, $.PingPong, $.Pointer, $.PokerCard, $.Process, $.Rank, $.Runner, $.SafetyKit, $.Shrug, $.Signature, $.SoccerBall, $.Spaces, $.Speaker, $.Spreadsheet, $.Stadium, $.Storm, $.Subgroup, $.Surfer, $.Taxi, $.TennisBall, $.TextBlock, $.TextParagraph, $.Tower, $.TrafficLight, $.Train, $.Tram, $.Union, $.ViewFinder, $.VisionPro, $.Wall, $.Wrench, $.Write, $.WritingAI, $.Refresh, $.Comment, $.Attachment, $.Blockquote, $.CodeBlock, $.Brick, $.Meta, $.OpenAI, $.Linear, $.Auth0, $.Chrome, $.Discord, $.Edge, $.Figma, $.Firefox, $.Intercom, $.Notion, $.OnePassword, $.Sentry, $.Slack, $.Zapier, $.Zendesk];
      static #t = this.burnerIconTypes = [$.CustomView, $.Project, $.Initiative, $.Team, $.Folder];
      static #n = this.allIconTypes = Object.keys($);
      static getIconTypes(t) {
          return e.burnerIconTypes.includes(t) ? [t, ...e.customIconTypes] : [t, e.burnerIconTypes[0], ...e.customIconTypes.filter(e => e !== t)]
      }
      static isDecorativeIconType(e) {
          return this.allIconTypes.includes(e)
      }
      static async keywords() {
          return await kt( () => import(`./decorativeIconKeywords.B72edX-A.js`), __vite__mapDeps([12, 4]), import.meta.url)
      }
  }
}
));
function B5(e, t) {
  return V5(wG(), e, t)
}
function V5(e, t, n) {
  if (!t)
      return;
  let r = e.baseTheme ?? e
    , i = n?.contrast ?? (r.isDark ? 38 : 18)
    , a = `${t}-${i}${r.color.bgBase}`
    , o = U5.get(a);
  if (o)
      return o;
  let s = H5[t.toLowerCase()];
  if (s)
      return r.color[s];
  let c = z$.fromCss(t)
    , l = z$.fromCss(r.color.bgBase);
  if (z$.sufficientContrastForText(c, l, i))
      return U5.set(a, t),
      t;
  let u = z$.toCss(r.colorFormat, Ife(c, l, i) ?? c);
  return U5.set(a, u),
  u
}
function Ife(e, t, n) {
  let[,r,i] = e
    , [a] = t
    , o = 0
    , s = 100
    , c = s
    , l = !1;
  for (; s - o > 1; ) {
      let e = (o + s) / 2
        , u = [e, r, i];
      z$.sufficientContrastForText(u, t, n) ? (l = !0,
      c = e,
      a > e ? o = e : s = e) : a > e ? s = e : o = e
  }
  if (l)
      return [c, r, i]
}
var H5, U5, W5 = t(( () => {
  WK(),
  H$(),
  H5 = {
      "#e8b600": `yellowBase`,
      "#f2c94c": `yellowBase`,
      "#5e6ad2": `purpleBase`,
      "#fc7840": `orangeBase`,
      "#0f783c": `greenBase`
  },
  U5 = new Map
}
)), G5, K5 = t(( () => {
  WK(),
  n1(),
  ir(),
  G5 = HK.div([`display:inline-flex;justify-content:center;align-items:center;flex-shrink:0;word-break:keep-all;font-family:`, `;width:`, `px;height:auto;max-width:`, `px;max-height:`, `px;`, ``], Z$(`emoji`), e => e.$size, e => e.$size, e => e.$size, e => rr.isSafari ? DG([`font-size:`, `px;line-height:1;@media (-webkit-min-device-pixel-ratio:2),(min-resolution:192dpi){font-size:`, `px;line-height:`, `px;}`], e.$size - 4, e.$size - 3, e.$size - 1) : DG([`font-size:`, `px;line-height:`, `px;@media (-webkit-min-device-pixel-ratio:2),(min-resolution:192dpi){font-size:`, `px;line-height:`, `px;}`], e.$size - 3, e.$size, e.$size - 1, e.$size))
}
)), q5, J5, Y5, X5, Z5, Q5 = t(( () => {
  w6(),
  Vd(),
  ro(),
  ni(),
  Ot(),
  q5 = `emojis:frequencies`,
  J5 = new Intl.DisplayNames([`en`],{
      type: `region`
  }),
  Y5 = function(e) {
      return e.SEARCH = `search`,
      e.SEARCH_NOT_FOUND = `search_not_found`,
      e.SUGGESTED = `suggested`,
      e.FREQUENTLY_USED = `frequently_used`,
      e.PEOPLE = `people`,
      e.ANIMALS_AND_NATURE = `animals_and_nature`,
      e.FOOD_AND_DRINK = `food_and_drink`,
      e.ACTIVITY = `activity`,
      e.TRAVEL_AND_PLACES = `travel_and_places`,
      e.OBJECTS = `objects`,
      e.SYMBOLS = `symbols`,
      e.FLAGS = `flags`,
      e.CUSTOM = `custom`,
      e
  }({}),
  X5 = new Map([[Y5.SEARCH, `Search results`], [Y5.SEARCH_NOT_FOUND, `No results found`], [Y5.SUGGESTED, `Suggested`], [Y5.FREQUENTLY_USED, `Frequently used`], [Y5.PEOPLE, `Smileys & People`], [Y5.ANIMALS_AND_NATURE, `Animals & Nature`], [Y5.FOOD_AND_DRINK, `Food & Drink`], [Y5.ACTIVITY, `Activity`], [Y5.TRAVEL_AND_PLACES, `Travel & Places`], [Y5.OBJECTS, `Objects`], [Y5.SYMBOLS, `Symbols`], [Y5.FLAGS, `Flags`], [Y5.CUSTOM, `Custom`]]),
  Z5 = class e extends Bd {
      static async initialize() {
          if (Object.keys(this._nativeEmojiByName).length > 0)
              return this._loadedPromise;
          try {
              let t = await kt( () => import(`./emojis.2I4cPjbc.js`), __vite__mapDeps([13, 4]), import.meta.url)
                , n = t.default || t;
              this._nativeEmojis = n.emojis.map(t => {
                  let r = {
                      name: t.n,
                      symbol: t.s,
                      category: n.categories[t.c],
                      keywords: t.k.map(e => n.keywords[e]),
                      emoticons: t.e ?? [],
                      color: t.d
                  }
                    , i = e.getCountryNameForEmoji(r);
                  return i && r.keywords.push(i),
                  r
              }
              );
              for (let e = 0; e < this._nativeEmojis.length; e++) {
                  let t = this._nativeEmojis[e];
                  this._nativeEmojiBySymbol[t.symbol] = t,
                  this._nativeEmojiByName[t.name] = t
              }
              this._loadedPromise.resolve()
          } catch (e) {
              this._loadedPromise.reject(e)
          }
          return this._loadedPromise
      }
      static get loadedPromise() {
          return this._loadedPromise
      }
      static findNativeByName(e) {
          if (!this._nativeEmojiByName)
              throw Error(`Failed to fetch emoji data`);
          return this._nativeEmojiByName[e]
      }
      static findNativeBySymbol(e) {
          if (!this._nativeEmojiBySymbol)
              throw Error(`Failed to fetch emoji data`);
          return this._nativeEmojiBySymbol[e]
      }
      static getFrequentlyUsed(t, n, r) {
          let i = e.getUsageFrequencies(t)
            , a = n.reduce( (e, t) => (e[t.name] = t,
          e), {})
            , o = Object.keys(a)
            , s = Object.entries(i.scores).sortBy( ([,e]) => -e).filter( ([e]) => !!o.includes(e)).map( ([e]) => e).slice(0, r);
          return i.lastUsed && !s.includes(i.lastUsed) && (s[s.length - 1] = i.lastUsed),
          s.map(e => a[e]).filter(Boolean)
      }
      static emojiWasUsed(t, n) {
          let r = e.getUsageFrequencies(t);
          r.lastUsed = n,
          r.scores[n] || (r.scores[n] = 0),
          r.scores[n] += 1,
          e.setUsageFrequencies(t, r)
      }
      static getFuzzyMatches(t, n) {
          let r = [];
          return t.forEach(function(t) {
              let i = e.score(t, n);
              i > .25 && r.push({
                  score: i,
                  item: t
              })
          }),
          r.sort(function(e, t) {
              return e.score === t.score ? e.item.name.localeCompare(t.item.name) : t.score - e.score
          }).map(e => e.item)
      }
      static getCategoryLabel(e) {
          let t = X5.get(e);
          if (!t)
              throw Error(`Unrecognized Emoji category`);
          return t
      }
      static score(t, n) {
          let r = `keywords`in t ? t.keywords : []
            , i = `emoticons`in t ? t.emoticons ?? [] : []
            , a = u6.score(t.name, n)
            , o = u6.score(r, n)
            , s = n.length <= 3 ? u6.score(i, `:${n}`) : 0
            , c = Math.max(a, u6.prioritize(s, 1e3), u6.deprioritize(o, 2));
          if (t.name === n)
              return u6.prioritize(c, 1e3);
          let l = e.COMMON_EMOJIS.indexOf(t.name);
          if (l > -1) {
              let e = this.COMMON_EMOJIS.length - l;
              return u6.prioritize(c, 50 + e)
          }
          let u = e.getCountryNameForEmoji(t)?.toLowerCase()
            , d = n.toLowerCase();
          return u && (d.length > 3 && u.startsWith(d) || d === u) ? o : c
      }
      static getNativeEmojis() {
          return this._nativeEmojis
      }
      static #e = this._nativeEmojis = [];
      static #t = this._nativeEmojiByName = {};
      static #n = this._nativeEmojiBySymbol = {};
      static #r = this._loadedPromise = no();
      static #i = this.COMMON_EMOJIS = [`+1`, `ok_hand`, `pray`, `joy`, `heart`, `eyes`, `white_check_mark`, `slightly_smiling_face`, `smiley`, `smile`, `grinning`, `thinking_face`, `sweat_smile`, `warning`, `eyes`, `confused`, `x`, `raised_hands`, `tada`, `wink`, `blush`, `shrug`, `wave`, `question`];
      static getUsageFrequencies(t) {
          let n = ei.getPersistent(q5, t);
          return n === void 0 && (n = {
              lastUsed: null,
              scores: this.COMMON_EMOJIS.reduce( (e, t) => (e[t] = 1,
              e), {})
          },
          e.setUsageFrequencies(t, n),
          ei.setPersistent(q5, t, n)),
          n
      }
      static setUsageFrequencies(e, t) {
          ei.setPersistent(q5, e, t)
      }
      static getCountryNameForEmoji(e) {
          if (!(`keywords`in e) || !e.keywords.includes(`country`))
              return null;
          try {
              let t = e.name.split(`-`)[1] ?? e.name;
              return J5.of(t.toUpperCase()) ?? null
          } catch {
              return null
          }
      }
  }
}
));
function $5({size: e, onlyIcon: t, hasIcon: n, rightAlignIcon: r}) {
  return t ? `0 2px` : n && !t ? r ? o7[e] : a7[e] : s7[e]
}
function Lfe({size: e, onlyIcon: t, isCircle: n, hasIcon: r, rightAlignIcon: i}) {
  let a;
  switch (e) {
  case `small`:
      return a = l7 ? 28 : 24,
      DG([``, ` height:`, `px;padding:`, `;font-size:`, `;`, ``], DG(n ? [`width:`, `px;`] : [`min-width:`, `px;`], a), a, $5({
          size: e,
          onlyIcon: t,
          hasIcon: r,
          rightAlignIcon: i
      }), l1(`mini`), !n && DG([`body.redesign-enabled &{border-radius:6px;}`]));
  case `medium`:
      return a = l7 ? 32 : 28,
      DG([``, ` height:`, `px;padding:`, `;font-size:`, `;`], DG(n ? [`width:`, `px;`] : [`min-width:`, `px;`], a), a, $5({
          size: e,
          onlyIcon: t,
          hasIcon: r,
          rightAlignIcon: i
      }), l1(`mini`));
  case `normal`:
      return a = l7 ? 36 : 32,
      DG([``, ` height:`, `px;padding:`, `;font-size:`, `;`], DG(n ? [`width:`, `px;`] : [`min-width:`, `px;`], a), a, $5({
          size: e,
          onlyIcon: t,
          hasIcon: r,
          rightAlignIcon: i
      }), l1(`small`));
  case `large`:
      return DG([``, ` height:44px;padding:`, `;font-size:`, `;`], DG(n ? [`width:44px;`] : [`min-width:32px;`]), $5({
          size: e,
          onlyIcon: t,
          hasIcon: r,
          rightAlignIcon: i
      }), l1(`small`));
  default:
      throw nW(e)
  }
}
function Rfe(e) {
  return e.icon === void 0 ? `` : `> *:${e.$rightAlign ? `last` : `first`}-child {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    ${e.size === `medium` ? `max-width: 16px; max-height: 16px;` : e.size === `normal` ? `max-width: 18px; max-height: 18px;` : e.size === `small` ? `max-width: 16px; max-height: 16px;` : ``}

    ${e.size ? e.$onlyIcon ? `&:not(:only-child) { margin-${e.$rightAlign ? `left` : `right`}: 6px; }` : `margin-${e.$rightAlign ? `left` : `right`}: 6px;` : ``};
    transition-property: fill, stroke;
    transition-duration: ${$$(`highlightFadeOut`)};
    svg {
      ${e.monotoneIcon ? `fill: currentColor;` : ``}
    }
  }
&:enabled:${J$} svg {
  transition-duration: ${$$(`highlightFadeIn`)};
}`
}
function e7() {
  return `&:not(:disabled, [data-disabled="true"]):${J$},
&[data-menu-open="true"], [data-menu-open="true"] > &`
}
var t7, n7, r7, i7, a7, o7, s7, c7, l7, u7 = t(( () => {
  t7 = e(o(), 1),
  WK(),
  A1(),
  iW(),
  ir(),
  H$(),
  n1(),
  T1(),
  n7 = (e=.15) => DG([`box-shadow:`, `,inset 0 `, ` 0 0 `, `;`], Q$(`low`), m1, t => z$.cssWithAlpha(t.theme.color.labelBase, e, t.theme.colorFormat)),
  r7 = DG([`display:inline-flex;vertical-align:top;align-items:center;justify-content:center;white-space:nowrap;flex-shrink:0;margin:0;border-radius:5px;font-weight:`, `;line-height:normal;transition-property:border,background-color,color,opacity;transition-duration:`, `;user-select:none;-webkit-app-region:no-drag;svg{transition-property:fill;transition-duration:`, `;}&:not(:disabled):`, `{transition-duration:`, `;svg{transition-duration:`, `;}}&:disabled{cursor:default;opacity:0.6;}body.redesign-enabled &{border-radius:var(--control-border-radius,7px);}`], u1(`medium`), $$(`highlightFadeOut`), $$(`highlightFadeOut`), J$, $$(`highlightFadeIn`), $$(`highlightFadeIn`)),
  i7 = (0,
  t7.default)(function({variant: e, active: t=!1}) {
      switch (e) {
      case `primary`:
          return DG([`border:`, `;box-shadow:`, `;background-color:`, `;color:`, `;html.dark body.redesign-enabled &{border:none;`, `;}`, `{background-color:`, `;}&:focus-visible{outline-offset:2px;}`], e => d1(e.theme.color.controlPrimaryHover), Q$(`low`), Y$(t ? `controlPrimaryHover` : `controlPrimary`), Y$(`controlLabel`), n7(.3), e7, Y$(`controlPrimaryHover`));
      case `secondary`:
          return DG([`border:`, `;box-shadow:`, `;background-color:`, `;color:`, `;`, `{background-color:`, `;}&:disabled{color:`, `;}html.dark body.redesign-enabled &{border:none;`, `;}`], f1(`bgBorderSolid`), Q$(`low`), Y$(t ? `controlSecondaryHover` : `controlSecondary`), Y$(t ? `labelTitle` : `labelBase`), e7, Y$(`controlSecondaryHover`), Y$(`labelMuted`), n7(.15));
      case `ghost`:
          return DG([`border:1px dashed `, `;background-color:transparent;color:`, `;`, `{color:`, `;background-color:`, `;`, `{color:`, `;}svg{fill:`, `;}}&:focus-visible{outline-offset:2px;}`], e => e.theme.highlightVariant(e.theme.color.bgBorderSolid), Y$(`labelBase`), e7, Y$(`labelTitle`), Y$(`controlTertiaryHover`), O1, Y$(`labelTitle`), Y$(`labelTitle`));
      case `borderless`:
          return DG([`border:`, `;background-color:`, `;color:`, `;`, `{color:`, `;background-color:`, `;`, `{color:`, `;}svg:not(.color-override){fill:`, `;}}body.redesign-enabled &{border:none;}`], d1(`transparent`), t ? Y$(`controlTertiarySelected`) : `transparent`, Y$(t ? `labelTitle` : `labelBase`), e7, Y$(`labelTitle`), Y$(`controlTertiaryHover`), O1, Y$(`labelTitle`), Y$(`labelTitle`));
      case `muted`:
          return DG([`border:`, `;background-color:`, `;color:`, `;`, `{color:`, `;background-color:`, `;`, `{color:`, `;}svg:not(.color-override){fill:`, `;}}`], d1(`transparent`), t ? Y$(`controlTertiaryHover`) : `transparent`, Y$(t ? `labelBase` : `labelMuted`), e7, Y$(`labelBase`), Y$(`controlTertiaryHover`), O1, Y$(`labelBase`), Y$(`labelBase`));
      case `dangerous-borderless`:
          return DG([`border:`, `;background-color:transparent;color:`, `;`, `{color:`, `;background-color:`, `;`, `{color:`, `;}svg:not(.color-override){fill:`, `;}}&:disabled{color:`, `;}body.redesign-enabled &{background-color:`, `;}html.dark body.redesign-enabled &{border:none;`, `{background-color:`, `;}}`], d1(`transparent`), Y$(`redText`), e7, Y$(`redText`), Y$(`redTint`), O1, Y$(`redText`), Y$(`redText`), Y$(`labelBase`), t ? Y$(`redTint`) : `transparent`, e7, Y$(`redTint`));
      case `link`:
          return DG([`border:`, `;box-shadow:none;background-color:transparent;color:`, `;`, `{color:`, `;svg{fill:`, `;}}`], d1(`transparent`), Y$(t ? `labelTitle` : `labelBase`), e7, Y$(`labelTitle`), Y$(`labelTitle`));
      case `dangerous`:
          return DG([`--focus-ring-color:`, `;--focus-ring-outline:var(--focus-ring-width) solid `, `;border:`, `;box-shadow:`, `;background-color:`, `;color:`, `;`, `{background-color:`, `;}&:focus-visible{outline-offset:2px;}html.dark body.redesign-enabled &{border:none;`, `;}`], Y$(`redBaseHover`), Y$(`redBaseHover`), e => d1(e.theme.color.redBaseHover), Q$(`low`), Y$(t ? `redBaseHover` : `redBase`), Y$(`controlLabel`), e7, Y$(`redBaseHover`), n7(.35));
      case `card`:
          return DG([`width:100%;flex-direction:column;gap:4px;border:`, `;background-color:`, `;color:`, `;svg{fill:`, `;}`, `{`, ` color:`, `;svg{fill:`, `;}}&:disabled{color:`, `;}`], f1(`bgBorderSolid`), t ? Y$(`bgShade`) : `transparent`, Y$(t ? `labelBase` : `labelMuted`), Y$(t ? `labelBase` : `labelMuted`), e7, t ? `` : DG([`background-color:`, `;border-color:`, `;`], Y$(`bgShadeHover`), Y$(`bgBorderSolidHover`)), Y$(`labelBase`), Y$(`labelBase`), Y$(`labelMuted`));
      case `circle`:
          return DG([`&&&&{border-radius:50%;}box-shadow:none;color:`, `;&:focus-visible{outline-offset:2px;}`], Y$(t ? `labelTitle` : `labelBase`));
      default:
          throw nW(e)
      }
  }, ({variant: e, active: t=!1}) => `${e}-${t}`),
  a7 = {
      small: `0 8px 0 6px`,
      medium: `0 14px 0 12px`,
      normal: `0 14px 0 12px`,
      large: `0 21px 0 19px`
  },
  o7 = {
      small: `0 6px 0 8px`,
      medium: `0 12px 0 14px`,
      normal: `0 12px 0 14px`,
      large: `0 19px 0 21px`
  },
  s7 = {
      small: `0 8px`,
      medium: `0 14px`,
      normal: `0 14px`,
      large: `0 21px`
  },
  c7 = {
      rootCss: r7,
      variantCss: i7,
      sizeCss: Lfe,
      iconCss: Rfe,
      redesignButtonShadow: n7
  },
  l7 = rr.isPureTouchDevice
}
));
function zfe(e) {
  let {indeterminate: t, checked: n, className: r, style: i, ref: a, ...o} = e
    , s = n || t;
  return (0,
  d7.jsxs)(h7, {
      className: r,
      style: i,
      $checked: !!n,
      $indeterminate: !!t,
      $disabled: !!o.disabled,
      children: [(0,
      d7.jsx)(Bfe, {
          ...o,
          ref: a,
          checked: n,
          "aria-checked": t ? `mixed` : n ? `true` : `false`
      }), s && (0,
      d7.jsx)(Vfe, {
          children: t ? (0,
          d7.jsx)(Ufe, {}) : (0,
          d7.jsx)(Hfe, {})
      })]
  })
}
var d7, f7, p7, m7, h7, Bfe, Vfe, Hfe, Ufe, g7, Wfe, _7, Gfe, Kfe, qfe = t(( () => {
  ht(),
  WK(),
  T1(),
  ir(),
  u7(),
  n1(),
  d7 = e(f(), 1),
  f7 = HK(`input`).attrs(e => ({
      "data-1p-ignore": e.allowPMAutofill !== !0
  }))([`height:`, `px;padding:`, `;background:`, `;border:`, `;border-radius:`, `;font-size:`, `;color:`, `;margin:0;appearance:none;transition:border `, `;-webkit-app-region:no-drag;font-feature-settings:"calt" 0;&:disabled{color:`, `;}&::placeholder{color:`, `;}&:not(:disabled):`, `{border-color:`, `;transition-duration:`, `;}`, ` `, `;`, `;`, `;`, `;`, `;`, `;`, ``], rr.isPureTouchDevice ? 36 : 32, e => e.theme.inputPadding, e => e.theme.inputBackground, e => e.noBorder ? `${m1()} solid transparent` : f1(`bgBorderSolid`)(e), e => e.theme.inputBorderRadius, e => e.theme.inputFontSize, Y$(`labelTitle`), $$(`highlightFadeOut`), Y$(`labelMuted`), Y$(`labelFaint`), J$, e => e.noBorder ? `transparent` : e.theme.highlightVariant(e.theme.color.bgBorderSolid), $$(`highlightFadeIn`), e => e.type !== `checkbox` && e.type !== `radio` ? `outline-offset: -1px;` : null, e => e.type === `checkbox` ? `
  height: auto;
` : ``, e => e.appearance === `small` ? `
  font-size: ${l1(`mini`)};
  height: 26px;
` : ``, e => e.appearance === `medium` ? `
    font-size: ${l1(`mini`)};
    height: 28px;
` : ``, e => e.appearance === `large` ? `
  height: 44px;
  padding: 12px;
  border-radius: 6px;
` : ``, e => e.appearance === `xlarge` ? `
  height: 48px;
  padding: 12px;
  border-radius: 6px;
` : ``, e => e.stretched ? `width: 100%;` : ``, e => e.allowPMAutofill ? `` : DG([`+ [data-lastpass-icon-root]{display:none;}`])),
  p7 = HK(f7).attrs({
      as: `textarea`
  })([`appearance:none;height:64px;resize:none;`]),
  m7 = HK(f7).attrs({
      as: `select`
  })([`height:`, `px;padding:6px 24px 6px 12px;border:`, `;border-radius:`, `;font-size:`, `;color:`, `;margin:0;appearance:none;transition:border `, `;&:`, `{background-color:`, `;transition-duration:`, `;}background-color:`, `;background-image:url("`, `");background-position:`, `;background-size:24px 24px;background-repeat:no-repeat;html.dark body.redesign-enabled &{border:none;`, `;}`, `;`], rr.isPureTouchDevice ? 36 : 32, f1(`bgBorderSolid`), e => e.theme.inputBorderRadius, e => e.theme.inputFontSize, Y$(`labelTitle`), $$(`highlightFadeOut`), J$, Y$(`controlSecondaryHover`), $$(`highlightFadeIn`), Y$(`controlSecondary`), e => Gfe(e.theme.color.labelMuted), rr.isPureTouchDevice ? `calc(100% + 6px) 14px` : `calc(100% + 4px) 12px`, n7(), e => e.appearance === `small` ? `
  font-size: ${l1(`mini`)};
  padding: 3px 24px 3px 12px;
  height: 24px;
  background-position: calc(100% + 4px) 9px;
  background-size: 20px 20px;
` : ``),
  h7 = HK.div([`position:relative;display:inline-flex;align-items:center;justify-content:center;flex-shrink:0;height:14px;width:14px;padding:2px;margin:0 8px 0 0;vertical-align:middle;box-sizing:border-box;transition:all 80ms ease-out;border-radius:3px;border:1px solid `, `;background-color:transparent;box-shadow:none;color:`, `;`, `;`, `;`, `;&:hover{`, `}`], Y$(`bgBorder`), Y$(`controlLabel`), e => e.$checked && DG([`background-color:`, `;border-color:`, `;border:1px solid `, `;`], e.theme.color.controlPrimary, e.theme.color.controlPrimary, e.theme.color.controlPrimary), e => e.$indeterminate && DG([`background-color:`, `;border-color:`, `;border:1px solid `, `;`], e.theme.color.labelFaint, e.theme.color.labelFaint, e.theme.color.labelFaint), e => e.$disabled && DG([`opacity:0.5;background-color:`, `;border-color:`, `;`], Y$(`bgBorderSolidThin`), Y$(`labelFaint`)), e => !e.$disabled && DG([`border:1px solid `, `;`], e.theme.color.controlPrimaryHover)),
  Bfe = HK(f7).attrs({
      type: `checkbox`
  })([`position:absolute;inset:0;margin:0;padding:0;opacity:0;cursor:pointer;`]),
  Vfe = HK.div([`pointer-events:none;display:flex;align-items:center;justify-content:center;`]),
  Hfe = () => (0,
  d7.jsx)(`svg`, {
      width: `10`,
      height: `9`,
      viewBox: `0 0 10 8`,
      xmlns: `http://www.w3.org/2000/svg`,
      children: (0,
      d7.jsx)(`path`, {
          d: `M3.46975 5.70757L1.88358 4.1225C1.65832 3.8974 1.29423 3.8974 1.06897 4.1225C0.843675 4.34765 0.843675 4.7116 1.06897 4.93674L3.0648 6.93117C3.29006 7.15628 3.65414 7.15628 3.8794 6.93117L8.93103 1.88306C9.15633 1.65792 9.15633 1.29397 8.93103 1.06883C8.70578 0.843736 8.34172 0.843724 8.11646 1.06879C8.11645 1.0688 8.11643 1.06882 8.11642 1.06883L3.46975 5.70757Z`,
          strokeWidth: `0.2`,
          fill: `currentColor`
      })
  }),
  Ufe = () => (0,
  d7.jsx)(`svg`, {
      width: `6`,
      height: `2`,
      viewBox: `0 0 6 2`,
      xmlns: `http://www.w3.org/2000/svg`,
      children: (0,
      d7.jsx)(`rect`, {
          y: `0.25`,
          width: `6`,
          height: `1.5`,
          fill: `currentColor`
      })
  }),
  g7 = HK(zfe).attrs(e => e)([``]),
  Wfe = HK(f7).attrs({
      type: `radio`
  })([`-webkit-appearance:none;background-color:transparent;flex-shrink:0;height:16px;width:16px;padding:2px;margin:0 8px 0 0;transition:all 80ms ease-out;border:1px solid `, `;border-radius:50%;box-shadow:none;position:relative;&:checked{background-color:`, `;border:1px solid `, `;&:after{content:"";position:absolute;height:4px;width:4px;border-radius:50%;top:5px;left:5px;background-color:`, `;}}&:hover:not(:disabled){border:1px solid `, `;}`], Y$(`bgBorderSolid`), Y$(`controlPrimary`), Y$(`controlPrimary`), Y$(`controlLabel`), e => e.checked ? e.theme.color.controlPrimary : e.theme.color.labelFaint),
  _7 = e => encodeURI(e).replace(/#/g, `%23`).replace(/\(/g, `%28`).replace(/\)/g, `%29`),
  Gfe = e => _7(`data:image/svg+xml;utf8,<svg width="32" height="32" viewBox="0 0 32 32" fill="color" xmlns="http://www.w3.org/2000/svg"><path d="M10.1611 0.314094L5.99463 4.48054L1.82819 0.314094C1.4094 -0.104698 0.732886 -0.104698 0.314094 0.314094C-0.104698 0.732886 -0.104698 1.4094 0.314094 1.82819L5.24295 6.75705C5.66174 7.17584 6.33825 7.17584 6.75705 6.75705L11.6859 1.82819C12.1047 1.4094 12.1047 0.732886 11.6859 0.314094C11.2671 -0.0939597 10.5799 -0.104698 10.1611 0.314094Z" transform="translate(0.77832 0.998535)"/></svg>`.replace(`color`, e)),
  Kfe = e => _7(`data:image/svg+xml;utf8,<svg width="10" height="9" viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg" fill="color"><path d="M3.46975 5.70757L1.88358 4.1225C1.65832 3.8974 1.29423 3.8974 1.06897 4.1225C0.843675 4.34765 0.843675 4.7116 1.06897 4.93674L3.0648 6.93117C3.29006 7.15628 3.65414 7.15628 3.8794 6.93117L8.93103 1.88306C9.15633 1.65792 9.15633 1.29397 8.93103 1.06883C8.70578 0.843736 8.34172 0.843724 8.11646 1.06879C8.11645 1.0688 8.11643 1.06882 8.11642 1.06883L3.46975 5.70757Z" stroke-width="0.2" /></svg>`.replace(`color`, e))
}
)), v7, y7, Jfe, b7 = t(( () => {
  ht(),
  WK(),
  Tn(),
  u7(),
  n1(),
  v7 = e(f(), 1),
  y7 = e => {
      let {icon: t, monotoneIcon: n=!0, rightAlignIcon: r=!1, children: i, type: a=`button`, ref: o, ...s} = e
        , c = t ? (0,
      v7.jsx)(`span`, {
          "aria-hidden": !0,
          children: t
      }) : null;
      return (0,
      v7.jsxs)(Jfe, {
          ref: o,
          type: a,
          icon: t,
          monotoneIcon: n,
          $onlyIcon: !i || e.onlyIcon,
          ...s,
          "data-active": e.active ?? !1,
          rightAlignIcon: r,
          children: [r ? null : c, e.onlyIcon ? null : i, r ? c : null]
      })
  }
  ,
  Jfe = HK.button.withConfig({
      shouldForwardProp: e => ![`monotoneIcon`, `variant`, `size`, `stretched`, `active`, `onlyIcon`].includes(e) && wn(e)
  }).attrs(e => ({
      variant: e.variant ?? `primary`,
      type: e.type ?? `button`,
      size: e.size ?? `normal`
  }))([``, ` border:1px solid transparent;position:relative;::placeholder{color:`, `;}`, `;`, ` `, ` `, `;`], c7.rootCss, Y$(`labelFaint`), e => e.stretched ? `width: 100%;` : ``, e => c7.variantCss({
      variant: e.variant ?? `primary`,
      active: e.active
  }), e => c7.sizeCss({
      size: e.size ?? `normal`,
      onlyIcon: e.$onlyIcon,
      isCircle: e.variant === `circle`,
      hasIcon: !!e.icon,
      rightAlignIcon: e.rightAlignIcon
  }), e => c7.iconCss({
      size: e.size ?? `normal`,
      $onlyIcon: e.$onlyIcon,
      $rightAlign: e.rightAlignIcon,
      icon: e.icon,
      monotoneIcon: e.monotoneIcon
  }))
}
)), x7, S7, C7, Yfe, Xfe = t(( () => {
  x7 = e(ht()),
  WK(),
  b7(),
  X1(),
  S7 = e(f()),
  C7 = e => {
      let {children: t, loading: n, disabled: r, loadingIconVariant: i, loadingDelay: a=1e3, ...o} = e
        , [s,c] = x7.useState(!!(n && !a));
      return x7.useEffect( () => {
          if (a && n) {
              let e = setTimeout( () => c(n || !1), a);
              return () => clearTimeout(e)
          } else {
              c(n || !1);
              return
          }
      }
      , [n, a]),
      (0,
      S7.jsxs)(y7, {
          disabled: r || n,
          ...o,
          children: [t, n && s && (0,
          S7.jsx)(Yfe, {
              variant: i ?? `pong`,
              color: o.variant === `primary` || !o.variant ? `labelBase` : `labelMuted`
          })]
      })
  }
  ,
  Yfe = HK(B1)([`width:14px;height:14px;margin-left:6px;`])
}
)), w7, T7, E7, D7 = t(( () => {
  w7 = e(ht()),
  T7 = (0,
  w7.createContext)(null),
  E7 = (0,
  w7.createContext)(null)
}
)), Zfe, O7, Qfe = t(( () => {
  Zfe = e(ht()),
  D7(),
  O7 = () => (0,
  Zfe.useContext)(T7)
}
));
async function $fe(e, t) {
  return (await e.query(Ut`
    query OrganizationInviteLinkDetails($inviteLink: String!) {
      organizationInviteLinkDetails(inviteLink: $inviteLink) {
        organizationId
        organizationLogoUrl
        organizationName
        organizationUrlKey
        organizationRegion
        allowedAuthServices
      }
    }
  `, {
      inviteLink: t
  })).organizationInviteLinkDetails
}
var epe = t(( () => {
  Wt()
}
));
async function tpe(e, t) {
  let n = Ut`
  mutation userAccountEmailChangeVerifyCode($email: String!, $code: String!) {
    userAccountEmailChangeVerifyCode(email: $email, code: $code) {
      success
      failureReason
    }
  }
`;
  return e.mutate(n, t)
}
var npe = t(( () => {
  Wt()
}
));
function k7(e) {
  let t = e + `=`
    , n = self.document.cookie.split(`;`);
  for (let e = 0; e < n.length; e++) {
      let r = n[e];
      for (; r.charAt(0) === ` `; )
          r = r.substring(1, r.length);
      if (r.indexOf(t) === 0)
          return r.substring(t.length, r.length)
  }
}
var rpe = t(( () => {}
)), A7, j7, M7, ipe, N7, P7 = t(( () => {
  A7 = `
id
name
urlKey
logoUrl
userCount
previousUrlKeys
deletionRequestedAt
samlEnabled
region
enabled
`,
  j7 = `
id
name
urlKey
logoUrl
userCount
enabled
samlEnabled
allowedAuthServices
`,
  M7 = `
id
name
displayName
email
avatarUrl
role
organization {
${A7}
}
`,
  ipe = `
id
name
displayName
email
avatarUrl
role
organization {
${j7}
}
`,
  N7 = `
id
email
allowDomainAccess
lastUsedOrganizationId
users {
${M7}
}
availableOrganizations {
${A7}
}
lockedOrganizations {
${j7}
}
lockedUsers {
${ipe}
}
`
}
));
async function ape(e) {
  return e.query(Ut`
  query {
    availableUsers {
      ${N7}
    }
  }
`, void 0, {
      dontLog: !0,
      asUserAccount: !0
  })
}
var ope = t(( () => {
  Wt(),
  P7()
}
));
async function spe(e, t, n={
  dontLog: !0
}) {
  let r = await e.query(Ut`
    query OrganizationInviteDetails($id: String!) {
      organizationInviteDetails(id: $id) {
        ... on OrganizationInviteFullDetailsPayload {
          status
          inviter
          email
          role
          createdAt
          organizationName
          organizationId
          organizationLogoUrl
          accepted
          expired
          allowedAuthServices
        }
        ... on OrganizationAcceptedOrExpiredInviteDetailsPayload {
          status
        }
      }
    }
  `, {
      id: t
  }, n);
  return {
      organizationInviteDetails: `createdAt`in r.organizationInviteDetails ? {
          ...r.organizationInviteDetails,
          createdAt: new Date(r.organizationInviteDetails.createdAt)
      } : r.organizationInviteDetails
  }
}
var cpe = t(( () => {
  Wt()
}
));
async function lpe(e, t) {
  let n = {
      urlKey: t
  };
  return e.query(Ut`
    query OrganizationExists($urlKey: String!) {
      organizationExists(urlKey: $urlKey) {
        success
        exists
      }
    }
  `, n)
}
var upe, dpe = t(( () => {
  TB(),
  Wt(),
  upe = wB( (e, t) => lpe(e, t), 500)
}
));
async function fpe(e, t) {
  let n = Ut`
  query SsoUrlFromEmailQuery($email: String!, $isDesktop: Boolean, $type: IdentityProviderType!) {
    ssoUrlFromEmail(email: $email, isDesktop: $isDesktop, type: $type) {
      success
      samlSsoUrl
    }
  }
`;
  return e.query(n, t, {
      asAnonymous: !0
  })
}
var ppe = t(( () => {
  Wt()
}
));
async function mpe(e, t) {
  let n = Ut`
mutation GoogleUserAccountAuth(
  $code: String!,
  $inviteLink: String,
  $redirectUri: String!,
  $timezone: String!
  $disallowSignup: Boolean
) {
  googleUserAccountAuth(
    input: {
      code: $code,
      inviteLink: $inviteLink,
      redirectUri: $redirectUri,
      timezone: $timezone
      disallowSignup: $disallowSignup,
    }
  ) {
    ${N7}
  }
}`;
  return e.mutate(n, t, {
      asAnonymous: !0
  })
}
var hpe = t(( () => {
  Wt(),
  P7()
}
));
async function gpe(e, t) {
  let n = Ut`
mutation SamlTokenUserAccountAuth($email: String!, $token: String!, $timezone: String!) {
  samlTokenUserAccountAuth(input: { email: $email, token: $token, timezone: $timezone }) {
    ${N7}
  }
}`;
  return e.mutate(n, t, {
      asAnonymous: !0
  })
}
var _pe = t(( () => {
  Wt(),
  P7()
}
));
async function vpe(e, t) {
  let n = Ut`
  mutation logout($reason: String) {
    logout(reason: $reason) {
      success
    }
  }
`;
  return e.mutate(n, {
      reason: t
  })
}
var ype = t(( () => {
  Wt()
}
));
async function bpe(e, t, n) {
  let r = Ut`
  mutation LeaveOrganization($organizationId: String!) {
    leaveOrganization(organizationId: $organizationId) {
      user {
        ${M7}
      }
    }
  }`
    , i = {
      organizationId: t
  };
  return e.mutate(r, i, {
      region: n
  })
}
var xpe = t(( () => {
  Wt(),
  P7()
}
));
async function Spe(e, t) {
  let {organizationId: n, inviteLink: r, region: i} = t
    , a = Ut`
  mutation JoinOrganizationFromOnboarding($organizationId: String!, $inviteLink: String) {
    joinOrganizationFromOnboarding(input: { organizationId: $organizationId, inviteLink: $inviteLink }) {
      user {
        ${M7}
      }
    }
  }`;
  return e.mutate(a, {
      organizationId: n,
      inviteLink: r
  }, {
      region: i,
      asUserAccount: !0
  })
}
var Cpe = t(( () => {
  Wt(),
  P7()
}
));
async function wpe(e, t) {
  let {name: n, urlKey: r, timezone: i, domainAccess: a, utm: o, survey: s, region: c} = t
    , l = Ut`
  mutation CreateOrganizationFromOnboarding($name: String!, $urlKey: String!, $domainAccess: Boolean, $timezone: String, $utm: String, $companyRole: String, $companySize: String) {
    createOrganizationFromOnboarding(input: { name: $name, urlKey: $urlKey, domainAccess: $domainAccess, timezone: $timezone, utm: $utm }, survey: {
      companyRole: $companyRole,
      companySize: $companySize
    }) {
      user {
        ${M7}
      }
    }
  }`
    , u = {
      name: n,
      urlKey: r,
      domainAccess: a,
      timezone: i,
      utm: o,
      companyRole: s?.companyRole,
      companySize: s?.companySize
  };
  return e.mutate(l, u, {
      asUserAccount: !0,
      region: c
  })
}
var Tpe = t(( () => {
  Wt(),
  P7()
}
));
async function Epe(e, t) {
  let n = {
      urlKey: t
  };
  return e.query(Ut`
    query OrganizationMeta($urlKey: String!) {
      organizationMeta(urlKey: $urlKey) {
        region
        allowedAuthServices
      }
    }
  `, n, {
      asAnonymous: !0
  })
}
var Dpe = t(( () => {
  Wt()
}
));
async function Ope(e, t) {
  let n = Ut`
  mutation EmailUserAccountAuthChallenge(
    $email: String!
    $clientAuthCode: String
    $isDesktop: Boolean
    $inviteLink: String
    $loginCodeOnly: Boolean
  ) {
    emailUserAccountAuthChallenge(
      input: {
        email: $email
        clientAuthCode: $clientAuthCode
        isDesktop: $isDesktop
        inviteLink: $inviteLink
        loginCodeOnly: $loginCodeOnly
      }
    ) {
      success
      authType
    }
  }
`;
  return e.mutate(n, t, {
      asAnonymous: !0
  })
}
var kpe = t(( () => {
  Wt()
}
));
async function Ape(e, t) {
  let n = Ut`
  mutation PasskeyLoginStartMutation($authId: String!) {
    passkeyLoginStart(authId: $authId) {
      success
      options
    }
  }
`;
  return e.mutate(n, t, {
      asAnonymous: !0
  })
}
var jpe = t(( () => {
  Wt()
}
));
async function Mpe(e, t) {
  let n = Ut`
  mutation PasskeyLoginFinishMutation($authId: String!, $response: JSONObject!) {
    passkeyLoginFinish(authId: $authId, response: $response) {
      ${N7}
    }
  }
`;
  return e.mutate(n, t, {
      asAnonymous: !0
  })
}
var Npe = t(( () => {
  Wt(),
  P7()
}
));
async function Ppe(e, t) {
  let n = Ut`
mutation EmailTokenUserAccountAuth($email: String!, $token: String!, $timezone: String!, $inviteLink: String) {
  emailTokenUserAccountAuth(input: {
    email: $email,
    token: $token,
    timezone: $timezone,
    inviteLink: $inviteLink
  }) {
    ${N7}
  }
}`;
  return e.mutate(n, t, {
      asAnonymous: !0
  })
}
var Fpe = t(( () => {
  Wt(),
  P7()
}
));
function F7() {
  return Lpe ||= new Rpe,
  Lpe
}
var Ipe, I7, L7, R7, z7, B7, Lpe, Rpe, V7, H7 = t(( () => {
  ss(),
  Ipe = e(ve()),
  zt(),
  zn(),
  No(),
  bd(),
  pX(),
  Yr(),
  fY(),
  _X(),
  pi(),
  epe(),
  es(),
  ng(),
  ws(),
  ni(),
  Qp(),
  DV(),
  npe(),
  rpe(),
  $J(),
  hQ(),
  kQ(),
  FQ(),
  C$(),
  ope(),
  cpe(),
  dpe(),
  ppe(),
  c$(),
  er(),
  hpe(),
  _pe(),
  ype(),
  xpe(),
  Cpe(),
  Tpe(),
  Dpe(),
  kpe(),
  jpe(),
  Npe(),
  Fpe(),
  Ot(),
  I7 = `ApplicationStore`,
  L7 = `isLinearSuperuser`,
  R7 = `redirectTo`,
  z7 = `AuthKey`,
  B7 = 50,
  Rpe = class {
      get isAuthenticated() {
          return this.currentUserAccountId !== void 0
      }
      get hasUser() {
          return !!(this.currentUserId && this.userAllowed(this.currentUserId))
      }
      get client() {
          return this.clientInstance ||= new lY({
              httpURL: $n.GRAPHQL_SERVER_HTTP
          }),
          this.clientInstance
      }
      get usersAvailableToSwitchTo() {
          return !this.currentUserId || !this.users || this.users.length < 2 ? [] : this.users.filter(e => e.id !== this.currentUserId)
      }
      get currentUser() {
          return this.users?.find(e => e.id === this.currentUserId)
      }
      get currentUserAccount() {
          if (!(!this.currentUserAccountId || !this.userAccounts))
              return this.userAccounts[this.currentUserAccountId]
      }
      get users() {
          return this.currentUserAccount?.users ?? []
      }
      get allUserAccounts() {
          return Object.values(this.userAccounts)
      }
      get allUsers() {
          return this.allUserAccounts.reduce( (e, t) => e.concat(t.users), [])
      }
      findUserAndUserAccountByOrgUrlKey(e) {
          for (let t of this.allUserAccounts) {
              let n = t.users.find(t => t.organization.urlKey === e);
              if (n)
                  return {
                      user: n,
                      userAccount: t
                  }
          }
      }
      get availableOrganizations() {
          return this.currentUserAccount?.availableOrganizations ?? []
      }
      get lockedOrganizations() {
          return this.currentUserAccount?.lockedOrganizations ?? []
      }
      get email() {
          return this.currentUserAccount?.email
      }
      get lockedUsers() {
          return this.currentUserAccount?.lockedUsers ?? []
      }
      get currentOrganization() {
          return this.currentUser?.organization
      }
      get organizations() {
          return !this.users || this.users.length === 0 ? [] : this.users.map(e => e.organization)
      }
      hasMultipleWorkspaces() {
          return this.allUsers.length > 1
      }
      async refreshStateSync() {
          this.log(`Refreshing workspace state`);
          let e = await this.fetchState();
          if (e) {
              if (!e.id) {
                  this.error(`Did not receive user account ID when refreshing state.`);
                  return
              }
              this.updateUserAccount(e),
              this.allowDomainAccess = e.allowDomainAccess,
              this.persistData()
          }
      }
      constructor() {
          this.userAccounts = {},
          this.currentUserId = void 0,
          this.currentUserAccountId = void 0,
          this.refreshState = (0,
          Ipe.default)( () => this.refreshStateSync(), 10 * b.SECOND, {
              leading: !0,
              trailing: !1
          }),
          this.fetchState = async () => {
              try {
                  return (await ape(this.client)).availableUsers
              } catch (e) {
                  if (Wo(e, {
                      logoutOnForbidden: !0
                  }) && !QJ) {
                      await this.logoutCurrentUserAccount(`Fetching state failed`, e);
                      return
                  }
                  this.log(`Could not refresh application store state`, {
                      error: e
                  })
              }
          }
          ,
          this.updateUserAccount = Ft(e => {
              e.id && (this.userAccounts[e.id] = {
                  ...this.userAccounts[e.id],
                  id: e.id,
                  email: e.email,
                  users: e.users,
                  lockedUsers: e.lockedUsers,
                  availableOrganizations: e.availableOrganizations,
                  lockedOrganizations: e.lockedOrganizations
              })
          }
          ),
          this.persistData = Ft( (e={}) => {
              let t = Object.assign({
                  currentUserAccountId: this.currentUserAccountId,
                  currentUserId: this.currentUserId,
                  allowDomainAccess: this.allowDomainAccess,
                  availableOrganizations: this.availableOrganizations,
                  userAccounts: this.userAccounts,
                  version: 2
              }, e);
              if (!ei.set(I7, t))
                  return !1;
              let n = {
                  currentUserId: t.currentUserId,
                  currentUserAccountId: t.currentUserAccountId
              };
              return !!ei.setSession(I7, n)
          }
          ),
          this.handleCheckStorage = Ft(e => {
              if (e.key === I7) {
                  if (!this.isAuthenticated) {
                      this.log(`Access token found, trying to log in`),
                      this.tryLogin();
                      return
                  }
                  this.log(`Application store information updated`);
                  for (let e of this.allUserAccounts)
                      this.updateUserAccount(e)
              }
          }
          ),
          this.tryLogin = Ft( () => {
              let e = ei.get(I7);
              if (!e)
                  return !1;
              if (!e.currentUserAccountId)
                  return this.reset(),
                  !1;
              if (e.version !== 2) {
                  let t = Error(`Persisted data version mismatch`);
                  return this.error(`Old application store data model found`, t, {
                      persistedData: e
                  }),
                  this.reset(),
                  MQ.forceRefresh(`persisted-data-version-mismatch`),
                  !1
              }
              let t = e.currentUserId
                , n = e.currentUserAccountId
                , r = ei.getSession(I7) || {};
              r.currentUserId && (t = r.currentUserId),
              r.currentUserAccountId && (n = r.currentUserAccountId);
              let i = n ? e.userAccounts[n] : void 0;
              if (QJ) {
                  if (!i)
                      return !1;
                  let e = i.users?.some(e => e.id !== $n.DEMO_USER_ID)
                    , t = [...i.availableOrganizations ?? [], ...i.users.map(e => e.organization)]?.some(e => e.id === $n.DEMO_ORGANIZATION_ID);
                  if (e || !t)
                      return !1
              }
              return this.login({
                  id: n,
                  email: i?.email,
                  users: i?.users || [],
                  lockedUsers: i?.lockedUsers || [],
                  availableOrganizations: i?.availableOrganizations,
                  allowDomainAccess: e.allowDomainAccess
              }, t, e.userAccounts),
              !0
          }
          ),
          this.handleMessage = e => {
              e.cmd === `updateWorkspaces` && setTimeout(this.refreshState, zle({
                  max: 30
              }) * 1e3)
          }
          ,
          Zp.trace(`startup`, `ApplicationStore.constructor`, () => {
              At(this, {
                  userAccounts: Vt,
                  currentUserId: Vt,
                  currentUserAccountId: Vt,
                  isAuthenticated: Bt,
                  organizations: Bt,
                  setUserAccount: Ft,
                  setUser: Ft,
                  login: Ft,
                  logout: Ft,
                  setServiceWorkerRegistration: Ft
              }),
              addEventListener(`storage`, this.handleCheckStorage),
              pQ().onMessage.subscribe(this.handleMessage),
              this.tryLogin() && this.refreshState()
          }
          )
      }
      ssoUrlFromEmail(e, t) {
          return fpe(this.client, {
              email: e,
              isDesktop: s$.isElectron,
              type: t
          })
      }
      async organizationExists(e) {
          return (await lpe(this.client, e)).organizationExists.exists
      }
      async organizationMeta(e) {
          return (await Epe(this.client, e)).organizationMeta
      }
      async organizationInviteDetails(e) {
          return (await spe(this.client, e)).organizationInviteDetails
      }
      async organizationInviteLinkDetails(e) {
          return await $fe(this.client, e)
      }
      async previewBuildLogin() {
          let e = await ape(this.client);
          this.login(e.availableUsers)
      }
      async googleAuthLogin(e, t) {
          let {inviteLink: n, redirectUri: r, disallowSignup: i} = t
            , {getCurrentTimezone: a} = await kt(async () => {
              let {getCurrentTimezone: e} = await import(`./timezone.DN00OUHb.js`);
              return {
                  getCurrentTimezone: e
              }
          }
          , __vite__mapDeps([14, 15, 16, 4, 17, 18, 5, 3, 6]), import.meta.url)
            , o = (await mpe(this.client, {
              code: e,
              inviteLink: n,
              redirectUri: r,
              timezone: a(),
              disallowSignup: i
          })).googleUserAccountAuth;
          return n ? await this.loginWithInviteLink(n, o) : await this.login(o)
      }
      async emailAuthChallenge(e, t={}) {
          let {inviteLink: n, loginCodeOnly: r} = t;
          return (await Ope(this.client, {
              email: e,
              clientAuthCode: this.generateAuthCode(),
              isDesktop: s$.isElectron,
              inviteLink: n,
              loginCodeOnly: r
          })).emailUserAccountAuthChallenge
      }
      async passkeyLoginStart(e) {
          return (await Ape(this.client, {
              authId: e
          })).passkeyLoginStart
      }
      async passkeyLoginFinish(e, t) {
          let n = await Mpe(this.client, {
              authId: e,
              response: t
          });
          return this.login(n.passkeyLoginFinish)
      }
      async tokenAuthLogin(e) {
          let {email: t, authToken: n, service: r, clientAuthCode: i, inviteLink: a} = e;
          if (this.isAuthenticated && this.currentUser?.email === t) {
              this.log(`Already logged in as this user, skipping email auth.`);
              return
          }
          if (i && !this.authCodeValid(i)) {
              let e = this.authCodes.length === 0;
              throw w.info(`Auth code invalid`, {
                  givenCode: i,
                  validCodes: this.authCodes
              }),
              new $o({
                  type: `authentication error`,
                  message: `Auth code invalid`,
                  userError: !0,
                  userPresentableMessage: `You're trying to log into a browser that was not used to initiate the login.`,
                  skipSentry: e
              })
          }
          let {getCurrentTimezone: o} = await kt(async () => {
              let {getCurrentTimezone: e} = await import(`./timezone.DN00OUHb.js`);
              return {
                  getCurrentTimezone: e
              }
          }
          , __vite__mapDeps([14, 15, 16, 4, 17, 18, 5, 3, 6]), import.meta.url);
          this.log(`Attempting token auth login for service ${r}`, {
              service: r
          });
          let s;
          switch (r) {
          case Eo.email:
              s = (await Ppe(this.client, {
                  email: t,
                  token: n,
                  timezone: o(),
                  inviteLink: a
              })).emailTokenUserAccountAuth,
              a ? await this.loginWithInviteLink(a, s) : await this.login(s);
              break;
          case Eo.saml:
              s = (await gpe(this.client, {
                  email: t,
                  token: n,
                  timezone: o()
              })).samlTokenUserAccountAuth,
              await this.login(s);
              break;
          default:
              throw new Rn(r)
          }
      }
      async login(e, t, n) {
          if (!e.id)
              return this.error(`Did not receive user account ID when refreshing state.`),
              this.reset(),
              !1;
          if (this.log(`Attempting login`, {
              login: {
                  authData: e,
                  userId: t,
                  userAccounts: n
              }
          }),
          Object.values(this.userAccounts).length === 0 && n && (this.userAccounts = n),
          this.updateUserAccount(e),
          this.allowDomainAccess = e.allowDomainAccess,
          e.id === this.currentUserAccountId)
              return this.log(`Client already logged in`),
              !0;
          let r = e.id
            , i = e.users
            , a = e.lastUsedOrganizationId
            , o = t || (i && i.length > 0 ? (i.find(e => e.organization.id === a && !e.organization.deletionRequestedAt) || i.find(e => !e.organization.deletionRequestedAt) || i[0]).id : void 0);
          return o && !this.userAllowed(o, r) ? (this.log(`User not allowed`, {
              notAllowed: {
                  userId: o,
                  userAccount: r
              }
          }),
          this.reset(),
          !1) : (s$.bridge.notifyLoginStatusChange(!0),
          this.log(`Client logged in`),
          o ? await this.setUser(o, r) : await this.setUserAccount(r))
      }
      async loginWithInviteLink(e, t) {
          if (this.spendRedirect(),
          !await this.login(t))
              return !1;
          try {
              let t = await this.organizationInviteLinkDetails(e);
              return this.organizations.some(e => e.id === t.organizationId) ? (window.location.replace(`/${t.organizationUrlKey}`),
              !0) : (await this.joinOrganization({
                  organizationId: t.organizationId,
                  inviteLink: e,
                  inviteRegion: t.organizationRegion
              }),
              window.location.replace(`/${t.organizationUrlKey}`),
              !0)
          } catch (e) {
              return e instanceof $o ? this.error(e.message, e) : this.error(`Failed to join organization`, e),
              !1
          }
      }
      async setUserAccount(e, t) {
          if (!this.userAccounts[e])
              return this.error(`User account not allowed`),
              await this.reset(),
              !1;
          if (this.currentUserAccountId === e)
              return !0;
          let n = this.currentUserAccountId;
          return this.log(`Setting user account`, {
              fromUserAccountId: n,
              toUserAccountId: e
          }),
          this.currentUserAccountId ? (this.persistData({
              currentUserAccountId: e,
              currentUserId: void 0
          }),
          t?.reloadOnly ? MQ.forceRefresh(`set-user-account-reload`) : window.location.href = t?.pathname ?? `/`) : (this.client.setUser({
              userAccountId: e
          }),
          this.currentUserAccountId = e,
          this.persistData({
              currentUserAccountId: e
          })),
          !0
      }
      async setUser(e, t, n) {
          if (!this.userAllowed(e, t))
              throw new V7(`User ${e} not allowed`);
          if (this.currentUserId === e)
              return fi.setUser(e),
              !0;
          let r = this.currentUserId
            , i = this.currentUserAccountId;
          if (t ??= this.currentUserAccountId,
          !t)
              return this.error(`Trying to set user, but do not have userAccountId`, void 0, {
                  fromUserAccountId: i,
                  fromUserId: r,
                  toUserId: e,
                  toUserAccountId: t
              }),
              !1;
          if (QJ || this.persistData({
              currentUserId: e,
              currentUserAccountId: t
          }) || this.log(`Failed persisting data when setting user`, {
              currentUserId: e,
              currentUserAccountId: t
          }),
          !this.currentUserId && (!this.currentUserAccountId || this.currentUserAccountId && (!t || this.currentUserAccountId === t))) {
              this.currentUserAccountId = t ?? this.currentUserAccountId,
              this.currentUserId = e;
              let n = this.currentUser;
              if (!n)
                  throw Error(`No current user`);
              fi.setUser(e),
              this.client.setUser({
                  userId: this.currentUserId,
                  userAccountId: this.currentUserAccountId
              }),
              await jde({
                  userAccountId: this.currentUserAccountId,
                  userId: n.id,
                  organizationId: n.organization.id
              })
          } else {
              let r = () => {
                  if (!t)
                      return;
                  let r = this.userAccounts[t].users?.find(t => t.id === e)?.organization.urlKey;
                  if (this.log(`Switching workspace to ${r}`, {
                      urlKey: r,
                      ...n
                  }),
                  n?.reloadOnly)
                      MQ.forceRefresh(`switch-workspace-reload`);
                  else {
                      let e = n?.path ?? (r ? `/${r}` : ``);
                      s$.hasNewDesktopQuitCloseRefreshBehaviour ? window.dispatchEvent(new CustomEvent(`workspace-switch`,{
                          detail: {
                              href: e
                          }
                      })) : window.location.href = e
                  }
              }
              ;
              return n?.checkOutstandingTransactions !== !1 && (pQ().outstandingTransactionCount ?? 0) > 0 ? (await new x$({
                  title: `Current workspace is still syncing`,
                  description: `If you switch before the syncing has finished, you could lose data.`,
                  confirmButtonTitle: `Switch workspace`,
                  confirmButtonType: `dangerous`
              }).show() === b$.confirm && r(),
              !1) : (r(),
              !1)
          }
          return this.log(`Setting user`, {
              fromUserAccountId: i,
              fromUserId: r,
              toUserId: e,
              toUserAccountId: t
          }),
          !0
      }
      async unsetUser() {
          let e = this.currentUserId
            , t = this.currentUserAccountId;
          this.log(`Unsetting user`, {
              fromUserId: e,
              fromUserAccountId: t
          }),
          this.persistData({
              currentUserId: void 0,
              currentUserAccountId: void 0
          }),
          this.currentUserId = void 0,
          this.currentUserAccountId = void 0,
          this.client.setUser({
              userId: void 0,
              userAccountId: void 0
          }),
          await Mde(),
          window.location.replace(`/`)
      }
      async reset() {
          this.log(`Resetting application store`),
          await this.logout(`Resetting application store`, !1),
          this.spendRedirect(),
          Mt( () => {
              this.currentUserAccountId = void 0,
              this.currentUserId = void 0,
              this.userAccounts = {}
          }
          )
      }
      setRedirect(e) {
          return this.log(`Set redirect`, {
              url: e
          }),
          ei.setString(R7, e ?? window.location.pathname, sessionStorage),
          e
      }
      spendRedirect() {
          let e = ei.getString(R7, sessionStorage);
          return e && (ei.remove(R7, sessionStorage),
          this.log(`Spent the redirect`, {
              url: e
          })),
          e
      }
      async logoutCurrentUserAccount(e, t) {
          let n = t && !Wo(t) ? !1 : s$.isElectron ? `/login` : `/`;
          qo(t) && t.metaData?.code === `RESTRICTED_COUNTRY_BLOCKED` && (n = `/not-available-in-your-country`);
          let r = this.allUserAccounts.find(e => e.id !== this.currentUserAccountId)?.id;
          if (QJ) {
              await eg.deleteDatabaseForUserId($n.DEMO_USER_ID),
              window.location.href = `/`;
              return
          }
          if (!this.currentUserAccountId || !r || this.allUserAccounts.length === 1)
              return await this.logout(e, n);
          this.log(`User account logged out`);
          let i = this.currentUserAccount?.users.map(e => e.id) || []
            , a = {
              ...this.userAccounts
          };
          delete a[this.currentUserAccountId],
          this.persistData({
              userAccounts: a,
              currentUserAccountId: r,
              currentUserId: void 0
          });
          for (let e of i)
              await eg.deleteDatabaseForUserId(e);
          n && (window.location.href = n)
      }
      async logout(e, t=!0) {
          w.remote(`Logging out`, this.loggerMetadata({
              reason: e
          }));
          try {
              await vpe(this.client, e)
          } catch (e) {
              e instanceof $o && e.metaData?.code && [`AUTHENTICATION_ERROR`, `FORBIDDEN`].includes(e.metaData?.code) || this.error(`Failed to revoke JWT`, e)
          }
          this.registration && await this.registration.unregister().catch(e => {
              this.error(`Service worker un-registration failed`, e)
          }
          ),
          this.currentUserId && this.log(`Client logged out`),
          s$.bridge.notifyLoginStatusChange(!1),
          ei.remove(I7, localStorage),
          ei.remove(I7, sessionStorage),
          eg.deleteAllDatabases(),
          ei.remove(L7, localStorage),
          ei.remove(mX, localStorage),
          ei.removeAllWithCondition(e => e.startsWith(uY), localStorage),
          await Nde(),
          t && (window.location.href = typeof t == `string` ? t : s$.isElectron ? `/login` : `/`)
      }
      async leaveOrganization() {
          let e = this.currentOrganization;
          if (!e)
              throw new V7(`Can't leave an organization you're not a member of.`);
          new x$({
              title: `Leave "${e.name}"?`,
              description: `You can always rejoin the workspace from the workspace picker.`,
              confirmButtonTitle: `Leave workspace`
          }).show().then(async e => {
              e === b$.confirm && t()
          }
          );
          let t = async () => {
              if (!this.users)
                  throw new V7(`Can't leave an organization as you're not a member of any.`);
              let {user: t} = (await bpe(this.client, e.id, e.region)).leaveOrganization
                , n = this.users.map(e => e.id).indexOf(t.id);
              if (this.users.splice(n, 1),
              this.currentUserAccount?.availableOrganizations?.push(e),
              this.currentUserId === t.id) {
                  let e = this.usersAvailableToSwitchTo[0];
                  if (e) {
                      this.setUser(e.id);
                      return
                  }
                  await this.unsetUser()
              }
          }
      }
      async joinOrganization(e) {
          let {organizationId: t, inviteLink: n, inviteRegion: r} = e, i;
          this.joinOrganizationLock ||= new fX(1);
          let a = await this.joinOrganizationLock.runExclusive(async () => {
              if (n)
                  r && (i = r);
              else {
                  if (!this.availableOrganizations)
                      throw new V7(`Can't join organization as theres no available organizations.`);
                  let e = this.availableOrganizations.map(e => e.id).indexOf(t);
                  if (e !== void 0 && e > -1)
                      i = this.availableOrganizations[e].region;
                  else {
                      let e = this.lockedOrganizations.find(e => e.id === t);
                      if (e && e.allowedAuthServices) {
                          let t = yd(e.allowedAuthServices?.map(e => Do[e]));
                          throw new $o({
                              type: `authentication error`,
                              message: `error joining organization`,
                              userError: !0,
                              userPresentableMessage: `The workspace you are trying to join only allows logging in via ${t}.\n
          Please sign out and log in with ${t} in order to accept the invite.`,
                              metaData: {
                                  authServiceRestriction: {
                                      allowed: e.allowedAuthServices.map(e => e.toString()),
                                      signOut: !0
                                  }
                              }
                          })
                      }
                      throw new V7(`Can't join organization that's not one of the available organizations.`)
                  }
              }
              if (!i)
                  throw new V7(`Can't join organization without a region.`);
              let {user: a} = (await Spe(this.client, {
                  ...e,
                  region: i
              })).joinOrganizationFromOnboarding;
              return this.currentUserAccount?.users?.push(a),
              await this.setUser(a.id)
          }
          );
          if (a === void 0)
              throw new $o({
                  type: `other`,
                  message: `joining organization already in progress`,
                  userError: !0,
                  userPresentableMessage: `Joining workspace already in progress`
              });
          return a
      }
      async createAndJoinOrganization(e) {
          let {name: t, urlKey: n, region: r, domainAccess: i, survey: a} = e
            , {getCurrentTimezone: o} = await kt(async () => {
              let {getCurrentTimezone: e} = await import(`./timezone.DN00OUHb.js`);
              return {
                  getCurrentTimezone: e
              }
          }
          , __vite__mapDeps([14, 15, 16, 4, 17, 18, 5, 3, 6]), import.meta.url)
            , {user: s} = (await wpe(this.client, {
              name: t,
              urlKey: n,
              region: r,
              domainAccess: i,
              timezone: o(),
              utm: k7(`utm`),
              survey: a
          })).createOrganizationFromOnboarding;
          this.currentUserAccount?.users?.push(s),
          this.setUser(s.id)
      }
      async verifyEmailChangeCode(e, t) {
          return await tpe(this.client, {
              email: e,
              code: t
          })
      }
      async setServiceWorkerRegistration(e) {
          this.registration = e
      }
      userAllowed(e, t) {
          let n = t ? this.userAccounts[t]?.users : this.users;
          return n?.length ? n.some(t => t.id === e) : !1
      }
      loggerMetadata(e={}) {
          return Object.assign({
              currentUserAccountId: this.currentUserAccountId,
              currentUserId: this.currentUserId,
              usersAccounts: this.userAccounts ? Object.values(this.userAccounts).reduce( (e, t) => (e[t.id] = {
                  id: t.id,
                  email: t.email,
                  users: t.users?.map(e => e.id),
                  lockedUsers: t.lockedUsers?.map(e => e.id),
                  availableOrganizations: t.availableOrganizations?.map(e => e.id),
                  lockedOrganizations: t.lockedOrganizations?.map(e => e.id)
              },
              e), {}) : void 0,
              isAuthenticated: this.isAuthenticated,
              hasUser: this.hasUser,
              email: this.email,
              allowDomainAccess: this.allowDomainAccess
          }, e)
      }
      log(e, t={}) {
          w.network(e, this.loggerMetadata(t))
      }
      error(e, t, n={}) {
          w.error(e, t, this.loggerMetadata(n))
      }
      get authCodes() {
          return ei.get(z7) || []
      }
      generateAuthCode() {
          let e = this.authCodes
            , t = os();
          return e.push(t),
          e.length > B7 && e.splice(0, e.length - B7),
          ei.set(z7, e),
          t
      }
      authCodeValid(e) {
          let t = this.authCodes;
          if (t.includes(e)) {
              let n = t.filter(t => t !== e);
              return ei.set(z7, n),
              !0
          }
          return !1
      }
  }
  ,
  V7 = class extends Error {
  }
}
));
function U7(e) {
  let {error: t, info: n, doNotRefresh: r, onHydrationRetry: i} = e
    , a = t instanceof dm
    , o = Go(t) === !0
    , s = () => {
      ei.remove(J7, sessionStorage),
      ei.remove(Y7, sessionStorage),
      ei.remove(X7, sessionStorage)
  }
    , c = W7.useRef(!1)
    , l = Number(ei.getString(X7, sessionStorage)) || 0;
  if (!c.current) {
      c.current = !0;
      let e = ei.getString(Y7, sessionStorage);
      (!e || Date.now() - parseInt(e) > b.MINUTE / 2) && (a ? (Vo.increment(`error.boundary.hydration`),
      navigator.onLine ? w.warning(`ErrorBoundary hit due to hydration error`, {
          info: n,
          error: t
      }) : w.info(`ErrorBoundary hit due to offline data error`, {
          info: n,
          error: t
      })) : o ? (Vo.increment(`error.boundary.network`),
      w.info(`ErrorBoundary hit due to network error`, {
          info: n,
          error: t,
          isOnline: navigator.onLine
      })) : (Vo.increment(`error.boundary`),
      w.remote(`ErrorBoundary hit`, {
          error: t.message,
          info: n
      }),
      n ? Upe(t, n, {
          mechanism: {
              handled: !0
          }
      }) : w.error(`ErrorBoundary hit`, t, {
          info: n
      })),
      ei.setString(Y7, Date.now().toString(), sessionStorage));
      let r = ei.getString(J7, sessionStorage) || Date.now().toString();
      ei.setString(J7, Date.now().toString(), sessionStorage),
      r && Date.now() - parseInt(r) < 3 * b.MINUTE ? (l++,
      ei.setString(X7, l.toString(), sessionStorage)) : s()
  }
  return vte( () => {
      r !== !0 && l === 1 && (w.remote(`Reloading page due to error-boundary errorCount = 1`),
      MQ.refreshWhenReady(hX.normal, `error-boundary-count-1`))
  }
  , 2 * b.MINUTE),
  (0,
  G7.jsx)(Kpe, {
      column: !0,
      auto: !0,
      align: `center`,
      justify: `center`,
      children: a ? (0,
      G7.jsx)(zpe, {
          onHydrationRetry: i
      }) : o ? (0,
      G7.jsx)(Bpe, {}) : (0,
      G7.jsx)(Vpe, {
          errorCount: l
      })
  })
}
function zpe({offlineActions: e, onHydrationRetry: t}) {
  let n = O7();
  return (0,
  G7.jsxs)(K7, {
      column: !0,
      align: `flex-start`,
      gap: 24,
      children: [(0,
      G7.jsx)(q7, {
          variant: `title2`,
          children: `Problem loading data`
      }), (0,
      G7.jsx)(O1, {
          variant: `regular`,
          color: `labelMuted`,
          children: `The requested data was not available locally, and there was an error loading it from the network. Try reloading the Linear app or check your internet connection.`
      }), (0,
      G7.jsxs)(a1, {
          gap: 16,
          children: [(!e || e.includes(`retry`)) && (0,
          G7.jsx)(y7, {
              onClick: () => {
                  pQ().invalidateRejectedHydrations(),
                  t?.()
              }
              ,
              children: `Retry`
          }), (!e || e.includes(`reload`)) && (0,
          G7.jsx)(y7, {
              onClick: () => {
                  MQ.forceRefresh(`problem-loading-data-user-action`)
              }
              ,
              variant: `secondary`,
              children: `Reload Linear`
          }), (!e || e.includes(`logout`)) && (0,
          G7.jsx)(y7, {
              onClick: () => n.logout(`User requested logout on error boundary`),
              variant: `secondary`,
              children: `Log out`
          })]
      })]
  })
}
function Bpe() {
  let e = O7();
  return (0,
  G7.jsxs)(K7, {
      column: !0,
      align: `flex-start`,
      gap: 24,
      children: [(0,
      G7.jsx)(q7, {
          variant: `title2`,
          children: `Network error`
      }), (0,
      G7.jsxs)(O1, {
          variant: `regular`,
          color: `labelMuted`,
          children: [`We detected a network error. Something might be wrong with your internet connection. Try reloading the Linear app. Don't hesitate to reach out to us if this problem persists:`, ` `, (0,
          G7.jsx)(`a`, {
              href: `mailto:support@linear.app`,
              children: `support@linear.app`
          })]
      }), (0,
      G7.jsxs)(a1, {
          gap: 16,
          children: [(0,
          G7.jsx)(y7, {
              onClick: () => {
                  MQ.forceRefresh(`network-error-user-action`)
              }
              ,
              children: `Reload Linear`
          }), e.currentUserId ? (0,
          G7.jsx)(y7, {
              onClick: () => e.logout(`User requested logout on error boundary`),
              variant: `secondary`,
              children: `Log out`
          }) : null]
      })]
  })
}
function Vpe({errorCount: e}) {
  let t = O7()
    , n = pQ()
    , r = () => t.logout(`User requested logout on error boundary`)
    , [i,a] = W7.useState(!0)
    , [o,s] = W7.useState(!1)
    , [c] = W7.useState(n.syncClient.shouldResetOnError);
  W7.useEffect( () => {
      c && (Vo.increment(`error.boundary.bootstrap`),
      n.resetLocalDatabase())
  }
  , []);
  let l = async e => {
      s(!0);
      try {
          e && (ei.clearAllNonAuthData(),
          await n.resetLocalDatabase()),
          MQ.forceRefresh(`exception-detected-user-action`)
      } catch (e) {
          w.error(`Error restarting client`, e),
          s(!1)
      }
  }
  ;
  return (0,
  G7.jsxs)(K7, {
      column: !0,
      align: `flex-start`,
      gap: 24,
      children: [(0,
      G7.jsx)(q7, {
          variant: `title2`,
          children: `> Exception detected.`
      }), (0,
      G7.jsxs)(O1, {
          variant: `regular`,
          color: `labelMuted`,
          children: [`We detected an exception and engineering has been notified. We do apologize for the inconvenience. Don't hesitate to reach out to us if this problem persists: `, (0,
          G7.jsx)(`a`, {
              href: `mailto:support@linear.app`,
              children: `support@linear.app`
          })]
      }), e > 1 && !c && (0,
      G7.jsxs)(a1, {
          gap: 8,
          column: !0,
          children: [(0,
          G7.jsxs)(qpe, {
              children: [(0,
              G7.jsx)(g7, {
                  checked: i,
                  onChange: () => a(!i)
              }), ` `, (0,
              G7.jsx)(O1, {
                  variant: `regular`,
                  color: `labelTitle`,
                  children: `Reset the Linear Client`
              })]
          }), (0,
          G7.jsx)(O1, {
              variant: `regular`,
              color: `labelMuted`,
              children: `Resetting your client will reload all data and might help mitigate this problem.`
          })]
      }), (0,
      G7.jsxs)(a1, {
          gap: 16,
          children: [(0,
          G7.jsx)(C7, {
              loading: o,
              onClick: () => {
                  l(e > 1 && i)
              }
              ,
              children: i && e > 1 ? `Reset Client` : s$.isElectron ? `Restart Linear` : `Reload Linear`
          }), t.currentUserId ? (0,
          G7.jsx)(y7, {
              onClick: r,
              variant: `secondary`,
              children: `Log out`
          }) : null]
      })]
  })
}
function Hpe(e, t) {
  let n = new WeakSet;
  function r(e, t) {
      if (!n.has(e)) {
          if (e.cause)
              return n.add(e),
              r(e.cause, t);
          e.cause = t
      }
  }
  r(e, t)
}
function Upe(e, {componentStack: t}, n) {
  if (e instanceof Error && t) {
      let n = Error(e.message);
      n.name = `React ErrorBoundary ${e.name}`,
      n.stack = t,
      Hpe(e, n)
  }
  return en(e, {
      ...n,
      captureContext: {
          contexts: {
              react: {
                  componentStack: t
              }
          }
      }
  })
}
var W7, G7, Wpe, Gpe, Kpe, K7, q7, qpe, J7, Y7, X7, Jpe = t(( () => {
  W7 = e(ht()),
  Xt(),
  WK(),
  tn(),
  r1(),
  s1(),
  A1(),
  E$(),
  qfe(),
  d2(),
  Yr(),
  b7(),
  Ya(),
  Es(),
  ws(),
  Ho(),
  F(),
  pm(),
  ni(),
  es(),
  hQ(),
  Xfe(),
  c$(),
  FQ(),
  Qfe(),
  H7(),
  G7 = e(f()),
  Wpe = function(e) {
      let t = Zt()
        , [n] = W7.useState(t)
        , r = W7.useMemo( () => new Ts, []);
      return W7.useEffect( () => {
          t !== n && r.fire(!0)
      }
      , [t]),
      (0,
      G7.jsx)(Gpe, {
          ...e,
          navigationSignal: r
      })
  }
  ,
  Gpe = class extends W7.Component {
      constructor(e) {
          super(e),
          this.retry = () => {
              this.setState({
                  error: void 0,
                  info: void 0
              })
          }
          ,
          this.setErrorAndNavigationListener = (e, t) => {
              this.cancelNavigationListen?.();
              let n = () => {
                  this.cancelNavigationListen?.(),
                  this.setState({
                      error: void 0,
                      info: void 0
                  })
              }
              ;
              this.props.navigationSignal.subscribe(n),
              this.cancelNavigationListen = () => {
                  this.props.navigationSignal.unsubscribe(n)
              }
              ,
              this.setState({
                  error: e,
                  waitFor: void 0,
                  info: {
                      ...t,
                      ...this.props.meta || {}
                  }
              })
          }
          ,
          this.state = {
              error: void 0,
              info: void 0,
              waitFor: void 0
          }
      }
      componentDidCatch(e, t) {
          let n = !!F7().currentUserId
            , r = qh.store.syncClient.deltaSyncReceivedPromise
            , i = Go(e) && !(e instanceof $o);
          n && r.isPending && !i ? (this.setState({
              error: void 0,
              info: void 0,
              waitFor: r
          }),
          Promise.race([r, Ja(b.MINUTE, `timeout`)]).then(n => {
              n === `timeout` ? this.setErrorAndNavigationListener(e, t) : this.setState({
                  error: void 0,
                  info: void 0,
                  waitFor: void 0
              })
          }
          )) : this.setErrorAndNavigationListener(e, t)
      }
      componentWillUnmount() {
          this.cancelNavigationListen?.()
      }
      render() {
          if (this.state.waitFor)
              throw this.state.waitFor;
          if (this.state.error) {
              let e = (0,
              G7.jsx)(U7, {
                  error: this.state.error,
                  info: this.state.info,
                  onHydrationRetry: this.retry
              });
              return typeof this.props.fallback == `function` ? this.props.fallback({
                  defaultFallback: e,
                  state: this.state
              }) : this.props.fallback ?? (0,
              G7.jsx)(G7.Fragment, {
                  children: e
              })
          }
          return this.props.children
      }
  }
  ,
  Kpe = HK(a1)([`height:100%;padding:24px;`, `;div a{color:`, `;}`], l2(), Y$(`labelLink`)),
  K7 = HK(a1)([`max-width:450px;`]),
  q7 = HK(O1)([`display:block;font-family:`, `;line-height:1em;`], Z$(`monospace`)),
  qpe = HK.label([`display:flex;align-items:center;`]),
  J7 = `lastErrorDetected`,
  Y7 = `lastErrorReported`,
  X7 = `errorCount`
}
)), Ype = t(( () => {
  Jpe()
}
)), Xpe, Z7, Q7 = t(( () => {
  Xpe = e(ht()),
  D7(),
  Z7 = () => (0,
  Xpe.useContext)(E7)
}
));
function Zpe(e, t) {
  let n = Dn(e)
    , r = typeof e != `function`;
  function i(e) {
      let i = $7.useRef(null)
        , a = $7.useRef(0)
        , o = $7.useRef(void 0)
        , s = $7.useRef(void 0)
        , [c,l] = $7.useState(!1);
      return $7.useEffect( () => {
          let e = t?.fallbackDelayMs ?? 0;
          if (!e) {
              l(!0);
              return
          }
          return s.current = setTimeout( () => l(!0), e),
          () => {
              o.current && clearTimeout(o.current),
              s.current && clearTimeout(s.current)
          }
      }
      , []),
      (0,
      e9.jsx)($7.Suspense, {
          fallback: c ? (0,
          e9.jsx)(Qpe, {
              loadingRef: a,
              fallback: e?.fallback || (typeof t?.fallback == `function` ? t?.fallback(e) : t?.fallback),
              onDone: () => {
                  i.current && (i.current.style.opacity = `0`),
                  window.requestAnimationFrame( () => {
                      a.current > 0 || i.current && (i.current.style.opacity = `1`,
                      i.current.classList.add(`suspenseFadeIn`))
                  }
                  )
              }
          }) : null,
          children: (0,
          e9.jsx)($pe, {
              timer: o,
              hydrationErrorFallback: t?.hydrationErrorFallback || `bubbleError`,
              props: e,
              children: r ? (0,
              e9.jsx)(n, {
                  ...e,
                  ref: i
              }) : (0,
              e9.jsx)(n, {
                  ...e
              })
          })
      })
  }
  return i
}
var $7, e9, Qpe, $pe, eme = t(( () => {
  $7 = e(ht()),
  On(),
  Yr(),
  ro(),
  zn(),
  pm(),
  F(),
  Ype(),
  Q7(),
  e9 = e(f()),
  Qpe = e => {
      let {loadingRef: t, onDone: n, fallback: r} = e
        , i = Z7()
        , a = $7.useRef(null)
        , o = `red dashed 1px`;
      return $7.useEffect( () => {
          ++t.current;
          let e = a.current?.parentElement, r;
          return e && (r = e.style.outline,
          e.style.outline = o),
          () => {
              --t.current,
              t.current === 0 && e && (e.style.outline = r !== void 0 && r !== o ? r : ``),
              n()
          }
      }
      , []),
      (0,
      e9.jsxs)(e9.Fragment, {
          children: [r || null, i.developerOptions?.suspenseVisuals ? (0,
          e9.jsx)(`div`, {
              ref: a,
              style: {
                  display: `none`
              }
          }) : null]
      })
  }
  ,
  $pe = class extends $7.Component {
      constructor(e) {
          super(e),
          this._isMounted = !1,
          this.retry = () => {
              this._isMounted && this.setState(e => ({
                  ...e,
                  error: void 0,
                  retries: e.retries + 1
              }))
          }
          ,
          this.state = {
              error: void 0,
              retries: 0,
              waitFor: void 0
          }
      }
      componentDidMount() {
          this._isMounted = !0;
          let e = qh.store.syncClient.deltaSyncReceivedPromise;
          e.isPending && e.then( () => {
              this._isMounted && this.setState(e => ({
                  ...e,
                  error: void 0,
                  waitFor: void 0
              }))
          }
          )
      }
      componentWillUnmount() {
          this._isMounted = !1
      }
      static getDerivedStateFromError(e) {
          let t = qh.store.syncClient.deltaSyncReceivedPromise;
          return t.isPending ? {
              error: void 0,
              waitFor: t
          } : {
              error: e
          }
      }
      render() {
          if (this.state.waitFor)
              throw this.state.waitFor;
          if (!this.state.error)
              return this.props.children;
          if (!(this.state.error instanceof dm))
              throw this.state.error;
          let {hydrationErrorFallback: e, timer: t, props: n} = this.props;
          if (qh.store.syncClient.deltaSyncReceivedPromise.isPending)
              throw this.setState(e => ({
                  ...e,
                  error: void 0,
                  retries: 0
              })),
              qh.store.syncClient.deltaSyncReceivedPromise;
          if ((this.state.retries ?? 0) < 3) {
              t.current && clearTimeout(t.current);
              let e = no();
              throw t.current = setTimeout( () => {
                  t.current = void 0,
                  this.retry(),
                  e.resolve()
              }
              , 1 * b.SECOND),
              e
          }
          if (e === `bubbleError`)
              throw this.state.error;
          return e === `renderNothing` ? null : typeof e == `function` ? e(n) : e.action === `showError` ? (0,
          e9.jsx)(U7, {
              error: this.state.error,
              doNotRefresh: !0,
              offlineActions: e.actions,
              onHydrationRetry: this.retry
          }) : (y(e.action),
          (0,
          e9.jsx)(U7, {
              error: this.state.error,
              doNotRefresh: !0,
              onHydrationRetry: this.retry
          }))
      }
  }
}
)), t9, n9, r9, tme = t(( () => {
  ht(),
  K5(),
  Q5(),
  M5(),
  eme(),
  Q7(),
  t9 = e(f()),
  n9 = Zpe(function(e) {
      let {emoji: t} = e
        , n = Z7();
      if (typeof t == `string`) {
          let r = Z5.toEmojiName(t)
            , i = A5(n.organization.getEmojiByName(r));
          if (i)
              return (0,
              t9.jsx)(r9, {
                  ...e,
                  emoji: i
              });
          let a = Z5.findNativeByName(r);
          return a ? (0,
          t9.jsx)(r9, {
              ...e,
              emoji: a
          }) : (0,
          t9.jsx)(t9.Fragment, {})
      }
      return (0,
      t9.jsx)(r9, {
          ...e,
          emoji: t
      })
  }, {
      fallback: e => {
          let {emoji: t, size: n=14} = e;
          if (typeof t == `string`) {
              let n = Z5.toEmojiName(t)
                , r = Z5.findNativeByName(n);
              if (r)
                  return (0,
                  t9.jsx)(r9, {
                      ...e,
                      emoji: r
                  })
          }
          return (0,
          t9.jsx)(G5, {
              $size: n || 14
          })
      }
  }),
  r9 = e => {
      let {emoji: t, size: n=14, shouldNotAlign: r, ...i} = e;
      return `url`in t ? (0,
      t9.jsx)(G5, {
          style: r ? void 0 : {
              transform: `translateY(2px)`,
              marginTop: -1
          },
          as: `img`,
          src: t.url,
          $size: n,
          ...i
      }) : (0,
      t9.jsx)(G5, {
          $size: n,
          ...i,
          "data-type": `emoji`,
          children: t.symbol
      })
  }
}
)), i9, a9, nme = t(( () => {
  ht(),
  On(),
  x0(),
  W5(),
  Vd(),
  tme(),
  i9 = e(f()),
  a9 = Dn(function(e) {
      let {model: t, fallbackIcon: n, color: r, size: i=16, className: a, ...o} = e
        , s = B5(r || t?.color)
        , c = a ? `${a} color-override` : `color-override`
        , l = (0,
      i9.jsx)(v0, {
          "aria-hidden": !0,
          icon: n,
          color: s,
          size: i,
          className: c,
          ...o
      });
      return t?.icon ? y0(t.icon) ? (0,
      i9.jsx)(v0, {
          "aria-hidden": !0,
          icon: t.icon,
          color: s,
          size: i,
          className: c,
          ...o
      }) : Bd.isEmojiCode(t.icon) ? (0,
      i9.jsx)(n9, {
          "aria-hidden": !0,
          emoji: t.icon,
          size: i,
          shouldNotAlign: !0,
          className: a,
          ...o
      }) : l : l
  })
}
)), rme, o9, ime = t(( () => {
  ht(),
  On(),
  z5(),
  nme(),
  rme = e(f()),
  o9 = Dn(function(e) {
      let {project: t, ...n} = e;
      return (0,
      rme.jsx)(a9, {
          model: t,
          fallbackIcon: $.Project,
          className: `color-override`,
          ...n
      })
  })
}
)), ame = t(( () => {
  ime()
}
)), ome, sme, s9, c9, cme, l9, lme, ume, dme, fme, pme, mme, hme, gme, _me, vme, yme, bme, xme, Sme, Cme, wme, Tme, Eme, Dme, Ome, kme, Ame, jme, Mme, Nme, Pme, Fme, u9, Ime, d9, Lme, f9, Rme, zme, Bme, Vme, Hme, Ume, Wme, Gme, Kme, qme, p9, Jme, Yme, Xme, Zme, Qme, $me, ehe, the, nhe, rhe, ihe, ahe, ohe, she, che, lhe, uhe, dhe, fhe, phe, mhe, hhe, ghe, _he, m9, h9, g9, vhe = t(( () => {
  ht(),
  ome = e(o()),
  sme = e(Gt()),
  m8(),
  _8(),
  b8(),
  C8(),
  E8(),
  k8(),
  M8(),
  F8(),
  R8(),
  V8(),
  n5(),
  a5(),
  Pz(),
  _H(),
  PR(),
  Lq(),
  sR(),
  iz(),
  mH(),
  GU(),
  HL(),
  hR(),
  DM(),
  FB(),
  WB(),
  TA(),
  Ij(),
  kH(),
  Dk(),
  oM(),
  x0(),
  c5(),
  _5(),
  C5(),
  L5(),
  ame(),
  s9 = e(f()),
  c9 = {
      name: e => {
          let t = e.targetedModelsOfType(XL, !0);
          if (t.length === 1) {
              let e = t[0];
              return e.isHydrated() ? BL.handleNotification(e, {
                  issue: t => t ? (0,
                  s9.jsx)(Q8, {
                      title: `${e.shortLabel}: ${t.identifier} ${t.title}`,
                      prefix: `Notification`,
                      highlightPrefix: !0,
                      dimHighlights: !0
                  }) : void 0,
                  document: t => t ? (0,
                  s9.jsx)(Q8, {
                      title: `${e.shortLabel}: ${t.displayTitle}`,
                      prefix: `Notification`,
                      highlightPrefix: !0,
                      dimHighlights: !0
                  }) : void 0,
                  oauthClientApproval: t => t ? (0,
                  s9.jsx)(Q8, {
                      title: `${e.shortLabel}`,
                      prefix: `Notification`,
                      highlightPrefix: !0,
                      dimHighlights: !0
                  }) : void 0,
                  project: t => t ? (0,
                  s9.jsx)(Q8, {
                      title: `${e.shortLabel}: ${t.name}`,
                      prefix: `Notification`,
                      highlightPrefix: !0,
                      dimHighlights: !0
                  }) : void 0,
                  initiative: t => t ? (0,
                  s9.jsx)(Q8, {
                      title: `${e.shortLabel}: ${t.name}`,
                      prefix: `Notification`,
                      highlightPrefix: !0,
                      dimHighlights: !0
                  }) : void 0,
                  initiativeUpdate: t => t ? (0,
                  s9.jsx)(Q8, {
                      title: `${e.shortLabel}: initiative update for ${t.initiative.name}`,
                      prefix: `Notification`,
                      highlightPrefix: !0,
                      dimHighlights: !0
                  }) : void 0,
                  projectUpdate: t => t ? (0,
                  s9.jsx)(Q8, {
                      title: `${e.shortLabel}: project update for ${t.project.name}`,
                      prefix: `Notification`,
                      highlightPrefix: !0,
                      dimHighlights: !0
                  }) : void 0,
                  projectMilestone: t => t ? (0,
                  s9.jsx)(Q8, {
                      title: `${e.shortLabel}: milestone for ${t.project.name}`,
                      prefix: `Notification`,
                      highlightPrefix: !0,
                      dimHighlights: !0
                  }) : void 0,
                  pullRequest: t => t ? (0,
                  s9.jsx)(Q8, {
                      title: `${e.shortLabel}: ${t.title}`,
                      prefix: `Notification`,
                      highlightPrefix: !0,
                      dimHighlights: !0
                  }) : void 0,
                  post: t => t ? (0,
                  s9.jsx)(Q8, {
                      title: `${e.shortLabel}: team update${t.title ? ` for ${t.title}` : ``}`,
                      prefix: `Notification`,
                      highlightPrefix: !0,
                      dimHighlights: !0
                  }) : void 0,
                  customer: t => t ? (0,
                  s9.jsx)(Q8, {
                      title: `${e.shortLabel}: ${t.name}`,
                      prefix: `Notification`,
                      highlightPrefix: !0,
                      dimHighlights: !0
                  }) : void 0
              }) ?? (0,
              s9.jsx)(Q8, {
                  title: e.shortLabel,
                  prefix: `Notification`,
                  highlightPrefix: !0,
                  dimHighlights: !0
              }) : (0,
              s9.jsx)(Q8, {
                  title: e.shortLabel,
                  prefix: `Notification`,
                  highlightPrefix: !0,
                  dimHighlights: !0
              })
          } else if (t.length > 1)
              return `${t.length} notifications`;
          return `Notification`
      }
      ,
      priority: e => g9.Notification + (e.hasTargetedModelsOfType(XL, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      promoteToTitle: e => e.hasTargetedModelsOfType(XL, !0)
  },
  cme = {
      name: `Notifications`,
      priority: e => y5(e.location.pathname) === `inbox` || e.location.state?.issueOrigin?.type === `inbox` ? g9.Notification : g9.Notification + m9.nonTargetedModelActions
  },
  l9 = {
      name: e => {
          let t = e.targetedModelsOfType(Y, !0);
          if (t.length > 1)
              return `${t.length} issues`;
          if (t.length === 1) {
              let e = t[0];
              return e.number ? (0,
              s9.jsx)(Q8, {
                  title: e.title,
                  prefix: e.identifier,
                  highlightPrefix: !0,
                  dimHighlights: !0
              }) : (0,
              s9.jsx)(Q8, {
                  title: e.title.trim().length > 0 ? e.title : `New issue`,
                  highlight: e.identifier,
                  dimHighlights: !0
              })
          }
          return `Issue`
      }
      ,
      priority: e => g9.Issue + (e.hasTargetedModelsOfType(Y, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(f8, {}),
      promoteToTitle: e => e.hasTargetedModelsOfType(Y, !0),
      showNameInBreadcrumb: (e, t) => !(e.targetedModelOfType(Y) && t === c9)
  },
  lme = {
      name: `Issues`,
      defaultImage: (0,
      s9.jsx)(f8, {}),
      priority: () => g9.Issue + m9.nonTargetedModelActions
  },
  ume = {
      name: e => {
          let t = e.targetedModelsOfType(OH, !0);
          return t.length === 1 ? (0,
          s9.jsx)(Q8, {
              prefix: `Label`,
              title: t[0].name,
              highlightPrefix: !0,
              dimHighlights: !0
          }) : `${t.length} labels`
      }
      ,
      priority: () => m9.targetedModelActions,
      promoteToTitle: e => e.hasTargetedModelsOfType(OH, !0)
  },
  dme = {
      name: e => {
          let t = e.targetedModelsOfType(Ek, !0);
          return t.length === 1 ? (0,
          s9.jsx)(Q8, {
              prefix: `Label`,
              title: t[0].name,
              highlightPrefix: !0,
              dimHighlights: !0
          }) : `${t.length} labels`
      }
      ,
      priority: () => m9.targetedModelActions,
      promoteToTitle: e => e.hasTargetedModelsOfType(Ek, !0)
  },
  fme = {
      name: `Embed`,
      priority: () => m9.nonTargetedModelActions
  },
  pme = {
      name: `Comment`,
      priority: () => m9.targetedModelActions
  },
  mme = {
      name: `Agent`,
      priority: () => m9.targetedModelActions
  },
  hme = {
      name: e => {
          let t = e.targetedModelsOfType(gH, !0);
          return t.length === 1 ? `${t[0].displayName}` : t.length > 1 ? `${t.length} cycles` : `Cycle`
      }
      ,
      priority: e => g9.Cycle + (e.hasTargetedModelsOfType(gH, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(F5, {}),
      promoteToTitle: e => e.hasTargetedModelsOfType(gH, !0)
  },
  gme = {
      name: e => {
          let t = e.targetedModelsOfType(NR, !0);
          if (t.length === 1) {
              let e = t[0];
              return (0,
              s9.jsx)(Q8, {
                  prefix: `Document`,
                  title: e.displayTitle,
                  highlightPrefix: !0,
                  dimHighlights: !0
              })
          } else if (t.length > 1)
              return `${t.length} documents`;
          return `Document`
      }
      ,
      priority: e => g9.Document + (e.hasTargetedModelsOfType(NR, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(v0, {
          icon: `Page`
      }),
      promoteToTitle: e => e.hasTargetedModelsOfType(NR, !0),
      showNameInBreadcrumb: (e, t) => !(e.targetedModelOfType(NR) && t === c9)
  },
  _me = {
      name: `Documents`,
      defaultImage: (0,
      s9.jsx)(v0, {
          icon: `Page`
      }),
      priority: () => g9.Document + m9.nonTargetedModelActions
  },
  vme = {
      name: e => {
          let t = e.targetedModelsOfType(G, !0);
          if (t.length === 1) {
              let e = t[0];
              return (0,
              s9.jsx)(Q8, {
                  prefix: `Project`,
                  title: e.name,
                  highlightPrefix: !0,
                  dimHighlights: !0
              })
          } else if (t.length > 1)
              return `${t.length} projects`;
          return `Project`
      }
      ,
      priority: e => {
          let t = y5(e.location.pathname);
          if (t === `teamProjects`)
              return h9;
          if (t === `customView`) {
              let t = e.targetedModelOfType(Az);
              if (t && t.modelType === `project`)
                  return h9
          }
          return g9.Project + (e.hasTargetedModelsOfType(G, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions)
      }
      ,
      defaultImage: (0,
      s9.jsx)(o9, {}),
      preventCollapsingInSearch: !0,
      promoteToTitle: e => e.hasTargetedModelsOfType(G, !0)
  },
  yme = {
      name: `Projects`,
      defaultImage: (0,
      s9.jsx)(o9, {}),
      priority: e => {
          let t = y5(e.location.pathname);
          return t === `initiative` ? g9.Initiative : !e.targetedModelOfType(W) && (t === `teamProjects` || t === `allProjects`) ? g9.Project : g9.Project + m9.nonTargetedModelActions
      }
  },
  bme = {
      name: e => {
          let t = e.targetedModelsOfType(mR, !0);
          if (t.length === 1) {
              let e = t[0];
              return (0,
              s9.jsx)(Q8, {
                  prefix: `Milestone`,
                  title: e.name,
                  highlightPrefix: !0,
                  dimHighlights: !0
              })
          } else if (t.length > 1)
              return `${t.length} milestones`;
          return `Milestone`
      }
      ,
      priority: e => g9.Project + (e.hasTargetedModelsOfType(mR, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(z8, {}),
      promoteToTitle: e => e.hasTargetedModelsOfType(mR, !0)
  },
  xme = {
      name: e => {
          let t = e.targetedModelsOfType(W, !0);
          if (t.length === 1) {
              let e = t[0];
              return (0,
              s9.jsx)(Q8, {
                  title: e.name,
                  prefix: `Initiative`,
                  highlightPrefix: !0,
                  dimHighlights: !0
              })
          } else if (t.length > 1)
              return `${t.length} initiatives`;
          return `Initiative`
      }
      ,
      priority: e => g9.Initiative + (e.hasTargetedModelsOfType(W, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(I8, {}),
      promoteToTitle: e => e.hasTargetedModelsOfType(W, !0)
  },
  Sme = {
      name: `Initiatives`,
      defaultImage: (0,
      s9.jsx)(I8, {}),
      priority: e => y5(e.location.pathname)?.startsWith(`initiatives`) ? g9.Initiative + m9.targetedModelActions + 1 : g9.Initiative + m9.nonTargetedModelActions
  },
  Cme = {
      name: e => {
          let t = e.targetedModelsOfType(aM, !0);
          if (t.length === 1) {
              let e = t[0];
              return (0,
              s9.jsx)(Q8, {
                  title: e.name,
                  prefix: `Release`,
                  highlightPrefix: !0,
                  dimHighlights: !0
              })
          } else if (t.length > 1)
              return `${t.length} releases`;
          return `Release`
      }
      ,
      priority: e => g9.Release + (e.hasTargetedModelsOfType(aM, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(o5, {}),
      promoteToTitle: e => e.hasTargetedModelsOfType(aM, !0)
  },
  wme = {
      name: `Releases`,
      defaultImage: (0,
      s9.jsx)(o5, {}),
      priority: () => g9.Release + m9.nonTargetedModelActions
  },
  Tme = {
      name: e => {
          let t = e.targetedModelsOfType(MB, !0);
          if (t.length === 1) {
              let e = t[0];
              return (0,
              s9.jsx)(Q8, {
                  prefix: `Customer`,
                  title: e.name,
                  highlightPrefix: !0,
                  dimHighlights: !0
              })
          } else if (t.length > 1)
              return `${t.length} customers`;
          return `Customer`
      }
      ,
      priority: e => g9.Customer + (e.hasTargetedModelsOfType(MB, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(A8, {}),
      promoteToTitle: e => e.hasTargetedModelsOfType(MB, !0)
  },
  Eme = {
      name: `Customers`,
      priority: e => y5(e.location.pathname)?.startsWith(`customer`) ? g9.Customer + m9.targetedModelActions + 1 : g9.Customer + m9.nonTargetedModelActions,
      defaultImage: (0,
      s9.jsx)(A8, {})
  },
  Dme = {
      name: e => {
          let t = e.targetedModelsOfType(UB, !0);
          if (t.length === 1) {
              let e = t[0];
              return `Customer request${e.customer?.value?.name ? ` from ${e.customer?.value?.name}` : ``}`
          } else if (t.length > 1)
              return `${t.length} requests`;
          return `Customer requests`
      }
      ,
      priority: e => g9.Customer + (e.hasTargetedModelsOfType(UB, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(A8, {}),
      promoteToTitle: e => e.hasTargetedModelsOfType(UB, !0)
  },
  Ome = {
      name: e => {
          let t = e.targetedModelsOfType(U, !0);
          if (t.length === 1) {
              let e = t[0];
              return (0,
              s9.jsx)(Q8, {
                  title: e.title,
                  prefix: `Review`,
                  highlightPrefix: !0,
                  dimHighlights: !0
              })
          } else if (t.length > 1)
              return `${t.length} reviews`;
          return `Review`
      }
      ,
      priority: e => g9.Review + (e.hasTargetedModelsOfType(U, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(N8, {}),
      promoteToTitle: e => e.hasTargetedModelsOfType(U, !0),
      showNameInBreadcrumb: (e, t) => !(e.targetedModelOfType(U) && t === c9)
  },
  kme = {
      name: `Reviews`,
      priority: e => e.targetedModelOfType(Y) ? g9.Issue + m9.targetedModelActions : g9.Review + m9.nonTargetedModelActions,
      defaultImage: (0,
      s9.jsx)(N8, {}),
      promoteToTitle: () => !1
  },
  Ame = {
      name: e => {
          let t = e.targetedModelsOfType(J, !0);
          if (t.length === 1) {
              let e = t[0];
              return (0,
              s9.jsx)(Q8, {
                  prefix: `User`,
                  title: e.name,
                  highlightPrefix: !0,
                  dimHighlights: !0
              })
          } else if (t.length > 1)
              return `${t.length} users`;
          return `User`
      }
      ,
      priority: e => g9.User + (e.hasTargetedModelsOfType(J, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(D8, {}),
      promoteToTitle: e => e.hasTargetedModelsOfType(J, !0)
  },
  jme = {
      name: e => {
          let t = e.targetedModelsOfType(Az, !0);
          return t.length === 1 ? (0,
          s9.jsx)(Q8, {
              prefix: `View`,
              title: t[0].name,
              highlightPrefix: !0,
              dimHighlights: !0
          }) : t.length > 1 ? `${t.length} views` : `View`
      }
      ,
      priority: e => g9.CustomView + (e.hasTargetedModelsOfType(Az, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(w8, {}),
      promoteToTitle: e => e.hasTargetedModelsOfType(Az, !0)
  },
  Mme = {
      name: `Views`,
      priority: e => {
          let t = y5(e.location.pathname);
          return t === `customView` || t === `customViewsList` || t === `teamCustomViewsList` ? g9.CustomView : g9.CustomView + m9.nonTargetedModelActions
      }
      ,
      defaultImage: (0,
      s9.jsx)(w8, {})
  },
  Nme = {
      name: e => {
          let t = e.targetedModelsOfType(Fj, !0);
          return t.length === 1 ? (0,
          s9.jsx)(Q8, {
              prefix: `Dashboard`,
              title: t[0].name,
              highlightPrefix: !0,
              dimHighlights: !0
          }) : t.length > 1 ? `${t.length} dashboards` : `Dashboard`
      }
      ,
      priority: e => g9.Dashboard + (e.hasTargetedModelsOfType(Fj, !0) ? m9.targetedModelActions : m9.nonTargetedModelActions),
      defaultImage: (0,
      s9.jsx)(v0, {
          icon: `Dashboard`
      }),
      promoteToTitle: e => e.hasTargetedModelsOfType(Fj, !0)
  },
  Pme = {
      name: e => {
          let t = e.targetedModelsOfType(K, !0);
          if (t.length === 1) {
              let e = t[0];
              return (0,
              s9.jsx)(Q8, {
                  prefix: `Team`,
                  title: e.name,
                  highlightPrefix: !0,
                  dimHighlights: !0
              })
          } else if (t.length > 1)
              return `${t.length} teams`;
          return `Team`
      }
      ,
      priority: () => g9.Team + m9.nonTargetedModelActions,
      defaultImage: (0,
      s9.jsx)(x8, {}),
      promoteToTitle: e => e.hasTargetedModelsOfType(K, !0)
  },
  Fme = {
      name: `Display options`,
      priority: () => m9.miscActions - 2,
      preventCollapsingInSearch: !0,
      showName: `always`,
      groupingAction: {
          name: `Display options`,
          image: (0,
          s9.jsx)(r5, {}),
          keywords: [`display`, `options`, `view`, `preferences`]
      }
  },
  u9 = {
      name: `Miscellaneous`,
      showNameInBreadcrumb: !1,
      priority: () => m9.miscActions
  },
  Ime = {
      name: `Export`,
      priority: () => m9.miscActions + 1
  },
  d9 = {
      name: `Feature flag`,
      priority: () => m9.miscActions + 7,
      defaultImage: (0,
      s9.jsx)(g5, {})
  },
  Lme = {
      name: `Settings`,
      priority: () => m9.miscActions + 8,
      preventCollapsingInSearch: !0,
      defaultImage: (0,
      s9.jsx)(v8, {})
  },
  f9 = {
      name: `Users from other teams`,
      showNameInBreadcrumb: !1,
      priority: () => m9.nonTargetedModelActions
  },
  Rme = {
      name: `New user`,
      priority: e => f9.priority(e) + .1
  },
  zme = {
      name: e => {
          let t = e.targetedModelsOfType(G)
            , n = t.length === 1 ? t[0] : void 0;
          return n ? `Users from the project ${(0,
          sme.default)(`team`, n.accessibleTeams.length)}` : `Users`
      }
      ,
      showNameInBreadcrumb: !1,
      priority: () => g9.Project + m9.targetedModelActions + 10
  },
  Bme = {
      name: `Suggested based on filters`,
      showNameInBreadcrumb: !1,
      priority: e => {
          let t = e.targetedModelOfType(G)
            , n = e.targetedModelOfType(Y);
          return (t ? g9.Project : n ? g9.Issue : 0) + m9.targetedModelActions
      }
  },
  Vme = {
      name: `Teams`,
      priority: () => m9.miscActions + 10,
      preventCollapsingInSearch: !0
  },
  Hme = {
      name: `Filter`,
      priority: () => m9.viewActions + 10,
      preventCollapsingInSearch: !0,
      defaultImage: (0,
      s9.jsx)(h8, {})
  },
  Ume = {
      name: `No template`,
      priority: () => m9.viewActions + 18,
      showName: `never`
  },
  Wme = (0,
  ome.default)( (e, t=0) => ({
      name: e,
      priority: () => m9.viewActions + 19 + t,
      groupWhenLifted: p9
  })),
  Gme = {
      name: `Workspace`,
      priority: () => m9.viewActions + 20,
      groupWhenLifted: l9
  },
  Kme = {
      name: `Template`,
      priority: () => m9.viewActions + 21
  },
  qme = {
      name: `Templates`,
      priority: () => m9.viewActions + 21
  },
  p9 = {
      name: `Team Templates`,
      priority: () => m9.viewActions + 22
  },
  Jme = {
      name: `Integrations`,
      priority: () => m9.viewActions + 30,
      preventCollapsingInSearch: !0
  },
  Yme = {
      name: `Favorite`,
      priority: () => m9.viewActions + 50
  },
  Xme = {
      name: `Favorites`,
      priority: () => m9.viewActions + 50
  },
  Zme = {
      name: `Navigation`,
      showNameInBreadcrumb: !1,
      priority: () => m9.navigationActions,
      preventCollapsingInSearch: !0,
      showName: `always`,
      availableDuringBootstrap: !0
  },
  Qme = {
      name: `Tabs`,
      priority: () => m9.navigationActions + 10,
      preventCollapsingInSearch: !0
  },
  $me = {
      name: `Help`,
      priority: () => m9.miscActions + 20,
      defaultImage: (0,
      s9.jsx)(v0, {
          icon: `Book`
      }),
      promoteToTitle: () => !0,
      availableDuringBootstrap: !0,
      preventCollapsingInSearch: !0
  },
  ehe = {
      name: e => {
          let t = e.targetedModelOfType(G);
          return t ? (0,
          s9.jsx)(Q8, {
              prefix: `Project`,
              title: t.name,
              highlightPrefix: !0,
              dimHighlights: !0
          }) : `Rollout stage`
      }
      ,
      priority: d9.priority,
      promoteToTitle: e => e.hasTargetedModelsOfType(G, !0)
  },
  the = {
      name: e => `What's new${e.user.settings.developerCMSDatasetOverrideValue === `development` ? ` [DEV CMS DATA]` : ``}`,
      priority: () => m9.miscActions + 25
  },
  nhe = {
      name: `Account`,
      defaultImage: (0,
      s9.jsx)(x8, {}),
      priority: () => m9.miscActions + 30
  },
  rhe = {
      name: `Third-party application approval requests`,
      priority: () => m9.miscActions + 40,
      defaultImage: (0,
      s9.jsx)(v8, {})
  },
  ihe = {
      name: `Actions`,
      showNameInBreadcrumb: !1,
      priority: () => 1
  },
  ahe = {
      name: e => e.searchInput ? `Quick results for "${(e.searchInput ?? ``).trim()}"` : `Search`,
      priority: e => e.searchInput ? m9.searchResultActions : m9.searchActions,
      defaultImage: (0,
      s9.jsx)(h8, {}),
      showNameInBreadcrumb: !1,
      preventCollapsingInSearch: !0,
      showName: `always`
  },
  ohe = {
      name: `Recent searches`,
      priority: () => m9.searchActions
  },
  she = {
      name: `Recent`,
      priority: () => m9.searchActions
  },
  che = {
      name: `Related issues`,
      priority: () => m9.searchActions
  },
  lhe = {
      name: `Developer`,
      priority: () => m9.developerActions,
      preventCollapsingInSearch: !0
  },
  uhe = {
      name: `Arcade`,
      priority: () => m9.miscActions + 50
  },
  dhe = {
      name: `Recent searches`,
      priority: () => m9.targetedModelActions
  },
  fhe = {
      name: `Suggestions`,
      priority: () => m9.targetedModelActions
  },
  phe = {
      name: `Similar issues`,
      priority: () => m9.targetedModelActions
  },
  mhe = {
      name: `Drafts`,
      priority: () => m9.targetedModelActions
  },
  hhe = {
      name: `Folders`,
      priority: () => m9.targetedModelActions
  },
  ghe = {
      name: `AI panel`,
      priority: () => m9.miscActions
  },
  _he = {
      name: `Email intake address`,
      priority: () => m9.targetedModelActions
  },
  m9 = function(e) {
      return e[e.targetedModelActions = 0] = `targetedModelActions`,
      e[e.nonTargetedModelActions = 1e3] = `nonTargetedModelActions`,
      e[e.viewActions = 2e3] = `viewActions`,
      e[e.navigationActions = 2500] = `navigationActions`,
      e[e.miscActions = 3e3] = `miscActions`,
      e[e.searchActions = 5e3] = `searchActions`,
      e[e.developerActions = 6e3] = `developerActions`,
      e[e.searchResultActions = 7e3] = `searchResultActions`,
      e
  }({}),
  h9 = -1,
  g9 = function(e) {
      return e[e.Notification = 0] = `Notification`,
      e[e.Issue = 1] = `Issue`,
      e[e.Cycle = 2] = `Cycle`,
      e[e.Project = 3] = `Project`,
      e[e.Document = 4] = `Document`,
      e[e.CustomView = 5] = `CustomView`,
      e[e.Dashboard = 6] = `Dashboard`,
      e[e.Widget = 7] = `Widget`,
      e[e.User = 8] = `User`,
      e[e.Initiative = 9] = `Initiative`,
      e[e.Team = 10] = `Team`,
      e[e.Customer = 11] = `Customer`,
      e[e.Review = 12] = `Review`,
      e[e.Meeting = 13] = `Meeting`,
      e[e.Release = 14] = `Release`,
      e
  }({})
}
)), _9, v9, yhe, bhe, xhe, She, y9, b9, Che, whe = t(( () => {
  _9 = e(ht()),
  On(),
  WK(),
  kn(),
  r1(),
  d3(),
  i6(),
  d8(),
  vhe(),
  v9 = e(f()),
  yhe = 4,
  bhe = a3(),
  xhe = Dn(function() {
      let[e,t] = _9.useState(void 0)
        , {toasts: n} = gte()
        , r = _9.useMemo( () => ({
          id: bhe,
          name: `Open link from last toast`,
          group: u9,
          keyboardShortcut: {
              key: `o`,
              mod: !0,
              alt: !0
          },
          keywords: `notification`,
          onlyVisibleThroughSearch: !0,
          applicable() {
              return e !== void 0
          },
          execute: () => {
              e && e.startsWith(`/`) && n6.instance.redirectTo(e)
          }
      }), [e]);
      return _9.useEffect( () => {
          let e = n[n.length - 1];
          if (e) {
              let n = e;
              if (n.link && n.link.to) {
                  let e = typeof n.link.to == `string` ? n.link.to : n.link.to.pathname;
                  e?.startsWith(`/`) && t(e)
              }
          }
      }
      , [n]),
      (0,
      v9.jsxs)(v9.Fragment, {
          children: [(0,
          v9.jsx)(u8, {
              action: r
          }), (0,
          v9.jsx)(b9, {
              lastToastLink: e
          })]
      })
  }),
  She = () => (0,
  v9.jsx)(b9, {}),
  y9 = _9.createContext(void 0),
  b9 = Dn(function(e) {
      return (0,
      v9.jsx)(y9.Provider, {
          value: e.lastToastLink,
          children: (0,
          v9.jsx)(Che, {
              mobileOffset: 16,
              expand: !0,
              visibleToasts: yhe
          })
      })
  }),
  Che = HK(_te)([`position:fixed;right:0;bottom:0;margin:0 16px 16px 16px;width:384px;max-width:calc(100vw - 32px);z-index:`, `;pointer-events:none;`, `{width:100%;right:16px;left:16px;margin:0;bottom:0;max-width:none;}`], U$.toast, q$.phone)
}
)), x9, The = t(( () => {
  WK(),
  r1(),
  s1(),
  ir(),
  x9 = HK(a1)([`position:absolute;right:9px;bottom:8px;align-items:center;gap:8px;opacity:`, `;transition:opacity `, `;`], rr.isPureTouchDevice ? 1 : 0, $$(`highlightFadeOut`))
}
));
function Ehe(e) {
  switch (e) {
  case `bordered`:
      return T9;
  case `active`:
      return Ohe;
  case `borderless`:
      return E9;
  case `recording`:
      return khe;
  case `error`:
      return Ahe;
  case `placeholder`:
      return jhe;
  default:
      return E9
  }
}
var S9, C9, Dhe, w9, T9, Ohe, khe, Ahe, jhe, E9, D9, Mhe, Nhe, O9, Phe = t(( () => {
  ht(),
  WK(),
  T1(),
  Q2(),
  H$(),
  n1(),
  A1(),
  S9 = e(f(), 1),
  C9 = e => {
      let {type: t=`bordered`, size: n=`normal`, variant: r=`default`, shortcutKey: i, additionalKey: a, alternateKey: o, mod: s, option: c, ctrl: l, shift: u, ...d} = e
        , f = [];
      if (l && f.push(`ctrl`),
      s) {
          let e = X2.systemModKeyText;
          e === `Ctrl` ? f.unshift(e) : f.push(e)
      }
      c && f.push(X2.systemAltKeyText),
      u && Mhe.indexOf(i || ``) < 0 && f.push(``),
      i && f.push(i);
      let p = Ehe(t)
        , m = () => {
          let e = ``;
          return f.length > 0 && (e = f.map(O9).join(` `)),
          a && (e = `${e} then ${O9(a)}`),
          o && (e = `${e} or ${O9(o)}`),
          e
      }
        , h = e => (Nhe[e] || e).replace(/[A-Za-z]/, e => e.toUpperCase());
      return (0,
      S9.jsxs)(Dhe, {
          ...d,
          "aria-label": m(),
          "data-variant": r,
          children: [f.map( (e, t) => (0,
          S9.jsx)(p, {
              "aria-hidden": !0,
              $size: n,
              children: h(e)
          }, t)), o && (0,
          S9.jsxs)(S9.Fragment, {
              children: [(0,
              S9.jsx)(D9, {
                  "aria-hidden": !0,
                  $size: n,
                  children: `or`
              }), (0,
              S9.jsx)(p, {
                  "aria-hidden": !0,
                  $size: n,
                  children: h(o)
              })]
          }), a && (0,
          S9.jsxs)(S9.Fragment, {
              children: [(0,
              S9.jsx)(D9, {
                  "aria-hidden": !0,
                  $size: n,
                  children: `then`
              }), (0,
              S9.jsx)(p, {
                  "aria-hidden": !0,
                  $size: n,
                  children: h(a)
              })]
          })]
      })
  }
  ,
  Dhe = HK(`span`)([`display:inline-flex;align-items:center;gap:3px;`]),
  w9 = HK(`kbd`)([`display:inline-block;vertical-align:baseline;text-align:center;color:`, `;font-size:`, `;line-height:110%;font-feature-settings:"cv08";background-color:`, `;`, `;`, `;`, `;`], Y$(`labelBase`), e => e.$size === `large` ? `13px` : `11px`, e => e.theme.isDark ? e.theme.highlightVariant(e.theme.highlightVariant(e.theme.color.bgFocus)) : e.theme.color.bgFocus, e => e.$size === `small` && `border-radius: 4px;
   padding: 2px;
   min-width: 18px;`, e => e.$size === `normal` && `padding: 4px;
   border-radius: 3px;
   min-width: 20px;`, e => e.$size === `large` && `padding: 5px;
   border-radius: 3px;
   min-width: 24px;`),
  T9 = HK(w9)([`border:`, `;color:`, `;background-color:transparent;[data-variant="primary"] &{border:`, `;background-color:transparent;color:`, `;}`], f1(`bgBorderSolid`), Y$(`labelMuted`), e => d1(z$.cssWithAlpha(e.theme.color.controlLabel, .4)), Y$(`controlLabel`)),
  Ohe = HK(T9)([`background-color:`, `;`], Y$(`controlSecondaryHover`)),
  khe = HK(w9)([`background-color:`, `;color:`, `;`], Y$(`orangeBg`), Y$(`orangeText`)),
  Ahe = HK(w9)([`background-color:`, `;color:`, `;`], Y$(`redBg`), Y$(`redText`)),
  jhe = HK(w9)([`background-color:`, `;color:`, `;border:0.5px solid `, `;opacity:0.5;`], Y$(`bgBase`), Y$(`labelMuted`), Y$(`labelFaint`)),
  E9 = HK(w9)([`color:`, `;font-weight:`, `;background:none;border-radius:0;min-width:10px;padding:0;[data-variant="primary"] &{color:`, `;}`], Y$(`labelMuted`), u1(`medium`), Y$(`labelBase`)),
  D9 = HK(O1)([`color:`, `;margin:0;[data-variant="primary"] &{color:`, `;}`, `;`, `;`, `;`], Y$(`labelMuted`), Y$(`controlPrimaryLabel`), e => e.$size === `small` && `font-size: 10px `, e => e.$size === `normal` && `font-size: ${l1(`micro`)} `, e => e.$size === `large` && `font-size: 0.75rem`),
  Mhe = [`#`, `^`, `+`, `?`],
  Nhe = {
      ArrowUp: ``,
      ArrowRight: ``,
      ArrowDown: ``,
      ArrowLeft: ``,
      Escape: `esc`,
      Backspace: ``,
      Enter: ``
  },
  O9 = e => {
      let t = {
          ArrowUp: `Arrow Up`,
          "": `Arrow Up`,
          ArrowRight: `Arrow Right`,
          "": `Arrow Right`,
          ArrowDown: `Arrow Down`,
          "": `Arrow Down`,
          ArrowLeft: `Arrow Left`,
          "": `Arrow Left`,
          Escape: `Escape`,
          Backspace: `Backspace`,
          Enter: `Enter`,
          "": `Enter`,
          "": `Backspace`,
          "": `Shift`,
          "": `Command`,
          "": `Option`,
          "": `Control`,
          Ctrl: `Control`,
          ctrl: `Control`,
          Esc: `Escape`,
          esc: `Escape`,
          "#": `Hash`,
          "{": `Left Curly Brace`,
          "}": `Right Curly Brace`,
          "+": `Plus`,
          "?": `Question Mark`,
          "[": `Left Square Bracket`,
          "]": `Right Square Bracket`
      };
      return t[e] ? t[e] : e.toUpperCase()
  }
}
)), k9, A9, j9 = t(( () => {
  ht(),
  Xt(),
  Lc(),
  L6(),
  er(),
  k9 = e(f()),
  A9 = e => {
      let {href: t, ref: n, ...r} = e
        , i = bee()
        , a = t?.startsWith(`/`) ? $n.CLIENT_URL + t : t;
      return !a || a === Ic(a) ? t && e.target !== `external` && I6(t) ? (0,
      k9.jsx)(`a`, {
          href: t,
          ...r,
          ref: n,
          onClick: e => {
              e.preventDefault(),
              e.stopPropagation();
              let n = $n.CLIENT_URL || ``;
              i((a ?? t).slice(n.length))
          }
      }) : (0,
      k9.jsx)(`a`, {
          ...e,
          target: e.target === `external` ? `external` : `_blank`,
          ref: n,
          rel: `noopener noreferrer`
      }) : (0,
      k9.jsx)(`span`, {
          ...r,
          ref: n
      })
  }
}
));
function Fhe(e) {
  if (!e)
      return null;
  let t = new URL(e)
    , n = t.pathname.split(`/`);
  return n[n.length - 1] = `<invite-hash>`,
  t.pathname = n.join(`/`),
  t.toString()
}
var M9, Ihe = t(( () => {
  F6(),
  M9 = e => {
      let t = e.split(`/`);
      if (t[1] === `` || !P6.isValidOrgPath(e))
          return e;
      switch (t[1] = `<org-id>`,
      t[2]) {
      case `document`:
          t[3] = `<document-id>`;
          break;
      case `project`:
          t[3] = `<project-id>`,
          t[4] && ([`overview`, `issues`, `activity`].includes(t[4]) || (t[4] = `<team-id>`));
          break;
      case `projects`:
          t[3] === `view` && t[4] && (t[4] = `<view-id>`);
          break;
      case `pulse`:
          t[3] === `view` && t[4] && (t[4] = `<view-id>`);
          break;
      case `issue`:
          t[3] = `<issue-id>`,
          t.splice(4);
          break;
      case `team`:
          t[3] = `<team-id>`,
          t[4] === `cycle` && ![`previous`, `active`, `upcoming`].includes(t[5]) && (t[5] = `<cycle-id>`),
          t[4] === `view` && (t[5] = `<view-id>`),
          t[4] === `projects` && t[5] === `view` && (t[6] = `<view-id>`);
          break;
      case `view`:
          t[3] = `<view-id>`;
          break;
      case `label`:
          t[3] = `<label-id>`;
          break;
      case `issue-label`:
          t[3] = `<label-id>`,
          t.splice(4);
          break;
      case `initiative`:
          t[3] = `<initiative-id>`,
          t[4] === `view` && t[5] && (t[5] = `<view-id>`);
          break;
      case `profiles`:
          t[3] = `<username>`;
          break;
      case `review`:
          t[3] = `<review-id>`;
          break;
      case `settings`:
          t[3] === `teams` && (t[4] = `<team-id>`);
          break;
      case `customer`:
          t[3] = `<customer-id>`;
          break;
      default:
      }
      return t.length > 1 && (t[t.length - 1] = t[t.length - 1].split(`#`)[0]),
      t.join(`/`)
  }
}
)), N9, Lhe, P9, Rhe = t(( () => {
  N9 = e(ht()),
  Lhe = {
      sensitivity: 2,
      interval: 100,
      handleFocus: !0
  },
  P9 = ({onOver: e, onOut: t, options: n}) => {
      let r = {
          ...Lhe,
          ...n
      }
        , i = N9.useRef({
          x: 0,
          y: 0,
          pX: 0,
          pY: 0
      })
        , a = N9.useRef(!1)
        , o = N9.useRef(null)
        , s = N9.useRef(!1)
        , c = N9.useRef(!1)
        , l = N9.useCallback( () => {
          o.current &&= (clearTimeout(o.current),
          null)
      }
      , []);
      N9.useEffect( () => l, [l]);
      let u = N9.useCallback(e => {
          i.current.x = e.clientX,
          i.current.y = e.clientY
      }
      , [])
        , d = N9.useCallback(t => {
          l(),
          Math.abs(i.current.pX - i.current.x) + Math.abs(i.current.pY - i.current.y) < r.sensitivity ? (a.current = !0,
          c.current || e?.(t)) : (i.current.pX = i.current.x,
          i.current.pY = i.current.y,
          o.current = self.setTimeout( () => d(t), r.interval))
      }
      , [l, r.interval, r.sensitivity, e])
        , f = N9.useCallback(e => {
          s.current = !0,
          l(),
          e.currentTarget.removeEventListener(`mousemove`, u),
          a.current || (i.current.pX = e.clientX,
          i.current.pY = e.clientY,
          e.currentTarget.addEventListener(`mousemove`, u),
          o.current = self.setTimeout( () => d(e), r.interval))
      }
      , [l, d, r.interval, u])
        , p = N9.useCallback(e => {
          s.current = !1,
          l(),
          e.currentTarget.removeEventListener(`mousemove`, u),
          a.current && (l(),
          a.current = !1,
          c.current || t?.(e))
      }
      , [l, u])
        , m = N9.useCallback(t => {
          s.current || (c.current = !0,
          e?.(t))
      }
      , [e])
        , h = N9.useCallback(e => {
          !s.current && c && (c.current = !1,
          t?.(e))
      }
      , [t]);
      return N9.useMemo( () => ({
          onMouseOver: f,
          onMouseOut: p,
          onFocus: r.handleFocus ? m : void 0,
          onBlur: r.handleFocus ? h : void 0
      }), [f, p, m, h, r.handleFocus])
  }
}
));
function zhe({to: e, state: t, enabled: n=!0}) {
  let r = Bhe(e, t);
  return P9({
      onOver: F9.useCallback( () => {
          if (!n)
              return;
          let i = JSON.stringify({
              to: e,
              state: t
          });
          L9.has(i) || (L9.add(i),
          r())
      }
      , [r, e, t, n])
  })
}
function Bhe(e, t) {
  let n = Z7()
    , r = F9.useContext(Tee);
  return F9.useMemo( () => !e || !n.isBootstrapped ? () => Promise.resolve() : async () => {
      let i = Jt(r?.router.routes ?? [], e) ?? [];
      for (let r of i) {
          r.route.lazy && typeof r.route.lazy == `function` && !I9.has(r.route.id) && (I9.add(r.route.id),
          r.route.lazy?.());
          let i = r.route.handle;
          if (typeof r.route.loader == `function` && i?.preloadOnHover) {
              let i = typeof e == `string` ? {
                  pathname: e,
                  hash: ``,
                  search: ``,
                  state: t,
                  key: ``
              } : {
                  pathname: e.pathname ?? ``,
                  hash: e.hash ?? ``,
                  search: e.search ?? ``,
                  state: t,
                  key: ``
              }
                , a = {
                  store: n,
                  getLocation: () => i,
                  matches: [],
                  type: `hover`,
                  isAuthenticatedAndBootstrapped: n.isAuthenticatedAndBootstrapped
              }
                , o = Date.now();
              try {
                  await r.route.loader({
                      request: new Request(``),
                      params: r.params,
                      context: a
                  }, a);
                  let e = Date.now() - o;
                  w.debug(`[ROU] Prefetched data on hover`, {
                      pathname: i.pathname,
                      duration: e
                  });
                  let t = M9(i.pathname);
                  Vo.reportSpans(`RoutePrefetch`, t, [{
                      name: `Prefetch`,
                      startTime: 0,
                      endTime: e
                  }])
              } catch (e) {
                  !(e instanceof Response) && !e.message.includes(`network error`) && w.error(`Prefetch on hover failed`, e, {
                      pathname: i.pathname,
                      duration: Date.now() - o
                  })
              }
          }
      }
  }
  , [e])
}
var F9, I9, L9, Vhe = t(( () => {
  Xt(),
  F9 = e(ht()),
  Ihe(),
  ws(),
  Ho(),
  Q7(),
  Rhe(),
  I9 = new Set,
  L9 = new Set
}
));
function Hhe(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
}
var R9, z9, B9, Uhe, Whe, Ghe, Khe, qhe, Jhe, Yhe, Xhe, Zhe, Qhe, $he = t(( () => {
  R9 = e(ht()),
  Xt(),
  WK(),
  r1(),
  u7(),
  L_(),
  i6(),
  Z3(),
  Vhe(),
  L6(),
  j9(),
  z9 = e(f()),
  B9 = e => {
      let {fastClick: t, to: n, onMouseDown: r, state: i, onMouseOver: a, prefetchOnHover: o=!0, draggable: s, allowTextSelection: c=!1, ref: l, ...u} = e, d = zhe({
          to: n,
          state: i,
          enabled: o
      }), f = Zt(), p = R9.useRef(!1), m = R9.useRef(!1), h;
      if (!n)
          h = void 0;
      else if (typeof n != `string`) {
          let e = Kt(n.pathname ?? ``);
          h = {
              pathname: e.pathname,
              hash: e.hash ?? n.hash,
              search: e.search ?? n.search
          }
      } else
          h = I6(n) && Hg.test(n) ? qt(new URL(n), f.pathname) : qt(Kt(n), f.pathname);
      let g = See(h ?? `.`)
        , _ = {
          ...i,
          tabId: X3.instance.activeTabId
      }
        , ee = t => {
          let n = c && p.current && Uhe();
          return !t.defaultPrevented && t.button === 0 && !e.target && !Hhe(t) && !n
      }
        , te = e => {
          c && (Whe(),
          p.current = !0,
          m.current = !1),
          r && r(e)
      }
        , ne = t => {
          if (e.onClick && e.onClick(t),
          ee(t) && (t.stopPropagation(),
          t.preventDefault(),
          ie()),
          c && p.current) {
              let e = t.metaKey
                , n = e && m.current;
              (!e || n) && (t.stopPropagation(),
              t.preventDefault()),
              p.current = !1
          }
      }
        , re = t => {
          e.onKeyDown && e.onKeyDown(t),
          !t.defaultPrevented && !t.metaKey && t.key === `Enter` && (ie(),
          t.currentTarget?.blur())
      }
        , ie = () => {
          h?.pathname && n6.instance.redirectTo(h, {
              state: _
          })
      }
        , ae = R9.useCallback(e => {
          p.current && (m.current = !0),
          d.onMouseOver(e),
          a?.(e)
      }
      , [d, a])
        , oe = R9.useCallback(e => {
          d.onMouseOut(e),
          u.onMouseOut?.(e)
      }
      , [d, u.onMouseOut])
        , se = R9.useCallback(e => {
          d.onFocus?.(e),
          u.onFocus?.(e)
      }
      , [d, u.onFocus])
        , ce = R9.useCallback(e => {
          d.onBlur?.(e),
          u.onBlur?.(e)
      }
      , [d, u.onBlur]);
      return (0,
      z9.jsx)(Khe, {
          ...u,
          draggable: c ? `false` : s,
          onMouseOver: ae,
          onMouseOut: oe,
          onFocus: se,
          onBlur: ce,
          onKeyDown: re,
          onMouseDown: t ? ne : te,
          onClick: t ? e => {
              ee(e) && (e.stopPropagation(),
              e.preventDefault())
          }
          : ne,
          href: g,
          ref: l,
          $allowTextSelection: c
      })
  }
  ,
  Uhe = () => {
      let e = self.document.getSelection();
      return !!e && e.type === `Range`
  }
  ,
  Whe = () => {
      let e = self.document.getSelection();
      e && e.removeAllRanges()
  }
  ,
  Ghe = e => {
      let {variant: t, size: n=`normal`, onlyIcon: r, icon: i, children: a, ref: o, ...s} = e;
      return (0,
      z9.jsx)(qhe, {
          children: i ? (0,
          z9.jsxs)(z9.Fragment, {
              children: [i, a]
          }) : a,
          ...s,
          ref: o,
          $icon: i,
          $variant: t,
          $size: n,
          $onlyIcon: r
      })
  }
  ,
  Khe = HK.a([``, ``], e => e.$allowTextSelection && `
    &, * {
      user-select: text;
    }
  `),
  qhe = HK(B9)([``, ` `, ` `, ` &:not([data-disabled="true"]):`, `{`, `}`, `;`], c7.rootCss, e => c7.variantCss({
      variant: e.$variant ?? `primary`,
      active: e.active
  }), e => c7.sizeCss({
      size: e.$size ?? `normal`,
      onlyIcon: e.$onlyIcon
  }), J$, e => c7.variantCss({
      variant: e.$variant ?? `primary`,
      active: e.active
  }), e => c7.iconCss({
      size: e.$size ?? `normal`,
      $onlyIcon: e.$onlyIcon,
      icon: e.$icon
  })),
  Jhe = e => {
      let {variant: t, size: n, ref: r, ...i} = e;
      return (0,
      z9.jsx)(Yhe, {
          ...i,
          ref: r,
          $variant: t,
          $size: n
      })
  }
  ,
  Yhe = HK(A9)([``, ` `, ` `, ` &:not([data-disabled="true"]):`, `{`, `}`], c7.rootCss, e => c7.variantCss({
      variant: e.$variant ?? `primary`
  }), e => c7.sizeCss({
      size: e.$size ?? `normal`
  }), J$, e => c7.variantCss({
      variant: e.$variant ?? `primary`,
      active: !0
  })),
  Xhe = (0,
  R9.forwardRef)(function(e, t) {
      return (0,
      z9.jsx)(Zhe, {
          ...e,
          ref: t
      })
  }),
  Zhe = HK(B9)([`position:absolute;border-radius:6px;inset:0;display:block;`]),
  Qhe = HK.a([`position:absolute;inset:0;display:block;`])
}
));
function ege(e) {
  let {link: t, isShownKeyboardTooltip: n} = e;
  return (0,
  V9.jsx)(rge, {
      "aria-hidden": !0,
      children: (0,
      V9.jsx)(nge, {
          isShownKeyboardTooltip: n ?? !1,
          children: t.external ? (0,
          V9.jsx)(A9, {
              href: t.to,
              children: t.label
          }) : (0,
          V9.jsx)(B9, {
              to: t.to,
              state: t.state,
              children: t.label
          })
      })
  })
}
function tge(e) {
  let {button: t, onClose: n, style: r} = e;
  return (0,
  V9.jsx)(y7, {
      variant: `borderless`,
      size: `small`,
      onClick: () => {
          t.onClick(),
          n?.()
      }
      ,
      style: {
          marginRight: 8,
          fontSize: l1(`smallPlus`),
          ...r
      },
      children: t.label
  })
}
function nge(e) {
  return e.isShownKeyboardTooltip === !1 ? (0,
  V9.jsx)(V9.Fragment, {
      children: e.children
  }) : (0,
  V9.jsx)(G4, {
      title: `Open toast link`,
      position: `left`,
      transitionDelay: 950,
      shortcut: (0,
      V9.jsx)(C9, {
          shortcutKey: `o`,
          mod: !0,
          option: !0,
          size: `small`
      }),
      children: e.children
  })
}
var V9, rge, ige = t(( () => {
  ht(),
  WK(),
  r1(),
  T1(),
  Phe(),
  Z4(),
  b7(),
  j9(),
  $he(),
  V9 = e(f()),
  rge = HK.div([`margin-left:-4px;padding:0 4px;border-radius:var(--control-border-radius,4px);transition:background-color `, `;background-color:transparent;box-decoration-break:clone;display:inline-flex;align-items:center;&:`, `{background-color:`, `;transition-duration:`, `;}a{color:`, `;}`], $$(`highlightFadeOut`), J$, Y$(`bgShade`), $$(`highlightFadeIn`), Y$(`labelLink`))
}
));
function age(e) {
  An.dismiss(e)
}
function oge(e) {
  if (An.getToasts().find(t => t.id === e.id)) {
      An.custom( () => (0,
      U9.jsx)(W9, {
          toast: e,
          reOccurred: !0
      }), {
          id: e.id
      }),
      setTimeout( () => {
          An.custom( () => (0,
          U9.jsx)(W9, {
              toast: e,
              reOccurred: !1
          }), {
              id: e.id
          })
      }
      , 200);
      return
  }
  An.custom( () => (0,
  U9.jsx)(W9, {
      reOccurred: !1,
      toast: e
  }), {
      duration: e.duration === 0 ? 1 / 0 : e.duration,
      id: e.id,
      onDismiss: t => e?.onClose?.(!1),
      link: e.link
  })
}
var H9, U9, W9, sge, cge, lge, G9, uge, dge, fge, pge, mge, hge, gge, _ge = t(( () => {
  H9 = e(ht()),
  On(),
  WK(),
  kn(),
  r1(),
  s1(),
  A1(),
  N1(),
  I1(),
  z1(),
  X1(),
  e0(),
  T1(),
  s0(),
  u0(),
  x0(),
  Z4(),
  t3(),
  r3(),
  whe(),
  The(),
  ige(),
  U9 = e(f()),
  W9 = Dn(H9.forwardRef(function(e, t) {
      let {toast: n, reOccurred: r} = e
        , i = gge[n.type]
        , a = H9.useContext(y9)
        , o = typeof a == `string` && n.link?.to === a && n.link.external !== !0
        , s = H9.useRef(null)
        , c = n.type === n3.process
        , l = c || n.singleLine || !(n.description || n.link)
        , u = H9.useCallback(async (e=!1) => {
          n.onClose && await n.onClose(e),
          An.dismiss(n.id)
      }
      , [n.onClose])
        , d = H9.useCallback(async e => {
          e.preventDefault(),
          e.stopPropagation(),
          await u(!0)
      }
      , [u])
        , f = H9.useCallback(e => {
          e.target instanceof HTMLAnchorElement && setTimeout( () => {
              u(!1)
          }
          , 0)
      }
      , [u])
        , p = (0,
      U9.jsxs)(a1, {
          align: `center`,
          children: [n.button ? (0,
          U9.jsx)(a1, {
              align: `center`,
              children: (0,
              U9.jsx)(mge, {
                  isSingleLine: l,
                  children: (0,
                  U9.jsx)(tge, {
                      style: {
                          marginRight: c ? 0 : 12
                      },
                      button: n.button,
                      onClose: () => u(!1)
                  })
              })
          }) : null, c ? null : (0,
          U9.jsx)(a1, {
              align: `flex-start`,
              style: {
                  height: `100%`,
                  marginRight: 2
              },
              children: (0,
              U9.jsx)(hge, {
                  onClick: d,
                  tabIndex: 0,
                  isMultiLineWithButton: !l && !!n.button,
                  children: (0,
                  U9.jsx)(j1, {})
              })
          })]
      });
      return (0,
      U9.jsx)(sge, {
          type: n.type,
          reoccurred: r.toString(),
          ref: t,
          children: (0,
          U9.jsxs)(cge, {
              auto: !0,
              ref: s,
              onMouseUp: f,
              gap: 8,
              align: l ? `center` : `flex-start`,
              role: n.type === n3.error || n.type === n3.warning ? `alert` : `status`,
              children: [c ? (0,
              U9.jsx)(G9, {
                  children: n.processVariant === `progress` ? (0,
                  U9.jsx)(Z1, {
                      progress: n.progress || 0
                  }) : (0,
                  U9.jsx)(B1, {
                      variant: n.processVariant || `pong`
                  })
              }) : n.icon ? (0,
              U9.jsx)(G9, {
                  children: n.icon
              }) : i === null ? null : (0,
              U9.jsx)(uge, {
                  ...i
              }), l ? (0,
              U9.jsxs)(a1, {
                  grow: 1,
                  align: `center`,
                  justify: `space-between`,
                  children: [(0,
                  U9.jsx)(G4, {
                      title: [n.title, `: `, n.description],
                      position: `top`,
                      children: (0,
                      U9.jsxs)(O1, {
                          variant: `smallPlus`,
                          color: `labelMuted`,
                          truncate: c ? 1 : 3,
                          children: [(0,
                          U9.jsx)(O1, {
                              variant: `smallPlus`,
                              color: `labelTitle`,
                              children: n.title
                          }), ` `, (0,
                          U9.jsx)(O1, {
                              variant: `small`,
                              color: `labelMuted`,
                              children: n.description
                          })]
                      })
                  }), p]
              }) : (0,
              U9.jsxs)(a1, {
                  grow: 1,
                  column: !0,
                  gap: 6,
                  style: {
                      maxWidth: `calc(100% - 20px)`
                  },
                  children: [(0,
                  U9.jsxs)(lge, {
                      justify: `space-between`,
                      $absolute: !n.title,
                      children: [(0,
                      U9.jsx)(O1, {
                          variant: `smallPlus`,
                          color: `labelTitle`,
                          truncate: 2,
                          style: {
                              lineHeight: `1.25`
                          },
                          children: n.title
                      }), p]
                  }), n.description ? (0,
                  U9.jsx)(fge, {
                      variant: `small`,
                      color: `labelMuted`,
                      truncate: typeof n.description == `string` && n.type !== n3.error && n.type !== n3.warning ? 3 : void 0,
                      children: dge(n.description)
                  }) : null, n.link ? (0,
                  U9.jsx)(a1, {
                      align: `center`,
                      children: n.link.render ? n.link.render({
                          ...n.link,
                          isShownKeyboardTooltip: o
                      }) : (0,
                      U9.jsx)(ege, {
                          link: n.link,
                          isShownKeyboardTooltip: o
                      })
                  }) : null]
              })]
          })
      })
  })),
  sge = HK(a0)([`border-radius:6px;overflow:hidden;box-shadow:`, `;pointer-events:all;width:384px;transition:transform 0.6s ease-in-out;font-size:`, `;`, `;`, `{width:100%;}`], e => e.theme.shadowMedium, D1(`small`), e => e.reoccurred === `true` && `transform: scale(1.05);
   transition: transform 0.1s ease-out;
`, q$.phone),
  cge = HK(a1)([`padding:12px;&:`, `{`, `{opacity:1;}}`], J$, x9),
  lge = HK(a1)([``, ``], e => e.$absolute && `position: absolute;
   right: 12px;
`),
  G9 = HK(a1)([`flex-shrink:0;justify-content:center;align-items:flex-start;`]),
  uge = HK(G9)([`border-radius:50%;width:16px;height:16px;display:flex;align-items:center;svg{fill:`, `;}`], e => e.theme.color[e.$bgColor]),
  dge = e => typeof e != `string` || !/<(br|strong)[^>]*\/?>/i.test(e) ? e : e.split(/(<br\s*\/?>)/).filter(Boolean).map( (e, t) => e.match(/<br\s*\/?>/i) ? null : (0,
  U9.jsx)(pge, {
      children: e.split(/(<strong>.*?<\/strong>)/).map( (e, t) => e.startsWith(`<strong>`) && e.endsWith(`</strong>`) ? (0,
      U9.jsx)(`strong`, {
          children: e.slice(8, -9)
      }, t) : e || null)
  }, t)).filter(Boolean),
  fge = HK(O1)([`line-height:1.25;strong{color:`, `;font-weight:600;}`], Y$(`labelTitle`)),
  pge = HK.span([`display:inline-block;& + &{margin-top:6px;}`]),
  mge = HK.div([``, ``], e => e.isSingleLine ? `` : `margin-top: -5px;`),
  hge = HK($4)([`outline:none;`, ` flex-shrink:0;`, ` svg{display:block;width:12px;height:12px;}&:hover svg{fill:`, `;}`], c1(10), e => e.isMultiLineWithButton ? `margin-top: 2px;` : ``, Y$(`labelBase`)),
  gge = {
      [n3.info]: {
          $bgColor: `labelMuted`,
          children: (0,
          U9.jsx)(c0, {})
      },
      [n3.success]: {
          $bgColor: `greenBase`,
          children: (0,
          U9.jsx)(L1, {})
      },
      [n3.warning]: {
          $bgColor: `yellowBase`,
          children: (0,
          U9.jsx)(v0, {
              icon: `Alert`
          })
      },
      [n3.error]: {
          $bgColor: `redBase`,
          children: (0,
          U9.jsx)(P1, {})
      },
      [n3.tip]: null,
      [n3.process]: null
  }
}
)), K9, vge = t(( () => {
  zt(),
  _ge(),
  K9 = class {
      static #e = this.show = Ft(e => {
          oge(e)
      }
      );
      static #t = this.close = Ft(e => {
          age(e)
      }
      )
  }
}
)), yge, q9, bge = t(( () => {
  zt(),
  Yr(),
  T$(),
  vge(),
  r3(),
  yge = 8500,
  q9 = class {
      constructor(e, t, n, r) {
          this.reOccurred = !1,
          this.type = e,
          this.title = t,
          this.description = n,
          this.icon = r?.icon,
          this.link = r?.link,
          this.button = r?.button,
          this.id = r?.id || this.type + w$.reactNodeToString(t) + w$.reactNodeToString(n) + this.link?.to,
          this.singleLine = r?.singleLine === void 0 ? e === n3.tip : r.singleLine,
          this.dontBounceOnRecurrence = r?.dontBounceOnRecurrence,
          this.onClose = r?.onClose,
          this.duration = e === n3.process ? b.YEAR : (r?.timeout ?? yge) || b.YEAR,
          this.processVariant = r?.processVariant,
          this.progress = r?.progress,
          At(this, {
              reOccurred: Vt,
              progress: Vt
          })
      }
      show() {
          return K9.show(this),
          this
      }
      close() {
          K9.close(this.id)
      }
  }
}
));
function xge(e) {
  let t = e?.parentElement;
  for (; t && t !== document.body && t !== document.documentElement; ) {
      let {overflowY: e} = window.getComputedStyle(t);
      if ((e === `auto` || e === `scroll`) && t.scrollHeight > t.clientHeight)
          return t;
      t = t.parentElement
  }
  return null
}
var J9, Sge, Cge, wge, Tge, Y9, Ege, X9, Dge = t(( () => {
  J9 = e(ht(), 1),
  Sge = e => {
      let t = e.indexOf(`-`);
      return {
          kind: e.substring(0, t),
          index: parseInt(e.substring(t + 1), 10)
      }
  }
  ,
  Cge = () => null,
  wge = (e, t) => {
      let n = []
        , r = new Set
        , i = Math.max(e.length, t.length)
        , a = e => !!e && e.changeType !== `collapsed` && e.changeType !== `spacer` && e.changeType !== `blank` && e.changeType !== `unchanged`;
      for (let o = 0; o < i; o++) {
          let s = e[o]
            , c = t[o]
            , l = s?.changeType === `collapsed` && s.collapsedInfo ? s : c?.changeType === `collapsed` && c.collapsedInfo ? c : null;
          if (!l || !l.collapsedInfo || r.has(l.collapsedInfo.id))
              continue;
          r.add(l.collapsedInfo.id);
          let u = !1;
          for (let n = 0; n < o; n++)
              if (a(e[n]) || a(t[n])) {
                  u = !0;
                  break
              }
          let d = !1;
          for (let n = o + 1; n < i; n++)
              if (a(e[n]) || a(t[n])) {
                  d = !0;
                  break
              }
          let f = u ? d ? `middle` : `bottom` : `top`;
          n.push({
              row: l,
              index: o,
              position: f
          })
      }
      return n
  }
  ,
  Tge = 20,
  Y9 = e => e ? e.split(/\r\n|\r|\n/).length : 0,
  Ege = (e, t, n, r) => {
      let i = J9.useMemo( () => Math.max(Y9(e), Y9(t)), [e, t])
        , a = J9.useMemo( () => !!(n && r === 0 && i > 0), [n, r, i]);
      return {
          estimatedLineCount: i,
          shouldRenderPlaceholder: a,
          placeholderHeight: J9.useMemo( () => a ? Math.max(1, i) * 20 : void 0, [a, i])
      }
  }
  ,
  X9 = {
      enableMoveDetection: !0,
      collapseUnchangedAreas: !0,
      enableStructuralDiff: !0,
      enableRefactorDetection: !1,
      wrapLines: !1
  }
}
)), Oge, kge = t(( () => {
  Oge = `` + window.__toStaticUrl(`assets/DiffParser.worker-CbLElEe6.js`)
}
));
function Age(e) {
  let t = e => e.changeType === `one-sided` || e.changeType === `one-sided-ws` || e.changeType === `modified` || e.changeType === `moved`
    , n = (e, n) => {
      let r = new Set;
      return e.forEach( (i, a) => {
          if (i.lineNumber !== void 0 && !(i.changeType === `blank` || i.changeType === `spacer` || i.changeType === `collapsed`)) {
              if (t(i)) {
                  r.add(i.lineNumber);
                  return
              }
              if (i.changeType === `unchanged`) {
                  let o = e => {
                      let n = Math.max(0, a - 3)
                        , r = Math.min(e.length - 1, a + 3);
                      for (let i = n; i <= r; i++)
                          if (e[i] && t(e[i]))
                              return !0;
                      return !1
                  }
                  ;
                  (o(e) || o(n)) && r.add(i.lineNumber)
              }
          }
      }
      ),
      r
  }
  ;
  return {
      original: n(e.original.rows, e.modified.rows),
      modified: n(e.modified.rows, e.original.rows)
  }
}
var jge, Mge, Z9, Nge = t(( () => {
  Pn(),
  E6(),
  Dge(),
  kge(),
  jge = class {
      async*computeFileDiff(e) {
          let t = Z9.get(), n = {}, r = {
              ...X9,
              ...e.options
          }, i = [], a, o = !1, s, c = () => {
              a &&= (a(),
              void 0)
          }
          , l = e => {
              i.push(e),
              (e.state === `done` || e.state === `error`) && (o = !0),
              c()
          }
          , u = wte(e => {
              let t = e.state === `done` && e.rows ? Age(e.rows) : void 0;
              l({
                  rows: e.rows,
                  language: e.language,
                  state: e.state,
                  commentableLines: t
              })
          }
          ), d = null;
          try {
              let c = t.getWorker(n);
              for (d = c,
              s = await c.createDiff(e.original, e.modified, e.filename, r, u); !o || i.length > 0; ) {
                  if (i.length === 0) {
                      await new Promise(e => {
                          a = e
                      }
                      );
                      continue
                  }
                  let e = i.shift();
                  e && (yield e)
              }
          } catch {
              for (l({
                  rows: {
                      original: {
                          sourceLines: {},
                          syntaxHighlighting: {},
                          rows: []
                      },
                      modified: {
                          sourceLines: {},
                          syntaxHighlighting: {},
                          rows: []
                      }
                  },
                  language: `Text`,
                  state: `error`,
                  commentableLines: {
                      original: new Set,
                      modified: new Set
                  }
              }); i.length > 0; ) {
                  let e = i.shift();
                  e && (yield e)
              }
          } finally {
              if (d && s !== void 0)
                  try {
                      await d.destroy(s)
                  } catch {}
              d && Z9.release(n);
              let e = u[Tte];
              e?.(),
              c()
          }
      }
  }
  ,
  Mge = new jge,
  Z9 = class {
      static get() {
          return this.pool ||= new T6(Oge),
          this.pool
      }
      static release(e) {
          this.pool?.release(e)
      }
  }
}
));
function Pge() {
  if (`serviceWorker`in navigator) {
      let e = new MessageChannel;
      e.port1.onmessage = e => {
          try {
              let {message: t, metadata: n, type: r} = e.data;
              if (r === `error`)
                  w.error(`Service worker: ${t}`, e.data.error, n);
              else if (r === `warning`)
                  w.warning(`Service worker: ${t}`, n);
              else if (r === `debug`)
                  w.debug(`Service worker: ${t}`, n);
              else
                  throw new Rn(r)
          } catch (e) {
              w.info(`Unknown message from service worker`, e)
          }
      }
      ;
      let t = performance.now()
        , n = !1;
      function r(r) {
          n || !r || (n = !0,
          r.postMessage({
              type: `init`,
              disableServiceWorkerCaching: pQ().settings.disableServiceWorkerCaching ?? !1
          }, [e.port2]),
          w.debug(`Service worker: initialized`, {
              duration: performance.now() - t
          }))
      }
      function i(e) {
          e && e.postMessage({
              type: `prefetch`,
              assetUrl: $n.ASSET_URL
          })
      }
      function a() {
          r(navigator.serviceWorker.controller),
          dZ.onLoadingDone.subscribeOnce( () => {
              i(navigator.serviceWorker.controller)
          }
          )
      }
      window.addEventListener(`load`, async () => {
          try {
              let e = await navigator.serviceWorker.register(Q9, {
                  scope: `/`,
                  type: `module`
              });
              pQ().pushNotification.setServiceWorkerRegistration(e),
              F7().setServiceWorkerRegistration(e),
              navigator.serviceWorker.controller ? a() : navigator.serviceWorker.addEventListener(`controllerchange`, () => {
                  a()
              }
              )
          } catch (e) {
              pQ().pushNotification.setServiceWorkerRegistration(void 0),
              F7().setServiceWorkerRegistration(void 0),
              w.info(`Service worker registration failed`, {
                  error: e,
                  serviceWorkerURL: Q9
              })
          }
      }
      )
  }
}
var Q9, Fge = t(( () => {
  zn(),
  fZ(),
  ws(),
  hQ(),
  H7(),
  er(),
  Q9 = `/client/sw.js` + (typeof SW_HASH < `u` && SW_HASH ? `?${SW_HASH}` : ``)
}
)), Ige, Lge = t(( () => {
  Ige = () => {
      let e = self.document.createElement(`div`);
      e.setAttribute(`style`, `width: 30px; height: 30px; overflow: auto;`),
      e.classList.add(`scrollbar-test`);
      let t = self.document.createElement(`div`);
      t.setAttribute(`style`, `width:100%;height:40px`),
      e.appendChild(t),
      self.document.body.appendChild(e),
      30 - e.firstChild.clientWidth && self.document.body.classList.add(`layoutScrollbarObtrusive`),
      self.document.body.removeChild(e)
  }
}
)), $9, Rge = t(( () => {
  zt(),
  ir(),
  Jte(),
  _r(),
  kQ(),
  ws(),
  hQ(),
  er(),
  FQ(),
  c$(),
  jQ(),
  C$(),
  bge(),
  Nge(),
  H7(),
  Fge(),
  Lge(),
  Ot(),
  kde({
      applicationStore: F7(),
      refreshManager: MQ,
      electron: s$,
      visibilityHelper: AQ,
      alertDialog: x$,
      toast: q9,
      diffComputer: Mge
  }),
  vee({
      enforceActions: `never`
  }),
  $9 = new Set,
  gee( (e, t) => {
      if (!$9.has(t.name_)) {
          let n = t.name_;
          w.error(`MobX.onReactionError`, e, {
              name: n
          }),
          $9.add(n),
          setTimeout( () => {
              $9.delete(n)
          }
          , 2e3)
      }
  }
  ),
  F7();
  try {
      [`/mobile-auth`, `/connect/pagerduty/callback`, `/connect/slack`].some(e => window.location.pathname.startsWith(e)) ? pQ().skipBootstrap() : Pge(),
      Ige(),
      hr(gr.versionString($n.BUILD_REVISION)),
      rr.isiOS && window.addEventListener(`touchmove`, e => {
          e.scale !== 1 && e.preventDefault()
      }
      , {
          passive: !1
      })
  } catch (e) {
      w.error(`Non-essential application setup failed`, e)
  }
  kt( () => import(`./Root.KqdDXkDP.js`), __vite__mapDeps([19, 20, 21, 3, 4, 6, 5, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 9, 34, 35, 36, 37, 17, 38, 39, 40, 41, 18, 42, 43, 44, 45, 46, 47, 48, 1, 2, 49, 50, 51, 52, 53]), import.meta.url).then(e => e.renderMainApplication())
}
));
t(( () => {
  Ote(),
  kte(),
  qte(),
  Rge()
}
))();
export {Qme as $, Hg as $A, GE as $C, eS as $D, dC as $E, Lc as $F, w as $I, $r as $L, op as $M, yd as $N, Lb as $O, Kl as $P, TO as $S, nse as $T, CF as $_, I2 as $a, Dj as $b, KZ as $c, TU as $d, WV as $f, WF as $g, pN as $h, w3 as $i, ng as $j, dy as $k, QJ as $l, mR as $m, R5 as $n, L1 as $o, mB as $p, E8 as $r, D$ as $s, qme as $t, mq as $u, ZF as $v, Sse as $w, tA as $x, $M as $y, j9 as A, kv as AA, FD as AC, jS as AD, VC as AE, Rne as AF, rc as AI, so as AL, pm as AM, tf as AN, ux as AO, Pu as AP, Xn as AR, dk as AS, Bw as AT, lle as A_, S4 as Aa, $j as Ab, qQ as Ac, iW as Ad, wH as Af, vF as Ag, KN as Ah, T6 as Ai, $g as Aj, Qy as Ak, oX as Al, G as Am, Xfe as An, R0 as Ao, Lle as Ap, l5 as Ar, Ide as As, cme as At, Zq as Au, _P as Av, tE as Aw, vce as Ax, zF as Ay, m9 as B, mv as BA, uD as BC, bS as BD, EC as BE, nl as BF, Ls as BI, Ha as BL, qp as BM, Bd as BN, $b as BO, gu as BP, QO as BS, jw as BT, rP as B_, a4 as Ba, Uj as Bb, Ade as Bc, BU as Bd, oH as Bf, uP as Bg, zN as Bh, F3 as Bi, Pg as Bj, Ay as Bk, bY as Bl, FR as Bm, e7 as Bn, qde as Bo, FB as Bp, U8 as Br, Z$ as Bs, Cme as Bt, Rq as Bu, xP as Bv, iE as Bw, RA as Bx, LI as By, zhe as C, Bv as CA, BD as CC, WS as CD, GC as CE, Bne as CF, lc as CI, wo as CL, vm as CM, gf as CN, Cx as CO, Vu as CP, rr as CR, Sk as CS, Ww as CT, TP as C_, X4 as Ca, dM as Cb, XQ as Cc, eG as Cd, LH as Cf, rI as Cg, qN as Ch, L6 as Ci, zre as Cj, rb as Ck, IX as Cl, hz as Cm, rpe as Cn, q0 as Co, QB as Cp, Afe as Cr, b1 as Cs, g9 as Ct, Vue as Cu, sle as Cv, pE as Cw, ej as Cx, uI as Cy, M9 as D, Nv as DA, ID as DC, AS as DD, FC as DE, gl as DF, Pne as DI, co as DL, mm as DM, nf as DN, bx as DO, k as DP, $n as DR, hk as DS, Uw as DT, PF as D_, j4 as Da, lM as Db, GQ as Dc, aW as Dd, NH as Df, DF as Dg, gN as Dh, M6 as Di, e_ as Dj, Yy as Dk, mX as Dl, pz as Dm, E7 as Dn, H0 as Do, DV as Dp, _5 as Dr, p1 as Ds, Rme as Dt, aJ as Du, LP as Dv, lE as Dw, yce as Dx, fI as Dy, Ihe as E, jv as EA, zD as EC, IS as ED, XC as EE, bl as EF, cc as EI, bo as EL, N as EM, af as EN, yx as EO, Ju as EP, tr as ER, yk as ES, Hw as ET, bF as E_, F4 as Ea, cM as Eb, ZQ as Ec, iue as Ed, MH as Ef, TF as Eg, TN as Eh, F6 as Ei, v_ as Ej, qy as Ek, kX as El, mz as Em, T7 as En, U0 as Eo, SV as Ep, g5 as Er, d1 as Es, the as Et, iJ as Eu, dL as Ev, uE as Ew, Sce as Ex, _I as Ey, xhe as F, wv as FA, _D as FC, SS as FD, PC as FE, ul as FF, Qs as FI, Xa as FL, em as FM, Wd as FN, ox as FO, Ou as FP, Un as FR, rk as FS, Iw as FT, gL as F_, f4 as Fa, Jj as Fb, LQ as Fc, QU as Fd, _H as Ff, pP as Fg, jN as Fh, s6 as Fi, Rg as Fj, By as Fk, RY as Fl, JR as Fm, m7 as Fn, O0 as Fo, UB as Fp, a5 as Fr, s1 as Fs, bme as Ft, Bq as Fu, eL as Fv, oE as Fw, WA as Fx, XP as Fy, pme as G, R_ as GA, qE as GC, mS as GD, xC as GE, qc as GF, Ks as GI, pi as GL, pp as GM, Nd as GN, qb as GO, du as GP, WO as GS, Ow as GT, YI as G_, J2 as Ga, Fj as Gb, vQ as Gc, FU as Gd, rH as Gf, yP as Gg, AN as Gh, A3 as Gi, Ng as Gj, Cy as Gk, hY as Gl, AR as Gm, Z5 as Gn, a0 as Go, wB as Gp, R8 as Gr, $$ as Gs, fhe as Gt, Oq as Gu, mF as Gv, KT as Gw, OA as Gx, JF as Gy, mme as H, Eie as HA, aD as HC, DS as HD, CC as HE, el as HF, qs as HI, di as HL, Gp as HM, Rd as HN, Yb as HO, lu as HP, KO as HS, kw as HT, IP as H_, $2 as Ha, Bj as Hb, DQ as Hc, LU as Hd, iH as Hf, OI as Hg, FN as Hh, I3 as Hi, Ag as Hj, Ny as Hk, vY as Hl, NR as Hm, u7 as Hn, x0 as Ho, AB as Hp, z8 as Hr, n1 as Hs, hhe as Ht, Lq as Hu, gP as Hv, cE as Hw, NA as Hx, kF as Hy, She as I, bv as IA, cD as IC, TS as ID, Yoe as IE, ll as IF, Vs as II, Ja as IL, tm as IM, Gd as IN, rx as IO, ku as IP, Rn as IR, ek as IS, Pw as IT, vP as I_, u4 as Ia, Wj as Ib, MQ as Ic, YU as Id, K as If, fF as Ig, uN as Ih, n6 as Ii, Ig as Ij, Ly as Ik, kY as Il, BR as Im, Wfe as In, D0 as Io, WB as Ip, Q8 as Ir, r1 as Is, yme as It, Hq as Iu, VP as Iv, sE as Iw, VA as Ix, WI as Iy, Tme as J, Gg as JA, JE as JC, nS as JD, bC as JE, Gc as JF, Xs as JI, rne as JL, dp as JM, kd as JN, Gb as JO, ru as JP, LO as JS, xw as JT, EI as J_, U2 as Ja, ele as Jb, aQ as Jc, AU as Jd, YV as Jf, wP as Jg, vN as Jh, D3 as Ji, Tg as Jj, vy as Jk, fY as Jl, wR as Jm, K5 as Jn, r0 as Jo, bB as Jp, A8 as Jr, z$ as Js, zme as Jt, Sq as Ju, WP as Jv, BT as Jw, SA as Jx, kP as Jy, jme as K, z_ as KA, XE as KC, hS as KD, SC as KE, Jc as KF, Js as KI, ai as KL, hp as KM, Id as KN, Wb as KO, qne as KP, IO as KS, Tw as KT, RP as K_, q2 as Ka, Ij as Kb, pQ as Kc, MU as Kd, LV as Kf, YF as Kg, bN as Kh, k3 as Ki, Og as Kj, Sy as Kk, lY as Kl, TR as Km, Q5 as Kn, s0 as Ko, TB as Kp, N8 as Kr, W$ as Ks, Lme as Kt, Tq as Ku, qP as Kv, WT as Kw, CA as Kx, MP as Ky, whe as L, _v as LA, oD as LC, wS as LD, HC as LE, ol as LF, Gs as LI, Ya as LL, nm as LM, Kd as LN, ix as LO, Tu as LP, zn as LR, $O as LS, Fw as LT, oI as L_, c4 as La, Gj as Lb, FQ as Lc, XU as Ld, mH as Lf, TL as Lg, sN as Lh, i6 as Li, Vg as Lj, Ry as Lk, AY as Ll, VR as Lm, p7 as Ln, C0 as Lo, IB as Lp, n5 as Lr, X$ as Ls, ohe as Lt, Iue as Lu, hL as Lv, aE as Lw, HA as Lx, fL as Ly, Phe as M, Tv as MA, TD as MC, LS as MD, BC as ME, pl as MF, tc as MI, Qa as ML, im as MM, $d as MN, sx as MO, Ru as MP, qn as MR, ok as MS, ose as MT, vL as M_, tfe as Ma, Xj as Mb, a$ as Mc, eW as Md, yH as Mf, DI as Mg, lN as Mh, u6 as Mi, r_ as Mj, $y as Mk, VY as Ml, qR as Mm, b7 as Mn, P0 as Mo, XB as Mp, o5 as Mr, g1 as Ms, f9 as Mt, zue as Mu, $I as Mv, ZT as Mw, GA as Mx, XI as My, x9 as N, Ev as NA, vD as NC, _S as ND, RC as NE, fl as NF, nc as NI, to as NL, am as NM, qd as NN, cx as NO, Mu as NP, Vn as NR, sk as NS, Lw as NT, _L as N_, m4 as Na, Zj as Nb, Pde as Nc, tW as Nd, bH as Nf, AI as Ng, ON as Nh, w6 as Ni, Ug as Nj, Uy as Nk, HY as Nl, KR as Nm, g7 as Nn, k0 as No, GB as Np, c5 as Nr, a1 as Ns, vme as Nt, Qq as Nu, QI as Nv, QT as Nw, KA as Nx, JI as Ny, Fhe as O, Pv as OA, LD as OC, MS as OD, IC as OE, hl as OF, ac as OI, lo as OL, hm as OM, rf as ON, hx as OO, Bu as OP, er as OR, gk as OS, Vw as OT, ML as O_, A4 as Oa, aM as Ob, KQ as Oc, oW as Od, OH as Of, EF as Og, GN as Oh, A6 as Oi, Zg as Oj, Jy as Ok, hX as Ol, dz as Om, D7 as On, G0 as Oo, tV as Op, p5 as Or, f1 as Os, Ume as Ot, tJ as Ou, cL as Ov, nE as Ow, _ce as Ox, BI as Oy, The as P, Cv as PA, pD as PC, yS as PD, NC as PE, dl as PF, Zs as PI, Za as PL, om as PM, Xd as PN, ax as PO, ju as PP, Bn as PR, nk as PS, Rw as PT, SP as P_, efe as Pa, qj as Pb, RQ as Pc, ZU as Pd, gH as Pf, kI as Pg, kL as Ph, a6 as Pi, iie as Pj, zy as Pk, LY as Pl, GR as Pm, f7 as Pn, N0 as Po, KB as Pp, r5 as Pr, o1 as Ps, dme as Pt, $q as Pu, zP as Pv, JT as Pw, UA as Px, jL as Py, Nme as Q, lie as QA, $E as QC, aS as QD, cC as QE, zc as QF, Es as QI, Xr as QL, cp as QM, Od as QN, Fb as QO, ql as QP, SO as QS, gw as QT, PP as Q_, P2 as Qa, Lce as Qb, GZ as Qc, wU as Qd, XV as Qf, KF as Qg, mN as Qh, C3 as Qi, eg as Qj, hy as Qk, $J as Ql, _R as Qm, $ as Qn, X1 as Qo, vB as Qp, w8 as Qr, F$ as Qs, Kme as Qt, vq as Qu, CP as Qv, uT as Qw, aA as Qx, ile as Qy, dhe as R, hv as RA, dD as RC, CS as RD, OC as RE, rl as RF, Bs as RI, qa as RL, Jp as RM, Hd as RN, tx as RO, Du as RP, y as RR, tk as RS, rse as RT, pF as R_, s4 as Ra, Kj as Rb, AQ as Rc, J as Rd, uH as Rf, BF as Rg, cN as Rh, X3 as Ri, Lg as Rj, Fy as Rk, EY as Rl, RR as Rm, Kfe as Rn, w0 as Ro, BB as Rp, t5 as Rr, Y$ as Rs, she as Rt, Vq as Ru, mL as Rv, $T as Rw, zA as Rx, pL as Ry, Vhe as S, Rv as SA, rce as SC, VS as SD, WC as SE, D as SF, mc as SI, Co as SL, ym as SM, hf as SN, wx as SO, qu as SP, cr as SR, Dk as SS, qw as ST, ple as S_, Z4 as Sa, hM as Sb, WQ as Sc, rG as Sd, IH as Sf, aI as Sg, YN as Sh, W6 as Si, Bre as Sj, vb as Sk, HX as Sl, Tz as Sm, k7 as Sn, n2 as So, pV as Sp, Mfe as Sr, c1 as Ss, u9 as St, uJ as Su, ole as Sv, fE as Sw, sj as Sx, lI as Sy, P9 as T, Iv as TA, RD as TC, FS as TD, KC as TE, yl as TF, sc as TI, yo as TL, M as TM, lf as TN, Sx as TO, Gu as TP, nr as TR, _k as TS, Kw as TT, NP as T_, J4 as Ta, tle as Tb, i$ as Tc, JW as Td, FH as Tf, wF as Tg, wN as Th, P6 as Ti, b_ as Tj, Ky as Tk, wX as Tl, Ele as Tm, O7 as Tn, V0 as To, $B as Tp, xfe as Tr, x1 as Ts, Zme as Tt, cJ as Tu, II as Tv, dE as Tw, QA as Tx, VI as Ty, ghe as U, U_ as UA, tD as UC, xS as UD, wC as UE, Yc as UF, T as UI, ui as UL, _p as UM, zd as UN, Xb as UO, su as UP, UO as US, Aw as UT, CI as U_, X2 as Ua, Lj as Ub, OQ as Uc, RU as Ud, aH as Uf, PI as Ug, dN as Uh, M3 as Ui, Fre as Uj, Py as Uk, _Y as Ul, PR as Um, n7 as Un, c0 as Uo, DB as Up, V8 as Ur, q$ as Us, Ome as Ut, kq as Uu, ZI as Uv, GT as Uw, FA as Ux, DP as Uy, ihe as V, fv as VA, iD as VC, vS as VD, DC as VE, $c as VF, Rs as VI, Ga as VL, Hp as VM, Vd as VN, ex as VO, _u as VP, GO as VS, Mw as VT, MI as V_, o4 as Va, zj as Vb, kQ as Vc, VU as Vd, sH as Vf, RF as Vg, UN as Vh, U3 as Vi, jg as Vj, ky as Vk, SY as Vl, IR as Vm, c7 as Vn, y0 as Vo, kB as Vp, G8 as Vr, J$ as Vs, wme as Vt, Y as Vu, uL as Vv, rE as Vw, MA as Vx, RI as Vy, uhe as W, W_ as WA, nD as WC, OS as WD, vC as WE, Zc as WF, Ys as WI, fi as WL, vp as WM, Fd as WN, Kb as WO, uu as WP, HO as WS, Dw as WT, wI as W_, Q2 as Wa, Rj as Wb, _Q as Wc, PU as Wd, nH as Wf, XF as Wg, DN as Wh, ffe as Wi, Pre as Wj, wy as Wk, pY as Wl, kR as Wm, Y5 as Wn, u0 as Wo, OB as Wp, I8 as Wr, Q$ as Ws, kme as Wt, Aq as Wu, UP as Wv, Qse as Ww, DA as Wx, gF as Wy, Eme as X, Jg as XA, QE as XC, oS as XD, sC as XE, Hc as XF, Is as XI, ei as XL, lp as XM, Cd as XN, Hb as XO, $l as XP, xO as XS, ww as XT, lP as X_, H2 as Xa, jj as Xb, nQ as Xc, DU as Xd, UV as Xf, sP as Xg, HN as Xh, T3 as Xi, L as Xj, py as Xk, oY as Xl, bR as Xm, W5 as Xn, e0 as Xo, Fle as Xp, D8 as Xr, H$ as Xs, p9 as Xt, yq as Xu, QF as Xv, PT as Xw, wA as Xx, tN as Xy, Dme as Y, Wg as YA, UE as YC, iS as YD, TC as YE, Vc as YF, Fs as YI, ii as YL, fp as YM, Md as YN, Vb as YO, iu as YP, DO as YS, bw as YT, qI as Y_, W2 as Ya, Bce as Yb, oQ as Yc, jU as Yd, qV as Yf, HI as Yg, yN as Yh, O3 as Yi, Eg as Yj, Boe as Yk, aY as Yl, yR as Ym, V5 as Yn, Z1 as Yo, gB as Yp, M8 as Yr, R$ as Ys, Pme as Yt, wq as Yu, yL as Yv, LT as Yw, TA as Yx, eN as Yy, hme as Z, qg as ZA, VE as ZC, rS as ZD, aC as ZE, Bc as ZF, Ts as ZI, ni as ZL, sp as ZM, Dd as ZN, Ib as ZO, eu as ZP, OO as ZS, hw as ZT, fle as Z_, F2 as Za, Aj as Zb, iQ as Zc, OU as Zd, JV as Zf, zI as Zg, IN as Zh, E3 as Zi, V as Zj, my as Zk, XJ as Zl, gR as Zm, B5 as Zn, B1 as Zo, _B as Zp, k8 as Zr, P$ as Zs, Vme as Zt, _q as Zu, cle as Zv, MT as Zw, iA as Zx, ale as Zy, Xhe as _, Wv as _A, HD as _C, YS as _D, nw as _E, El as _F, E as _I, yne as _L, P as _M, pf as _N, Ox as _O, ed as _P, zr as _R, jk as _S, $w as _T, rL as __, o3 as _a, bM as _b, f$ as _c, DG as _d, WH as _f, QP as _g, IL as _h, Z6 as _i, Yre as _j, mb as _k, KX as _l, Bz as _m, L7 as _n, i2 as _o, Rle as _p, b5 as _r, T1 as _s, ahe as _t, fJ as _u, wL as _v, CE as _w, uj as _x, iN as _y, wge as a, iy as aA, gO as aC, hC as aD, dw as aE, Ul as aF, Tc as aI, es as aL, Uh as aM, Uf as aN, dS as aO, ld as aP, Rr as aR, Jk as aS, aT, GI as a_, _3 as aa, WM as ab, j$ as ac, aq as ad, fU as af, LN as ag, XL as ah, _8 as ai, u_ as aj, kb as ak, vZ as al, dB as am, ime as an, T2 as ao, QV as ap, M5 as ar, O1 as as, _he as at, jJ as au, oL as av, BE as aw, wj as ax, OP as ay, B9 as b, zv as bA, GD as bC, BS as bD, JC as bE, wl as bF, pc as bI, Mo as bL, Am as bM, uf as bN, Ex as bO, Uu as bP, _r as bR, kk as bS, Yw as bT, FF as b_, $4 as ba, _M as bb, s$ as bc, HK as bd, RH as bf, ZP as bg, PL as bh, K6 as bi, F_ as bj, hb as bk, VX as bl, Pz as bm, dpe as bn, Z0 as bo, wV as bp, jfe as br, Rde as bs, ume as bt, pJ as bu, bP as bv, vE as bw, lj as bx, cI as by, Ege as c, Qv as cA, lO as cC, ZS as cD, uw as cE, Pl as cF, Oc as cI, Jo as cL, Vh as cM, wf as cN, Wx as cO, j as cP, Vr as cR, qk as cS, hse as cT, xL as c_, f3 as ca, qM as cb, T$ as cc, iq as cd, q as cf, EN as cg, YL as ch, u8 as ci, m_ as cj, wb as ck, nZ as cl, Zz as cm, n9 as cn, C2 as co, jV as cp, O5 as cr, D1 as cs, Yme as ct, PJ as cu, sL as cv, EE as cw, xj as cx, QN as cy, K9 as d, Zv as dA, oO as dC, tC as dD, aw as dE, Gne as dF, Cc as dI, Ho as dL, Um as dM, Kf as dN, Lx as dO, hd as dP, Sr as dR, zk as dS, pse as dT, dF as d_, u3 as da, kM as db, C$ as dc, XK as dd, nU as df, MN as dg, WL as dh, c8 as di, I_ as dj, sb as dk, tZ as dl, Uz as dm, Zpe as dn, c2 as do, AV as dp, C5 as dr, v1 as ds, ehe as dt, DJ as du, bI as dv, _E as dw, yj as dx, mI as dy, fy as eA, EO as eC, mC as eD, tse as eE, Jl as eF, Ic as eI, xs as eL, Jh as eM, up as eN, cS as eO, bd as eP, Lr as eR, nA as eS, lT as eT, hP as e_, x3 as ea, ZM as eb, Fde as ec, hq as ed, xU as ef, hN as eg, hR as eh, x8 as ei, a_ as ej, Pb as ek, HZ as el, Ple as em, Ame as en, A2 as eo, GV as ep, z5 as er, z1 as es, lhe as et, YJ as eu, DL as ev, ZE as ew, Oj as ex, EP as ey, vge as f, qv as fA, sO as fC, QS as fD, ow as fE, Al as fF, yc as fI, Fo as fL, Wm as fM, Jf as fN, Bx as fO, nd as fP, xr as fR, Bk as fS, tT as fT, OF as f_, a3 as fa, AM as fb, _$ as fc, ZK as fd, QH as ff, fN as fg, UL as fh, bfe as fi, Wre as fj, db as fk, YX as fl, Wz as fm, Q7 as fn, u2 as fo, rV as fp, Efe as fr, Bde as fs, Hme as ft, kJ as fu, nI as fv, OE as fw, gj as fx, yI as fy, Ghe as g, Uv as gA, QD as gC, qS as gD, tw as gE, O as gF, vc as gI, Do as gL, Im as gM, Yf as gN, Hx as gO, Zu as gP, Yr as gR, Fk as gS, use as gT, SF as g_, s3 as ga, wM as gb, d$ as gc, kG as gd, UH as gf, $F as gg, FL as gh, r8 as gi, c_ as gj, lb as gk, GX as gl, zz as gm, U7 as gn, s2 as go, vV as gp, x5 as gr, _1 as gs, Sme as gt, vJ as gu, EL as gv, bE as gw, Oce as gx, pI as gy, ige as h, Kv as hA, YD as hC, JS as hD, ew as hE, Vne as hF, _c as hI, Eo as hL, Fm as hM, Sf as hN, zx as hO, ad as hP, Zte as hR, Pk as hS, eT as hT, nF as h_, i3 as ha, CM as hb, p$ as hc, TG as hd, KH as hf, UI as hg, HL as hh, n8 as hi, y_ as hj, pb as hk, JX as hl, Rz as hm, Wpe as hn, o2 as ho, oV as hp, Sfe as hr, u1 as hs, xme as ht, _J as hu, aF as hv, yE as hw, pj as hx, gI as hy, xge as i, ny as iA, hO as iC, oC as iD, $oe as iE, Hl as iF, Ec as iI, $o as iL, F as iM, ap as iN, uS as iO, dd as iP, b as iR, Zk as iS, oT as iT, KI as i_, b3 as ia, GM as ib, M$ as ic, uq as id, dU as if, NN as ig, lR as ih, h8 as ii, l_ as ij, Ob as ik, _Z as il, uB as im, o9 as in, D2 as io, KV as ip, L5 as ir, N1 as is, mhe as it, qJ as iu, jF as iv, zE as iw, Pce as ix, nP as iy, C9 as j, Av as jA, CD as jC, NS as jD, zC as jE, ml as jF, ic as jI, $a as jL, rm as jM, Qd as jN, dx as jO, Iu as jP, Kn as jR, pk as jS, zw as jT, tL as j_, E4 as ja, eM as jb, JQ as jc, nW as jd, TH as jf, _F as jg, xN as jh, E6 as ji, o_ as jj, Zy as jk, cX as jl, iz as jm, y7 as jn, I0 as jo, YB as jp, d5 as jr, h1 as js, rhe as jt, eJ as ju, aN as jv, YT as jw, bce as jx, FP as jy, A9 as k, Ov as kA, ND as kC, PS as kD, LC as kE, vl as kF, oc as kI, ao as kL, dm as kM, ef as kN, gx as kO, Lu as kP, Jn as kR, fk as kS, cse as kT, nN as k_, v4 as ka, oM as kb, YQ as kc, rW as kd, kH as kf, yF as kg, WN as kh, N6 as ki, Qg as kj, Xy as kk, _X as kl, fz as km, C7 as kn, L0 as ko, ZB as kp, m5 as kr, m1 as ks, c9 as kt, rJ as ku, lL as kv, XT as kw, qA as kx, cP as ky, q9 as l, $v as lA, cO as lC, eC as lD, lw as lE, Nl as lF, Ac as lI, Uo as lL, Ph as lM, Cf as lN, Gx as lO, md as lP, Ur as lR, Uk as lS, mse as lT, mP as l_, m3 as la, HM as lb, x$ as lc, $K as ld, iU as lf, oN as lg, KL as lh, d8 as li, C_ as lj, Db as lk, rZ as ll, Qz as lm, tme as ln, h2 as lo, MV as lp, k5 as lr, E1 as ls, Xme as lt, NJ as lu, iL as lv, hE as lw, Sj as lx, $N as ly, ege as m, Gv as mA, iO as mC, rC as mD, iw as mE, Ml as mF, xc as mI, Oo as mL, Vm as mM, bf as mN, Vx as mO, td as mP, Qte as mR, Lk as mS, dse as mT, AF as m_, ufe as ma, DM as mb, m$ as mc, Eue as md, GH as mf, cF as mg, BL as mh, a8 as mi, x_ as mj, _b as mk, qX as ml, Hz as mm, Ype as mn, d2 as mo, eV as mp, Dfe as mr, l1 as ms, $me as mt, yJ as mu, oF as mv, xE as mw, fj as mx, dI as my, X9 as n, ly as nA, wO as nC, fC as nD, mw as nE, Gl as nF, Mc as nI, ss as nL, qh as nM, $f as nN, lS as nO, _d as nP, Wr as nR, $k as nS, vse as nT, UF as n_, y3 as na, YM as nb, O$ as nc, pq as nd, mU as nf, JN as ng, fR as nh, v8 as ni, __ as nj, Ab as nk, bZ as nl, Nle as nm, vhe as nn, j2 as no, ZV as np, Pfe as nr, I1 as ns, gme as nt, BJ as nu, IF as nv, KE as nw, Ice as nx, aP as ny, Dge as o, ey as oA, dO as oC, uC as oD, fw as oE, zl as oF, Dc as oI, qo as oL, Wh as oM, Tf as oN, Jx as oO, cd as oP, $te as oR, Yk as oS, gse as oT, SL as o_, h3 as oa, KM as ob, E$ as oc, sq as od, aU as of, VN as og, sR as oh, f8 as oi, Xg as oj, Tb as ok, dZ as ol, nB as om, a9 as on, E2 as oo, PV as op, A5 as or, A1 as os, fme as ot, EJ as ou, aL as ov, eD as ow, Cj as ox, sF as oy, tge as p, Jv as pA, nO as pC, $S as pD, rw as pE, jl as pF, bc as pI, Lo as pL, Bm as pM, yf as pN, Rx as pO, id as pP, tne as pR, Ik as pS, rT as pT, HF as p_, d3 as pa, W as pb, v$ as pc, QK as pd, $H as pf, RN as pg, GL as ph, o8 as pi, L_ as pj, cb as pk, XX as pl, Vz as pm, Z7 as pn, l2 as po, nV as pp, kfe as pr, C1 as ps, Bme as pt, gJ as pu, MF as pv, DE as pw, _j as px, hI as py, Mme as q, Kg as qA, YE as qC, $x as qD, yC as qE, Wc as qF, Ws as qI, ri as qL, gp as qM, Ld as qN, Ub as qO, ou as qP, FO as qS, Ew as qT, oP as q_, Y2 as qa, Nj as qb, hQ as qc, NU as qd, HV as qf, hF as qg, _N as qh, j3 as qi, kg as qj, xy as qk, dY as ql, CR as qm, G5 as qn, t0 as qo, yB as qp, F8 as qr, U$ as qs, phe as qt, Eq as qu, GP as qv, VT as qw, U as qx, jP as qy, Cge as r, ry as rA, kO as rC, lC as rD, ese as rE, Vl as rF, Fc as rI, os as rL, Xh as rM, ip as rN, tS as rO, vd as rP, Gr as rR, Xk as rS, sT as rT, tI as r_, dfe as ra, XM as rb, k$ as rc, cq as rd, hU as rf, kN as rg, cR as rh, b8 as ri, d_ as rj, jb as rk, xZ as rl, hB as rm, ame as rn, k2 as ro, BV as rp, Ffe as rr, j1 as rs, _me as rt, Q as ru, uF as rv, WE as rw, Fce as rx, NF as ry, Sge as s, ty as sA, fO as sC, gC as sD, Zoe as sE, Bl as sF, kc as sI, Go as sL, Lh as sM, Ef as sN, Zx as sO, A as sP, ene as sR, Kk as sS, iT as sT, bL as s_, g3 as sa, JM as sb, w$ as sc, nq as sd, oU as sf, OL as sg, JL as sh, m8 as si, g_ as sj, Eb as sk, fZ as sl, rB as sm, nme as sn, g2 as so, FV as sp, Nfe as sr, k1 as ss, Ime as st, OJ as su, xI as sv, AE as sw, Nce as sx, YP as sy, Tge as t, cy as tA, CO as tC, pC as tD, pw as tE, Wl as tF, Pc as tI, ws as tL, Yh as tM, rp as tN, sS as tO, gd as tP, Kr as tR, Qk as tS, bse as tT, GF as t_, S3 as ta, QM as tb, N$ as tc, fq as td, SU as tf, fP as tg, dR as th, C8 as ti, n_ as tj, Rb as tk, UZ as tl, Mle as tm, Gme as tn, M2 as to, VV as tp, F5 as tr, P1 as ts, Fme as tt, Wue as tu, LF as tv, HE as tw, Tj as tx, iP as ty, bge as u, H as uA, uO as uC, nC as uD, Xoe as uE, Il as uF, Sc as uI, Vo as uL, Ih as uM, Wf as uN, Kx as uO, sd as uP, Cr as uR, Wk as uS, nT as uT, JP as u_, l3 as ua, UM as ub, b$ as uc, tq as ud, tU as uf, PN as ug, qL as uh, l8 as ui, S_ as uj, fb as uk, eZ as ul, Gz as um, eme as un, f2 as uo, kV as up, y5 as ur, w1 as us, d9 as ut, FJ as uu, dle as uv, TE as uw, vj as ux, ZN as uy, Jhe as v, Vv as vA, KD as vC, zS as vD, ZC as vE, Dl as vF, hc as vI, ko as vL, Nm as vM, ff as vN, kx as vO, $u as vP, Tr as vR, Mk as vS, Qw as vT, nL as v_, n3 as va, xM as vb, l$ as vc, WK as vd, BH as vf, $P as vg, mle as vh, $6 as vi, Ure as vj, ob as vk, UX as vl, Az as vm, F7 as vn, a2 as vo, lV as vp, Ofe as vr, S1 as vs, Jme as vt, hJ as vu, KP as vv, wE as vw, Ece as vx, HP as vy, Rhe as w, Fv as wA, VD as wC, GS as wD, qC as wE, Sl as wF, uc as wI, To as wL, Sm as wM, Xne as wN, xx as wO, Ku as wP, ir as wR, Ck as wS, Gw as wT, eP as w_, G4 as wa, pM as wb, UQ as wc, tG as wd, PH as wf, lF as wg, CN as wh, I6 as wi, M_ as wj, ab as wk, LX as wl, _z as wm, Qfe as wn, B0 as wo, mV as wp, Cfe as wr, y1 as ws, Wme as wt, sJ as wu, rF as wv, ece as ww, tj as wx, vI as wy, $he as x, Lv as xA, qD as xC, HS as xD, YC as xE, Tl as xF, dc as xI, Ao as xL, _m as xM, df as xN, Dx as xO, Wu as xP, sr as xR, Ek as xS, Jw as xT, tP as x_, t3 as xa, mM as xb, c$ as xc, wG as xd, zH as xf, iI as xg, SN as xh, U6 as xi, i_ as xj, ub as xk, BX as xl, wz as xm, upe as xn, t2 as xo, TV as xp, wfe as xr, Lde as xs, lme as xt, dJ as xu, iF as xv, gE as xw, oj as xx, ule as xy, Qhe as y, Hv as yA, WD as yC, US as yD, QC as yE, Cl as yF, gc as yI, No as yL, km as yM, mf as yN, Ax as yO, Qu as yP, gr as yR, Ok as yS, Xw as yT, tF as y_, r3 as ya, gM as yb, u$ as yc, jue as yd, HH as yf, eF as yg, NL as yh, G6 as yi, h_ as yj, gb as yk, WX as yl, Oz as ym, H7 as yn, X0 as yo, EV as yp, Tfe as yr, zde as ys, l9 as yt, mJ as yu, AP as yv, SE as yw, cj as yx, sI as yy, nhe as z, gv as zA, fD as zC, ES as zD, kC as zE, tl as zF, Us as zI, Ka as zL, Xp as zM, Ud as zN, nx as zO, mu as zP, Ln as zR, qO as zS, Nw as zT, xF as z_, r4 as za, Hj as zb, jQ as zc, GU as zd, dH as zf, VF as zg, BN as zh, Z3 as zi, Fg as zj, Iy as zk, OY as zl, zR as zm, qfe as zn, v0 as zo, MB as zp, W8 as zr, e1 as zs, che as zt, zq as zu, BP as zv, eE as zw, LA as zx, XN as zy};
//# debugId=77044b42-b44e-52ae-9245-698515222543
